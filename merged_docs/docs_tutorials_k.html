<hr>
<div class="td-content"><h1 data-pagefind-weight="10">Running Multiple Instances of Your App</h1><h2 id="objectives">Objectives</h2><ul><li>Scale an existing app manually using kubectl.</li></ul><h2 id="scaling-an-application">Scaling an application</h2><div class="alert alert-primary" role="alert"><em>You can create from the start a Deployment with multiple instances using the --replicas
parameter for the kubectl create deployment command.</em></div><p>Previously we created a <a href="/docs/concepts/workloads/controllers/deployment/">Deployment</a>,
and then exposed it publicly via a <a href="/docs/concepts/services-networking/service/">Service</a>.
The Deployment created only one Pod for running our application. When traffic increases,
we will need to scale the application to keep up with user demand.</p><p>If you haven't worked through the earlier sections, start from
<a href="/docs/tutorials/kubernetes-basics/create-cluster/cluster-intro/">Using minikube to create a cluster</a>.</p><p><em>Scaling</em> is accomplished by changing the number of replicas in a Deployment.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4><p>If you are trying this after the
<a href="/docs/tutorials/kubernetes-basics/expose/expose-intro/">previous section</a>, then you
may have deleted the service you created, or have created a Service of <code>type: NodePort</code>.
In this section, it is assumed that a service with <code>type: LoadBalancer</code> is created
for the kubernetes-bootcamp Deployment.</p><p>If you have <em>not</em> deleted the Service created in
<a href="/docs/tutorials/kubernetes-basics/expose/expose-intro/">the previous section</a>,
first delete that Service and then run the following command to create a new Service
with its <code>type</code> set to <code>LoadBalancer</code>:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl expose deployment/kubernetes-bootcamp --type<span style="color:#666">=</span><span style="color:#b44">"LoadBalancer"</span> --port <span style="color:#666">8080</span>
</span></span></code></pre></div></div><h2 id="scaling-overview">Scaling overview</h2><div class="col-md-8"><div id="myCarousel" class="carousel" data-ride="carousel" data-interval="3000"><div class="carousel-inner" role="listbox"><div class="item carousel-item active"><img src="/docs/tutorials/kubernetes-basics/public/images/module_05_scaling1.svg"/></div><div class="item carousel-item"><img src="/docs/tutorials/kubernetes-basics/public/images/module_05_scaling2.svg"/></div></div></div></div><div class="alert alert-primary" role="alert"><em>Scaling is accomplished by changing the number of replicas in a Deployment.</em></div><p>Scaling out a Deployment will ensure new Pods are created and scheduled to Nodes
with available resources. Scaling will increase the number of Pods to the new desired
state. Kubernetes also supports <a href="/docs/tasks/run-application/horizontal-pod-autoscale/">autoscaling</a>
of Pods, but it is outside of the scope of this tutorial. Scaling to zero is also
possible, and it will terminate all Pods of the specified Deployment.</p><p>Running multiple instances of an application will require a way to distribute the
traffic to all of them. Services have an integrated load-balancer that will distribute
network traffic to all Pods of an exposed Deployment. Services will monitor continuously
the running Pods using endpoints, to ensure the traffic is sent only to available Pods.</p><p>Once you have multiple instances of an application running, you would be able to
do Rolling updates without downtime. We'll cover that in the next section of the
tutorial. Now, let's go to the terminal and scale our application.</p><h3 id="scaling-a-deployment">Scaling a Deployment</h3><p>To list your Deployments, use the <code>get deployments</code> subcommand:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl get deployments
</span></span></code></pre></div><p>The output should be similar to:</p><pre tabindex="0"><code>NAME                  READY   UP-TO-DATE   AVAILABLE   AGE
kubernetes-bootcamp   1/1     1            1           11m
</code></pre><p>We should have 1 Pod. If not, run the command again. This shows:</p><ul><li><em>NAME</em> lists the names of the Deployments in the cluster.</li><li><em>READY</em> shows the ratio of CURRENT/DESIRED replicas</li><li><em>UP-TO-DATE</em> displays the number of replicas that have been updated to achieve the desired state.</li><li><em>AVAILABLE</em> displays how many replicas of the application are available to your users.</li><li><em>AGE</em> displays the amount of time that the application has been running.</li></ul><p>To see the ReplicaSet created by the Deployment, run:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl get rs
</span></span></code></pre></div><p>Notice that the name of the ReplicaSet is always formatted as
<nobr>[DEPLOYMENT-NAME]-[RANDOM-STRING]</nobr>.
The random string is randomly generated and uses the pod-template-hash as a seed.</p><p>Two important columns of this output are:</p><ul><li><em>DESIRED</em> displays the desired number of replicas of the application, which you
define when you create the Deployment. This is the desired state.</li><li><em>CURRENT</em> displays how many replicas are currently running.</li></ul><p>Next, let’s scale the Deployment to 4 replicas. We’ll use the <code>kubectl scale</code> command,
followed by the Deployment type, name and desired number of instances:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl scale deployments/kubernetes-bootcamp --replicas<span style="color:#666">=</span><span style="color:#666">4</span>
</span></span></code></pre></div><p>To list your Deployments once again, use <code>get deployments</code>:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl get deployments
</span></span></code></pre></div><p>The change was applied, and we have 4 instances of the application available. Next,
let’s check if the number of Pods changed:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl get pods -o wide
</span></span></code></pre></div><p>There are 4 Pods now, with different IP addresses. The change was registered in
the Deployment events log. To check that, use the <code>describe</code> subcommand:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl describe deployments/kubernetes-bootcamp
</span></span></code></pre></div><p>You can also view in the output of this command that there are 4 replicas now.</p><h3 id="load-balancing">Load Balancing</h3><p>Let's check that the Service is load-balancing the traffic. To find out the exposed
IP and Port we can use <code>describe service</code> as we learned in the previous part of the tutorial:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl describe services/kubernetes-bootcamp
</span></span></code></pre></div><p>Create an environment variable called NODE_PORT that has a value as the Node port:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span><span style="color:#a2f">export</span> <span style="color:#b8860b">NODE_PORT</span><span style="color:#666">=</span><span style="color:#b44">"</span><span style="color:#a2f;font-weight:700">$(</span>kubectl get services/kubernetes-bootcamp -o go-template<span style="color:#666">=</span><span style="color:#b44">'{{(index .spec.ports 0).nodePort}}'</span><span style="color:#a2f;font-weight:700">)</span><span style="color:#b44">"</span>
</span></span><span style="display:flex"><span><span style="color:#a2f">echo</span> <span style="color:#b8860b">NODE_PORT</span><span style="color:#666">=</span><span style="color:#b8860b">$NODE_PORT</span>
</span></span></code></pre></div><p>Next, we’ll do a <code>curl</code> to the exposed IP address and port. Execute the command multiple times:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>curl http://<span style="color:#b44">"</span><span style="color:#a2f;font-weight:700">$(</span>minikube ip<span style="color:#a2f;font-weight:700">)</span><span style="color:#b44">:</span><span style="color:#b8860b">$NODE_PORT</span><span style="color:#b44">"</span>
</span></span></code></pre></div><p>We hit a different Pod with every request. This demonstrates that the load-balancing is working.</p><p>The output should be similar to:</p><pre tabindex="0"><code>Hello Kubernetes bootcamp! | Running on: kubernetes-bootcamp-644c5687f4-wp67j | v=1
Hello Kubernetes bootcamp! | Running on: kubernetes-bootcamp-644c5687f4-hs9dj | v=1
Hello Kubernetes bootcamp! | Running on: kubernetes-bootcamp-644c5687f4-4hjvf | v=1
Hello Kubernetes bootcamp! | Running on: kubernetes-bootcamp-644c5687f4-wp67j | v=1
Hello Kubernetes bootcamp! | Running on: kubernetes-bootcamp-644c5687f4-4hjvf | v=1
</code></pre><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4><p>If you're running minikube with Docker Desktop as the container driver, a minikube
tunnel is needed. This is because containers inside Docker Desktop are isolated
from your host computer.</p><p>In a separate terminal window, execute:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>minikube service kubernetes-bootcamp --url
</span></span></code></pre></div><p>The output looks like this:</p><pre tabindex="0"><code>http://127.0.0.1:51082
!  Because you are using a Docker driver on darwin, the terminal needs to be open to run it.
</code></pre><p>Then use the given URL to access the app:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>curl 127.0.0.1:51082
</span></span></code></pre></div></div><h3 id="scale-down">Scale Down</h3><p>To scale down the Deployment to 2 replicas, run again the <code>scale</code> subcommand:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl scale deployments/kubernetes-bootcamp --replicas<span style="color:#666">=</span><span style="color:#666">2</span>
</span></span></code></pre></div><p>List the Deployments to check if the change was applied with the <code>get deployments</code> subcommand:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl get deployments
</span></span></code></pre></div><p>The number of replicas decreased to 2. List the number of Pods, with <code>get pods</code>:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl get pods -o wide
</span></span></code></pre></div><p>This confirms that 2 Pods were terminated.</p><h2 id="what-s-next">What's next</h2><ul><li>Tutorial
<a href="/docs/tutorials/kubernetes-basics/update/update-intro/">Performing a Rolling Update</a>.</li><li>Learn more about <a href="/docs/concepts/workloads/controllers/replicaset/">ReplicaSet</a>.</li><li>Learn more about <a href="/docs/concepts/workloads/autoscaling/">Autoscaling</a>.</li></ul></div>
<hr>
<div class="td-content"><h1 data-pagefind-weight="10">Performing a Rolling Update</h1><h2 id="objectives">Objectives</h2><p>Perform a rolling update using kubectl.</p><h2 id="updating-an-application">Updating an application</h2><div class="alert alert-primary" role="alert"><em>Rolling updates allow Deployments' update to take place with zero downtime by
incrementally updating Pods instances with new ones.</em></div><p>Users expect applications to be available all the time, and developers are expected
to deploy new versions of them several times a day. In Kubernetes this is done with
rolling updates. A <strong>rolling update</strong> allows a Deployment update to take place with
zero downtime. It does this by incrementally replacing the current Pods with new ones.
The new Pods are scheduled on Nodes with available resources, and Kubernetes waits
for those new Pods to start before removing the old Pods.</p><p>In the previous module we scaled our application to run multiple instances. This
is a requirement for performing updates without affecting application availability.
By default, the maximum number of Pods that can be unavailable during the update
and the maximum number of new Pods that can be created, is one. Both options can
be configured to either numbers or percentages (of Pods). In Kubernetes, updates are
versioned and any Deployment update can be reverted to a previous (stable) version.</p><h2 id="rolling-updates-overview">Rolling updates overview</h2><div class="col-md-8"><div id="myCarousel" class="carousel" data-ride="carousel" data-interval="3000"><div class="carousel-inner" role="listbox"><div class="item carousel-item active"><img src="/docs/tutorials/kubernetes-basics/public/images/module_06_rollingupdates1.svg"/></div><div class="item carousel-item"><img src="/docs/tutorials/kubernetes-basics/public/images/module_06_rollingupdates2.svg"/></div><div class="item carousel-item"><img src="/docs/tutorials/kubernetes-basics/public/images/module_06_rollingupdates3.svg"/></div><div class="item carousel-item"><img src="/docs/tutorials/kubernetes-basics/public/images/module_06_rollingupdates4.svg"/></div></div></div></div><div class="alert alert-primary" role="alert"><em>If a Deployment is exposed publicly, the Service will load-balance the traffic
only to available Pods during the update.</em></div><p>Similar to application Scaling, if a Deployment is exposed publicly, the Service
will load-balance the traffic only to available Pods during the update. An available
Pod is an instance that is available to the users of the application.</p><p>Rolling updates allow the following actions:</p><ul><li>Promote an application from one environment to another (via container image updates)</li><li>Rollback to previous versions</li><li>Continuous Integration and Continuous Delivery of applications with zero downtime</li></ul><p>In the following interactive tutorial, we'll update our application to a new version,
and also perform a rollback.</p><h3 id="update-the-version-of-the-app">Update the version of the app</h3><p>To list your Deployments, run the <code>get deployments</code> subcommand:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl get deployments
</span></span></code></pre></div><p>To list the running Pods, run the <code>get pods</code> subcommand:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl get pods
</span></span></code></pre></div><p>To view the current image version of the app, run the <code>describe pods</code> subcommand
and look for the <code>Image</code> field:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl describe pods
</span></span></code></pre></div><p>To update the image of the application to version 2, use the <code>set image</code> subcommand,
followed by the deployment name and the new image version:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl <span style="color:#a2f">set</span> image deployments/kubernetes-bootcamp kubernetes-bootcamp<span style="color:#666">=</span>docker.io/jocatalin/kubernetes-bootcamp:v2
</span></span></code></pre></div><p>The command notified the Deployment to use a different image for your app and initiated
a rolling update. Check the status of the new Pods, and view the old one terminating
with the <code>get pods</code> subcommand:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl get pods
</span></span></code></pre></div><h3 id="verify-an-update">Verify an update</h3><p>First, check that the service is running, as you might have deleted it in previous
tutorial step, run <code>describe services/kubernetes-bootcamp</code>. If it's missing,
you can create it again with:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl expose deployment/kubernetes-bootcamp --type<span style="color:#666">=</span><span style="color:#b44">"NodePort"</span> --port <span style="color:#666">8080</span>
</span></span></code></pre></div><p>Create an environment variable called <code>NODE_PORT</code> that has the value of the Node
port assigned:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span><span style="color:#a2f">export</span> <span style="color:#b8860b">NODE_PORT</span><span style="color:#666">=</span><span style="color:#b44">"</span><span style="color:#a2f;font-weight:700">$(</span>kubectl get services/kubernetes-bootcamp -o go-template<span style="color:#666">=</span><span style="color:#b44">'{{(index .spec.ports 0).nodePort}}'</span><span style="color:#a2f;font-weight:700">)</span><span style="color:#b44">"</span>
</span></span><span style="display:flex"><span><span style="color:#a2f">echo</span> <span style="color:#b44">"NODE_PORT=</span><span style="color:#b8860b">$NODE_PORT</span><span style="color:#b44">"</span>
</span></span></code></pre></div><p>Next, do a <code>curl</code> to the exposed IP and port:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>curl http://<span style="color:#b44">"</span><span style="color:#a2f;font-weight:700">$(</span>minikube ip<span style="color:#a2f;font-weight:700">)</span><span style="color:#b44">:</span><span style="color:#b8860b">$NODE_PORT</span><span style="color:#b44">"</span>
</span></span></code></pre></div><p>Every time you run the <code>curl</code> command, you will hit a different Pod. Notice that
all Pods are now running the latest version (<code>v2</code>).</p><p>You can also confirm the update by running the <code>rollout status</code> subcommand:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl rollout status deployments/kubernetes-bootcamp
</span></span></code></pre></div><p>To view the current image version of the app, run the describe pods subcommand:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl describe pods
</span></span></code></pre></div><p>In the <code>Image</code> field of the output, verify that you are running the latest image
version (<code>v2</code>).</p><h3 id="roll-back-an-update">Roll back an update</h3><p>Let’s perform another update, and try to deploy an image tagged with <code>v10</code>:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl <span style="color:#a2f">set</span> image deployments/kubernetes-bootcamp kubernetes-bootcamp<span style="color:#666">=</span>gcr.io/google-samples/kubernetes-bootcamp:v10
</span></span></code></pre></div><p>Use <code>get deployments</code> to see the status of the deployment:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl get deployments
</span></span></code></pre></div><p>Notice that the output doesn't list the desired number of available Pods. Run the
<code>get pods</code> subcommand to list all Pods:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl get pods
</span></span></code></pre></div><p>Notice that some of the Pods have a status of <code>ImagePullBackOff</code>.</p><p>To get more insight into the problem, run the <code>describe pods</code> subcommand:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl describe pods
</span></span></code></pre></div><p>In the <code>Events</code> section of the output for the affected Pods, notice that the <code>v10</code>
image version did not exist in the repository.</p><p>To roll back the deployment to your last working version, use the <code>rollout undo</code>
subcommand:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl rollout undo deployments/kubernetes-bootcamp
</span></span></code></pre></div><p>The <code>rollout undo</code> command reverts the deployment to the previous known state
(<code>v2</code> of the image). Updates are versioned and you can revert to any previously
known state of a Deployment.</p><p>Use the <code>get pods</code> subcommand to list the Pods again:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl get pods
</span></span></code></pre></div><p>To check the image deployed on the running Pods, use the <code>describe pods</code> subcommand:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl describe pods
</span></span></code></pre></div><p>The Deployment is once again using a stable version of the app (<code>v2</code>). The rollback
was successful.</p><p>Remember to clean up your local cluster.</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl delete deployments/kubernetes-bootcamp services/kubernetes-bootcamp
</span></span></code></pre></div><h2 id="what-s-next">What's next</h2><ul><li>Learn more about <a href="/docs/concepts/workloads/controllers/deployment/">Deployments</a>.</li></ul></div>
<hr>
<div class="td-content"><h1 data-pagefind-weight="10">Using a Service to Expose Your App</h1><h2 id="objectives">Objectives</h2><ul><li>Learn about a Service in Kubernetes.</li><li>Understand how labels and selectors relate to a Service.</li><li>Expose an application outside a Kubernetes cluster.</li></ul><h2 id="overview-of-kubernetes-services">Overview of Kubernetes Services</h2><p>Kubernetes <a href="/docs/concepts/workloads/pods/">Pods</a> are mortal. Pods have a
<a href="/docs/concepts/workloads/pods/pod-lifecycle/">lifecycle</a>. When a worker node dies,
the Pods running on the Node are also lost. A <a href="/docs/concepts/workloads/controllers/replicaset/">Replicaset</a>
might then dynamically drive the cluster back to the desired state via the creation
of new Pods to keep your application running. As another example, consider an image-processing
backend with 3 replicas. Those replicas are exchangeable; the front-end system should
not care about backend replicas or even if a Pod is lost and recreated. That said,
each Pod in a Kubernetes cluster has a unique IP address, even Pods on the same Node,
so there needs to be a way of automatically reconciling changes among Pods so that your
applications continue to function.</p><div class="alert alert-primary" role="alert"><em>A Kubernetes Service is an abstraction layer which defines a logical set of Pods and
enables external traffic exposure, load balancing and service discovery for those Pods.</em></div><p>A <a href="/docs/concepts/services-networking/service/">Service</a> in Kubernetes is an abstraction
which defines a logical set of Pods and a policy by which to access them. Services
enable a loose coupling between dependent Pods. A Service is defined using YAML or JSON,
like all Kubernetes object manifests. The set of Pods targeted by a Service is usually
determined by a <em>label selector</em> (see below for why you might want a Service without
including a <code>selector</code> in the spec).</p><p>Although each Pod has a unique IP address, those IPs are not exposed outside the
cluster without a Service. Services allow your applications to receive traffic.
Services can be exposed in different ways by specifying a <code>type</code> in the <code>spec</code> of the Service:</p><ul><li><p><em>ClusterIP</em> (default) - Exposes the Service on an internal IP in the cluster. This
type makes the Service only reachable from within the cluster.</p></li><li><p><em>NodePort</em> - Exposes the Service on the same port of each selected Node in the cluster using NAT.
Makes a Service accessible from outside the cluster using <code>NodeIP:NodePort</code>. Superset of ClusterIP.</p></li><li><p><em>LoadBalancer</em> - Creates an external load balancer in the current cloud (if supported)
and assigns a fixed, external IP to the Service. Superset of NodePort.</p></li><li><p><em>ExternalName</em> - Maps the Service to the contents of the <code>externalName</code> field
(e.g. <code>foo.bar.example.com</code>), by returning a <code>CNAME</code> record with its value.
No proxying of any kind is set up. This type requires v1.7 or higher of <code>kube-dns</code>,
or CoreDNS version 0.0.8 or higher.</p></li></ul><p>More information about the different types of Services can be found in the
<a href="/docs/tutorials/services/source-ip/">Using Source IP</a> tutorial. Also see
<a href="/docs/tutorials/services/connect-applications-service/">Connecting Applications with Services</a>.</p><p>Additionally, note that there are some use cases with Services that involve not defining
a <code>selector</code> in the spec. A Service created without <code>selector</code> will also not create
the corresponding Endpoints object. This allows users to manually map a Service to
specific endpoints. Another possibility why there may be no selector is you are strictly
using <code>type: ExternalName</code>.</p><h2 id="services-and-labels">Services and Labels</h2><p>A Service routes traffic across a set of Pods. Services are the abstraction that allows
pods to die and replicate in Kubernetes without impacting your application. Discovery
and routing among dependent Pods (such as the frontend and backend components in an application)
are handled by Kubernetes Services.</p><p>Services match a set of Pods using
<a href="/docs/concepts/overview/working-with-objects/labels/">labels and selectors</a>, a grouping
primitive that allows logical operation on objects in Kubernetes. Labels are key/value
pairs attached to objects and can be used in any number of ways:</p><ul><li>Designate objects for development, test, and production</li><li>Embed version tags</li><li>Classify an object using tags</li></ul><figure class="diagram-medium"><img src="/docs/tutorials/kubernetes-basics/public/images/module_04_labels.svg"/></figure><p>Labels can be attached to objects at creation time or later on. They can be modified
at any time. Let's expose our application now using a Service and apply some labels.</p><h3 id="step-1-creating-a-new-service">Step 1: Creating a new Service</h3><p>Let’s verify that our application is running. We’ll use the <code>kubectl get</code> command
and look for existing Pods:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl get pods
</span></span></code></pre></div><p>If no Pods are running then it means the objects from the previous tutorials were
cleaned up. In this case, go back and recreate the deployment from the
<a href="/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro/#deploy-an-app">Using kubectl to create a Deployment</a>
tutorial. Please wait a couple of seconds and list the Pods again. You can continue
once you see the one Pod running.</p><p>Next, let’s list the current Services from our cluster:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl get services
</span></span></code></pre></div><p>To expose the deployment to external traffic, we'll use the kubectl expose command with the --type=NodePort option:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl expose deployment/kubernetes-bootcamp --type<span style="color:#666">=</span><span style="color:#b44">"NodePort"</span> --port <span style="color:#666">8080</span>
</span></span></code></pre></div><p>We have now a running Service called kubernetes-bootcamp. Here we see that the Service
received a unique cluster-IP, an internal port and an external-IP (the IP of the Node).</p><p>To find out what port was opened externally (for the <code>type: NodePort</code> Service) we’ll
run the <code>describe service</code> subcommand:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl describe services/kubernetes-bootcamp
</span></span></code></pre></div><p>Create an environment variable called <code>NODE_PORT</code> that has the value of the Node
port assigned:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span><span style="color:#a2f">export</span> <span style="color:#b8860b">NODE_PORT</span><span style="color:#666">=</span><span style="color:#b44">"</span><span style="color:#a2f;font-weight:700">$(</span>kubectl get services/kubernetes-bootcamp -o go-template<span style="color:#666">=</span><span style="color:#b44">'{{(index .spec.ports 0).nodePort}}'</span><span style="color:#a2f;font-weight:700">)</span><span style="color:#b44">"</span>
</span></span><span style="display:flex"><span><span style="color:#a2f">echo</span> <span style="color:#b44">"NODE_PORT=</span><span style="color:#b8860b">$NODE_PORT</span><span style="color:#b44">"</span>
</span></span></code></pre></div><p>Now we can test that the app is exposed outside of the cluster using <code>curl</code>, the
IP address of the Node and the externally exposed port:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>curl http://<span style="color:#b44">"</span><span style="color:#a2f;font-weight:700">$(</span>minikube ip<span style="color:#a2f;font-weight:700">)</span><span style="color:#b44">:</span><span style="color:#b8860b">$NODE_PORT</span><span style="color:#b44">"</span>
</span></span></code></pre></div><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4><p>If you're running minikube with Docker Desktop as the container driver, a minikube
tunnel is needed. This is because containers inside Docker Desktop are isolated
from your host computer.</p><p>In a separate terminal window, execute:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>minikube service kubernetes-bootcamp --url
</span></span></code></pre></div><p>The output looks like this:</p><pre tabindex="0"><code>http://127.0.0.1:51082
!  Because you are using a Docker driver on darwin, the terminal needs to be open to run it.
</code></pre><p>Then use the given URL to access the app:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>curl 127.0.0.1:51082
</span></span></code></pre></div></div><p>And we get a response from the server. The Service is exposed.</p><h3 id="step-2-using-labels">Step 2: Using labels</h3><p>The Deployment created automatically a label for our Pod. With the <code>describe deployment</code>
subcommand you can see the name (the <em>key</em>) of that label:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl describe deployment
</span></span></code></pre></div><p>Let’s use this label to query our list of Pods. We’ll use the <code>kubectl get pods</code>
command with <code>-l</code> as a parameter, followed by the label values:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl get pods -l <span style="color:#b8860b">app</span><span style="color:#666">=</span>kubernetes-bootcamp
</span></span></code></pre></div><p>You can do the same to list the existing Services:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl get services -l <span style="color:#b8860b">app</span><span style="color:#666">=</span>kubernetes-bootcamp
</span></span></code></pre></div><p>Get the name of the Pod and store it in the POD_NAME environment variable:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span><span style="color:#a2f">export</span> <span style="color:#b8860b">POD_NAME</span><span style="color:#666">=</span><span style="color:#b44">"</span><span style="color:#a2f;font-weight:700">$(</span>kubectl get pods -o go-template --template <span style="color:#b44">'{{range .items}}{{.metadata.name}}{{"\n"}}{{end}}'</span><span style="color:#a2f;font-weight:700">)</span><span style="color:#b44">"</span>
</span></span><span style="display:flex"><span><span style="color:#a2f">echo</span> <span style="color:#b44">"Name of the Pod: </span><span style="color:#b8860b">$POD_NAME</span><span style="color:#b44">"</span>
</span></span></code></pre></div><p>To apply a new label we use the label subcommand followed by the object type,
object name and the new label:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl label pods <span style="color:#b44">"</span><span style="color:#b8860b">$POD_NAME</span><span style="color:#b44">"</span> <span style="color:#b8860b">version</span><span style="color:#666">=</span>v1
</span></span></code></pre></div><p>This will apply a new label to our Pod (we pinned the application version to the Pod),
and we can check it with the <code>describe pod</code> command:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl describe pods <span style="color:#b44">"</span><span style="color:#b8860b">$POD_NAME</span><span style="color:#b44">"</span>
</span></span></code></pre></div><p>We see here that the label is attached now to our Pod. And we can query now the
list of pods using the new label:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl get pods -l <span style="color:#b8860b">version</span><span style="color:#666">=</span>v1
</span></span></code></pre></div><p>And we see the Pod.</p><h3 id="step-3-deleting-a-service">Step 3: Deleting a service</h3><p>To delete Services you can use the <code>delete service</code> subcommand. Labels can be used
also here:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl delete service -l <span style="color:#b8860b">app</span><span style="color:#666">=</span>kubernetes-bootcamp
</span></span></code></pre></div><p>Confirm that the Service is gone:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl get services
</span></span></code></pre></div><p>This confirms that our Service was removed. To confirm that route is not exposed
anymore you can <code>curl</code> the previously exposed IP and port:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>curl http://<span style="color:#b44">"</span><span style="color:#a2f;font-weight:700">$(</span>minikube ip<span style="color:#a2f;font-weight:700">)</span><span style="color:#b44">:</span><span style="color:#b8860b">$NODE_PORT</span><span style="color:#b44">"</span>
</span></span></code></pre></div><p>This proves that the application is not reachable anymore from outside of the cluster.
You can confirm that the app is still running with a <code>curl</code> from inside the pod:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl <span style="color:#a2f">exec</span> -ti <span style="color:#b8860b">$POD_NAME</span> -- curl http://localhost:8080
</span></span></code></pre></div><p>We see here that the application is up. This is because the Deployment is managing
the application. To shut down the application, you would need to delete the Deployment
as well.</p><h2 id="what-s-next">What's next</h2><ul><li>Tutorial
<a href="/docs/tutorials/kubernetes-basics/scale/scale-intro/">Running Multiple Instances of Your App</a>.</li><li>Learn more about <a href="/docs/concepts/services-networking/service/">Service</a>.</li></ul></div>
<hr>
<div class="td-content"><h1>Expose Your App Publicly</h1><div class="section-index"><hr class="panel-line"/><div class="entry"><h5><a href="/docs/tutorials/kubernetes-basics/expose/expose-intro/">Using a Service to Expose Your App</a></h5><p/></div></div></div>
<hr>
<div class="td-content"><h1>Update Your App</h1><div class="section-index"><hr class="panel-line"/><div class="entry"><h5><a href="/docs/tutorials/kubernetes-basics/update/update-intro/">Performing a Rolling Update</a></h5><p/></div></div></div>
<hr>
<div class="td-content"><h1>Deploy an App</h1><div class="section-index"><hr class="panel-line"/><div class="entry"><h5><a href="/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro/">Using kubectl to Create a Deployment</a></h5><p/></div></div></div>
<hr>
<div class="td-content"><h1 data-pagefind-weight="10">Create a Cluster</h1><p>Learn about Kubernetes <a class="glossary-tooltip" title="A set of worker machines, called nodes, that run containerized applications. Every cluster has at least one worker node." data-toggle="tooltip" data-placement="top" href="/docs/reference/glossary/?all=true#term-cluster" target="_blank" aria-label="cluster">cluster</a> and create a simple cluster using Minikube.</p><div class="section-index"><hr class="panel-line"/><div class="entry"><h5><a href="/docs/tutorials/kubernetes-basics/create-cluster/cluster-intro/">Using Minikube to Create a Cluster</a></h5><p/></div></div></div>
<hr>
<div class="td-content"><h1>Explore Your App</h1><div class="section-index"><hr class="panel-line"/><div class="entry"><h5><a href="/docs/tutorials/kubernetes-basics/explore/explore-intro/">Viewing Pods and Nodes</a></h5><p/></div></div></div>
<hr>
<div class="td-content"><h1>Scale Your App</h1><div class="section-index"><hr class="panel-line"/><div class="entry"><h5><a href="/docs/tutorials/kubernetes-basics/scale/scale-intro/">Running Multiple Instances of Your App</a></h5><p/></div></div></div>
<hr>
<div class="td-content"><h1 data-pagefind-weight="10">Using Minikube to Create a Cluster</h1><h2 id="objectives">Objectives</h2><ul><li>Learn what a Kubernetes cluster is.</li><li>Learn what Minikube is.</li><li>Start a Kubernetes cluster on your computer.</li></ul><h2 id="kubernetes-clusters">Kubernetes Clusters</h2><div class="alert alert-primary" role="alert"><em>Kubernetes is a production-grade, open-source platform that orchestrates
the placement (scheduling) and execution of application containers
within and across computer clusters.</em></div><p><strong>Kubernetes coordinates a highly available cluster of computers that are connected
to work as a single unit.</strong> The abstractions in Kubernetes allow you to deploy
containerized applications to a cluster without tying them specifically to individual
machines. To make use of this new model of deployment, applications need to be packaged
in a way that decouples them from individual hosts: they need to be containerized.
Containerized applications are more flexible and available than in past deployment models,
where applications were installed directly onto specific machines as packages deeply
integrated into the host. <strong>Kubernetes automates the distribution and scheduling of
application containers across a cluster in a more efficient way.</strong> Kubernetes is an
open-source platform and is production-ready.</p><p>A Kubernetes cluster consists of two types of resources:</p><ul><li>The <strong>Control Plane</strong> coordinates the cluster</li><li><strong>Nodes</strong> are the workers that run applications</li></ul><h3 id="cluster-diagram">Cluster Diagram</h3><figure><img src="/docs/tutorials/kubernetes-basics/public/images/module_01_cluster.svg"/></figure><p><strong>The Control Plane is responsible for managing the cluster.</strong> The Control Plane
coordinates all activities in your cluster, such as scheduling applications, maintaining
applications' desired state, scaling applications, and rolling out new updates.</p><div class="alert alert-primary" role="alert"><em>Control Planes manage the cluster and the nodes that are used to host the running
applications.</em></div><p><strong>A node is a VM or a physical computer that serves as a worker machine in a Kubernetes
cluster.</strong> Each node has a Kubelet, which is an agent for managing the node and
communicating with the Kubernetes control plane. The node should also have tools for
handling container operations, such as <a class="glossary-tooltip" title="A container runtime with an emphasis on simplicity, robustness and portability" data-toggle="tooltip" data-placement="top" href="https://containerd.io/docs/" target="_blank" aria-label="containerd">containerd</a>
or <a class="glossary-tooltip" title="A lightweight container runtime specifically for Kubernetes" data-toggle="tooltip" data-placement="top" href="https://cri-o.io/#what-is-cri-o" target="_blank" aria-label="CRI-O">CRI-O</a>. A Kubernetes cluster that handles production
traffic should have a minimum of three nodes because if one node goes down, both an
<a href="/docs/concepts/architecture/#etcd">etcd</a> member and a control plane instance are lost,
and redundancy is compromised. You can mitigate this risk by adding more control plane nodes.</p><p>When you deploy applications on Kubernetes, you tell the control plane to start
the application containers. The control plane schedules the containers to run on
the cluster's nodes. <strong>Node-level components, such as the kubelet, communicate
with the control plane using the <a href="/docs/concepts/overview/kubernetes-api/">Kubernetes API</a></strong>,
which the control plane exposes. End users can also use the Kubernetes API directly
to interact with the cluster.</p><p>A Kubernetes cluster can be deployed on either physical or virtual machines. To
get started with Kubernetes development, you can use Minikube. Minikube is a lightweight
Kubernetes implementation that creates a VM on your local machine and deploys a
simple cluster containing only one node. Minikube is available for Linux, macOS,
and Windows systems. The Minikube CLI provides basic bootstrapping operations for
working with your cluster, including start, stop, status, and delete.</p><h2 id="what-s-next">What's next</h2><ul><li>Tutorial <a href="/docs/tutorials/hello-minikube/">Hello Minikube</a>.</li><li>Learn more about <a href="/docs/concepts/architecture/">Cluster Architecture</a>.</li></ul></div>
<hr>
<div class="td-content"><h1 data-pagefind-weight="10">Viewing Pods and Nodes</h1><h2 id="objectives">Objectives</h2><ul><li>Learn about Kubernetes Pods.</li><li>Learn about Kubernetes Nodes.</li><li>Troubleshoot deployed applications.</li></ul><h2 id="kubernetes-pods">Kubernetes Pods</h2><div class="alert alert-primary" role="alert"><em>A Pod is a group of one or more application containers (such as Docker) and includes
shared storage (volumes), IP address and information about how to run them.</em></div><p>When you created a Deployment in <a href="/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro/">Module 2</a>,
Kubernetes created a <strong>Pod</strong> to host your application instance. A Pod is a Kubernetes
abstraction that represents a group of one or more application containers (such as Docker),
and some shared resources for those containers. Those resources include:</p><ul><li>Shared storage, as Volumes</li><li>Networking, as a unique cluster IP address</li><li>Information about how to run each container, such as the container image version
or specific ports to use</li></ul><p>A Pod models an application-specific "logical host" and can contain different application
containers which are relatively tightly coupled. For example, a Pod might include
both the container with your Node.js app as well as a different container that feeds
the data to be published by the Node.js webserver. The containers in a Pod share an
IP Address and port space, are always co-located and co-scheduled, and run in a shared
context on the same Node.</p><p>Pods are the atomic unit on the Kubernetes platform. When we create a Deployment
on Kubernetes, that Deployment creates Pods with containers inside them (as opposed
to creating containers directly). Each Pod is tied to the Node where it is scheduled,
and remains there until termination (according to restart policy) or deletion. In
case of a Node failure, identical Pods are scheduled on other available Nodes in
the cluster.</p><h3 id="pods-overview">Pods overview</h3><figure class="diagram-medium"><img src="/docs/tutorials/kubernetes-basics/public/images/module_03_pods.svg"/></figure><div class="alert alert-primary" role="alert"><em>Containers should only be scheduled together in a single Pod if they are tightly
coupled and need to share resources such as disk.</em></div><h2 id="nodes">Nodes</h2><p>A Pod always runs on a <strong>Node</strong>. A Node is a worker machine in Kubernetes and may
be either a virtual or a physical machine, depending on the cluster. Each Node is
managed by the control plane. A Node can have multiple pods, and the Kubernetes
control plane automatically handles scheduling the pods across the Nodes in the
cluster. The control plane's automatic scheduling takes into account the available
resources on each Node.</p><p>Every Kubernetes Node runs at least:</p><ul><li><p>Kubelet, a process responsible for communication between the Kubernetes control
plane and the Node; it manages the Pods and the containers running on a machine.</p></li><li><p>A container runtime (like Docker) responsible for pulling the container image
from a registry, unpacking the container, and running the application.</p></li></ul><h3 id="nodes-overview">Nodes overview</h3><figure class="diagram-medium"><img src="/docs/tutorials/kubernetes-basics/public/images/module_03_nodes.svg"/></figure><h2 id="troubleshooting-with-kubectl">Troubleshooting with kubectl</h2><p>In <a href="/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro/">Module 2</a>, you used
the kubectl command-line interface. You'll continue to use it in Module 3 to get
information about deployed applications and their environments. The most common
operations can be done with the following kubectl subcommands:</p><ul><li><code>kubectl get</code> - list resources</li><li><code>kubectl describe</code> - show detailed information about a resource</li><li><code>kubectl logs</code> - print the logs from a container in a pod</li><li><code>kubectl exec</code> - execute a command on a container in a pod</li></ul><p>You can use these commands to see when applications were deployed, what their current
statuses are, where they are running and what their configurations are.</p><p>Now that we know more about our cluster components and the command line, let's
explore our application.</p><h3 id="check-application-configuration">Check application configuration</h3><p>Let's verify that the application we deployed in the previous scenario is running.
We'll use the <code>kubectl get</code> command and look for existing Pods:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl get pods
</span></span></code></pre></div><p>If no pods are running, please wait a couple of seconds and list the Pods again.
You can continue once you see one Pod running.</p><p>Next, to view what containers are inside that Pod and what images are used to build
those containers we run the <code>kubectl describe pods</code> command:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl describe pods
</span></span></code></pre></div><p>We see here details about the Pod’s container: IP address, the ports used and a
list of events related to the lifecycle of the Pod.</p><p>The output of the <code>describe</code> subcommand is extensive and covers some concepts that
we didn’t explain yet, but don’t worry, they will become familiar by the end of this tutorial.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>The <code>describe</code> subcommand can be used to get detailed information about most of the
Kubernetes primitives, including Nodes, Pods, and Deployments. The describe output is
designed to be human readable, not to be scripted against.</div><h3 id="show-the-app-in-the-terminal">Show the app in the terminal</h3><p>Recall that Pods are running in an isolated, private network - so we need to proxy access
to them so we can debug and interact with them. To do this, we'll use the <code>kubectl proxy</code>
command to run a proxy in a <strong>second terminal</strong>. Open a new terminal window, and
in that new terminal, run:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl proxy
</span></span></code></pre></div><p>Now again, we'll get the Pod name and query that pod directly through the proxy.
To get the Pod name and store it in the <code>POD_NAME</code> environment variable:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span><span style="color:#a2f">export</span> <span style="color:#b8860b">POD_NAME</span><span style="color:#666">=</span><span style="color:#b44">"</span><span style="color:#a2f;font-weight:700">$(</span>kubectl get pods -o go-template --template <span style="color:#b44">'{{range .items}}{{.metadata.name}}{{"\n"}}{{end}}'</span><span style="color:#a2f;font-weight:700">)</span><span style="color:#b44">"</span>
</span></span><span style="display:flex"><span><span style="color:#a2f">echo</span> Name of the Pod: <span style="color:#b8860b">$POD_NAME</span>
</span></span></code></pre></div><p>To see the output of our application, run a <code>curl</code> request:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>curl http://localhost:8001/api/v1/namespaces/default/pods/<span style="color:#b8860b">$POD_NAME</span>:8080/proxy/
</span></span></code></pre></div><p>The URL is the route to the API of the Pod.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>We don't need to specify the container name, because we only have one container inside the pod.</div><h3 id="executing-commands-on-the-container">Executing commands on the container</h3><p>We can execute commands directly on the container once the Pod is up and running.
For this, we use the <code>exec</code> subcommand and use the name of the Pod as a parameter.
Let’s list the environment variables:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl <span style="color:#a2f">exec</span> <span style="color:#b44">"</span><span style="color:#b8860b">$POD_NAME</span><span style="color:#b44">"</span> -- env
</span></span></code></pre></div><p>Again, it's worth mentioning that the name of the container itself can be omitted
since we only have a single container in the Pod.</p><p>Next let’s start a bash session in the Pod’s container:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl <span style="color:#a2f">exec</span> -ti <span style="color:#b8860b">$POD_NAME</span> -- bash
</span></span></code></pre></div><p>We have now an open console on the container where we run our NodeJS application.
The source code of the app is in the <code>server.js</code> file:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>cat server.js
</span></span></code></pre></div><p>You can check that the application is up by running a curl command:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>curl http://localhost:8080
</span></span></code></pre></div><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>Here we used <code>localhost</code> because we executed the command inside the NodeJS Pod.
If you cannot connect to <code>localhost:8080</code>, check to make sure you have run the
<code>kubectl exec</code> command and are launching the command from within the Pod.</div><p>To close your container connection, type <code>exit</code>.</p><h2 id="what-s-next">What's next</h2><ul><li>Tutorial
<a href="/docs/tutorials/kubernetes-basics/expose/expose-intro/">Using A Service To Expose Your App</a>.</li><li>Learn more about <a href="/docs/concepts/workloads/pods/">Pods</a>.</li><li>Learn more about <a href="/docs/concepts/architecture/nodes/">Nodes</a>.</li></ul></div>
<hr>
<div class="td-content"><h1 data-pagefind-weight="10">Using kubectl to Create a Deployment</h1><h2 id="objectives">Objectives</h2><ul><li>Learn about application Deployments.</li><li>Deploy your first app on Kubernetes with kubectl.</li></ul><h2 id="kubernetes-deployments">Kubernetes Deployments</h2><div class="alert alert-primary" role="alert"><em>A Deployment is responsible for creating and updating instances of your application.</em></div><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>This tutorial uses a container that requires the AMD64 architecture. If you are using
minikube on a computer with a different CPU architecture, you could try using minikube with
a driver that can emulate AMD64. For example, the Docker Desktop driver can do this.</div><p>Once you have a <a href="/docs/tutorials/kubernetes-basics/create-cluster/cluster-intro/">running Kubernetes cluster</a>,
you can deploy your containerized applications on top of it. To do so, you create a
Kubernetes <strong>Deployment</strong>. The Deployment instructs Kubernetes how to create and
update instances of your application. Once you've created a Deployment, the Kubernetes
control plane schedules the application instances included in that Deployment to run
on individual Nodes in the cluster.</p><p>Once the application instances are created, a Kubernetes Deployment controller continuously
monitors those instances. If the Node hosting an instance goes down or is deleted,
the Deployment controller replaces the instance with an instance on another Node
in the cluster. <strong>This provides a self-healing mechanism to address machine failure
or maintenance.</strong></p><p>In a pre-orchestration world, installation scripts would often be used to start
applications, but they did not allow recovery from machine failure. By both creating
your application instances and keeping them running across Nodes, Kubernetes Deployments
provide a fundamentally different approach to application management.</p><h2 id="deploying-your-first-app-on-kubernetes">Deploying your first app on Kubernetes</h2><div class="alert alert-primary" role="alert"><em>Applications need to be packaged into one of the supported container formats in
order to be deployed on Kubernetes.</em></div><figure class="diagram-medium"><img src="/docs/tutorials/kubernetes-basics/public/images/module_02_first_app.svg"/></figure><p>You can create and manage a Deployment by using the Kubernetes command line interface,
<a href="/docs/reference/kubectl/">kubectl</a>. <code>kubectl</code> uses the Kubernetes API to interact
with the cluster. In this module, you'll learn the most common <code>kubectl</code> commands
needed to create Deployments that run your applications on a Kubernetes cluster.</p><p>When you create a Deployment, you'll need to specify the container image for your
application and the number of replicas that you want to run. You can change that
information later by updating your Deployment; <a href="/docs/tutorials/kubernetes-basics/scale/scale-intro/">Module 5</a>
and <a href="/docs/tutorials/kubernetes-basics/update/update-intro/">Module 6</a> of the bootcamp
discuss how you can scale and update your Deployments.</p><p>For your first Deployment, you'll use a hello-node application packaged in a Docker
container that uses NGINX to echo back all the requests. (If you didn't already try
creating a hello-node application and deploying it using a container, you can do
that first by following the instructions from the <a href="/docs/tutorials/hello-minikube/">Hello Minikube tutorial</a>.)</p><p>You will need to have installed kubectl as well. If you need to install it, visit
<a href="/docs/tasks/tools/#kubectl">install tools</a>.</p><p>Now that you know what Deployments are, let's deploy our first app!</p><h3 id="kubectl-basics">kubectl basics</h3><p>The common format of a kubectl command is: <code>kubectl action resource</code>.</p><p>This performs the specified <em>action</em> (like <code>create</code>, <code>describe</code> or <code>delete</code>) on the
specified <em>resource</em> (like <code>node</code> or <code>deployment</code>. You can use <code>--help</code> after the
subcommand to get additional info about possible parameters (for example: <code>kubectl get nodes --help</code>).</p><p>Check that kubectl is configured to talk to your cluster, by running the <code>kubectl version</code> command.</p><p>Check that kubectl is installed and that you can see both the client and the server versions.</p><p>To view the nodes in the cluster, run the <code>kubectl get nodes</code> command.</p><p>You see the available nodes. Later, Kubernetes will choose where to deploy our
application based on Node available resources.</p><h3 id="deploy-an-app">Deploy an app</h3><p>Let’s deploy our first app on Kubernetes with the <code>kubectl create deployment</code> command.
We need to provide the deployment name and app image location (include the full
repository url for images hosted outside Docker Hub).</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl create deployment kubernetes-bootcamp --image<span style="color:#666">=</span>gcr.io/google-samples/kubernetes-bootcamp:v1
</span></span></code></pre></div><p>Great! You just deployed your first application by creating a deployment. This performed a few things for you:</p><ul><li>searched for a suitable node where an instance of the application could be run (we have only 1 available node)</li><li>scheduled the application to run on that Node</li><li>configured the cluster to reschedule the instance on a new Node when needed</li></ul><p>To list your deployments use the <code>kubectl get deployments</code> command:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl get deployments
</span></span></code></pre></div><p>We see that there is 1 deployment running a single instance of your app. The instance
is running inside a container on your node.</p><h3 id="view-the-app">View the app</h3><p><a href="/docs/concepts/workloads/pods/">Pods</a> that are running inside Kubernetes are running
on a private, isolated network. By default they are visible from other pods and services
within the same Kubernetes cluster, but not outside that network. When we use <code>kubectl</code>,
we're interacting through an API endpoint to communicate with our application.</p><p>We will cover other options on how to expose your application outside the Kubernetes
cluster later, in <a href="/docs/tutorials/kubernetes-basics/expose/">Module 4</a>.
Also as a basic tutorial, we're not explaining what <code>Pods</code> are in any
detail here, it will be covered in later topics.</p><p>The <code>kubectl proxy</code> command can create a proxy that will forward communications
into the cluster-wide, private network. The proxy can be terminated by pressing
control-C and won't show any output while it's running.</p><p><strong>You need to open a second terminal window to run the proxy.</strong></p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl proxy
</span></span></code></pre></div><p>We now have a connection between our host (the terminal) and the Kubernetes cluster.
The proxy enables direct access to the API from these terminals.</p><p>You can see all those APIs hosted through the proxy endpoint. For example, we can
query the version directly through the API using the <code>curl</code> command:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>curl http://localhost:8001/version
</span></span></code></pre></div><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>If port 8001 is not accessible, ensure that the <code>kubectl proxy</code> that you started
above is running in the second terminal.</div><p>The API server will automatically create an endpoint for each pod, based on the
pod name, that is also accessible through the proxy.</p><p>First we need to get the Pod name, and we'll store it in the environment variable <code>POD_NAME</code>.</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span><span style="color:#a2f">export</span> <span style="color:#b8860b">POD_NAME</span><span style="color:#666">=</span><span style="color:#a2f;font-weight:700">$(</span>kubectl get pods -o go-template --template <span style="color:#b44">'{{range .items}}{{.metadata.name}}{{"\n"}}{{end}}'</span><span style="color:#a2f;font-weight:700">)</span>
</span></span><span style="display:flex"><span><span style="color:#a2f">echo</span> Name of the Pod: <span style="color:#b8860b">$POD_NAME</span>
</span></span></code></pre></div><p>You can access the Pod through the proxied API, by running:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>curl http://localhost:8001/api/v1/namespaces/default/pods/<span style="color:#b8860b">$POD_NAME</span>:8080/proxy/
</span></span></code></pre></div><p>In order for the new Deployment to be accessible without using the proxy, a Service
is required which will be explained in <a href="/docs/tutorials/kubernetes-basics/expose/">Module 4</a>.</p><h2 id="what-s-next">What's next</h2><ul><li>Tutorial <a href="/docs/tutorials/kubernetes-basics/explore/explore-intro/">Viewing Pods and Nodes</a>.</li><li>Learn more about <a href="/docs/concepts/workloads/controllers/deployment/">Deployments</a>.</li></ul></div>
<hr>
<div class="td-content"><h1 data-pagefind-weight="10">Learn Kubernetes Basics</h1><h2 id="objectives">Objectives</h2><p>This tutorial provides a walkthrough of the basics of the Kubernetes cluster orchestration
system. Each module contains some background information on major Kubernetes features
and concepts, and a tutorial for you to follow along.</p><p>Using the tutorials, you can learn to:</p><ul><li>Deploy a containerized application on a cluster.</li><li>Scale the deployment.</li><li>Update the containerized application with a new software version.</li><li>Debug the containerized application.</li></ul><h2 id="what-can-kubernetes-do-for-you">What can Kubernetes do for you?</h2><p>With modern web services, users expect applications to be available 24/7, and developers
expect to deploy new versions of those applications several times a day. Containerization
helps package software to serve these goals, enabling applications to be released and updated
without downtime. Kubernetes helps you make sure those containerized applications run where
and when you want, and helps them find the resources and tools they need to work. Kubernetes
is a production-ready, open source platform designed with Google's accumulated experience in
container orchestration, combined with best-of-breed ideas from the community.</p><h2 id="kubernetes-basics-modules">Kubernetes Basics Modules</h2><link rel="stylesheet" href="/css/style_tutorials.css"/><div class="tutorials-modules"><div class="module"><a href="/docs/tutorials/kubernetes-basics/create-cluster/cluster-intro/"><img src="/docs/tutorials/kubernetes-basics/public/images/module_01.svg?v=1469803628347" alt="Module 1"/><h5>1. Create a Kubernetes cluster</h5></a></div><div class="module"><a href="/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro/"><img src="/docs/tutorials/kubernetes-basics/public/images/module_02.svg?v=1469803628347" alt="Module 2"/><h5>2. Deploy an app</h5></a></div><div class="module"><a href="/docs/tutorials/kubernetes-basics/explore/explore-intro/"><img src="/docs/tutorials/kubernetes-basics/public/images/module_03.svg?v=1469803628347" alt="Module 3"/><h5>3. Explore your app</h5></a></div><div class="module"><a href="/docs/tutorials/kubernetes-basics/expose/expose-intro/"><img src="/docs/tutorials/kubernetes-basics/public/images/module_04.svg?v=1469803628347" alt="Module 4"/><h5>4. Expose your app publicly</h5></a></div><div class="module"><a href="/docs/tutorials/kubernetes-basics/scale/scale-intro/"><img src="/docs/tutorials/kubernetes-basics/public/images/module_05.svg?v=1469803628347" alt="Module 5"/><h5>5. Scale up your app</h5></a></div><div class="module"><a href="/docs/tutorials/kubernetes-basics/update/update-intro/"><img src="/docs/tutorials/kubernetes-basics/public/images/module_06.svg?v=1469803628347" alt="Module 6"/><h5>6. Update your app</h5></a></div></div><h2 id="what-s-next">What's next</h2><ul><li>Tutorial <a href="/docs/tutorials/kubernetes-basics/create-cluster/">Using Minikube to Create a Cluster</a></li></ul><div class="section-index"/></div>