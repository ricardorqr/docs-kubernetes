<hr>
<div class="td-content"><h1 data-pagefind-weight="10">kubeadm kubeconfig</h1><p><code>kubeadm kubeconfig</code> provides utilities for managing kubeconfig files.</p><p>For examples on how to use <code>kubeadm kubeconfig user</code> see
<a href="/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/#kubeconfig-additional-users">Generating kubeconfig files for additional users</a>.</p><h2 id="cmd-kubeconfig">kubeadm kubeconfig</h2><ul class="nav nav-tabs" id="tab-kubeconfig" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-kubeconfig-0" role="tab" aria-controls="tab-kubeconfig-0" aria-selected="true">overview</a></li></ul><div class="tab-content" id="tab-kubeconfig"><div id="tab-kubeconfig-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-kubeconfig-0"><p><h3 id="synopsis">Synopsis</h3><p>Kubeconfig file utilities.</p><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for kubeconfig</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div></div><h2 id="cmd-kubeconfig-user">kubeadm kubeconfig user</h2><p>This command can be used to output a kubeconfig file for an additional user.</p><ul class="nav nav-tabs" id="tab-kubeconfig-user" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-kubeconfig-user-0" role="tab" aria-controls="tab-kubeconfig-user-0" aria-selected="true">user</a></li></ul><div class="tab-content" id="tab-kubeconfig-user"><div id="tab-kubeconfig-user-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-kubeconfig-user-0"><p><h3 id="synopsis">Synopsis</h3><p>Output a kubeconfig file for an additional user.</p><pre tabindex="0"><code>kubeadm kubeconfig user [flags]
</code></pre><h3 id="examples">Examples</h3><pre tabindex="0"><code>  # Output a kubeconfig file for an additional user named foo
  kubeadm kubeconfig user --client-name=foo
  
  # Output a kubeconfig file for an additional user named foo using a kubeadm config file bar
  kubeadm kubeconfig user --client-name=foo --config=bar
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--client-name string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The name of user. It will be used as the CN if client certificates are created</p></td></tr><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for user</p></td></tr><tr><td colspan="2">--org strings</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The organizations of the client certificate. It will be used as the O if client certificates are created</p></td></tr><tr><td colspan="2">--token string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The token that should be used as the authentication mechanism for this kubeconfig, instead of client certificates</p></td></tr><tr><td colspan="2">--validity-period duration     Default: 8760h0m0s</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The validity period of the client certificate. It is an offset from the current time.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div></div></div>
<hr>
<div class="td-content"><h1 data-pagefind-weight="10">kubeadm certs</h1><p><code>kubeadm certs</code> provides utilities for managing certificates.
For more details on how these commands can be used, see
<a href="/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/">Certificate Management with kubeadm</a>.</p><h2 id="cmd-certs">kubeadm certs</h2><p>A collection of operations for operating Kubernetes certificates.</p><ul class="nav nav-tabs" id="tab-certs" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-certs-0" role="tab" aria-controls="tab-certs-0" aria-selected="true">overview</a></li></ul><div class="tab-content" id="tab-certs"><div id="tab-certs-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-certs-0"><p><h3 id="synopsis">Synopsis</h3><p>Commands related to handling Kubernetes certificates</p><pre tabindex="0"><code>kubeadm certs [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for certs</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div></div><h2 id="cmd-certs-renew">kubeadm certs renew</h2><p>You can renew all Kubernetes certificates using the <code>all</code> subcommand or renew them selectively.
For more details see <a href="/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/#manual-certificate-renewal">Manual certificate renewal</a>.</p><ul class="nav nav-tabs" id="tab-certs-renew" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-certs-renew-0" role="tab" aria-controls="tab-certs-renew-0" aria-selected="true">renew</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-renew-1" role="tab" aria-controls="tab-certs-renew-1">all</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-renew-2" role="tab" aria-controls="tab-certs-renew-2">admin.conf</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-renew-3" role="tab" aria-controls="tab-certs-renew-3">apiserver-etcd-client</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-renew-4" role="tab" aria-controls="tab-certs-renew-4">apiserver-kubelet-client</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-renew-5" role="tab" aria-controls="tab-certs-renew-5">apiserver</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-renew-6" role="tab" aria-controls="tab-certs-renew-6">controller-manager.conf</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-renew-7" role="tab" aria-controls="tab-certs-renew-7">etcd-healthcheck-client</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-renew-8" role="tab" aria-controls="tab-certs-renew-8">etcd-peer</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-renew-9" role="tab" aria-controls="tab-certs-renew-9">etcd-server</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-renew-10" role="tab" aria-controls="tab-certs-renew-10">front-proxy-client</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-renew-11" role="tab" aria-controls="tab-certs-renew-11">scheduler.conf</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-renew-12" role="tab" aria-controls="tab-certs-renew-12">super-admin.conf</a></li></ul><div class="tab-content" id="tab-certs-renew"><div id="tab-certs-renew-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-certs-renew-0"><p><h3 id="synopsis">Synopsis</h3><p>Renew certificates for a Kubernetes cluster</p><pre tabindex="0"><code>kubeadm certs renew [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for renew</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div><div id="tab-certs-renew-1" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-renew-1"><p><p>Renew all available certificates</p><h3 id="synopsis">Synopsis</h3><p>Renew all known certificates necessary to run the control plane. Renewals are run unconditionally, regardless of expiration date. Renewals can also be run individually for more control.</p><pre tabindex="0"><code>kubeadm certs renew all [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--cert-dir string     Default: "/etc/kubernetes/pki"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path where to save the certificates</p></td></tr><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for all</p></td></tr><tr><td colspan="2">--kubeconfig string     Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div><div id="tab-certs-renew-2" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-renew-2"><p><h3 id="synopsis">Synopsis</h3><p>Renew the certificate embedded in the kubeconfig file for the admin to use and for kubeadm itself.</p><p>Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.</p><p>Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.</p><p>After renewal, in order to make changes effective, is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.</p><pre tabindex="0"><code>kubeadm certs renew admin.conf [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--cert-dir string     Default: "/etc/kubernetes/pki"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path where to save the certificates</p></td></tr><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for admin.conf</p></td></tr><tr><td colspan="2">--kubeconfig string     Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div><div id="tab-certs-renew-3" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-renew-3"><p><h3 id="synopsis">Synopsis</h3><p>Renew the certificate the apiserver uses to access etcd.</p><p>Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.</p><p>Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.</p><p>After renewal, in order to make changes effective, is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.</p><pre tabindex="0"><code>kubeadm certs renew apiserver-etcd-client [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--cert-dir string     Default: "/etc/kubernetes/pki"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path where to save the certificates</p></td></tr><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for apiserver-etcd-client</p></td></tr><tr><td colspan="2">--kubeconfig string     Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div><div id="tab-certs-renew-4" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-renew-4"><p><h3 id="synopsis">Synopsis</h3><p>Renew the certificate for the API server to connect to kubelet.</p><p>Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.</p><p>Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.</p><p>After renewal, in order to make changes effective, is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.</p><pre tabindex="0"><code>kubeadm certs renew apiserver-kubelet-client [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--cert-dir string     Default: "/etc/kubernetes/pki"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path where to save the certificates</p></td></tr><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for apiserver-kubelet-client</p></td></tr><tr><td colspan="2">--kubeconfig string     Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div><div id="tab-certs-renew-5" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-renew-5"><p><h3 id="synopsis">Synopsis</h3><p>Renew the certificate for serving the Kubernetes API.</p><p>Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.</p><p>Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.</p><p>After renewal, in order to make changes effective, is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.</p><pre tabindex="0"><code>kubeadm certs renew apiserver [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--cert-dir string     Default: "/etc/kubernetes/pki"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path where to save the certificates</p></td></tr><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for apiserver</p></td></tr><tr><td colspan="2">--kubeconfig string     Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div><div id="tab-certs-renew-6" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-renew-6"><p><h3 id="synopsis">Synopsis</h3><p>Renew the certificate embedded in the kubeconfig file for the controller manager to use.</p><p>Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.</p><p>Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.</p><p>After renewal, in order to make changes effective, is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.</p><pre tabindex="0"><code>kubeadm certs renew controller-manager.conf [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--cert-dir string     Default: "/etc/kubernetes/pki"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path where to save the certificates</p></td></tr><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for controller-manager.conf</p></td></tr><tr><td colspan="2">--kubeconfig string     Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div><div id="tab-certs-renew-7" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-renew-7"><p><h3 id="synopsis">Synopsis</h3><p>Renew the certificate for liveness probes to healthcheck etcd.</p><p>Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.</p><p>Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.</p><p>After renewal, in order to make changes effective, is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.</p><pre tabindex="0"><code>kubeadm certs renew etcd-healthcheck-client [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--cert-dir string     Default: "/etc/kubernetes/pki"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path where to save the certificates</p></td></tr><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for etcd-healthcheck-client</p></td></tr><tr><td colspan="2">--kubeconfig string     Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div><div id="tab-certs-renew-8" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-renew-8"><p><h3 id="synopsis">Synopsis</h3><p>Renew the certificate for etcd nodes to communicate with each other.</p><p>Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.</p><p>Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.</p><p>After renewal, in order to make changes effective, is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.</p><pre tabindex="0"><code>kubeadm certs renew etcd-peer [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--cert-dir string     Default: "/etc/kubernetes/pki"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path where to save the certificates</p></td></tr><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for etcd-peer</p></td></tr><tr><td colspan="2">--kubeconfig string     Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div><div id="tab-certs-renew-9" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-renew-9"><p><h3 id="synopsis">Synopsis</h3><p>Renew the certificate for serving etcd.</p><p>Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.</p><p>Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.</p><p>After renewal, in order to make changes effective, is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.</p><pre tabindex="0"><code>kubeadm certs renew etcd-server [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--cert-dir string     Default: "/etc/kubernetes/pki"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path where to save the certificates</p></td></tr><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for etcd-server</p></td></tr><tr><td colspan="2">--kubeconfig string     Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div><div id="tab-certs-renew-10" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-renew-10"><p><h3 id="synopsis">Synopsis</h3><p>Renew the certificate for the front proxy client.</p><p>Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.</p><p>Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.</p><p>After renewal, in order to make changes effective, is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.</p><pre tabindex="0"><code>kubeadm certs renew front-proxy-client [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--cert-dir string     Default: "/etc/kubernetes/pki"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path where to save the certificates</p></td></tr><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for front-proxy-client</p></td></tr><tr><td colspan="2">--kubeconfig string     Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div><div id="tab-certs-renew-11" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-renew-11"><p><h3 id="synopsis">Synopsis</h3><p>Renew the certificate embedded in the kubeconfig file for the scheduler manager to use.</p><p>Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.</p><p>Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.</p><p>After renewal, in order to make changes effective, is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.</p><pre tabindex="0"><code>kubeadm certs renew scheduler.conf [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--cert-dir string     Default: "/etc/kubernetes/pki"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path where to save the certificates</p></td></tr><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for scheduler.conf</p></td></tr><tr><td colspan="2">--kubeconfig string     Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div><div id="tab-certs-renew-12" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-renew-12"><p><h3 id="synopsis">Synopsis</h3><p>Renew the certificate embedded in the kubeconfig file for the super-admin.</p><p>Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.</p><p>Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.</p><p>After renewal, in order to make changes effective, is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.</p><pre tabindex="0"><code>kubeadm certs renew super-admin.conf [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--cert-dir string     Default: "/etc/kubernetes/pki"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path where to save the certificates</p></td></tr><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for super-admin.conf</p></td></tr><tr><td colspan="2">--kubeconfig string     Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div></div><h2 id="cmd-certs-certificate-key">kubeadm certs certificate-key</h2><p>This command can be used to generate a new control-plane certificate key.
The key can be passed as <code>--certificate-key</code> to <a href="/docs/reference/setup-tools/kubeadm/kubeadm-init/"><code>kubeadm init</code></a>
and <a href="/docs/reference/setup-tools/kubeadm/kubeadm-join/"><code>kubeadm join</code></a>
to enable the automatic copy of certificates when joining additional control-plane nodes.</p><ul class="nav nav-tabs" id="tab-certs-certificate-key" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-certs-certificate-key-0" role="tab" aria-controls="tab-certs-certificate-key-0" aria-selected="true">certificate-key</a></li></ul><div class="tab-content" id="tab-certs-certificate-key"><div id="tab-certs-certificate-key-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-certs-certificate-key-0"><p><p>Generate certificate keys</p><h3 id="synopsis">Synopsis</h3><p>This command will print out a secure randomly-generated certificate key that can be used with
the "init" command.</p><p>You can also use "kubeadm init --upload-certs" without specifying a certificate key and it will
generate and print one for you.</p><pre tabindex="0"><code>kubeadm certs certificate-key [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for certificate-key</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div></div><h2 id="cmd-certs-check-expiration">kubeadm certs check-expiration</h2><p>This command checks expiration for the certificates in the local PKI managed by kubeadm.
For more details see
<a href="/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/#check-certificate-expiration">Check certificate expiration</a>.</p><ul class="nav nav-tabs" id="tab-certs-check-expiration" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-certs-check-expiration-0" role="tab" aria-controls="tab-certs-check-expiration-0" aria-selected="true">check-expiration</a></li></ul><div class="tab-content" id="tab-certs-check-expiration"><div id="tab-certs-check-expiration-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-certs-check-expiration-0"><p><p>Check certificates expiration for a Kubernetes cluster</p><h3 id="synopsis">Synopsis</h3><p>Checks expiration for the certificates in the local PKI managed by kubeadm.</p><pre tabindex="0"><code>kubeadm certs check-expiration [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--allow-missing-template-keys     Default: true</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>If true, ignore any errors in templates when a field or map key is missing in the template. Only applies to golang and jsonpath output formats.</p></td></tr><tr><td colspan="2">--cert-dir string     Default: "/etc/kubernetes/pki"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path where to save the certificates</p></td></tr><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for check-expiration</p></td></tr><tr><td colspan="2">--kubeconfig string     Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan="2">-o, --output string     Default: "text"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Output format. One of: text|json|yaml|go-template|go-template-file|template|templatefile|jsonpath|jsonpath-as-json|jsonpath-file.</p></td></tr><tr><td colspan="2">--show-managed-fields</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>If true, keep the managedFields when printing objects in JSON or YAML format.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div></div><h2 id="cmd-certs-generate-csr">kubeadm certs generate-csr</h2><p>This command can be used to generate keys and CSRs for all control-plane certificates and kubeconfig files.
The user can then sign the CSRs with a CA of their choice. To read more information
on how to use the command see
<a href="/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/#signing-csr">Signing certificate signing requests (CSR) generated by kubeadm</a>.</p><ul class="nav nav-tabs" id="tab-certs-generate-csr" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-certs-generate-csr-0" role="tab" aria-controls="tab-certs-generate-csr-0" aria-selected="true">generate-csr</a></li></ul><div class="tab-content" id="tab-certs-generate-csr"><div id="tab-certs-generate-csr-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-certs-generate-csr-0"><p><p>Generate keys and certificate signing requests</p><h3 id="synopsis">Synopsis</h3><p>Generates keys and certificate signing requests (CSRs) for all the certificates required to run the control plane. This command also generates partial kubeconfig files with private key data in the "users &gt; user &gt; client-key-data" field, and for each kubeconfig file an accompanying ".csr" file is created.</p><p>This command is designed for use in <a href="https://kubernetes.io/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/#external-ca-mode">Kubeadm External CA Mode</a>. It generates CSRs which you can then submit to your external certificate authority for signing.</p><p>The PEM encoded signed certificates should then be saved alongside the key files, using ".crt" as the file extension, or in the case of kubeconfig files, the PEM encoded signed certificate should be base64 encoded and added to the kubeconfig file in the "users &gt; user &gt; client-certificate-data" field.</p><pre tabindex="0"><code>kubeadm certs generate-csr [flags]
</code></pre><h3 id="examples">Examples</h3><pre tabindex="0"><code>  # The following command will generate keys and CSRs for all control-plane certificates and kubeconfig files:
  kubeadm certs generate-csr --kubeconfig-dir /tmp/etc-k8s --cert-dir /tmp/etc-k8s/pki
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--cert-dir string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path where to save the certificates</p></td></tr><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for generate-csr</p></td></tr><tr><td colspan="2">--kubeconfig-dir string     Default: "/etc/kubernetes"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path where to save the kubeconfig file.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div></div><h2 id="what-s-next">What's next</h2><ul><li><a href="/docs/reference/setup-tools/kubeadm/kubeadm-init/">kubeadm init</a> to bootstrap a Kubernetes control-plane node</li><li><a href="/docs/reference/setup-tools/kubeadm/kubeadm-join/">kubeadm join</a> to connect a node to the cluster</li><li><a href="/docs/reference/setup-tools/kubeadm/kubeadm-reset/">kubeadm reset</a> to revert any changes made to this host by <code>kubeadm init</code> or <code>kubeadm join</code></li></ul></div>
<hr>
<div class="td-content"><h1 data-pagefind-weight="10">kubeadm token</h1><p>Bootstrap tokens are used for establishing bidirectional trust between a node joining
the cluster and a control-plane node, as described in <a href="/docs/reference/access-authn-authz/bootstrap-tokens/">authenticating with bootstrap tokens</a>.</p><p><code>kubeadm init</code> creates an initial token with a 24-hour TTL. The following commands allow you to manage
such a token and also to create and manage new ones.</p><h2 id="cmd-token-create">kubeadm token create</h2><p>Create bootstrap tokens on the server</p><h3 id="synopsis">Synopsis</h3><p>This command will create a bootstrap token for you.
You can specify the usages for this token, the "time to live" and an optional human friendly description.</p><p>The [token] is the actual token to write.
This should be a securely generated random token of the form "[a-z0-9]{6}.[a-z0-9]{16}".
If no [token] is given, kubeadm will generate a random token instead.</p><pre tabindex="0"><code>kubeadm token create [token]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--certificate-key string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>When used together with '--print-join-command', print the full 'kubeadm join' flag needed to join the cluster as a control-plane. To create a new certificate key you must use 'kubeadm init phase upload-certs --upload-certs'.</p></td></tr><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">--description string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>A human friendly description of how this token is used.</p></td></tr><tr><td colspan="2">--groups strings     Default: "system:bootstrappers:kubeadm:default-node-token"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Extra groups that this token will authenticate as when used for authentication. Must match "\Asystem:bootstrappers:[a-z0-9:-]{0,255}[a-z0-9]\z"</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for create</p></td></tr><tr><td colspan="2">--print-join-command</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Instead of printing only the token, print the full 'kubeadm join' flag needed to join the cluster using the token.</p></td></tr><tr><td colspan="2">--ttl duration     Default: 24h0m0s</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The duration before the token is automatically deleted (e.g. 1s, 2m, 3h). If set to '0', the token will never expire</p></td></tr><tr><td colspan="2">--usages strings     Default: "signing,authentication"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Describes the ways in which this token can be used. You can pass --usages multiple times or provide a comma separated list of options. Valid options: [signing,authentication]</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Whether to enable dry-run mode or not</p></td></tr><tr><td colspan="2">--kubeconfig string     Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table><h2 id="cmd-token-delete">kubeadm token delete</h2><p>Delete bootstrap tokens on the server</p><h3 id="synopsis">Synopsis</h3><p>This command will delete a list of bootstrap tokens for you.</p><p>The [token-value] is the full Token of the form "[a-z0-9]{6}.[a-z0-9]{16}" or the
Token ID of the form "[a-z0-9]{6}" to delete.</p><pre tabindex="0"><code>kubeadm token delete [token-value] ...
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for delete</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Whether to enable dry-run mode or not</p></td></tr><tr><td colspan="2">--kubeconfig string     Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table><h2 id="cmd-token-generate">kubeadm token generate</h2><p>Generate and print a bootstrap token, but do not create it on the server</p><h3 id="synopsis">Synopsis</h3><p>This command will print out a randomly-generated bootstrap token that can be used with
the "init" and "join" commands.</p><p>You don't have to use this command in order to generate a token. You can do so
yourself as long as it is in the format "[a-z0-9]{6}.[a-z0-9]{16}". This
command is provided for convenience to generate tokens in the given format.</p><p>You can also use "kubeadm init" without specifying a token and it will
generate and print one for you.</p><pre tabindex="0"><code>kubeadm token generate [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for generate</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Whether to enable dry-run mode or not</p></td></tr><tr><td colspan="2">--kubeconfig string     Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table><h2 id="cmd-token-list">kubeadm token list</h2><p>List bootstrap tokens on the server</p><h3 id="synopsis">Synopsis</h3><p>This command will list all bootstrap tokens for you.</p><pre tabindex="0"><code>kubeadm token list [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--allow-missing-template-keys     Default: true</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>If true, ignore any errors in templates when a field or map key is missing in the template. Only applies to golang and jsonpath output formats.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for list</p></td></tr><tr><td colspan="2">-o, --output string     Default: "text"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Output format. One of: text|json|yaml|go-template|go-template-file|template|templatefile|jsonpath|jsonpath-as-json|jsonpath-file.</p></td></tr><tr><td colspan="2">--show-managed-fields</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>If true, keep the managedFields when printing objects in JSON or YAML format.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Whether to enable dry-run mode or not</p></td></tr><tr><td colspan="2">--kubeconfig string     Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table><h2 id="what-s-next">What's next</h2><ul><li><a href="/docs/reference/setup-tools/kubeadm/kubeadm-join/">kubeadm join</a> to bootstrap a Kubernetes worker node and join it to the cluster</li></ul></div>
<hr>
<div class="td-content"><h1 data-pagefind-weight="10">kubeadm init phase</h1><p><code>kubeadm init phase</code> enables you to invoke atomic steps of the bootstrap process.
Hence, you can let kubeadm do some of the work and you can fill in the gaps
if you wish to apply customization.</p><p><code>kubeadm init phase</code> is consistent with the <a href="/docs/reference/setup-tools/kubeadm/kubeadm-init/#init-workflow">kubeadm init workflow</a>,
and behind the scene both use the same code.</p><h2 id="cmd-phase-preflight">kubeadm init phase preflight</h2><p>Using this command you can execute preflight checks on a control-plane node.</p><ul class="nav nav-tabs" id="tab-preflight" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-preflight-0" role="tab" aria-controls="tab-preflight-0" aria-selected="true">preflight</a></li></ul><div class="tab-content" id="tab-preflight"><div id="tab-preflight-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-preflight-0"><p><h3 id="synopsis">Synopsis</h3><p>Run pre-flight checks for kubeadm init.</p><pre tabindex="0"><code>kubeadm init phase preflight [flags]
</code></pre><h3 id="examples">Examples</h3><pre tabindex="0"><code>  # Run pre-flight checks for kubeadm init using a config file.
  kubeadm init phase preflight --config kubeadm-config.yaml
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">--cri-socket string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to the CRI socket to connect. If empty kubeadm will try to auto-detect this value; use this option only if you have more than one CRI installed or if you have non-standard CRI socket.</p></td></tr><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for preflight</p></td></tr><tr><td colspan="2">--ignore-preflight-errors strings</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>A list of checks whose errors will be shown as warnings. Example: 'IsPrivilegedUser,Swap'. Value 'all' ignores errors from all checks.</p></td></tr><tr><td colspan="2">--image-repository string     Default: "registry.k8s.io"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Choose a container registry to pull control plane images from</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div></div><h2 id="cmd-phase-kubelet-start">kubeadm init phase kubelet-start</h2><p>This phase will write the kubelet configuration file and environment file and then start the kubelet.</p><ul class="nav nav-tabs" id="tab-kubelet-start" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-kubelet-start-0" role="tab" aria-controls="tab-kubelet-start-0" aria-selected="true">kubelet-start</a></li></ul><div class="tab-content" id="tab-kubelet-start"><div id="tab-kubelet-start-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-kubelet-start-0"><p><p>Write kubelet settings and (re)start the kubelet</p><h3 id="synopsis">Synopsis</h3><p>Write a file with KubeletConfiguration and an environment file with node specific kubelet settings, and then (re)start kubelet.</p><pre tabindex="0"><code>kubeadm init phase kubelet-start [flags]
</code></pre><h3 id="examples">Examples</h3><pre tabindex="0"><code>  # Writes a dynamic environment file with kubelet flags from a InitConfiguration file.
  kubeadm init phase kubelet-start --config config.yaml
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">--cri-socket string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to the CRI socket to connect. If empty kubeadm will try to auto-detect this value; use this option only if you have more than one CRI installed or if you have non-standard CRI socket.</p></td></tr><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for kubelet-start</p></td></tr><tr><td colspan="2">--image-repository string     Default: "registry.k8s.io"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Choose a container registry to pull control plane images from</p></td></tr><tr><td colspan="2">--node-name string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Specify the node name.</p></td></tr><tr><td colspan="2">--patches string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "target" can be one of "kube-apiserver", "kube-controller-manager", "kube-scheduler", "etcd", "kubeletconfiguration", "corednsdeployment". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div></div><h2 id="cmd-phase-certs">kubeadm init phase certs</h2><p>Can be used to create all required certificates by kubeadm.</p><ul class="nav nav-tabs" id="tab-certs" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-certs-0" role="tab" aria-controls="tab-certs-0" aria-selected="true">certs</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-1" role="tab" aria-controls="tab-certs-1">all</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-2" role="tab" aria-controls="tab-certs-2">ca</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-3" role="tab" aria-controls="tab-certs-3">apiserver</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-4" role="tab" aria-controls="tab-certs-4">apiserver-kubelet-client</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-5" role="tab" aria-controls="tab-certs-5">front-proxy-ca</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-6" role="tab" aria-controls="tab-certs-6">front-proxy-client</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-7" role="tab" aria-controls="tab-certs-7">etcd-ca</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-8" role="tab" aria-controls="tab-certs-8">etcd-server</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-9" role="tab" aria-controls="tab-certs-9">etcd-peer</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-10" role="tab" aria-controls="tab-certs-10">healthcheck-client</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-11" role="tab" aria-controls="tab-certs-11">apiserver-etcd-client</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-12" role="tab" aria-controls="tab-certs-12">sa</a></li></ul><div class="tab-content" id="tab-certs"><div id="tab-certs-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-certs-0"><p><h3 id="synopsis">Synopsis</h3><p>Certificate generation</p><pre tabindex="0"><code>kubeadm init phase certs [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for certs</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div><div id="tab-certs-1" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-1"><p><h3 id="synopsis">Synopsis</h3><p>Generate all certificates</p><pre tabindex="0"><code>kubeadm init phase certs all [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--apiserver-advertise-address string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.</p></td></tr><tr><td colspan="2">--apiserver-cert-extra-sans strings</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Optional extra Subject Alternative Names (SANs) to use for the API Server serving certificate. Can be both IP addresses and DNS names.</p></td></tr><tr><td colspan="2">--cert-dir string     Default: "/etc/kubernetes/pki"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">--control-plane-endpoint string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Specify a stable IP address or DNS name for the control plane.</p></td></tr><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for all</p></td></tr><tr><td colspan="2">--kubernetes-version string     Default: "stable-1"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Choose a specific Kubernetes version for the control plane.</p></td></tr><tr><td colspan="2">--service-cidr string     Default: "10.96.0.0/12"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Use alternative range of IP address for service VIPs.</p></td></tr><tr><td colspan="2">--service-dns-domain string     Default: "cluster.local"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Use alternative domain for services, e.g. "myorg.internal".</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div><div id="tab-certs-2" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-2"><p><h3 id="synopsis">Synopsis</h3><p>Generate the self-signed Kubernetes CA to provision identities for other Kubernetes components, and save them into ca.crt and ca.key files.</p><p>If both files already exist, kubeadm skips the generation step and existing files will be used.</p><pre tabindex="0"><code>kubeadm init phase certs ca [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--cert-dir string     Default: "/etc/kubernetes/pki"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for ca</p></td></tr><tr><td colspan="2">--kubernetes-version string     Default: "stable-1"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Choose a specific Kubernetes version for the control plane.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div><div id="tab-certs-3" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-3"><p><h3 id="synopsis">Synopsis</h3><p>Generate the certificate for serving the Kubernetes API, and save them into apiserver.crt and apiserver.key files.</p><p>If both files already exist, kubeadm skips the generation step and existing files will be used.</p><pre tabindex="0"><code>kubeadm init phase certs apiserver [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--apiserver-advertise-address string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.</p></td></tr><tr><td colspan="2">--apiserver-cert-extra-sans strings</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Optional extra Subject Alternative Names (SANs) to use for the API Server serving certificate. Can be both IP addresses and DNS names.</p></td></tr><tr><td colspan="2">--cert-dir string     Default: "/etc/kubernetes/pki"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">--control-plane-endpoint string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Specify a stable IP address or DNS name for the control plane.</p></td></tr><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for apiserver</p></td></tr><tr><td colspan="2">--kubernetes-version string     Default: "stable-1"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Choose a specific Kubernetes version for the control plane.</p></td></tr><tr><td colspan="2">--service-cidr string     Default: "10.96.0.0/12"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Use alternative range of IP address for service VIPs.</p></td></tr><tr><td colspan="2">--service-dns-domain string     Default: "cluster.local"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Use alternative domain for services, e.g. "myorg.internal".</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div><div id="tab-certs-4" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-4"><p><h3 id="synopsis">Synopsis</h3><p>Generate the certificate for the API server to connect to kubelet, and save them into apiserver-kubelet-client.crt and apiserver-kubelet-client.key files.</p><p>If both files already exist, kubeadm skips the generation step and existing files will be used.</p><pre tabindex="0"><code>kubeadm init phase certs apiserver-kubelet-client [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--cert-dir string     Default: "/etc/kubernetes/pki"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for apiserver-kubelet-client</p></td></tr><tr><td colspan="2">--kubernetes-version string     Default: "stable-1"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Choose a specific Kubernetes version for the control plane.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div><div id="tab-certs-5" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-5"><p><h3 id="synopsis">Synopsis</h3><p>Generate the self-signed CA to provision identities for front proxy, and save them into front-proxy-ca.crt and front-proxy-ca.key files.</p><p>If both files already exist, kubeadm skips the generation step and existing files will be used.</p><pre tabindex="0"><code>kubeadm init phase certs front-proxy-ca [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--cert-dir string     Default: "/etc/kubernetes/pki"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for front-proxy-ca</p></td></tr><tr><td colspan="2">--kubernetes-version string     Default: "stable-1"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Choose a specific Kubernetes version for the control plane.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div><div id="tab-certs-6" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-6"><p><h3 id="synopsis">Synopsis</h3><p>Generate the certificate for the front proxy client, and save them into front-proxy-client.crt and front-proxy-client.key files.</p><p>If both files already exist, kubeadm skips the generation step and existing files will be used.</p><pre tabindex="0"><code>kubeadm init phase certs front-proxy-client [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--cert-dir string     Default: "/etc/kubernetes/pki"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for front-proxy-client</p></td></tr><tr><td colspan="2">--kubernetes-version string     Default: "stable-1"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Choose a specific Kubernetes version for the control plane.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div><div id="tab-certs-7" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-7"><p><h3 id="synopsis">Synopsis</h3><p>Generate the self-signed CA to provision identities for etcd, and save them into etcd/ca.crt and etcd/ca.key files.</p><p>If both files already exist, kubeadm skips the generation step and existing files will be used.</p><pre tabindex="0"><code>kubeadm init phase certs etcd-ca [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--cert-dir string     Default: "/etc/kubernetes/pki"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for etcd-ca</p></td></tr><tr><td colspan="2">--kubernetes-version string     Default: "stable-1"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Choose a specific Kubernetes version for the control plane.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div><div id="tab-certs-8" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-8"><p><h3 id="synopsis">Synopsis</h3><p>Generate the certificate for serving etcd, and save them into etcd/server.crt and etcd/server.key files.</p><p>Default SANs are localhost, 127.0.0.1, 127.0.0.1, ::1</p><p>If both files already exist, kubeadm skips the generation step and existing files will be used.</p><pre tabindex="0"><code>kubeadm init phase certs etcd-server [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--cert-dir string     Default: "/etc/kubernetes/pki"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for etcd-server</p></td></tr><tr><td colspan="2">--kubernetes-version string     Default: "stable-1"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Choose a specific Kubernetes version for the control plane.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div><div id="tab-certs-9" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-9"><p><h3 id="synopsis">Synopsis</h3><p>Generate the certificate for etcd nodes to communicate with each other, and save them into etcd/peer.crt and etcd/peer.key files.</p><p>Default SANs are localhost, 127.0.0.1, 127.0.0.1, ::1</p><p>If both files already exist, kubeadm skips the generation step and existing files will be used.</p><pre tabindex="0"><code>kubeadm init phase certs etcd-peer [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--cert-dir string     Default: "/etc/kubernetes/pki"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for etcd-peer</p></td></tr><tr><td colspan="2">--kubernetes-version string     Default: "stable-1"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Choose a specific Kubernetes version for the control plane.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div><div id="tab-certs-10" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-10"><p><h3 id="synopsis">Synopsis</h3><p>Generate the certificate for liveness probes to healthcheck etcd, and save them into etcd/healthcheck-client.crt and etcd/healthcheck-client.key files.</p><p>If both files already exist, kubeadm skips the generation step and existing files will be used.</p><pre tabindex="0"><code>kubeadm init phase certs etcd-healthcheck-client [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--cert-dir string     Default: "/etc/kubernetes/pki"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for etcd-healthcheck-client</p></td></tr><tr><td colspan="2">--kubernetes-version string     Default: "stable-1"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Choose a specific Kubernetes version for the control plane.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div><div id="tab-certs-11" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-11"><p><h3 id="synopsis">Synopsis</h3><p>Generate the certificate the apiserver uses to access etcd, and save them into apiserver-etcd-client.crt and apiserver-etcd-client.key files.</p><p>If both files already exist, kubeadm skips the generation step and existing files will be used.</p><pre tabindex="0"><code>kubeadm init phase certs apiserver-etcd-client [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--cert-dir string     Default: "/etc/kubernetes/pki"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for apiserver-etcd-client</p></td></tr><tr><td colspan="2">--kubernetes-version string     Default: "stable-1"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Choose a specific Kubernetes version for the control plane.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div><div id="tab-certs-12" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-12"><p><p>Generate a private key for signing service account tokens along with its public key</p><h3 id="synopsis">Synopsis</h3><p>Generate the private key for signing service account tokens along with its public key, and save them into sa.key and sa.pub files.</p><p>If both files already exist, kubeadm skips the generation step and existing files will be used.</p><pre tabindex="0"><code>kubeadm init phase certs sa [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--cert-dir string     Default: "/etc/kubernetes/pki"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for sa</p></td></tr><tr><td colspan="2">--kubernetes-version string     Default: "stable-1"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Choose a specific Kubernetes version for the control plane.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div></div><h2 id="cmd-phase-kubeconfig">kubeadm init phase kubeconfig</h2><p>You can create all required kubeconfig files by calling the <code>all</code> subcommand or call them individually.</p><ul class="nav nav-tabs" id="tab-kubeconfig" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-kubeconfig-0" role="tab" aria-controls="tab-kubeconfig-0" aria-selected="true">kubeconfig</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-kubeconfig-1" role="tab" aria-controls="tab-kubeconfig-1">all</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-kubeconfig-2" role="tab" aria-controls="tab-kubeconfig-2">admin</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-kubeconfig-3" role="tab" aria-controls="tab-kubeconfig-3">kubelet</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-kubeconfig-4" role="tab" aria-controls="tab-kubeconfig-4">controller-manager</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-kubeconfig-5" role="tab" aria-controls="tab-kubeconfig-5">scheduler</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-kubeconfig-6" role="tab" aria-controls="tab-kubeconfig-6">super-admin</a></li></ul><div class="tab-content" id="tab-kubeconfig"><div id="tab-kubeconfig-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-kubeconfig-0"><p><h3 id="synopsis">Synopsis</h3><p>Generate all kubeconfig files necessary to establish the control plane and the admin kubeconfig file</p><pre tabindex="0"><code>kubeadm init phase kubeconfig [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for kubeconfig</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div><div id="tab-kubeconfig-1" class="tab-pane" role="tabpanel" aria-labelledby="tab-kubeconfig-1"><p><h3 id="synopsis">Synopsis</h3><p>Generate all kubeconfig files</p><pre tabindex="0"><code>kubeadm init phase kubeconfig all [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--apiserver-advertise-address string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.</p></td></tr><tr><td colspan="2">--apiserver-bind-port int32     Default: 6443</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Port for the API Server to bind to.</p></td></tr><tr><td colspan="2">--cert-dir string     Default: "/etc/kubernetes/pki"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">--control-plane-endpoint string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Specify a stable IP address or DNS name for the control plane.</p></td></tr><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for all</p></td></tr><tr><td colspan="2">--kubeconfig-dir string     Default: "/etc/kubernetes"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path where to save the kubeconfig file.</p></td></tr><tr><td colspan="2">--kubernetes-version string     Default: "stable-1"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Choose a specific Kubernetes version for the control plane.</p></td></tr><tr><td colspan="2">--node-name string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Specify the node name.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div><div id="tab-kubeconfig-2" class="tab-pane" role="tabpanel" aria-labelledby="tab-kubeconfig-2"><p><p>Generate a kubeconfig file for the admin to use and for kubeadm itself</p><h3 id="synopsis">Synopsis</h3><p>Generate the kubeconfig file for the admin and for kubeadm itself, and save it to admin.conf file.</p><pre tabindex="0"><code>kubeadm init phase kubeconfig admin [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--apiserver-advertise-address string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.</p></td></tr><tr><td colspan="2">--apiserver-bind-port int32     Default: 6443</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Port for the API Server to bind to.</p></td></tr><tr><td colspan="2">--cert-dir string     Default: "/etc/kubernetes/pki"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">--control-plane-endpoint string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Specify a stable IP address or DNS name for the control plane.</p></td></tr><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for admin</p></td></tr><tr><td colspan="2">--kubeconfig-dir string     Default: "/etc/kubernetes"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path where to save the kubeconfig file.</p></td></tr><tr><td colspan="2">--kubernetes-version string     Default: "stable-1"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Choose a specific Kubernetes version for the control plane.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div><div id="tab-kubeconfig-3" class="tab-pane" role="tabpanel" aria-labelledby="tab-kubeconfig-3"><p><p>Generate a kubeconfig file for the kubelet to use <em>only</em> for cluster bootstrapping purposes</p><h3 id="synopsis">Synopsis</h3><p>Generate the kubeconfig file for the kubelet to use and save it to kubelet.conf file.</p><p>Please note that this should <em>only</em> be used for cluster bootstrapping purposes. After your control plane is up, you should request all kubelet credentials from the CSR API.</p><pre tabindex="0"><code>kubeadm init phase kubeconfig kubelet [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--apiserver-advertise-address string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.</p></td></tr><tr><td colspan="2">--apiserver-bind-port int32     Default: 6443</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Port for the API Server to bind to.</p></td></tr><tr><td colspan="2">--cert-dir string     Default: "/etc/kubernetes/pki"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">--control-plane-endpoint string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Specify a stable IP address or DNS name for the control plane.</p></td></tr><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for kubelet</p></td></tr><tr><td colspan="2">--kubeconfig-dir string     Default: "/etc/kubernetes"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path where to save the kubeconfig file.</p></td></tr><tr><td colspan="2">--kubernetes-version string     Default: "stable-1"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Choose a specific Kubernetes version for the control plane.</p></td></tr><tr><td colspan="2">--node-name string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Specify the node name.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div><div id="tab-kubeconfig-4" class="tab-pane" role="tabpanel" aria-labelledby="tab-kubeconfig-4"><p><p>Generate a kubeconfig file for the controller manager to use</p><h3 id="synopsis">Synopsis</h3><p>Generate the kubeconfig file for the controller manager to use and save it to controller-manager.conf file</p><pre tabindex="0"><code>kubeadm init phase kubeconfig controller-manager [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--apiserver-advertise-address string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.</p></td></tr><tr><td colspan="2">--apiserver-bind-port int32     Default: 6443</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Port for the API Server to bind to.</p></td></tr><tr><td colspan="2">--cert-dir string     Default: "/etc/kubernetes/pki"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">--control-plane-endpoint string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Specify a stable IP address or DNS name for the control plane.</p></td></tr><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for controller-manager</p></td></tr><tr><td colspan="2">--kubeconfig-dir string     Default: "/etc/kubernetes"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path where to save the kubeconfig file.</p></td></tr><tr><td colspan="2">--kubernetes-version string     Default: "stable-1"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Choose a specific Kubernetes version for the control plane.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div><div id="tab-kubeconfig-5" class="tab-pane" role="tabpanel" aria-labelledby="tab-kubeconfig-5"><p><p>Generate a kubeconfig file for the scheduler to use</p><h3 id="synopsis">Synopsis</h3><p>Generate the kubeconfig file for the scheduler to use and save it to scheduler.conf file.</p><pre tabindex="0"><code>kubeadm init phase kubeconfig scheduler [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--apiserver-advertise-address string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.</p></td></tr><tr><td colspan="2">--apiserver-bind-port int32     Default: 6443</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Port for the API Server to bind to.</p></td></tr><tr><td colspan="2">--cert-dir string     Default: "/etc/kubernetes/pki"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">--control-plane-endpoint string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Specify a stable IP address or DNS name for the control plane.</p></td></tr><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for scheduler</p></td></tr><tr><td colspan="2">--kubeconfig-dir string     Default: "/etc/kubernetes"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path where to save the kubeconfig file.</p></td></tr><tr><td colspan="2">--kubernetes-version string     Default: "stable-1"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Choose a specific Kubernetes version for the control plane.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div><div id="tab-kubeconfig-6" class="tab-pane" role="tabpanel" aria-labelledby="tab-kubeconfig-6"><p><h3 id="synopsis">Synopsis</h3><p>Generate a kubeconfig file for the super-admin, and save it to super-admin.conf file.</p><pre tabindex="0"><code>kubeadm init phase kubeconfig super-admin [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--apiserver-advertise-address string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.</p></td></tr><tr><td colspan="2">--apiserver-bind-port int32     Default: 6443</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Port for the API Server to bind to.</p></td></tr><tr><td colspan="2">--cert-dir string     Default: "/etc/kubernetes/pki"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">--control-plane-endpoint string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Specify a stable IP address or DNS name for the control plane.</p></td></tr><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for super-admin</p></td></tr><tr><td colspan="2">--kubeconfig-dir string     Default: "/etc/kubernetes"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path where to save the kubeconfig file.</p></td></tr><tr><td colspan="2">--kubernetes-version string     Default: "stable-1"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Choose a specific Kubernetes version for the control plane.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div></div><h2 id="cmd-phase-control-plane">kubeadm init phase control-plane</h2><p>Using this phase you can create all required static Pod files for the control plane components.</p><ul class="nav nav-tabs" id="tab-control-plane" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-control-plane-0" role="tab" aria-controls="tab-control-plane-0" aria-selected="true">control-plane</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-control-plane-1" role="tab" aria-controls="tab-control-plane-1">all</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-control-plane-2" role="tab" aria-controls="tab-control-plane-2">apiserver</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-control-plane-3" role="tab" aria-controls="tab-control-plane-3">controller-manager</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-control-plane-4" role="tab" aria-controls="tab-control-plane-4">scheduler</a></li></ul><div class="tab-content" id="tab-control-plane"><div id="tab-control-plane-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-control-plane-0"><p><h3 id="synopsis">Synopsis</h3><p>Generate all static Pod manifest files necessary to establish the control plane</p><pre tabindex="0"><code>kubeadm init phase control-plane [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for control-plane</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div><div id="tab-control-plane-1" class="tab-pane" role="tabpanel" aria-labelledby="tab-control-plane-1"><p><h3 id="synopsis">Synopsis</h3><p>Generate all static Pod manifest files</p><pre tabindex="0"><code>kubeadm init phase control-plane all [flags]
</code></pre><h3 id="examples">Examples</h3><pre tabindex="0"><code>  # Generates all static Pod manifest files for control plane components,
  # functionally equivalent to what is generated by kubeadm init.
  kubeadm init phase control-plane all
  
  # Generates all static Pod manifest files using options read from a configuration file.
  kubeadm init phase control-plane all --config config.yaml
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--apiserver-advertise-address string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.</p></td></tr><tr><td colspan="2">--apiserver-bind-port int32     Default: 6443</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Port for the API Server to bind to.</p></td></tr><tr><td colspan="2">--cert-dir string     Default: "/etc/kubernetes/pki"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">--control-plane-endpoint string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Specify a stable IP address or DNS name for the control plane.</p></td></tr><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan="2">--feature-gates string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>A set of key=value pairs that describe feature gates for various features. Options are:<br/>ControlPlaneKubeletLocalMode=true|false (BETA - default=true)<br/>NodeLocalCRISocket=true|false (BETA - default=true)<br/>PublicKeysECDSA=true|false (DEPRECATED - default=false)<br/>RootlessControlPlane=true|false (ALPHA - default=false)<br/>WaitForAllControlPlaneComponents=true|false (default=true)</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for all</p></td></tr><tr><td colspan="2">--image-repository string     Default: "registry.k8s.io"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Choose a container registry to pull control plane images from</p></td></tr><tr><td colspan="2">--kubernetes-version string     Default: "stable-1"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Choose a specific Kubernetes version for the control plane.</p></td></tr><tr><td colspan="2">--patches string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "target" can be one of "kube-apiserver", "kube-controller-manager", "kube-scheduler", "etcd", "kubeletconfiguration", "corednsdeployment". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.</p></td></tr><tr><td colspan="2">--pod-network-cidr string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Specify range of IP addresses for the pod network. If set, the control plane will automatically allocate CIDRs for every node.</p></td></tr><tr><td colspan="2">--service-cidr string     Default: "10.96.0.0/12"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Use alternative range of IP address for service VIPs.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div><div id="tab-control-plane-2" class="tab-pane" role="tabpanel" aria-labelledby="tab-control-plane-2"><p><h3 id="synopsis">Synopsis</h3><p>Generates the kube-apiserver static Pod manifest</p><pre tabindex="0"><code>kubeadm init phase control-plane apiserver [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--apiserver-advertise-address string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.</p></td></tr><tr><td colspan="2">--apiserver-bind-port int32     Default: 6443</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Port for the API Server to bind to.</p></td></tr><tr><td colspan="2">--cert-dir string     Default: "/etc/kubernetes/pki"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">--control-plane-endpoint string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Specify a stable IP address or DNS name for the control plane.</p></td></tr><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan="2">--feature-gates string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>A set of key=value pairs that describe feature gates for various features. Options are:<br/>ControlPlaneKubeletLocalMode=true|false (BETA - default=true)<br/>NodeLocalCRISocket=true|false (BETA - default=true)<br/>PublicKeysECDSA=true|false (DEPRECATED - default=false)<br/>RootlessControlPlane=true|false (ALPHA - default=false)<br/>WaitForAllControlPlaneComponents=true|false (default=true)</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for apiserver</p></td></tr><tr><td colspan="2">--image-repository string     Default: "registry.k8s.io"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Choose a container registry to pull control plane images from</p></td></tr><tr><td colspan="2">--kubernetes-version string     Default: "stable-1"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Choose a specific Kubernetes version for the control plane.</p></td></tr><tr><td colspan="2">--patches string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "target" can be one of "kube-apiserver", "kube-controller-manager", "kube-scheduler", "etcd", "kubeletconfiguration", "corednsdeployment". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.</p></td></tr><tr><td colspan="2">--service-cidr string     Default: "10.96.0.0/12"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Use alternative range of IP address for service VIPs.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div><div id="tab-control-plane-3" class="tab-pane" role="tabpanel" aria-labelledby="tab-control-plane-3"><p><h3 id="synopsis">Synopsis</h3><p>Generates the kube-controller-manager static Pod manifest</p><pre tabindex="0"><code>kubeadm init phase control-plane controller-manager [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--cert-dir string     Default: "/etc/kubernetes/pki"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for controller-manager</p></td></tr><tr><td colspan="2">--image-repository string     Default: "registry.k8s.io"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Choose a container registry to pull control plane images from</p></td></tr><tr><td colspan="2">--kubernetes-version string     Default: "stable-1"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Choose a specific Kubernetes version for the control plane.</p></td></tr><tr><td colspan="2">--patches string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "target" can be one of "kube-apiserver", "kube-controller-manager", "kube-scheduler", "etcd", "kubeletconfiguration", "corednsdeployment". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.</p></td></tr><tr><td colspan="2">--pod-network-cidr string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Specify range of IP addresses for the pod network. If set, the control plane will automatically allocate CIDRs for every node.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div><div id="tab-control-plane-4" class="tab-pane" role="tabpanel" aria-labelledby="tab-control-plane-4"><p><h3 id="synopsis">Synopsis</h3><p>Generates the kube-scheduler static Pod manifest</p><pre tabindex="0"><code>kubeadm init phase control-plane scheduler [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--cert-dir string     Default: "/etc/kubernetes/pki"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for scheduler</p></td></tr><tr><td colspan="2">--image-repository string     Default: "registry.k8s.io"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Choose a container registry to pull control plane images from</p></td></tr><tr><td colspan="2">--kubernetes-version string     Default: "stable-1"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Choose a specific Kubernetes version for the control plane.</p></td></tr><tr><td colspan="2">--patches string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "target" can be one of "kube-apiserver", "kube-controller-manager", "kube-scheduler", "etcd", "kubeletconfiguration", "corednsdeployment". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div></div><h2 id="cmd-phase-etcd">kubeadm init phase etcd</h2><p>Use the following phase to create a local etcd instance based on a static Pod file.</p><ul class="nav nav-tabs" id="tab-etcd" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-etcd-0" role="tab" aria-controls="tab-etcd-0" aria-selected="true">etcd</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-etcd-1" role="tab" aria-controls="tab-etcd-1">local</a></li></ul><div class="tab-content" id="tab-etcd"><div id="tab-etcd-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-etcd-0"><p><h3 id="synopsis">Synopsis</h3><p>Generate static Pod manifest file for local etcd</p><pre tabindex="0"><code>kubeadm init phase etcd [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for etcd</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div><div id="tab-etcd-1" class="tab-pane" role="tabpanel" aria-labelledby="tab-etcd-1"><p><h3 id="synopsis">Synopsis</h3><p>Generate the static Pod manifest file for a local, single-node local etcd instance</p><pre tabindex="0"><code>kubeadm init phase etcd local [flags]
</code></pre><h3 id="examples">Examples</h3><pre tabindex="0"><code>  # Generates the static Pod manifest file for etcd, functionally
  # equivalent to what is generated by kubeadm init.
  kubeadm init phase etcd local
  
  # Generates the static Pod manifest file for etcd using options
  # read from a configuration file.
  kubeadm init phase etcd local --config config.yaml
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--cert-dir string     Default: "/etc/kubernetes/pki"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for local</p></td></tr><tr><td colspan="2">--image-repository string     Default: "registry.k8s.io"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Choose a container registry to pull control plane images from</p></td></tr><tr><td colspan="2">--patches string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "target" can be one of "kube-apiserver", "kube-controller-manager", "kube-scheduler", "etcd", "kubeletconfiguration", "corednsdeployment". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div></div><h2 id="cmd-phase-upload-config">kubeadm init phase upload-config</h2><p>You can use this command to upload the kubeadm configuration to your cluster.
Alternatively, you can use <a href="/docs/reference/setup-tools/kubeadm/kubeadm-config/">kubeadm config</a>.</p><ul class="nav nav-tabs" id="upload-config" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#upload-config-0" role="tab" aria-controls="upload-config-0" aria-selected="true">upload-config</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#upload-config-1" role="tab" aria-controls="upload-config-1">all</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#upload-config-2" role="tab" aria-controls="upload-config-2">kubeadm</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#upload-config-3" role="tab" aria-controls="upload-config-3">kubelet</a></li></ul><div class="tab-content" id="upload-config"><div id="upload-config-0" class="tab-pane show active" role="tabpanel" aria-labelledby="upload-config-0"><p><h3 id="synopsis">Synopsis</h3><p>Upload the kubeadm and kubelet configuration to a ConfigMap</p><pre tabindex="0"><code>kubeadm init phase upload-config [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for upload-config</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div><div id="upload-config-1" class="tab-pane" role="tabpanel" aria-labelledby="upload-config-1"><p><h3 id="synopsis">Synopsis</h3><p>Upload all configuration to a config map</p><pre tabindex="0"><code>kubeadm init phase upload-config all [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">--cri-socket string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to the CRI socket to connect. If empty kubeadm will try to auto-detect this value; use this option only if you have more than one CRI installed or if you have non-standard CRI socket.</p></td></tr><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for all</p></td></tr><tr><td colspan="2">--kubeconfig string     Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div><div id="upload-config-2" class="tab-pane" role="tabpanel" aria-labelledby="upload-config-2"><p><h3 id="synopsis">Synopsis</h3><p>Upload the kubeadm ClusterConfiguration to a ConfigMap called kubeadm-config in the kube-system namespace. This enables correct configuration of system components and a seamless user experience when upgrading.</p><p>Alternatively, you can use kubeadm config.</p><pre tabindex="0"><code>kubeadm init phase upload-config kubeadm [flags]
</code></pre><h3 id="examples">Examples</h3><pre tabindex="0"><code>  # upload the configuration of your cluster
  kubeadm init phase upload-config kubeadm --config=myConfig.yaml
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">--cri-socket string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to the CRI socket to connect. If empty kubeadm will try to auto-detect this value; use this option only if you have more than one CRI installed or if you have non-standard CRI socket.</p></td></tr><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for kubeadm</p></td></tr><tr><td colspan="2">--kubeconfig string     Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div><div id="upload-config-3" class="tab-pane" role="tabpanel" aria-labelledby="upload-config-3"><p><p>Upload the kubelet component config to a ConfigMap</p><h3 id="synopsis">Synopsis</h3><p>Upload the kubelet configuration extracted from the kubeadm InitConfiguration object to a kubelet-config ConfigMap in the cluster</p><pre tabindex="0"><code>kubeadm init phase upload-config kubelet [flags]
</code></pre><h3 id="examples">Examples</h3><pre tabindex="0"><code>  # Upload the kubelet configuration from the kubeadm Config file to a ConfigMap in the cluster.
  kubeadm init phase upload-config kubelet --config kubeadm.yaml
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">--cri-socket string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to the CRI socket to connect. If empty kubeadm will try to auto-detect this value; use this option only if you have more than one CRI installed or if you have non-standard CRI socket.</p></td></tr><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for kubelet</p></td></tr><tr><td colspan="2">--kubeconfig string     Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div></div><h2 id="cmd-phase-upload-certs">kubeadm init phase upload-certs</h2><p>Use the following phase to upload control-plane certificates to the cluster.
By default the certs and encryption key expire after two hours.</p><ul class="nav nav-tabs" id="tab-upload-certs" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-upload-certs-0" role="tab" aria-controls="tab-upload-certs-0" aria-selected="true">upload-certs</a></li></ul><div class="tab-content" id="tab-upload-certs"><div id="tab-upload-certs-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-upload-certs-0"><p><p>Upload certificates to kubeadm-certs</p><h3 id="synopsis">Synopsis</h3><p>Upload control plane certificates to the kubeadm-certs Secret</p><pre tabindex="0"><code>kubeadm init phase upload-certs [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--certificate-key string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Key used to encrypt the control-plane certificates in the kubeadm-certs Secret. The certificate key is a hex encoded string that is an AES key of size 32 bytes.</p></td></tr><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for upload-certs</p></td></tr><tr><td colspan="2">--kubeconfig string     Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan="2">--skip-certificate-key-print</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Don't print the key used to encrypt the control-plane certificates.</p></td></tr><tr><td colspan="2">--upload-certs</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Upload control-plane certificates to the kubeadm-certs Secret.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div></div><h2 id="cmd-phase-mark-control-plane">kubeadm init phase mark-control-plane</h2><p>Use the following phase to label and taint the node as a control plane node.</p><ul class="nav nav-tabs" id="tab-mark-control-plane" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-mark-control-plane-0" role="tab" aria-controls="tab-mark-control-plane-0" aria-selected="true">mark-control-plane</a></li></ul><div class="tab-content" id="tab-mark-control-plane"><div id="tab-mark-control-plane-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-mark-control-plane-0"><p><h3 id="synopsis">Synopsis</h3><p>Mark a node as a control-plane</p><pre tabindex="0"><code>kubeadm init phase mark-control-plane [flags]
</code></pre><h3 id="examples">Examples</h3><pre tabindex="0"><code>  # Applies control-plane label and taint to the current node, functionally equivalent to what executed by kubeadm init.
  kubeadm init phase mark-control-plane --config config.yaml
  
  # Applies control-plane label and taint to a specific node
  kubeadm init phase mark-control-plane --node-name myNode
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for mark-control-plane</p></td></tr><tr><td colspan="2">--node-name string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Specify the node name.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div></div><h2 id="cmd-phase-bootstrap-token">kubeadm init phase bootstrap-token</h2><p>Use the following phase to configure bootstrap tokens.</p><ul class="nav nav-tabs" id="tab-bootstrap-token" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-bootstrap-token-0" role="tab" aria-controls="tab-bootstrap-token-0" aria-selected="true">bootstrap-token</a></li></ul><div class="tab-content" id="tab-bootstrap-token"><div id="tab-bootstrap-token-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-bootstrap-token-0"><p><p>Generates bootstrap tokens used to join a node to a cluster</p><h3 id="synopsis">Synopsis</h3><p>Bootstrap tokens are used for establishing bidirectional trust between a node joining the cluster and a control-plane node.</p><p>This command makes all the configurations required to make bootstrap tokens works and then creates an initial token.</p><pre tabindex="0"><code>kubeadm init phase bootstrap-token [flags]
</code></pre><h3 id="examples">Examples</h3><pre tabindex="0"><code>  # Make all the bootstrap token configurations and create an initial token, functionally
  # equivalent to what generated by kubeadm init.
  kubeadm init phase bootstrap-token
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for bootstrap-token</p></td></tr><tr><td colspan="2">--kubeconfig string     Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan="2">--skip-token-print</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Skip printing of the default bootstrap token generated by 'kubeadm init'.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div></div><h2 id="cmd-phase-kubelet-finalize-all">kubeadm init phase kubelet-finalize</h2><p>Use the following phase to update settings relevant to the kubelet after TLS
bootstrap. You can use the <code>all</code> subcommand to run all <code>kubelet-finalize</code>
phases.</p><ul class="nav nav-tabs" id="tab-kubelet-finalize" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-kubelet-finalize-0" role="tab" aria-controls="tab-kubelet-finalize-0" aria-selected="true">kubelet-finalize</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-kubelet-finalize-1" role="tab" aria-controls="tab-kubelet-finalize-1">kubelet-finalize-all</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-kubelet-finalize-2" role="tab" aria-controls="tab-kubelet-finalize-2">kubelet-finalize-enable-client-cert-rotation</a></li></ul><div class="tab-content" id="tab-kubelet-finalize"><div id="tab-kubelet-finalize-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-kubelet-finalize-0"><p><h3 id="synopsis">Synopsis</h3><p>Updates settings relevant to the kubelet after TLS bootstrap</p><pre tabindex="0"><code>kubeadm init phase kubelet-finalize [flags]
</code></pre><h3 id="examples">Examples</h3><pre tabindex="0"><code>  # Updates settings relevant to the kubelet after TLS bootstrap"
  kubeadm init phase kubelet-finalize all --config
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for kubelet-finalize</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div><div id="tab-kubelet-finalize-1" class="tab-pane" role="tabpanel" aria-labelledby="tab-kubelet-finalize-1"><p><h3 id="synopsis">Synopsis</h3><p>Run all kubelet-finalize phases</p><pre tabindex="0"><code>kubeadm init phase kubelet-finalize all [flags]
</code></pre><h3 id="examples">Examples</h3><pre tabindex="0"><code>  # Updates settings relevant to the kubelet after TLS bootstrap"
  kubeadm init phase kubelet-finalize all --config
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--cert-dir string     Default: "/etc/kubernetes/pki"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for all</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div><div id="tab-kubelet-finalize-2" class="tab-pane" role="tabpanel" aria-labelledby="tab-kubelet-finalize-2"><p><h3 id="synopsis">Synopsis</h3><p>Enable kubelet client certificate rotation</p><pre tabindex="0"><code>kubeadm init phase kubelet-finalize enable-client-cert-rotation [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--cert-dir string     Default: "/etc/kubernetes/pki"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for enable-client-cert-rotation</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div></div><h2 id="cmd-phase-addon">kubeadm init phase addon</h2><p>You can install all the available addons with the <code>all</code> subcommand, or
install them selectively.</p><ul class="nav nav-tabs" id="tab-addon" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-addon-0" role="tab" aria-controls="tab-addon-0" aria-selected="true">addon</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-addon-1" role="tab" aria-controls="tab-addon-1">all</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-addon-2" role="tab" aria-controls="tab-addon-2">coredns</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-addon-3" role="tab" aria-controls="tab-addon-3">kube-proxy</a></li></ul><div class="tab-content" id="tab-addon"><div id="tab-addon-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-addon-0"><p><h3 id="synopsis">Synopsis</h3><p>Install required addons for passing conformance tests</p><pre tabindex="0"><code>kubeadm init phase addon [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for addon</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div><div id="tab-addon-1" class="tab-pane" role="tabpanel" aria-labelledby="tab-addon-1"><p><h3 id="synopsis">Synopsis</h3><p>Install all the addons</p><pre tabindex="0"><code>kubeadm init phase addon all [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--apiserver-advertise-address string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.</p></td></tr><tr><td colspan="2">--apiserver-bind-port int32     Default: 6443</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Port for the API Server to bind to.</p></td></tr><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">--control-plane-endpoint string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Specify a stable IP address or DNS name for the control plane.</p></td></tr><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan="2">--feature-gates string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>A set of key=value pairs that describe feature gates for various features. Options are:<br/>ControlPlaneKubeletLocalMode=true|false (BETA - default=true)<br/>NodeLocalCRISocket=true|false (BETA - default=true)<br/>PublicKeysECDSA=true|false (DEPRECATED - default=false)<br/>RootlessControlPlane=true|false (ALPHA - default=false)<br/>WaitForAllControlPlaneComponents=true|false (default=true)</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for all</p></td></tr><tr><td colspan="2">--image-repository string     Default: "registry.k8s.io"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Choose a container registry to pull control plane images from</p></td></tr><tr><td colspan="2">--kubeconfig string     Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan="2">--kubernetes-version string     Default: "stable-1"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Choose a specific Kubernetes version for the control plane.</p></td></tr><tr><td colspan="2">--pod-network-cidr string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Specify range of IP addresses for the pod network. If set, the control plane will automatically allocate CIDRs for every node.</p></td></tr><tr><td colspan="2">--service-cidr string     Default: "10.96.0.0/12"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Use alternative range of IP address for service VIPs.</p></td></tr><tr><td colspan="2">--service-dns-domain string     Default: "cluster.local"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Use alternative domain for services, e.g. "myorg.internal".</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div><div id="tab-addon-2" class="tab-pane" role="tabpanel" aria-labelledby="tab-addon-2"><p><p>Install the CoreDNS addon to a Kubernetes cluster</p><h3 id="synopsis">Synopsis</h3><p>Install the CoreDNS addon components via the API server. Please note that although the DNS server is deployed, it will not be scheduled until CNI is installed.</p><pre tabindex="0"><code>kubeadm init phase addon coredns [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan="2">--feature-gates string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>A set of key=value pairs that describe feature gates for various features. Options are:<br/>ControlPlaneKubeletLocalMode=true|false (BETA - default=true)<br/>NodeLocalCRISocket=true|false (BETA - default=true)<br/>PublicKeysECDSA=true|false (DEPRECATED - default=false)<br/>RootlessControlPlane=true|false (ALPHA - default=false)<br/>WaitForAllControlPlaneComponents=true|false (default=true)</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for coredns</p></td></tr><tr><td colspan="2">--image-repository string     Default: "registry.k8s.io"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Choose a container registry to pull control plane images from</p></td></tr><tr><td colspan="2">--kubeconfig string     Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan="2">--kubernetes-version string     Default: "stable-1"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Choose a specific Kubernetes version for the control plane.</p></td></tr><tr><td colspan="2">--print-manifest</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Print the addon manifests to STDOUT instead of installing them</p></td></tr><tr><td colspan="2">--service-cidr string     Default: "10.96.0.0/12"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Use alternative range of IP address for service VIPs.</p></td></tr><tr><td colspan="2">--service-dns-domain string     Default: "cluster.local"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Use alternative domain for services, e.g. "myorg.internal".</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div><div id="tab-addon-3" class="tab-pane" role="tabpanel" aria-labelledby="tab-addon-3"><p><p>Install the kube-proxy addon to a Kubernetes cluster</p><h3 id="synopsis">Synopsis</h3><p>Install the kube-proxy addon components via the API server.</p><pre tabindex="0"><code>kubeadm init phase addon kube-proxy [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--apiserver-advertise-address string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.</p></td></tr><tr><td colspan="2">--apiserver-bind-port int32     Default: 6443</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Port for the API Server to bind to.</p></td></tr><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">--control-plane-endpoint string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Specify a stable IP address or DNS name for the control plane.</p></td></tr><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for kube-proxy</p></td></tr><tr><td colspan="2">--image-repository string     Default: "registry.k8s.io"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Choose a container registry to pull control plane images from</p></td></tr><tr><td colspan="2">--kubeconfig string     Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan="2">--kubernetes-version string     Default: "stable-1"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Choose a specific Kubernetes version for the control plane.</p></td></tr><tr><td colspan="2">--pod-network-cidr string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Specify range of IP addresses for the pod network. If set, the control plane will automatically allocate CIDRs for every node.</p></td></tr><tr><td colspan="2">--print-manifest</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Print the addon manifests to STDOUT instead of installing them</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div></div><p>For more details on each field in the <code>v1beta4</code> configuration you can navigate to our
<a href="/docs/reference/config-api/kubeadm-config.v1beta4/">API reference pages.</a></p><h2 id="what-s-next">What's next</h2><ul><li><a href="/docs/reference/setup-tools/kubeadm/kubeadm-init/">kubeadm init</a> to bootstrap a Kubernetes control-plane node</li><li><a href="/docs/reference/setup-tools/kubeadm/kubeadm-join/">kubeadm join</a> to connect a node to the cluster</li><li><a href="/docs/reference/setup-tools/kubeadm/kubeadm-reset/">kubeadm reset</a> to revert any changes made to this host by <code>kubeadm init</code> or <code>kubeadm join</code></li><li><a href="/docs/reference/setup-tools/kubeadm/kubeadm-alpha/">kubeadm alpha</a> to try experimental functionality</li></ul></div>
<hr>
<div class="td-content"><h1 data-pagefind-weight="10">kubeadm upgrade</h1><p><code>kubeadm upgrade</code> is a user-friendly command that wraps complex upgrading logic
behind one command, with support for both planning an upgrade and actually performing it.</p><h2 id="kubeadm-upgrade-guidance">kubeadm upgrade guidance</h2><p>The steps for performing an upgrade using kubeadm are outlined in <a href="/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/">this document</a>.
For older versions of kubeadm, please refer to older documentation sets of the Kubernetes website.</p><p>You can use <code>kubeadm upgrade diff</code> to see the changes that would be applied to static pod manifests.</p><p>In Kubernetes v1.15.0 and later, <code>kubeadm upgrade apply</code> and <code>kubeadm upgrade node</code> will also
automatically renew the kubeadm managed certificates on this node, including those stored in kubeconfig files.
To opt-out, it is possible to pass the flag <code>--certificate-renewal=false</code>. For more details about certificate
renewal see the <a href="/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/">certificate management documentation</a>.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>The commands <code>kubeadm upgrade apply</code> and <code>kubeadm upgrade plan</code> have a legacy <code>--config</code>
flag which makes it possible to reconfigure the cluster, while performing planning or upgrade of that particular
control-plane node. Please be aware that the upgrade workflow was not designed for this scenario and there are
reports of unexpected results.</div><h2 id="cmd-upgrade-plan">kubeadm upgrade plan</h2><h3 id="synopsis">Synopsis</h3><p>Check which versions are available to upgrade to and validate whether your current cluster is upgradeable. This command can only run on the control plane nodes where the kubeconfig file "admin.conf" exists. To skip the internet check, pass in the optional [version] parameter.</p><pre tabindex="0"><code>kubeadm upgrade plan [version] [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--allow-experimental-upgrades</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Show unstable versions of Kubernetes as an upgrade alternative and allow upgrading to an alpha/beta/release candidate versions of Kubernetes.</p></td></tr><tr><td colspan="2">--allow-missing-template-keys     Default: true</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>If true, ignore any errors in templates when a field or map key is missing in the template. Only applies to golang and jsonpath output formats.</p></td></tr><tr><td colspan="2">--allow-release-candidate-upgrades</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Show release candidate versions of Kubernetes as an upgrade alternative and allow upgrading to a release candidate versions of Kubernetes.</p></td></tr><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">--etcd-upgrade     Default: true</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Perform the upgrade of etcd.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for plan</p></td></tr><tr><td colspan="2">--ignore-preflight-errors strings</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>A list of checks whose errors will be shown as warnings. Example: 'IsPrivilegedUser,Swap'. Value 'all' ignores errors from all checks.</p></td></tr><tr><td colspan="2">--kubeconfig string     Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan="2">-o, --output string     Default: "text"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Output format. One of: text|json|yaml|go-template|go-template-file|template|templatefile|jsonpath|jsonpath-as-json|jsonpath-file.</p></td></tr><tr><td colspan="2">--print-config</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Specifies whether the configuration file that will be used in the upgrade should be printed or not.</p></td></tr><tr><td colspan="2">--show-managed-fields</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>If true, keep the managedFields when printing objects in JSON or YAML format.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table><h2 id="cmd-upgrade-apply">kubeadm upgrade apply</h2><h3 id="synopsis">Synopsis</h3><p>Upgrade your Kubernetes cluster to the specified version</p><p>The "apply [version]" command executes the following phases:</p><pre tabindex="0"><code>preflight        Run preflight checks before upgrade
control-plane    Upgrade the control plane
upload-config    Upload the kubeadm and kubelet configurations to ConfigMaps
  /kubeadm         Upload the kubeadm ClusterConfiguration to a ConfigMap
  /kubelet         Upload the kubelet configuration to a ConfigMap
kubelet-config   Upgrade the kubelet configuration for this node
bootstrap-token  Configures bootstrap token and cluster-info RBAC rules
addon            Upgrade the default kubeadm addons
  /coredns         Upgrade the CoreDNS addon
  /kube-proxy      Upgrade the kube-proxy addon
post-upgrade     Run post upgrade tasks
</code></pre><pre tabindex="0"><code>kubeadm upgrade apply [version]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--allow-experimental-upgrades</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Show unstable versions of Kubernetes as an upgrade alternative and allow upgrading to an alpha/beta/release candidate versions of Kubernetes.</p></td></tr><tr><td colspan="2">--allow-release-candidate-upgrades</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Show release candidate versions of Kubernetes as an upgrade alternative and allow upgrading to a release candidate versions of Kubernetes.</p></td></tr><tr><td colspan="2">--certificate-renewal     Default: true</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Perform the renewal of certificates used by component changed during upgrades.</p></td></tr><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Do not change any state, just output what actions would be performed.</p></td></tr><tr><td colspan="2">--etcd-upgrade     Default: true</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Perform the upgrade of etcd.</p></td></tr><tr><td colspan="2">-f, --force</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Force upgrading although some requirements might not be met. This also implies non-interactive mode.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for apply</p></td></tr><tr><td colspan="2">--ignore-preflight-errors strings</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>A list of checks whose errors will be shown as warnings. Example: 'IsPrivilegedUser,Swap'. Value 'all' ignores errors from all checks.</p></td></tr><tr><td colspan="2">--kubeconfig string     Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan="2">--patches string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "target" can be one of "kube-apiserver", "kube-controller-manager", "kube-scheduler", "etcd", "kubeletconfiguration", "corednsdeployment". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.</p></td></tr><tr><td colspan="2">--print-config</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Specifies whether the configuration file that will be used in the upgrade should be printed or not.</p></td></tr><tr><td colspan="2">--skip-phases strings</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>List of phases to be skipped</p></td></tr><tr><td colspan="2">-y, --yes</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Perform the upgrade and do not prompt for confirmation (non-interactive mode).</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table><h2 id="cmd-upgrade-diff">kubeadm upgrade diff</h2><h3 id="synopsis">Synopsis</h3><p>Show what differences would be applied to existing static pod manifests. See also: kubeadm upgrade apply --dry-run</p><pre tabindex="0"><code>kubeadm upgrade diff [version] [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">-c, --context-lines int     Default: 3</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>How many lines of context in the diff</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for diff</p></td></tr><tr><td colspan="2">--kubeconfig string     Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table><h2 id="cmd-upgrade-node">kubeadm upgrade node</h2><h3 id="synopsis">Synopsis</h3><p>Upgrade commands for a node in the cluster</p><p>The "node" command executes the following phases:</p><pre tabindex="0"><code>preflight       Run upgrade node pre-flight checks
control-plane   Upgrade the control plane instance deployed on this node, if any
kubelet-config  Upgrade the kubelet configuration for this node
addon           Upgrade the default kubeadm addons
  /coredns        Upgrade the CoreDNS addon
  /kube-proxy     Upgrade the kube-proxy addon
post-upgrade    Run post upgrade tasks
</code></pre><pre tabindex="0"><code>kubeadm upgrade node [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--certificate-renewal     Default: true</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Perform the renewal of certificates used by component changed during upgrades.</p></td></tr><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Do not change any state, just output the actions that would be performed.</p></td></tr><tr><td colspan="2">--etcd-upgrade     Default: true</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Perform the upgrade of etcd.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for node</p></td></tr><tr><td colspan="2">--ignore-preflight-errors strings</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>A list of checks whose errors will be shown as warnings. Example: 'IsPrivilegedUser,Swap'. Value 'all' ignores errors from all checks.</p></td></tr><tr><td colspan="2">--kubeconfig string     Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan="2">--patches string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "target" can be one of "kube-apiserver", "kube-controller-manager", "kube-scheduler", "etcd", "kubeletconfiguration", "corednsdeployment". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.</p></td></tr><tr><td colspan="2">--skip-phases strings</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>List of phases to be skipped</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table><h2 id="what-s-next">What's next</h2><ul><li><a href="/docs/reference/setup-tools/kubeadm/kubeadm-config/">kubeadm config</a> if you initialized your cluster using kubeadm v1.7.x or lower, to configure your cluster for <code>kubeadm upgrade</code></li></ul></div>
<hr>
<div class="td-content"><h1 data-pagefind-weight="10">Scheduler Configuration</h1><div class="feature-state-notice feature-stable"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.25 [stable]</code></div><p>You can customize the behavior of the <code>kube-scheduler</code> by writing a configuration
file and passing its path as a command line argument.</p><p>A scheduling Profile allows you to configure the different stages of scheduling
in the <a class="glossary-tooltip" title="Control plane component that watches for newly created pods with no assigned node, and selects a node for them to run on." data-toggle="tooltip" data-placement="top" href="/docs/reference/command-line-tools-reference/kube-scheduler/" target="_blank" aria-label="kube-scheduler">kube-scheduler</a>.
Each stage is exposed in an extension point. Plugins provide scheduling behaviors
by implementing one or more of these extension points.</p><p>You can specify scheduling profiles by running <code>kube-scheduler --config &lt;filename&gt;</code>,
using the
KubeSchedulerConfiguration <a href="/docs/reference/config-api/kube-scheduler-config.v1/">v1</a>
struct.</p><p>A minimal configuration looks as follows:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>kubescheduler.config.k8s.io/v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>KubeSchedulerConfiguration<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">clientConnection</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">kubeconfig</span>:<span style="color:#bbb"> </span>/etc/srv/kubernetes/kube-scheduler/kubeconfig<span style="color:#bbb">
</span></span></span></code></pre></div><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>KubeSchedulerConfiguration v1beta3 is deprecated in v1.26 and is removed in v1.29.
Please migrate KubeSchedulerConfiguration to <a href="/docs/reference/config-api/kube-scheduler-config.v1/">v1</a>.</div><h2 id="profiles">Profiles</h2><p>A scheduling Profile allows you to configure the different stages of scheduling
in the <a class="glossary-tooltip" title="Control plane component that watches for newly created pods with no assigned node, and selects a node for them to run on." data-toggle="tooltip" data-placement="top" href="/docs/reference/command-line-tools-reference/kube-scheduler/" target="_blank" aria-label="kube-scheduler">kube-scheduler</a>.
Each stage is exposed in an <a href="#extension-points">extension point</a>.
<a href="#scheduling-plugins">Plugins</a> provide scheduling behaviors by implementing one
or more of these extension points.</p><p>You can configure a single instance of <code>kube-scheduler</code> to run
<a href="#multiple-profiles">multiple profiles</a>.</p><h3 id="extension-points">Extension points</h3><p>Scheduling happens in a series of stages that are exposed through the following
extension points:</p><ol><li><code>queueSort</code>: These plugins provide an ordering function that is used to
sort pending Pods in the scheduling queue. Exactly one queue sort plugin
may be enabled at a time.</li><li><code>preFilter</code>: These plugins are used to pre-process or check information
about a Pod or the cluster before filtering. They can mark a pod as
unschedulable.</li><li><code>filter</code>: These plugins are the equivalent of Predicates in a scheduling
Policy and are used to filter out nodes that can not run the Pod. Filters
are called in the configured order. A pod is marked as unschedulable if no
nodes pass all the filters.</li><li><code>postFilter</code>: These plugins are called in their configured order when no
feasible nodes were found for the pod. If any <code>postFilter</code> plugin marks the
Pod <em>schedulable</em>, the remaining plugins are not called.</li><li><code>preScore</code>: This is an informational extension point that can be used
for doing pre-scoring work.</li><li><code>score</code>: These plugins provide a score to each node that has passed the
filtering phase. The scheduler will then select the node with the highest
weighted scores sum.</li><li><code>reserve</code>: This is an informational extension point that notifies plugins
when resources have been reserved for a given Pod. Plugins also implement an
<code>Unreserve</code> call that gets called in the case of failure during or after
<code>Reserve</code>.</li><li><code>permit</code>: These plugins can prevent or delay the binding of a Pod.</li><li><code>preBind</code>: These plugins perform any work required before a Pod is bound.</li><li><code>bind</code>: The plugins bind a Pod to a Node. <code>bind</code> plugins are called in order
and once one has done the binding, the remaining plugins are skipped. At
least one bind plugin is required.</li><li><code>postBind</code>: This is an informational extension point that is called after
a Pod has been bound.</li><li><code>multiPoint</code>: This is a config-only field that allows plugins to be enabled
or disabled for all of their applicable extension points simultaneously.</li></ol><p>For each extension point, you could disable specific <a href="#scheduling-plugins">default plugins</a>
or enable your own. For example:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>kubescheduler.config.k8s.io/v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>KubeSchedulerConfiguration<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">profiles</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span>- <span style="color:green;font-weight:700">plugins</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">score</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">disabled</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>PodTopologySpread<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">enabled</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>MyCustomPluginA<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">          </span><span style="color:green;font-weight:700">weight</span>:<span style="color:#bbb"> </span><span style="color:#666">2</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>MyCustomPluginB<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">          </span><span style="color:green;font-weight:700">weight</span>:<span style="color:#bbb"> </span><span style="color:#666">1</span><span style="color:#bbb">
</span></span></span></code></pre></div><p>You can use <code>*</code> as name in the disabled array to disable all default plugins
for that extension point. This can also be used to rearrange plugins order, if
desired.</p><h3 id="scheduling-plugins">Scheduling plugins</h3><p>The following plugins, enabled by default, implement one or more of these
extension points:</p><ul><li><code>ImageLocality</code>: Favors nodes that already have the container images that the
Pod runs.
Extension points: <code>score</code>.</li><li><code>TaintToleration</code>: Implements
<a href="/docs/concepts/scheduling-eviction/taint-and-toleration/">taints and tolerations</a>.
Implements extension points: <code>filter</code>, <code>preScore</code>, <code>score</code>.</li><li><code>NodeName</code>: Checks if a Pod spec node name matches the current node.
Extension points: <code>filter</code>.</li><li><code>NodePorts</code>: Checks if a node has free ports for the requested Pod ports.
Extension points: <code>preFilter</code>, <code>filter</code>.</li><li><code>NodeAffinity</code>: Implements
<a href="/docs/concepts/scheduling-eviction/assign-pod-node/#nodeselector">node selectors</a>
and <a href="/docs/concepts/scheduling-eviction/assign-pod-node/#node-affinity">node affinity</a>.
Extension points: <code>filter</code>, <code>score</code>.</li><li><code>PodTopologySpread</code>: Implements
<a href="/docs/concepts/scheduling-eviction/topology-spread-constraints/">Pod topology spread</a>.
Extension points: <code>preFilter</code>, <code>filter</code>, <code>preScore</code>, <code>score</code>.</li><li><code>NodeUnschedulable</code>: Filters out nodes that have <code>.spec.unschedulable</code> set to
true.
Extension points: <code>filter</code>.</li><li><code>NodeResourcesFit</code>: Checks if the node has all the resources that the Pod is
requesting. The score can use one of three strategies: <code>LeastAllocated</code>
(default), <code>MostAllocated</code> and <code>RequestedToCapacityRatio</code>.
Extension points: <code>preFilter</code>, <code>filter</code>, <code>score</code>.</li><li><code>NodeResourcesBalancedAllocation</code>: Favors nodes that would obtain a more
balanced resource usage if the Pod is scheduled there.
Extension points: <code>score</code>.</li><li><code>VolumeBinding</code>: Checks if the node has or if it can bind the requested
<a class="glossary-tooltip" title="A directory containing data, accessible to the containers in a pod." data-toggle="tooltip" data-placement="top" href="/docs/concepts/storage/volumes/" target="_blank" aria-label="volumes">volumes</a>.
Extension points: <code>preFilter</code>, <code>filter</code>, <code>reserve</code>, <code>preBind</code>, <code>score</code>.<div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4><code>score</code> extension point is enabled when <code>StorageCapacityScoring</code> feature is
enabled. It prioritizes the smallest PVs that can fit the requested volume
size.</div></li><li><code>VolumeRestrictions</code>: Checks that volumes mounted in the node satisfy
restrictions that are specific to the volume provider.
Extension points: <code>filter</code>.</li><li><code>VolumeZone</code>: Checks that volumes requested satisfy any zone requirements they
might have.
Extension points: <code>filter</code>.</li><li><code>NodeVolumeLimits</code>: Checks that CSI volume limits can be satisfied for the
node.
Extension points: <code>filter</code>.</li><li><code>EBSLimits</code>: Checks that AWS EBS volume limits can be satisfied for the node.
Extension points: <code>filter</code>.</li><li><code>GCEPDLimits</code>: Checks that GCP-PD volume limits can be satisfied for the node.
Extension points: <code>filter</code>.</li><li><code>AzureDiskLimits</code>: Checks that Azure disk volume limits can be satisfied for
the node.
Extension points: <code>filter</code>.</li><li><code>InterPodAffinity</code>: Implements
<a href="/docs/concepts/scheduling-eviction/assign-pod-node/#inter-pod-affinity-and-anti-affinity">inter-Pod affinity and anti-affinity</a>.
Extension points: <code>preFilter</code>, <code>filter</code>, <code>preScore</code>, <code>score</code>.</li><li><code>PrioritySort</code>: Provides the default priority based sorting.
Extension points: <code>queueSort</code>.</li><li><code>DefaultBinder</code>: Provides the default binding mechanism.
Extension points: <code>bind</code>.</li><li><code>DefaultPreemption</code>: Provides the default preemption mechanism.
Extension points: <code>postFilter</code>.</li></ul><p>You can also enable the following plugins, through the component config APIs,
that are not enabled by default:</p><ul><li><code>CinderLimits</code>: Checks that <a href="https://docs.openstack.org/cinder/">OpenStack Cinder</a>
volume limits can be satisfied for the node.
Extension points: <code>filter</code>.</li></ul><h3 id="multiple-profiles">Multiple profiles</h3><p>You can configure <code>kube-scheduler</code> to run more than one profile.
Each profile has an associated scheduler name and can have a different set of
plugins configured in its <a href="#extension-points">extension points</a>.</p><p>With the following sample configuration, the scheduler will run with two
profiles: one with the default plugins and one with all scoring plugins
disabled.</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>kubescheduler.config.k8s.io/v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>KubeSchedulerConfiguration<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">profiles</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span>- <span style="color:green;font-weight:700">schedulerName</span>:<span style="color:#bbb"> </span>default-scheduler<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span>- <span style="color:green;font-weight:700">schedulerName</span>:<span style="color:#bbb"> </span><span style="color:#a2f;font-weight:700">no</span>-scoring-scheduler<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">plugins</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">preScore</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">disabled</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span><span style="color:#b44">'*'</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">score</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">disabled</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span><span style="color:#b44">'*'</span><span style="color:#bbb">
</span></span></span></code></pre></div><p>Pods that want to be scheduled according to a specific profile can include
the corresponding scheduler name in its <code>.spec.schedulerName</code>.</p><p>By default, one profile with the scheduler name <code>default-scheduler</code> is created.
This profile includes the default plugins described above. When declaring more
than one profile, a unique scheduler name for each of them is required.</p><p>If a Pod doesn't specify a scheduler name, kube-apiserver will set it to
<code>default-scheduler</code>. Therefore, a profile with this scheduler name should exist
to get those pods scheduled.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4><p>Pod's scheduling events have <code>.spec.schedulerName</code> as their <code>reportingController</code>.
Events for leader election use the scheduler name of the first profile in the list.</p><p>For more information, please refer to the <code>reportingController</code> section under
<a href="/docs/reference/kubernetes-api/cluster-resources/event-v1/">Event API Reference</a>.</p></div><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>All profiles must use the same plugin in the <code>queueSort</code> extension point and have
the same configuration parameters (if applicable). This is because the scheduler
only has one pending pods queue.</div><h3 id="multipoint">Plugins that apply to multiple extension points</h3><p>Starting from <code>kubescheduler.config.k8s.io/v1beta3</code>, there is an additional field in the
profile config, <code>multiPoint</code>, which allows for easily enabling or disabling a plugin
across several extension points. The intent of <code>multiPoint</code> config is to simplify the
configuration needed for users and administrators when using custom profiles.</p><p>Consider a plugin, <code>MyPlugin</code>, which implements the <code>preScore</code>, <code>score</code>, <code>preFilter</code>,
and <code>filter</code> extension points. To enable <code>MyPlugin</code> for all its available extension
points, the profile config looks like:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>kubescheduler.config.k8s.io/v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>KubeSchedulerConfiguration<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">profiles</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span>- <span style="color:green;font-weight:700">schedulerName</span>:<span style="color:#bbb"> </span>multipoint-scheduler<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">plugins</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">multiPoint</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">enabled</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>MyPlugin<span style="color:#bbb">
</span></span></span></code></pre></div><p>This would equate to manually enabling <code>MyPlugin</code> for all of its extension
points, like so:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>kubescheduler.config.k8s.io/v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>KubeSchedulerConfiguration<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">profiles</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span>- <span style="color:green;font-weight:700">schedulerName</span>:<span style="color:#bbb"> </span>non-multipoint-scheduler<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">plugins</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">preScore</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">enabled</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>MyPlugin<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">score</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">enabled</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>MyPlugin<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">preFilter</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">enabled</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>MyPlugin<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">filter</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">enabled</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>MyPlugin<span style="color:#bbb">
</span></span></span></code></pre></div><p>One benefit of using <code>multiPoint</code> here is that if <code>MyPlugin</code> implements another
extension point in the future, the <code>multiPoint</code> config will automatically enable it
for the new extension.</p><p>Specific extension points can be excluded from <code>MultiPoint</code> expansion using
the <code>disabled</code> field for that extension point. This works with disabling default
plugins, non-default plugins, or with the wildcard (<code>'*'</code>) to disable all plugins.
An example of this, disabling <code>Score</code> and <code>PreScore</code>, would be:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>kubescheduler.config.k8s.io/v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>KubeSchedulerConfiguration<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">profiles</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span>- <span style="color:green;font-weight:700">schedulerName</span>:<span style="color:#bbb"> </span>non-multipoint-scheduler<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">plugins</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">multiPoint</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">enabled</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span><span style="color:#b44">'MyPlugin'</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">preScore</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">disabled</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span><span style="color:#b44">'*'</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">score</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">disabled</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span><span style="color:#b44">'*'</span><span style="color:#bbb">
</span></span></span></code></pre></div><p>Starting from <code>kubescheduler.config.k8s.io/v1beta3</code>, all <a href="#scheduling-plugins">default plugins</a>
are enabled internally through <code>MultiPoint</code>.
However, individual extension points are still available to allow flexible
reconfiguration of the default values (such as ordering and Score weights). For
example, consider two Score plugins <code>DefaultScore1</code> and <code>DefaultScore2</code>, each with
a weight of <code>1</code>. They can be reordered with different weights like so:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>kubescheduler.config.k8s.io/v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>KubeSchedulerConfiguration<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">profiles</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span>- <span style="color:green;font-weight:700">schedulerName</span>:<span style="color:#bbb"> </span>multipoint-scheduler<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">plugins</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">score</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">enabled</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span><span style="color:#b44">'DefaultScore2'</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">          </span><span style="color:green;font-weight:700">weight</span>:<span style="color:#bbb"> </span><span style="color:#666">5</span><span style="color:#bbb">
</span></span></span></code></pre></div><p>In this example, it's unnecessary to specify the plugins in <code>MultiPoint</code> explicitly
because they are default plugins. And the only plugin specified in <code>Score</code> is <code>DefaultScore2</code>.
This is because plugins set through specific extension points will always take precedence
over <code>MultiPoint</code> plugins. So, this snippet essentially re-orders the two plugins
without needing to specify both of them.</p><p>The general hierarchy for precedence when configuring <code>MultiPoint</code> plugins is as follows:</p><ol><li>Specific extension points run first, and their settings override whatever is set elsewhere</li><li>Plugins manually configured through <code>MultiPoint</code> and their settings</li><li>Default plugins and their default settings</li></ol><p>To demonstrate the above hierarchy, the following example is based on these plugins:</p><table><thead><tr><th>Plugin</th><th>Extension Points</th></tr></thead><tbody><tr><td><code>DefaultQueueSort</code></td><td><code>QueueSort</code></td></tr><tr><td><code>CustomQueueSort</code></td><td><code>QueueSort</code></td></tr><tr><td><code>DefaultPlugin1</code></td><td><code>Score</code>, <code>Filter</code></td></tr><tr><td><code>DefaultPlugin2</code></td><td><code>Score</code></td></tr><tr><td><code>CustomPlugin1</code></td><td><code>Score</code>, <code>Filter</code></td></tr><tr><td><code>CustomPlugin2</code></td><td><code>Score</code>, <code>Filter</code></td></tr></tbody></table><p>A valid sample configuration for these plugins would be:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>kubescheduler.config.k8s.io/v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>KubeSchedulerConfiguration<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">profiles</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span>- <span style="color:green;font-weight:700">schedulerName</span>:<span style="color:#bbb"> </span>multipoint-scheduler<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">plugins</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">multiPoint</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">enabled</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span><span style="color:#b44">'CustomQueueSort'</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span><span style="color:#b44">'CustomPlugin1'</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">          </span><span style="color:green;font-weight:700">weight</span>:<span style="color:#bbb"> </span><span style="color:#666">3</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span><span style="color:#b44">'CustomPlugin2'</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">disabled</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span><span style="color:#b44">'DefaultQueueSort'</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">filter</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">disabled</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span><span style="color:#b44">'DefaultPlugin1'</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">score</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">enabled</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span><span style="color:#b44">'DefaultPlugin2'</span><span style="color:#bbb">
</span></span></span></code></pre></div><p>Note that there is no error for re-declaring a <code>MultiPoint</code> plugin in a specific
extension point. The re-declaration is ignored (and logged), as specific extension points
take precedence.</p><p>Besides keeping most of the config in one spot, this sample does a few things:</p><ul><li>Enables the custom <code>queueSort</code> plugin and disables the default one</li><li>Enables <code>CustomPlugin1</code> and <code>CustomPlugin2</code>, which will run first for all of their extension points</li><li>Disables <code>DefaultPlugin1</code>, but only for <code>filter</code></li><li>Reorders <code>DefaultPlugin2</code> to run first in <code>score</code> (even before the custom plugins)</li></ul><p>In versions of the config before <code>v1beta3</code>, without <code>multiPoint</code>, the above snippet would equate to this:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>kubescheduler.config.k8s.io/v1beta2<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>KubeSchedulerConfiguration<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">profiles</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span>- <span style="color:green;font-weight:700">schedulerName</span>:<span style="color:#bbb"> </span>multipoint-scheduler<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">plugins</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># Disable the default QueueSort plugin</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">queueSort</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">enabled</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span><span style="color:#b44">'CustomQueueSort'</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">disabled</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span><span style="color:#b44">'DefaultQueueSort'</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># Enable custom Filter plugins</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">filter</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">enabled</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span><span style="color:#b44">'CustomPlugin1'</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span><span style="color:#b44">'CustomPlugin2'</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span><span style="color:#b44">'DefaultPlugin2'</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">disabled</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span><span style="color:#b44">'DefaultPlugin1'</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># Enable and reorder custom score plugins</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">score</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">enabled</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span><span style="color:#b44">'DefaultPlugin2'</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">          </span><span style="color:green;font-weight:700">weight</span>:<span style="color:#bbb"> </span><span style="color:#666">1</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span><span style="color:#b44">'DefaultPlugin1'</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">          </span><span style="color:green;font-weight:700">weight</span>:<span style="color:#bbb"> </span><span style="color:#666">3</span><span style="color:#bbb">
</span></span></span></code></pre></div><p>While this is a complicated example, it demonstrates the flexibility of <code>MultiPoint</code> config
as well as its seamless integration with the existing methods for configuring extension points.</p><h2 id="scheduler-configuration-migrations">Scheduler configuration migrations</h2><ul class="nav nav-tabs" id="tab-with-md" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-with-md-0" role="tab" aria-controls="tab-with-md-0" aria-selected="true">v1beta1 → v1beta2</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-with-md-1" role="tab" aria-controls="tab-with-md-1">v1beta2 → v1beta3</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-with-md-2" role="tab" aria-controls="tab-with-md-2">v1beta3 → v1</a></li></ul><div class="tab-content" id="tab-with-md"><div id="tab-with-md-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-with-md-0"><p><ul><li><p>With the v1beta2 configuration version, you can use a new score extension for the
<code>NodeResourcesFit</code> plugin.
The new extension combines the functionalities of the <code>NodeResourcesLeastAllocated</code>,
<code>NodeResourcesMostAllocated</code> and <code>RequestedToCapacityRatio</code> plugins.
For example, if you previously used the <code>NodeResourcesMostAllocated</code> plugin, you
would instead use <code>NodeResourcesFit</code> (enabled by default) and add a <code>pluginConfig</code>
with a <code>scoreStrategy</code> that is similar to:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>kubescheduler.config.k8s.io/v1beta2<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>KubeSchedulerConfiguration<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">profiles</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/>- <span style="color:green;font-weight:700">pluginConfig</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span>- <span style="color:green;font-weight:700">args</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">scoringStrategy</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">resources</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>cpu<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">          </span><span style="color:green;font-weight:700">weight</span>:<span style="color:#bbb"> </span><span style="color:#666">1</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">type</span>:<span style="color:#bbb"> </span>MostAllocated<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>NodeResourcesFit<span style="color:#bbb">
</span></span></span></code></pre></div></li><li><p>The scheduler plugin <code>NodeLabel</code> is deprecated; instead, use the <a href="/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity"><code>NodeAffinity</code></a> plugin (enabled by default) to achieve similar behavior.</p></li><li><p>The scheduler plugin <code>ServiceAffinity</code> is deprecated; instead, use the <a href="/docs/concepts/scheduling-eviction/assign-pod-node/#inter-pod-affinity-and-anti-affinity"><code>InterPodAffinity</code></a> plugin (enabled by default) to achieve similar behavior.</p></li><li><p>The scheduler plugin <code>NodePreferAvoidPods</code> is deprecated; instead, use <a href="/docs/concepts/scheduling-eviction/taint-and-toleration/">node taints</a> to achieve similar behavior.</p></li><li><p>A plugin enabled in a v1beta2 configuration file takes precedence over the default configuration for that plugin.</p></li><li><p>Invalid <code>host</code> or <code>port</code> configured for scheduler healthz and metrics bind address will cause validation failure.</p></li></ul></p></div><div id="tab-with-md-1" class="tab-pane" role="tabpanel" aria-labelledby="tab-with-md-1"><p><ul><li>Three plugins' weight are increased by default:<ul><li><code>InterPodAffinity</code> from 1 to 2</li><li><code>NodeAffinity</code> from 1 to 2</li><li><code>TaintToleration</code> from 1 to 3</li></ul></li></ul></p></div><div id="tab-with-md-2" class="tab-pane" role="tabpanel" aria-labelledby="tab-with-md-2"><p><ul><li>The scheduler plugin <code>SelectorSpread</code> is removed, instead, use the <code>PodTopologySpread</code> plugin (enabled by default)
to achieve similar behavior.</li></ul></p></div></div><h2 id="what-s-next">What's next</h2><ul><li>Read the <a href="/docs/reference/command-line-tools-reference/kube-scheduler/">kube-scheduler reference</a></li><li>Learn about <a href="/docs/concepts/scheduling-eviction/kube-scheduler/">scheduling</a></li><li>Read the <a href="/docs/reference/config-api/kube-scheduler-config.v1/">kube-scheduler configuration (v1)</a> reference</li></ul></div>
<hr>
<div class="td-content"><h1 data-pagefind-weight="10">Implementation details</h1><div class="feature-state-notice feature-stable"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.10 [stable]</code></div><p><code>kubeadm init</code> and <code>kubeadm join</code> together provide a nice user experience for creating a
bare Kubernetes cluster from scratch, that aligns with the best-practices.
However, it might not be obvious <em>how</em> kubeadm does that.</p><p>This document provides additional details on what happens under the hood, with the aim of sharing
knowledge on the best practices for a Kubernetes cluster.</p><h2 id="core-design-principles">Core design principles</h2><p>The cluster that <code>kubeadm init</code> and <code>kubeadm join</code> set up should be:</p><ul><li><strong>Secure</strong>: It should adopt latest best-practices like:<ul><li>enforcing RBAC</li><li>using the Node Authorizer</li><li>using secure communication between the control plane components</li><li>using secure communication between the API server and the kubelets</li><li>lock-down the kubelet API</li><li>locking down access to the API for system components like the kube-proxy and CoreDNS</li><li>locking down what a Bootstrap Token can access</li></ul></li><li><strong>User-friendly</strong>: The user should not have to run anything more than a couple of commands:<ul><li><code>kubeadm init</code></li><li><code>export KUBECONFIG=/etc/kubernetes/admin.conf</code></li><li><code>kubectl apply -f &lt;network-plugin-of-choice.yaml&gt;</code></li><li><code>kubeadm join --token &lt;token&gt; &lt;endpoint&gt;:&lt;port&gt;</code></li></ul></li><li><strong>Extendable</strong>:<ul><li>It should <em>not</em> favor any particular network provider. Configuring the cluster network is out-of-scope</li><li>It should provide the possibility to use a config file for customizing various parameters</li></ul></li></ul><h2 id="constants-and-well-known-values-and-paths">Constants and well-known values and paths</h2><p>In order to reduce complexity and to simplify development of higher level tools that build on top of kubeadm, it uses a
limited set of constant values for well-known paths and file names.</p><p>The Kubernetes directory <code>/etc/kubernetes</code> is a constant in the application, since it is clearly the given path
in a majority of cases, and the most intuitive location; other constant paths and file names are:</p><ul><li><p><code>/etc/kubernetes/manifests</code> as the path where the kubelet should look for static Pod manifests.
Names of static Pod manifests are:</p><ul><li><code>etcd.yaml</code></li><li><code>kube-apiserver.yaml</code></li><li><code>kube-controller-manager.yaml</code></li><li><code>kube-scheduler.yaml</code></li></ul></li><li><p><code>/etc/kubernetes/</code> as the path where kubeconfig files with identities for control plane
components are stored. Names of kubeconfig files are:</p><ul><li><code>kubelet.conf</code> (<code>bootstrap-kubelet.conf</code> during TLS bootstrap)</li><li><code>controller-manager.conf</code></li><li><code>scheduler.conf</code></li><li><code>admin.conf</code> for the cluster admin and kubeadm itself</li><li><code>super-admin.conf</code> for the cluster super-admin that can bypass RBAC</li></ul></li><li><p>Names of certificates and key files:</p><ul><li><code>ca.crt</code>, <code>ca.key</code> for the Kubernetes certificate authority</li><li><code>apiserver.crt</code>, <code>apiserver.key</code> for the API server certificate</li><li><code>apiserver-kubelet-client.crt</code>, <code>apiserver-kubelet-client.key</code> for the client certificate used
by the API server to connect to the kubelets securely</li><li><code>sa.pub</code>, <code>sa.key</code> for the key used by the controller manager when signing ServiceAccount</li><li><code>front-proxy-ca.crt</code>, <code>front-proxy-ca.key</code> for the front proxy certificate authority</li><li><code>front-proxy-client.crt</code>, <code>front-proxy-client.key</code> for the front proxy client</li></ul></li></ul><h2 id="the-kubeadm-configuration-file-format">The kubeadm configuration file format</h2><p>Most kubeadm commands support a <code>--config</code> flag which allows passing a configuration file from
disk. The configuration file format follows the common Kubernetes API <code>apiVersion</code> / <code>kind</code> scheme,
but is considered a component configuration format. Several Kubernetes components, such as the kubelet,
also support file-based configuration.</p><p>Different kubeadm subcommands require a different <code>kind</code> of configuration file.
For example, <code>InitConfiguration</code> for <code>kubeadm init</code>, <code>JoinConfiguration</code> for <code>kubeadm join</code>, <code>UpgradeConfiguration</code> for <code>kubeadm upgrade</code> and <code>ResetConfiguration</code>
for <code>kubeadm reset</code>.</p><p>The command <code>kubeadm config migrate</code> can be used to migrate an older format configuration
file to a newer (current) configuration format. The kubeadm tool only supports migrating from
deprecated configuration formats to the current format.</p><p>See the <a href="/docs/reference/config-api/kubeadm-config.v1beta4/">kubeadm configuration reference</a> page for more details.</p><h2 id="kubeadm-init-workflow-internal-design">kubeadm init workflow internal design</h2><p>The <code>kubeadm init</code> consists of a sequence of atomic work tasks to perform,
as described in the <code>kubeadm init</code> <a href="/docs/reference/setup-tools/kubeadm/kubeadm-init/#init-workflow">internal workflow</a>.</p><p>The <a href="/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/"><code>kubeadm init phase</code></a> command allows
users to invoke each task individually, and ultimately offers a reusable and composable
API/toolbox that can be used by other Kubernetes bootstrap tools, by any IT automation tool or by
an advanced user for creating custom clusters.</p><h3 id="preflight-checks">Preflight checks</h3><p>Kubeadm executes a set of preflight checks before starting the init, with the aim to verify
preconditions and avoid common cluster startup problems.
The user can skip specific preflight checks or all of them with the <code>--ignore-preflight-errors</code> option.</p><ul><li>[Warning] if the Kubernetes version to use (specified with the <code>--kubernetes-version</code> flag) is
at least one minor version higher than the kubeadm CLI version.</li><li>Kubernetes system requirements:<ul><li>if running on linux:<ul><li>[Error] if Kernel is older than the minimum required version</li><li>[Error] if required cgroups subsystem aren't set up</li></ul></li></ul></li><li>[Error] if the CRI endpoint does not answer</li><li>[Error] if user is not root</li><li>[Error] if the machine hostname is not a valid DNS subdomain</li><li>[Warning] if the host name cannot be reached via network lookup</li><li>[Error] if kubelet version is lower that the minimum kubelet version supported by kubeadm (current minor -1)</li><li>[Error] if kubelet version is at least one minor higher than the required controlplane version (unsupported version skew)</li><li>[Warning] if kubelet service does not exist or if it is disabled</li><li>[Warning] if firewalld is active</li><li>[Error] if API server bindPort or ports 10250/10251/10252 are used</li><li>[Error] if <code>/etc/kubernetes/manifest</code> folder already exists and it is not empty</li><li>[Error] if swap is on</li><li>[Error] if <code>ip</code>, <code>iptables</code>, <code>mount</code>, <code>nsenter</code> commands are not present in the command path</li><li>[Warning] if <code>ethtool</code>, <code>tc</code>, <code>touch</code> commands are not present in the command path</li><li>[Warning] if extra arg flags for API server, controller manager, scheduler contains some invalid options</li><li>[Warning] if connection to https://API.AdvertiseAddress:API.BindPort goes through proxy</li><li>[Warning] if connection to services subnet goes through proxy (only first address checked)</li><li>[Warning] if connection to Pods subnet goes through proxy (only first address checked)</li><li>If external etcd is provided:<ul><li>[Error] if etcd version is older than the minimum required version</li><li>[Error] if etcd certificates or keys are specified, but not provided</li></ul></li><li>If external etcd is NOT provided (and thus local etcd will be installed):<ul><li>[Error] if ports 2379 is used</li><li>[Error] if Etcd.DataDir folder already exists and it is not empty</li></ul></li><li>If authorization mode is ABAC:<ul><li>[Error] if abac_policy.json does not exist</li></ul></li><li>If authorization mode is WebHook<ul><li>[Error] if webhook_authz.conf does not exist</li></ul></li></ul><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>Preflight checks can be invoked individually with the
<a href="/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-preflight"><code>kubeadm init phase preflight</code></a>
command.</div><h3 id="generate-the-necessary-certificates">Generate the necessary certificates</h3><p>Kubeadm generates certificate and private key pairs for different purposes:</p><ul><li><p>A self signed certificate authority for the Kubernetes cluster saved into <code>ca.crt</code> file and
<code>ca.key</code> private key file</p></li><li><p>A serving certificate for the API server, generated using <code>ca.crt</code> as the CA, and saved into
<code>apiserver.crt</code> file with its private key <code>apiserver.key</code>. This certificate should contain
the following alternative names:</p><ul><li>The Kubernetes service's internal clusterIP (the first address in the services CIDR, e.g.
<code>10.96.0.1</code> if service subnet is <code>10.96.0.0/12</code>)</li><li>Kubernetes DNS names, e.g. <code>kubernetes.default.svc.cluster.local</code> if <code>--service-dns-domain</code>
flag value is <code>cluster.local</code>, plus default DNS names <code>kubernetes.default.svc</code>,
<code>kubernetes.default</code>, <code>kubernetes</code></li><li>The node-name</li><li>The <code>--apiserver-advertise-address</code></li><li>Additional alternative names specified by the user</li></ul></li><li><p>A client certificate for the API server to connect to the kubelets securely, generated using
<code>ca.crt</code> as the CA and saved into <code>apiserver-kubelet-client.crt</code> file with its private key
<code>apiserver-kubelet-client.key</code>.
This certificate should be in the <code>system:masters</code> organization</p></li><li><p>A private key for signing ServiceAccount Tokens saved into <code>sa.key</code> file along with its public key <code>sa.pub</code></p></li><li><p>A certificate authority for the front proxy saved into <code>front-proxy-ca.crt</code> file with its key
<code>front-proxy-ca.key</code></p></li><li><p>A client certificate for the front proxy client, generated using <code>front-proxy-ca.crt</code> as the CA and
saved into <code>front-proxy-client.crt</code> file with its private key<code>front-proxy-client.key</code></p></li></ul><p>Certificates are stored by default in <code>/etc/kubernetes/pki</code>, but this directory is configurable
using the <code>--cert-dir</code> flag.</p><p>Please note that:</p><ol><li>If a given certificate and private key pair both exist, and their content is evaluated to be compliant with the above specs, the existing files will
be used and the generation phase for the given certificate will be skipped. This means the user can, for example, copy an existing CA to
<code>/etc/kubernetes/pki/ca.{crt,key}</code>, and then kubeadm will use those files for signing the rest of the certs.
See also <a href="/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/#custom-certificates">using custom certificates</a></li><li>For the CA, it is possible to provide the <code>ca.crt</code> file but not the <code>ca.key</code> file. If all other certificates and kubeconfig files
are already in place, kubeadm recognizes this condition and activates the ExternalCA, which also implies the <code>csrsigner</code> controller in
controller-manager won't be started</li><li>If kubeadm is running in <a href="/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/#external-ca-mode">external CA mode</a>;
all the certificates must be provided by the user, because kubeadm cannot generate them by itself</li><li>In case kubeadm is executed in the <code>--dry-run</code> mode, certificate files are written in a temporary folder</li><li>Certificate generation can be invoked individually with the
<a href="/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-certs"><code>kubeadm init phase certs all</code></a> command</li></ol><h3 id="generate-kubeconfig-files-for-control-plane-components">Generate kubeconfig files for control plane components</h3><p>Kubeadm generates kubeconfig files with identities for control plane components:</p><ul><li><p>A kubeconfig file for the kubelet to use during TLS bootstrap -
<code>/etc/kubernetes/bootstrap-kubelet.conf</code>. Inside this file, there is a bootstrap-token or embedded
client certificates for authenticating this node with the cluster.</p><p>This client certificate should:</p><ul><li>Be in the <code>system:nodes</code> organization, as required by the
<a href="/docs/reference/access-authn-authz/node/">Node Authorization</a> module</li><li>Have the Common Name (CN) <code>system:node:&lt;hostname-lowercased&gt;</code></li></ul></li><li><p>A kubeconfig file for controller-manager, <code>/etc/kubernetes/controller-manager.conf</code>; inside this
file is embedded a client certificate with controller-manager identity. This client certificate should
have the CN <code>system:kube-controller-manager</code>, as defined by default
<a href="/docs/reference/access-authn-authz/rbac/#core-component-roles">RBAC core components roles</a></p></li><li><p>A kubeconfig file for scheduler, <code>/etc/kubernetes/scheduler.conf</code>; inside this file is embedded
a client certificate with scheduler identity.
This client certificate should have the CN <code>system:kube-scheduler</code>, as defined by default
<a href="/docs/reference/access-authn-authz/rbac/#core-component-roles">RBAC core components roles</a></p></li></ul><p>Additionally, a kubeconfig file for kubeadm as an administrative entity is generated and stored
in <code>/etc/kubernetes/admin.conf</code>. This file includes a certificate with
<code>Subject: O = kubeadm:cluster-admins, CN = kubernetes-admin</code>. <code>kubeadm:cluster-admins</code>
is a group managed by kubeadm. It is bound to the <code>cluster-admin</code> ClusterRole during <code>kubeadm init</code>,
by using the <code>super-admin.conf</code> file, which does not require RBAC.
This <code>admin.conf</code> file must remain on control plane nodes and should not be shared with additional users.</p><p>During <code>kubeadm init</code> another kubeconfig file is generated and stored in <code>/etc/kubernetes/super-admin.conf</code>.
This file includes a certificate with <code>Subject: O = system:masters, CN = kubernetes-super-admin</code>.
<code>system:masters</code> is a superuser group that bypasses RBAC and makes <code>super-admin.conf</code> useful in case
of an emergency where a cluster is locked due to RBAC misconfiguration.
The <code>super-admin.conf</code> file must be stored in a safe location and should not be shared with additional users.</p><p>See <a href="/docs/reference/access-authn-authz/rbac/#user-facing-roles">RBAC user facing role bindings</a>
for additional information on RBAC and built-in ClusterRoles and groups.</p><p>You can run <a href="/docs/reference/setup-tools/kubeadm/kubeadm-kubeconfig/#cmd-kubeconfig-user"><code>kubeadm kubeconfig user</code></a>
to generate kubeconfig files for additional users.</p><div class="alert alert-caution" role="alert"><h4 class="alert-heading">Caution:</h4>The generated configuration files include an embedded authentication key, and you should treat
them as confidential.</div><p>Also note that:</p><ol><li><code>ca.crt</code> certificate is embedded in all the kubeconfig files.</li><li>If a given kubeconfig file exists, and its content is evaluated as compliant with the above specs,
the existing file will be used and the generation phase for the given kubeconfig will be skipped</li><li>If kubeadm is running in <a href="/docs/reference/setup-tools/kubeadm/kubeadm-init/#external-ca-mode">ExternalCA mode</a>,
all the required kubeconfig must be provided by the user as well, because kubeadm cannot
generate any of them by itself</li><li>In case kubeadm is executed in the <code>--dry-run</code> mode, kubeconfig files are written in a temporary folder</li><li>Generation of kubeconfig files can be invoked individually with the
<a href="/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-kubeconfig"><code>kubeadm init phase kubeconfig all</code></a> command</li></ol><h3 id="generate-static-pod-manifests-for-control-plane-components">Generate static Pod manifests for control plane components</h3><p>Kubeadm writes static Pod manifest files for control plane components to
<code>/etc/kubernetes/manifests</code>. The kubelet watches this directory for Pods to be created on startup.</p><p>Static Pod manifests share a set of common properties:</p><ul><li><p>All static Pods are deployed on <code>kube-system</code> namespace</p></li><li><p>All static Pods get <code>tier:control-plane</code> and <code>component:{component-name}</code> labels</p></li><li><p>All static Pods use the <code>system-node-critical</code> priority class</p></li><li><p><code>hostNetwork: true</code> is set on all static Pods to allow control plane startup before a network is
configured; as a consequence:</p><ul><li>The <code>address</code> that the controller-manager and the scheduler use to refer to the API server is <code>127.0.0.1</code></li><li>If the etcd server is set up locally, the <code>etcd-server</code> address will be set to <code>127.0.0.1:2379</code></li></ul></li><li><p>Leader election is enabled for both the controller-manager and the scheduler</p></li><li><p>Controller-manager and the scheduler will reference kubeconfig files with their respective, unique identities</p></li><li><p>All static Pods get any extra flags or patches that you specify, as described in
<a href="/docs/setup/production-environment/tools/kubeadm/control-plane-flags/">passing custom arguments to control plane components</a></p></li><li><p>All static Pods get any extra Volumes specified by the user (Host path)</p></li></ul><p>Please note that:</p><ol><li>All images will be pulled from registry.k8s.io by default.
See <a href="/docs/reference/setup-tools/kubeadm/kubeadm-init/#custom-images">using custom images</a>
for customizing the image repository</li><li>In case kubeadm is executed in the <code>--dry-run</code> mode, static Pod files are written in a
temporary folder</li><li>Static Pod manifest generation for control plane components can be invoked individually with
the <a href="/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-control-plane"><code>kubeadm init phase control-plane all</code></a> command</li></ol><h4 id="api-server">API server</h4><p>The static Pod manifest for the API server is affected by the following parameters provided by the users:</p><ul><li>The <code>apiserver-advertise-address</code> and <code>apiserver-bind-port</code> to bind to; if not provided, those
values default to the IP address of the default network interface on the machine and port 6443</li><li>The <code>service-cluster-ip-range</code> to use for services</li><li>If an external etcd server is specified, the <code>etcd-servers</code> address and related TLS settings
(<code>etcd-cafile</code>, <code>etcd-certfile</code>, <code>etcd-keyfile</code>);
if an external etcd server is not provided, a local etcd will be used (via host network)</li><li>If a cloud provider is specified, the corresponding <code>--cloud-provider</code> parameter is configured together
with the <code>--cloud-config</code> path if such file exists (this is experimental, alpha and will be
removed in a future version)</li></ul><p>Other API server flags that are set unconditionally are:</p><ul><li><p><code>--insecure-port=0</code> to avoid insecure connections to the api server</p></li><li><p><code>--enable-bootstrap-token-auth=true</code> to enable the <code>BootstrapTokenAuthenticator</code> authentication module.
See <a href="/docs/reference/access-authn-authz/kubelet-tls-bootstrapping/">TLS Bootstrapping</a> for more details</p></li><li><p><code>--allow-privileged</code> to <code>true</code> (required e.g. by kube proxy)</p></li><li><p><code>--requestheader-client-ca-file</code> to <code>front-proxy-ca.crt</code></p></li><li><p><code>--enable-admission-plugins</code> to:</p><ul><li><a href="/docs/reference/access-authn-authz/admission-controllers/#namespacelifecycle"><code>NamespaceLifecycle</code></a>
e.g. to avoid deletion of system reserved namespaces</li><li><a href="/docs/reference/access-authn-authz/admission-controllers/#limitranger"><code>LimitRanger</code></a>
and <a href="/docs/reference/access-authn-authz/admission-controllers/#resourcequota"><code>ResourceQuota</code></a>
to enforce limits on namespaces</li><li><a href="/docs/reference/access-authn-authz/admission-controllers/#serviceaccount"><code>ServiceAccount</code></a>
to enforce service account automation</li><li><a href="/docs/reference/access-authn-authz/admission-controllers/#persistentvolumelabel"><code>PersistentVolumeLabel</code></a>
attaches region or zone labels to PersistentVolumes as defined by the cloud provider (This
admission controller is deprecated and will be removed in a future version.
It is not deployed by kubeadm by default with v1.9 onwards when not explicitly opting into
using <code>gce</code> or <code>aws</code> as cloud providers)</li><li><a href="/docs/reference/access-authn-authz/admission-controllers/#defaultstorageclass"><code>DefaultStorageClass</code></a>
to enforce default storage class on <code>PersistentVolumeClaim</code> objects</li><li><a href="/docs/reference/access-authn-authz/admission-controllers/#defaulttolerationseconds"><code>DefaultTolerationSeconds</code></a></li><li><a href="/docs/reference/access-authn-authz/admission-controllers/#noderestriction"><code>NodeRestriction</code></a>
to limit what a kubelet can modify (e.g. only pods on this node)</li></ul></li><li><p><code>--kubelet-preferred-address-types</code> to <code>InternalIP,ExternalIP,Hostname;</code> this makes <code>kubectl logs</code> and other API server-kubelet communication work in environments where the hostnames of the
nodes aren't resolvable</p></li><li><p>Flags for using certificates generated in previous steps:</p><ul><li><code>--client-ca-file</code> to <code>ca.crt</code></li><li><code>--tls-cert-file</code> to <code>apiserver.crt</code></li><li><code>--tls-private-key-file</code> to <code>apiserver.key</code></li><li><code>--kubelet-client-certificate</code> to <code>apiserver-kubelet-client.crt</code></li><li><code>--kubelet-client-key</code> to <code>apiserver-kubelet-client.key</code></li><li><code>--service-account-key-file</code> to <code>sa.pub</code></li><li><code>--requestheader-client-ca-file</code> to <code>front-proxy-ca.crt</code></li><li><code>--proxy-client-cert-file</code> to <code>front-proxy-client.crt</code></li><li><code>--proxy-client-key-file</code> to <code>front-proxy-client.key</code></li></ul></li><li><p>Other flags for securing the front proxy
(<a href="/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/">API Aggregation</a>)
communications:</p><ul><li><code>--requestheader-username-headers=X-Remote-User</code></li><li><code>--requestheader-group-headers=X-Remote-Group</code></li><li><code>--requestheader-extra-headers-prefix=X-Remote-Extra-</code></li><li><code>--requestheader-allowed-names=front-proxy-client</code></li></ul></li></ul><h4 id="controller-manager">Controller manager</h4><p>The static Pod manifest for the controller manager is affected by following parameters provided by
the users:</p><ul><li><p>If kubeadm is invoked specifying a <code>--pod-network-cidr</code>, the subnet manager feature required for
some CNI network plugins is enabled by setting:</p><ul><li><code>--allocate-node-cidrs=true</code></li><li><code>--cluster-cidr</code> and <code>--node-cidr-mask-size</code> flags according to the given CIDR</li></ul></li></ul><p>Other flags that are set unconditionally are:</p><ul><li><p><code>--controllers</code> enabling all the default controllers plus <code>BootstrapSigner</code> and <code>TokenCleaner</code>
controllers for TLS bootstrap. See <a href="/docs/reference/access-authn-authz/kubelet-tls-bootstrapping/">TLS Bootstrapping</a>
for more details.</p></li><li><p><code>--use-service-account-credentials</code> to <code>true</code></p></li><li><p>Flags for using certificates generated in previous steps:</p><ul><li><code>--root-ca-file</code> to <code>ca.crt</code></li><li><code>--cluster-signing-cert-file</code> to <code>ca.crt</code>, if External CA mode is disabled, otherwise to <code>""</code></li><li><code>--cluster-signing-key-file</code> to <code>ca.key</code>, if External CA mode is disabled, otherwise to <code>""</code></li><li><code>--service-account-private-key-file</code> to <code>sa.key</code></li></ul></li></ul><h4 id="scheduler">Scheduler</h4><p>The static Pod manifest for the scheduler is not affected by parameters provided by the user.</p><h3 id="generate-static-pod-manifest-for-local-etcd">Generate static Pod manifest for local etcd</h3><p>If you specified an external etcd, this step will be skipped, otherwise kubeadm generates a
static Pod manifest file for creating a local etcd instance running in a Pod with following attributes:</p><ul><li>listen on <code>localhost:2379</code> and use <code>HostNetwork=true</code></li><li>make a <code>hostPath</code> mount out from the <code>dataDir</code> to the host's filesystem</li><li>Any extra flags specified by the user</li></ul><p>Please note that:</p><ol><li>The etcd container image will be pulled from <code>registry.gcr.io</code> by default. See
<a href="/docs/reference/setup-tools/kubeadm/kubeadm-init/#custom-images">using custom images</a>
for customizing the image repository.</li><li>If you run kubeadm in <code>--dry-run</code> mode, the etcd static Pod manifest is written
into a temporary folder.</li><li>You can directly invoke static Pod manifest generation for local etcd, using the
<a href="/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-etcd"><code>kubeadm init phase etcd local</code></a>
command.</li></ol><h3 id="wait-for-the-control-plane-to-come-up">Wait for the control plane to come up</h3><p>On control plane nodes, kubeadm waits up to 4 minutes for the control plane components
and the kubelet to be available. It does that by performing a health check on the respective
component <code>/healthz</code> or <code>/livez</code> endpoints.</p><p>After the control plane is up, kubeadm completes the tasks described in following paragraphs.</p><h3 id="save-the-kubeadm-clusterconfiguration-in-a-configmap-for-later-reference">Save the kubeadm ClusterConfiguration in a ConfigMap for later reference</h3><p>kubeadm saves the configuration passed to <code>kubeadm init</code> in a ConfigMap named <code>kubeadm-config</code>
under <code>kube-system</code> namespace.</p><p>This will ensure that kubeadm actions executed in future (e.g <code>kubeadm upgrade</code>) will be able to
determine the actual/current cluster state and make new decisions based on that data.</p><p>Please note that:</p><ol><li>Before saving the ClusterConfiguration, sensitive information like the token is stripped from the configuration</li><li>Upload of control plane node configuration can be invoked individually with the command
<a href="/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-upload-config"><code>kubeadm init phase upload-config</code></a>.</li></ol><h3 id="mark-the-node-as-control-plane">Mark the node as control-plane</h3><p>As soon as the control plane is available, kubeadm executes the following actions:</p><ul><li>Labels the node as control-plane with <code>node-role.kubernetes.io/control-plane=""</code></li><li>Taints the node with <code>node-role.kubernetes.io/control-plane:NoSchedule</code></li></ul><p>Please note that the phase to mark the control-plane phase can be invoked
individually with the <a href="/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-mark-control-plane"><code>kubeadm init phase mark-control-plane</code></a> command.</p><h3 id="configure-tls-bootstrapping-for-node-joining">Configure TLS-Bootstrapping for node joining</h3><p>Kubeadm uses <a href="/docs/reference/access-authn-authz/bootstrap-tokens/">Authenticating with Bootstrap Tokens</a>
for joining new nodes to an existing cluster; for more details see also
<a href="https://git.k8s.io/design-proposals-archive/cluster-lifecycle/bootstrap-discovery.md">design proposal</a>.</p><p><code>kubeadm init</code> ensures that everything is properly configured for this process, and this includes
following steps as well as setting API server and controller flags as already described in
previous paragraphs.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>TLS bootstrapping for nodes can be configured with the command
<a href="/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-bootstrap-token"><code>kubeadm init phase bootstrap-token</code></a>,
executing all the configuration steps described in following paragraphs;
alternatively, each step can be invoked individually.</div><h4 id="create-a-bootstrap-token">Create a bootstrap token</h4><p><code>kubeadm init</code> creates a first bootstrap token, either generated automatically or provided by the
user with the <code>--token</code> flag; as documented in bootstrap token specification, token should be
saved as a secret with name <code>bootstrap-token-&lt;token-id&gt;</code> under <code>kube-system</code> namespace.</p><p>Please note that:</p><ol><li>The default token created by <code>kubeadm init</code> will be used to validate temporary user during TLS
bootstrap process; those users will be member of
<code>system:bootstrappers:kubeadm:default-node-token</code> group</li><li>The token has a limited validity, default 24 hours (the interval may be changed with the <code>—token-ttl</code> flag)</li><li>Additional tokens can be created with the <a href="/docs/reference/setup-tools/kubeadm/kubeadm-token/"><code>kubeadm token</code></a>
command, that provide other useful functions for token management as well.</li></ol><h4 id="allow-joining-nodes-to-call-csr-api">Allow joining nodes to call CSR API</h4><p>Kubeadm ensures that users in <code>system:bootstrappers:kubeadm:default-node-token</code> group are able to
access the certificate signing API.</p><p>This is implemented by creating a ClusterRoleBinding named <code>kubeadm:kubelet-bootstrap</code> between the
group above and the default RBAC role <code>system:node-bootstrapper</code>.</p><h4 id="set-up-auto-approval-for-new-bootstrap-tokens">Set up auto approval for new bootstrap tokens</h4><p>Kubeadm ensures that the Bootstrap Token will get its CSR request automatically approved by the
csrapprover controller.</p><p>This is implemented by creating ClusterRoleBinding named <code>kubeadm:node-autoapprove-bootstrap</code>
between the <code>system:bootstrappers:kubeadm:default-node-token</code> group and the default role
<code>system:certificates.k8s.io:certificatesigningrequests:nodeclient</code>.</p><p>The role <code>system:certificates.k8s.io:certificatesigningrequests:nodeclient</code> should be created as
well, granting POST permission to
<code>/apis/certificates.k8s.io/certificatesigningrequests/nodeclient</code>.</p><h4 id="set-up-nodes-certificate-rotation-with-auto-approval">Set up nodes certificate rotation with auto approval</h4><p>Kubeadm ensures that certificate rotation is enabled for nodes, and that a new certificate request
for nodes will get its CSR request automatically approved by the csrapprover controller.</p><p>This is implemented by creating ClusterRoleBinding named
<code>kubeadm:node-autoapprove-certificate-rotation</code> between the <code>system:nodes</code> group and the default
role <code>system:certificates.k8s.io:certificatesigningrequests:selfnodeclient</code>.</p><h4 id="create-the-public-cluster-info-configmap">Create the public cluster-info ConfigMap</h4><p>This phase creates the <code>cluster-info</code> ConfigMap in the <code>kube-public</code> namespace.</p><p>Additionally, it creates a Role and a RoleBinding granting access to the ConfigMap for
unauthenticated users (i.e. users in RBAC group <code>system:unauthenticated</code>).</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>The access to the <code>cluster-info</code> ConfigMap <em>is not</em> rate-limited. This may or may not be a
problem if you expose your cluster's API server to the internet; worst-case scenario here is a
DoS attack where an attacker uses all the in-flight requests the kube-apiserver can handle to
serve the <code>cluster-info</code> ConfigMap.</div><h3 id="install-addons">Install addons</h3><p>Kubeadm installs the internal DNS server and the kube-proxy addon components via the API server.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>This phase can be invoked individually with the command
<a href="/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-addon"><code>kubeadm init phase addon all</code></a>.</div><h4 id="proxy">proxy</h4><p>A ServiceAccount for <code>kube-proxy</code> is created in the <code>kube-system</code> namespace; then kube-proxy is
deployed as a DaemonSet:</p><ul><li>The credentials (<code>ca.crt</code> and <code>token</code>) to the control plane come from the ServiceAccount</li><li>The location (URL) of the API server comes from a ConfigMap</li><li>The <code>kube-proxy</code> ServiceAccount is bound to the privileges in the <code>system:node-proxier</code> ClusterRole</li></ul><h4 id="dns">DNS</h4><ul><li><p>The CoreDNS service is named <code>kube-dns</code> for compatibility reasons with the legacy <code>kube-dns</code>
addon.</p></li><li><p>A ServiceAccount for CoreDNS is created in the <code>kube-system</code> namespace.</p></li><li><p>The <code>coredns</code> ServiceAccount is bound to the privileges in the <code>system:coredns</code> ClusterRole</p></li></ul><p>In Kubernetes version 1.21, support for using <code>kube-dns</code> with kubeadm was removed.
You can use CoreDNS with kubeadm even when the related Service is named <code>kube-dns</code>.</p><h2 id="kubeadm-join-phases-internal-design">kubeadm join phases internal design</h2><p>Similarly to <code>kubeadm init</code>, also <code>kubeadm join</code> internal workflow consists of a sequence of
atomic work tasks to perform.</p><p>This is split into discovery (having the Node trust the Kubernetes API Server) and TLS bootstrap
(having the Kubernetes API Server trust the Node).</p><p>see <a href="/docs/reference/access-authn-authz/bootstrap-tokens/">Authenticating with Bootstrap Tokens</a>
or the corresponding <a href="https://git.k8s.io/design-proposals-archive/cluster-lifecycle/bootstrap-discovery.md">design proposal</a>.</p><h3 id="preflight-checks-1">Preflight checks</h3><p><code>kubeadm</code> executes a set of preflight checks before starting the join, with the aim to verify
preconditions and avoid common cluster startup problems.</p><p>Also note that:</p><ol><li><code>kubeadm join</code> preflight checks are basically a subset of <code>kubeadm init</code> preflight checks</li><li>If you are joining a Windows node, Linux specific controls are skipped.</li><li>In any case the user can skip specific preflight checks (or eventually all preflight checks)
with the <code>--ignore-preflight-errors</code> option.</li></ol><h3 id="discovery-cluster-info">Discovery cluster-info</h3><p>There are 2 main schemes for discovery. The first is to use a shared token along with the IP
address of the API server.
The second is to provide a file (that is a subset of the standard kubeconfig file).</p><h4 id="shared-token-discovery">Shared token discovery</h4><p>If <code>kubeadm join</code> is invoked with <code>--discovery-token</code>, token discovery is used; in this case the
node basically retrieves the cluster CA certificates from the <code>cluster-info</code> ConfigMap in the
<code>kube-public</code> namespace.</p><p>In order to prevent "man in the middle" attacks, several steps are taken:</p><ul><li><p>First, the CA certificate is retrieved via insecure connection (this is possible because
<code>kubeadm init</code> is granted access to <code>cluster-info</code> users for <code>system:unauthenticated</code>)</p></li><li><p>Then the CA certificate goes through following validation steps:</p><ul><li>Basic validation: using the token ID against a JWT signature</li><li>Pub key validation: using provided <code>--discovery-token-ca-cert-hash</code>. This value is available
in the output of <code>kubeadm init</code> or can be calculated using standard tools (the hash is
calculated over the bytes of the Subject Public Key Info (SPKI) object as in RFC7469). The
<code>--discovery-token-ca-cert-hash flag</code> may be repeated multiple times to allow more than one public key.</li><li>As an additional validation, the CA certificate is retrieved via secure connection and then
compared with the CA retrieved initially</li></ul></li></ul><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>You can skip CA validation by passing the <code>--discovery-token-unsafe-skip-ca-verification</code> flag on the command line.
This weakens the kubeadm security model since others can potentially impersonate the Kubernetes API server.</div><h4 id="file-https-discovery">File/https discovery</h4><p>If <code>kubeadm join</code> is invoked with <code>--discovery-file</code>, file discovery is used; this file can be a
local file or downloaded via an HTTPS URL; in case of HTTPS, the host installed CA bundle is used
to verify the connection.</p><p>With file discovery, the cluster CA certificate is provided into the file itself; in fact, the
discovery file is a kubeconfig file with only <code>server</code> and <code>certificate-authority-data</code> attributes
set, as described in the <a href="/docs/reference/setup-tools/kubeadm/kubeadm-join/#file-or-https-based-discovery"><code>kubeadm join</code></a>
reference doc; when the connection with the cluster is established, kubeadm tries to access the
<code>cluster-info</code> ConfigMap, and if available, uses it.</p><h2 id="tls-bootstrap">TLS Bootstrap</h2><p>Once the cluster info is known, the file <code>bootstrap-kubelet.conf</code> is written, thus allowing
kubelet to do TLS Bootstrapping.</p><p>The TLS bootstrap mechanism uses the shared token to temporarily authenticate with the Kubernetes
API server to submit a certificate signing request (CSR) for a locally created key pair.</p><p>The request is then automatically approved and the operation completes saving <code>ca.crt</code> file and
<code>kubelet.conf</code> file to be used by the kubelet for joining the cluster, while <code>bootstrap-kubelet.conf</code>
is deleted.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4><ul><li>The temporary authentication is validated against the token saved during the <code>kubeadm init</code>
process (or with additional tokens created with <code>kubeadm token</code> command)</li><li>The temporary authentication resolves to a user member of
<code>system:bootstrappers:kubeadm:default-node-token</code> group which was granted access to the CSR api
during the <code>kubeadm init</code> process</li><li>The automatic CSR approval is managed by the csrapprover controller, according to
the configuration present in the <code>kubeadm init</code> process</li></ul></div><h2 id="kubeadm-upgrade-workflow-internal-design">kubeadm upgrade workflow internal design</h2><p><code>kubeadm upgrade</code> has sub-commands for handling the upgrade of the Kubernetes cluster created by kubeadm.
You must run <code>kubeadm upgrade apply</code> on a control plane node (you can choose which one);
this starts the upgrade process. You then run <code>kubeadm upgrade node</code> on all remaining
nodes (both worker nodes and control plane nodes).</p><p>Both <code>kubeadm upgrade apply</code> and <code>kubeadm upgrade node</code> have a <code>phase</code> subcommand which provides access
to the internal phases of the upgrade process.
See <a href="/docs/reference/setup-tools/kubeadm/kubeadm-upgrade-phase/"><code>kubeadm upgrade phase</code></a> for more details.</p><p>Additional utility upgrade commands are <code>kubeadm upgrade plan</code> and <code>kubeadm upgrade diff</code>.</p><p>All upgrade sub-commands support passing a configuration file.</p><h3 id="kubeadm-upgrade-plan">kubeadm upgrade plan</h3><p>You can optionally run <code>kubeadm upgrade plan</code> before you run <code>kubeadm upgrade apply</code>.
The <code>plan</code> subcommand checks which versions are available to upgrade
to and validates whether your current cluster is upgradeable.</p><h3 id="kubeadm-upgrade-diff">kubeadm upgrade diff</h3><p>This shows what differences would be applied to existing static pod manifests for control plane nodes.
A more verbose way to do the same thing is running <code>kubeadm upgrade apply --dry-run</code> or
<code>kubeadm upgrade node --dry-run</code>.</p><h3 id="kubeadm-upgrade-apply">kubeadm upgrade apply</h3><p><code>kubeadm upgrade apply</code> prepares the cluster for the upgrade of all nodes, and also
upgrades the control plane node where it's run. The steps it performs are:</p><ul><li>Runs preflight checks similarly to <code>kubeadm init</code> and <code>kubeadm join</code>, ensuring container images are downloaded
and the cluster is in a good state to be upgraded.</li><li>Upgrades the control plane manifest files on disk in <code>/etc/kubernetes/manifests</code> and waits
for the kubelet to restart the components if the files have changed.</li><li>Uploads the updated kubeadm and kubelet configurations to the cluster in the <code>kubeadm-config</code>
and the <code>kubelet-config</code> ConfigMaps (both in the <code>kube-system</code> namespace).</li><li>Writes updated kubelet configuration for this node in <code>/var/lib/kubelet/config.yaml</code>,
and read the node's <code>/var/lib/kubelet/instance-config.yaml</code> file
and patch fields like <code>containerRuntimeEndpoint</code>
from this instance configuration into <code>/var/lib/kubelet/config.yaml</code>.</li><li>Configures bootstrap token and the <code>cluster-info</code> ConfigMap for RBAC rules. This is the same as
in the <code>kubeadm init</code> stage and ensures that the cluster continues to support nodes joining with bootstrap tokens.</li><li>Upgrades the kube-proxy and CoreDNS addons conditionally if all existing kube-apiservers in the cluster
have already been upgraded to the target version.</li><li>Performs any post-upgrade tasks, such as, cleaning up deprecated features which are release specific.</li></ul><h3 id="kubeadm-upgrade-node">kubeadm upgrade node</h3><p><code>kubeadm upgrade node</code> upgrades a single control plane or worker node after the cluster upgrade has
started (by running <code>kubeadm upgrade apply</code>). The command detects if the node is a control plane node by checking
if the file <code>/etc/kubernetes/manifests/kube-apiserver.yaml</code> exists. On finding that file, the kubeadm tool
infers that there is a running kube-apiserver Pod on this node.</p><ul><li>Runs preflight checks similarly to <code>kubeadm upgrade apply</code>.</li><li>For control plane nodes, upgrades the control plane manifest files on disk in <code>/etc/kubernetes/manifests</code>
and waits for the kubelet to restart the components if the files have changed.</li><li>Writes updated kubelet configuration for this node in <code>/var/lib/kubelet/config.yaml</code>,
and read the node's <code>/var/lib/kubelet/instance-config.yaml</code> file and
patch fields like <code>containerRuntimeEndpoint</code>
from this instance configuration into <code>/var/lib/kubelet/config.yaml</code>.</li><li>(For control plane nodes) upgrades the kube-proxy and CoreDNS
<a class="glossary-tooltip" title="Resources that extend the functionality of Kubernetes." data-toggle="tooltip" data-placement="top" href="/docs/concepts/cluster-administration/addons/" target="_blank" aria-label="addons">addons</a> conditionally, provided that all existing
API servers in the cluster have already been upgraded to the target version.</li><li>Performs any post-upgrade tasks, such as cleaning up deprecated features which are release specific.</li></ul><h2 id="kubeadm-reset-workflow-internal-design">kubeadm reset workflow internal design</h2><p>You can use the <code>kubeadm reset</code> subcommand on a node where kubeadm commands previously executed.
This subcommand performs a <strong>best-effort</strong> cleanup of the node.
If certain actions fail you must intervene and perform manual cleanup.</p><p>The command supports phases.
See <a href="/docs/reference/setup-tools/kubeadm/kubeadm-reset-phase/"><code>kubeadm reset phase</code></a> for more details.</p><p>The command supports a configuration file.</p><p>Additionally:</p><ul><li>IPVS, iptables and nftables rules are <strong>not</strong> cleaned up.</li><li>CNI (network plugin) configuration is <strong>not</strong> cleaned up.</li><li><code>.kube/</code> in the user's home directory is <strong>not</strong> cleaned up.</li></ul><p>The command has the following stages:</p><ul><li>Runs preflight checks on the node to determine if its healthy.</li><li>For control plane nodes, removes any local etcd member data.</li><li>Stops the kubelet.</li><li>Stops running containers.</li><li>Unmounts any mounted directories in <code>/var/lib/kubelet</code>.</li><li>Deletes any files and directories managed by kubeadm in <code>/var/lib/kubelet</code> and <code>/etc/kubernetes</code>.</li></ul></div>
<hr>
<div class="td-content"><h1>Scheduling</h1><div class="section-index"><hr class="panel-line"/><div class="entry"><h5><a href="/docs/reference/scheduling/config/">Scheduler Configuration</a></h5><p/></div><div class="entry"><h5><a href="/docs/reference/scheduling/policies/">Scheduling Policies</a></h5><p/></div></div></div>
<hr>
<div class="td-content"><h1 data-pagefind-weight="10">kubeadm version</h1><p>This command prints the version of kubeadm.</p><h3 id="synopsis">Synopsis</h3><p>Print the version of kubeadm</p><pre tabindex="0"><code>kubeadm version [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for version</p></td></tr><tr><td colspan="2">-o, --output string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Output format; available options are 'yaml', 'json' and 'short'</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></div>
<hr>
<div class="td-content"><h1 data-pagefind-weight="10">kubeadm config</h1><p>During <code>kubeadm init</code>, kubeadm uploads the <code>ClusterConfiguration</code> object to your cluster
in a ConfigMap called <code>kubeadm-config</code> in the <code>kube-system</code> namespace. This configuration is then read during
<code>kubeadm join</code>, <code>kubeadm reset</code> and <code>kubeadm upgrade</code>.</p><p>You can use <code>kubeadm config print</code> to print the default static configuration that kubeadm
uses for <code>kubeadm init</code> and <code>kubeadm join</code>.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>The output of the command is meant to serve as an example. You must manually edit the output
of this command to adapt to your setup. Remove the fields that you are not certain about and kubeadm
will try to default them on runtime by examining the host.</div><p>For more information on <code>init</code> and <code>join</code> navigate to
<a href="/docs/reference/setup-tools/kubeadm/kubeadm-init/#config-file">Using kubeadm init with a configuration file</a>
or <a href="/docs/reference/setup-tools/kubeadm/kubeadm-join/#config-file">Using kubeadm join with a configuration file</a>.</p><p>For more information on using the kubeadm configuration API navigate to
<a href="/docs/setup/production-environment/tools/kubeadm/control-plane-flags/">Customizing components with the kubeadm API</a>.</p><p>You can use <code>kubeadm config migrate</code> to convert your old configuration files that contain a deprecated
API version to a newer, supported API version.</p><p><code>kubeadm config validate</code> can be used for validating a configuration file.</p><p><code>kubeadm config images list</code> and <code>kubeadm config images pull</code> can be used to list and pull the images
that kubeadm requires.</p><h2 id="cmd-config-print">kubeadm config print</h2><p>Print configuration</p><h3 id="synopsis">Synopsis</h3><p>This command prints configurations for subcommands provided.
For details, see: <a href="https://pkg.go.dev/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm#section-directories">https://pkg.go.dev/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm#section-directories</a></p><pre tabindex="0"><code>kubeadm config print [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for print</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--kubeconfig string     Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table><h2 id="cmd-config-print-init-defaults">kubeadm config print init-defaults</h2><p>Print default init configuration, that can be used for 'kubeadm init'</p><h3 id="synopsis">Synopsis</h3><p>This command prints objects such as the default init configuration that is used for 'kubeadm init'.</p><p>Note that sensitive values like the Bootstrap Token fields are replaced with placeholder values like "abcdef.0123456789abcdef" in order to pass validation but
not perform the real computation for creating a token.</p><pre tabindex="0"><code>kubeadm config print init-defaults [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--component-configs strings</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>A comma-separated list for component config API objects to print the default values for. Available values: [KubeProxyConfiguration KubeletConfiguration]. If this flag is not set, no component configs will be printed.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for init-defaults</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--kubeconfig string     Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table><h2 id="cmd-config-print-join-defaults">kubeadm config print join-defaults</h2><p>Print default join configuration, that can be used for 'kubeadm join'</p><h3 id="synopsis">Synopsis</h3><p>This command prints objects such as the default join configuration that is used for 'kubeadm join'.</p><p>Note that sensitive values like the Bootstrap Token fields are replaced with placeholder values like "abcdef.0123456789abcdef" in order to pass validation but
not perform the real computation for creating a token.</p><pre tabindex="0"><code>kubeadm config print join-defaults [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for join-defaults</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--kubeconfig string     Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table><h2 id="cmd-config-migrate">kubeadm config migrate</h2><p>Read an older version of the kubeadm configuration API types from a file, and output the similar config object for the newer version</p><h3 id="synopsis">Synopsis</h3><p>This command lets you convert configuration objects of older versions to the latest supported version,
locally in the CLI tool without ever touching anything in the cluster.
In this version of kubeadm, the following API versions are supported:</p><ul><li>kubeadm.k8s.io/v1beta4</li></ul><p>Further, kubeadm can only write out config of version "kubeadm.k8s.io/v1beta4", but read both types.
So regardless of what version you pass to the --old-config parameter here, the API object will be
read, deserialized, defaulted, converted, validated, and re-serialized when written to stdout or
--new-config if specified.</p><p>In other words, the output of this command is what kubeadm actually would read internally if you
submitted this file to "kubeadm init"</p><pre tabindex="0"><code>kubeadm config migrate [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--allow-experimental-api</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Allow migration to experimental, unreleased APIs.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for migrate</p></td></tr><tr><td colspan="2">--new-config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to the resulting equivalent kubeadm config file using the new API version. Optional, if not specified output will be sent to STDOUT.</p></td></tr><tr><td colspan="2">--old-config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to the kubeadm config file that is using an old API version and should be converted. This flag is mandatory.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--kubeconfig string     Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table><h2 id="cmd-config-validate">kubeadm config validate</h2><p>Read a file containing the kubeadm configuration API and report any validation problems</p><h3 id="synopsis">Synopsis</h3><p>This command lets you validate a kubeadm configuration API file and report any warnings and errors.
If there are no errors the exit status will be zero, otherwise it will be non-zero.
Any unmarshaling problems such as unknown API fields will trigger errors. Unknown API versions and
fields with invalid values will also trigger errors. Any other errors or warnings may be reported
depending on contents of the input file.</p><p>In this version of kubeadm, the following API versions are supported:</p><ul><li>kubeadm.k8s.io/v1beta4</li></ul><pre tabindex="0"><code>kubeadm config validate [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--allow-experimental-api</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Allow validation of experimental, unreleased APIs.</p></td></tr><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for validate</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--kubeconfig string     Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table><h2 id="cmd-config-images-list">kubeadm config images list</h2><h3 id="synopsis">Synopsis</h3><p>Print a list of images kubeadm will use. The configuration file is used in case any images or image repositories are customized</p><pre tabindex="0"><code>kubeadm config images list [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--allow-missing-template-keys     Default: true</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>If true, ignore any errors in templates when a field or map key is missing in the template. Only applies to golang and jsonpath output formats.</p></td></tr><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">--feature-gates string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>A set of key=value pairs that describe feature gates for various features. Options are:<br/>ControlPlaneKubeletLocalMode=true|false (BETA - default=true)<br/>NodeLocalCRISocket=true|false (BETA - default=true)<br/>PublicKeysECDSA=true|false (DEPRECATED - default=false)<br/>RootlessControlPlane=true|false (ALPHA - default=false)<br/>WaitForAllControlPlaneComponents=true|false (default=true)</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for list</p></td></tr><tr><td colspan="2">--image-repository string     Default: "registry.k8s.io"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Choose a container registry to pull control plane images from</p></td></tr><tr><td colspan="2">--kubernetes-version string     Default: "stable-1"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Choose a specific Kubernetes version for the control plane.</p></td></tr><tr><td colspan="2">-o, --output string     Default: "text"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Output format. One of: text|json|yaml|go-template|go-template-file|template|templatefile|jsonpath|jsonpath-as-json|jsonpath-file.</p></td></tr><tr><td colspan="2">--show-managed-fields</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>If true, keep the managedFields when printing objects in JSON or YAML format.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--kubeconfig string     Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table><h2 id="cmd-config-images-pull">kubeadm config images pull</h2><h3 id="synopsis">Synopsis</h3><p>Pull images used by kubeadm</p><pre tabindex="0"><code>kubeadm config images pull [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">--cri-socket string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to the CRI socket to connect. If empty kubeadm will try to auto-detect this value; use this option only if you have more than one CRI installed or if you have non-standard CRI socket.</p></td></tr><tr><td colspan="2">--feature-gates string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>A set of key=value pairs that describe feature gates for various features. Options are:<br/>ControlPlaneKubeletLocalMode=true|false (BETA - default=true)<br/>NodeLocalCRISocket=true|false (BETA - default=true)<br/>PublicKeysECDSA=true|false (DEPRECATED - default=false)<br/>RootlessControlPlane=true|false (ALPHA - default=false)<br/>WaitForAllControlPlaneComponents=true|false (default=true)</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for pull</p></td></tr><tr><td colspan="2">--image-repository string     Default: "registry.k8s.io"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Choose a container registry to pull control plane images from</p></td></tr><tr><td colspan="2">--kubernetes-version string     Default: "stable-1"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Choose a specific Kubernetes version for the control plane.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--kubeconfig string     Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table><h2 id="what-s-next">What's next</h2><ul><li><a href="/docs/reference/setup-tools/kubeadm/kubeadm-upgrade/">kubeadm upgrade</a> to upgrade a Kubernetes cluster to a newer version</li></ul></div>
<hr>
<div class="td-content"><h1 data-pagefind-weight="10">kubeadm reset phase</h1><p><code>kubeadm reset phase</code> enables you to invoke atomic steps of the node reset process.
Hence, you can let kubeadm do some of the work and you can fill in the gaps
if you wish to apply customization.</p><p><code>kubeadm reset phase</code> is consistent with the <a href="/docs/reference/setup-tools/kubeadm/kubeadm-reset/#reset-workflow">kubeadm reset workflow</a>,
and behind the scene both use the same code.</p><h2 id="cmd-reset-phase">kubeadm reset phase</h2><ul class="nav nav-tabs" id="tab-phase" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-phase-0" role="tab" aria-controls="tab-phase-0" aria-selected="true">phase</a></li></ul><div class="tab-content" id="tab-phase"><div id="tab-phase-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-phase-0"><p><h3 id="synopsis">Synopsis</h3><p>Use this command to invoke single phase of the "reset" workflow</p><pre tabindex="0"><code>kubeadm reset phase [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for phase</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div></div><h2 id="cmd-reset-phase-preflight">kubeadm reset phase preflight</h2><p>Using this phase you can execute preflight checks on a node that is being reset.</p><ul class="nav nav-tabs" id="tab-preflight" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-preflight-0" role="tab" aria-controls="tab-preflight-0" aria-selected="true">preflight</a></li></ul><div class="tab-content" id="tab-preflight"><div id="tab-preflight-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-preflight-0"><p><p>Run reset pre-flight checks</p><h3 id="synopsis">Synopsis</h3><p>Run pre-flight checks for kubeadm reset.</p><pre tabindex="0"><code>kubeadm reset phase preflight [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan="2">-f, --force</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Reset the node without prompting for confirmation.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for preflight</p></td></tr><tr><td colspan="2">--ignore-preflight-errors strings</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>A list of checks whose errors will be shown as warnings. Example: 'IsPrivilegedUser,Swap'. Value 'all' ignores errors from all checks.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div></div><h2 id="cmd-reset-phase-remove-etcd-member">kubeadm reset phase remove-etcd-member</h2><p>Using this phase you can remove this control-plane node's etcd member from the etcd cluster.</p><ul class="nav nav-tabs" id="tab-remove-etcd-member" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-remove-etcd-member-0" role="tab" aria-controls="tab-remove-etcd-member-0" aria-selected="true">remove-etcd-member</a></li></ul><div class="tab-content" id="tab-remove-etcd-member"><div id="tab-remove-etcd-member-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-remove-etcd-member-0"><p><h3 id="synopsis">Synopsis</h3><p>Remove a local etcd member for a control plane node.</p><pre tabindex="0"><code>kubeadm reset phase remove-etcd-member [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for remove-etcd-member</p></td></tr><tr><td colspan="2">--kubeconfig string     Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div></div><h2 id="cmd-reset-phase-cleanup-node">kubeadm reset phase cleanup-node</h2><p>Using this phase you can perform cleanup on this node.</p><ul class="nav nav-tabs" id="tab-cleanup-node" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-cleanup-node-0" role="tab" aria-controls="tab-cleanup-node-0" aria-selected="true">cleanup-node</a></li></ul><div class="tab-content" id="tab-cleanup-node"><div id="tab-cleanup-node-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-cleanup-node-0"><p><h3 id="synopsis">Synopsis</h3><p>Run cleanup node.</p><pre tabindex="0"><code>kubeadm reset phase cleanup-node [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--cert-dir string     Default: "/etc/kubernetes/pki"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the directory where the certificates are stored. If specified, clean this directory.</p></td></tr><tr><td colspan="2">--cleanup-tmp-dir</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Cleanup the "/etc/kubernetes/tmp" directory</p></td></tr><tr><td colspan="2">--cri-socket string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to the CRI socket to connect. If empty kubeadm will try to auto-detect this value; use this option only if you have more than one CRI installed or if you have non-standard CRI socket.</p></td></tr><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for cleanup-node</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div></div><h2 id="what-s-next">What's next</h2><ul><li><a href="/docs/reference/setup-tools/kubeadm/kubeadm-init/">kubeadm init</a> to bootstrap a Kubernetes control-plane node</li><li><a href="/docs/reference/setup-tools/kubeadm/kubeadm-join/">kubeadm join</a> to connect a node to the cluster</li><li><a href="/docs/reference/setup-tools/kubeadm/kubeadm-reset/">kubeadm reset</a> to revert any changes made to this host by <code>kubeadm init</code> or <code>kubeadm join</code></li><li><a href="/docs/reference/setup-tools/kubeadm/kubeadm-alpha/">kubeadm alpha</a> to try experimental functionality</li></ul></div>
<hr>
<div class="td-content"><h1 data-pagefind-weight="10">Scheduling Policies</h1><p>In Kubernetes versions before v1.23, a scheduling policy can be used to specify the <em>predicates</em> and <em>priorities</em> process. For example, you can set a scheduling policy by
running <code>kube-scheduler --policy-config-file &lt;filename&gt;</code> or <code>kube-scheduler --policy-configmap &lt;ConfigMap&gt;</code>.</p><p>This scheduling policy is not supported since Kubernetes v1.23. Associated flags <code>policy-config-file</code>, <code>policy-configmap</code>, <code>policy-configmap-namespace</code> and <code>use-legacy-policy-config</code> are also not supported. Instead, use the <a href="/docs/reference/scheduling/config/">Scheduler Configuration</a> to achieve similar behavior.</p><h2 id="what-s-next">What's next</h2><ul><li>Learn about <a href="/docs/concepts/scheduling-eviction/kube-scheduler/">scheduling</a></li><li>Learn about <a href="/docs/reference/scheduling/config/">kube-scheduler Configuration</a></li><li>Read the <a href="/docs/reference/config-api/kube-scheduler-config.v1/">kube-scheduler configuration reference (v1)</a></li></ul></div>
<hr>
<div class="td-content"><h1 data-pagefind-weight="10">kubeadm upgrade phases</h1><h2 id="cmd-apply-phase">kubeadm upgrade apply phase</h2><p>Using the phases of <code>kubeadm upgrade apply</code>, you can choose to execute the separate steps of the initial upgrade
of a control plane node.</p><ul class="nav nav-tabs" id="tab-apply-phase" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-apply-phase-0" role="tab" aria-controls="tab-apply-phase-0" aria-selected="true">phase</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-apply-phase-1" role="tab" aria-controls="tab-apply-phase-1">preflight</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-apply-phase-2" role="tab" aria-controls="tab-apply-phase-2">control-plane</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-apply-phase-3" role="tab" aria-controls="tab-apply-phase-3">upload-config</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-apply-phase-4" role="tab" aria-controls="tab-apply-phase-4">kubelet-config</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-apply-phase-5" role="tab" aria-controls="tab-apply-phase-5">bootstrap-token</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-apply-phase-6" role="tab" aria-controls="tab-apply-phase-6">addon</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-apply-phase-7" role="tab" aria-controls="tab-apply-phase-7">post-upgrade</a></li></ul><div class="tab-content" id="tab-apply-phase"><div id="tab-apply-phase-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-apply-phase-0"><p><h3 id="synopsis">Synopsis</h3><p>Use this command to invoke single phase of the "apply" workflow</p><pre tabindex="0"><code>kubeadm upgrade apply phase [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for phase</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div><div id="tab-apply-phase-1" class="tab-pane" role="tabpanel" aria-labelledby="tab-apply-phase-1"><p><h3 id="synopsis">Synopsis</h3><p>Run preflight checks before upgrade</p><pre tabindex="0"><code>kubeadm upgrade apply phase preflight [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--allow-experimental-upgrades</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Show unstable versions of Kubernetes as an upgrade alternative and allow upgrading to an alpha/beta/release candidate versions of Kubernetes.</p></td></tr><tr><td colspan="2">--allow-release-candidate-upgrades</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Show release candidate versions of Kubernetes as an upgrade alternative and allow upgrading to a release candidate versions of Kubernetes.</p></td></tr><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Do not change any state, just output what actions would be performed.</p></td></tr><tr><td colspan="2">-f, --force</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Force upgrading although some requirements might not be met. This also implies non-interactive mode.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for preflight</p></td></tr><tr><td colspan="2">--ignore-preflight-errors strings</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>A list of checks whose errors will be shown as warnings. Example: 'IsPrivilegedUser,Swap'. Value 'all' ignores errors from all checks.</p></td></tr><tr><td colspan="2">--kubeconfig string     Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan="2">-y, --yes</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Perform the upgrade and do not prompt for confirmation (non-interactive mode).</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div><div id="tab-apply-phase-2" class="tab-pane" role="tabpanel" aria-labelledby="tab-apply-phase-2"><p><h3 id="synopsis">Synopsis</h3><p>Upgrade the control plane</p><pre tabindex="0"><code>kubeadm upgrade apply phase control-plane [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--certificate-renewal     Default: true</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Perform the renewal of certificates used by component changed during upgrades.</p></td></tr><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Do not change any state, just output what actions would be performed.</p></td></tr><tr><td colspan="2">--etcd-upgrade     Default: true</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Perform the upgrade of etcd.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for control-plane</p></td></tr><tr><td colspan="2">--kubeconfig string     Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan="2">--patches string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "target" can be one of "kube-apiserver", "kube-controller-manager", "kube-scheduler", "etcd", "kubeletconfiguration", "corednsdeployment". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div><div id="tab-apply-phase-3" class="tab-pane" role="tabpanel" aria-labelledby="tab-apply-phase-3"><p><h3 id="synopsis">Synopsis</h3><p>Upload the kubeadm and kubelet configurations to ConfigMaps</p><pre tabindex="0"><code>kubeadm upgrade apply phase upload-config [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for upload-config</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div><div id="tab-apply-phase-4" class="tab-pane" role="tabpanel" aria-labelledby="tab-apply-phase-4"><p><h3 id="synopsis">Synopsis</h3><p>Upgrade the kubelet configuration for this node by downloading it from the kubelet-config ConfigMap stored in the cluster</p><pre tabindex="0"><code>kubeadm upgrade apply phase kubelet-config [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Do not change any state, just output what actions would be performed.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for kubelet-config</p></td></tr><tr><td colspan="2">--kubeconfig string     Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan="2">--patches string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "target" can be one of "kube-apiserver", "kube-controller-manager", "kube-scheduler", "etcd", "kubeletconfiguration", "corednsdeployment". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div><div id="tab-apply-phase-5" class="tab-pane" role="tabpanel" aria-labelledby="tab-apply-phase-5"><p><h3 id="synopsis">Synopsis</h3><p>Configures bootstrap token and cluster-info RBAC rules</p><pre tabindex="0"><code>kubeadm upgrade apply phase bootstrap-token [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Do not change any state, just output what actions would be performed.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for bootstrap-token</p></td></tr><tr><td colspan="2">--kubeconfig string     Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div><div id="tab-apply-phase-6" class="tab-pane" role="tabpanel" aria-labelledby="tab-apply-phase-6"><p><h3 id="synopsis">Synopsis</h3><p>Upgrade the default kubeadm addons</p><pre tabindex="0"><code>kubeadm upgrade apply phase addon [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for addon</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div><div id="tab-apply-phase-7" class="tab-pane" role="tabpanel" aria-labelledby="tab-apply-phase-7"><p><h3 id="synopsis">Synopsis</h3><p>Run post upgrade tasks</p><pre tabindex="0"><code>kubeadm upgrade apply phase post-upgrade [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Do not change any state, just output what actions would be performed.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for post-upgrade</p></td></tr><tr><td colspan="2">--kubeconfig string     Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div></div><h2 id="cmd-node-phase">kubeadm upgrade node phase</h2><p>Using the phases of <code>kubeadm upgrade node</code> you can choose to execute the separate steps of the upgrade of
secondary control-plane or worker nodes.</p><ul class="nav nav-tabs" id="tab-upgrade-phase" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-upgrade-phase-0" role="tab" aria-controls="tab-upgrade-phase-0" aria-selected="true">phase</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-upgrade-phase-1" role="tab" aria-controls="tab-upgrade-phase-1">preflight</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-upgrade-phase-2" role="tab" aria-controls="tab-upgrade-phase-2">control-plane</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-upgrade-phase-3" role="tab" aria-controls="tab-upgrade-phase-3">kubelet-config</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-upgrade-phase-4" role="tab" aria-controls="tab-upgrade-phase-4">addon</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-upgrade-phase-5" role="tab" aria-controls="tab-upgrade-phase-5">post-upgrade</a></li></ul><div class="tab-content" id="tab-upgrade-phase"><div id="tab-upgrade-phase-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-upgrade-phase-0"><p><h3 id="synopsis">Synopsis</h3><p>Use this command to invoke single phase of the "node" workflow</p><pre tabindex="0"><code>kubeadm upgrade node phase [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for phase</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div><div id="tab-upgrade-phase-1" class="tab-pane" role="tabpanel" aria-labelledby="tab-upgrade-phase-1"><p><p>Run upgrade node pre-flight checks</p><h3 id="synopsis">Synopsis</h3><p>Run pre-flight checks for kubeadm upgrade node.</p><pre tabindex="0"><code>kubeadm upgrade node phase preflight [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for preflight</p></td></tr><tr><td colspan="2">--ignore-preflight-errors strings</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>A list of checks whose errors will be shown as warnings. Example: 'IsPrivilegedUser,Swap'. Value 'all' ignores errors from all checks.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div><div id="tab-upgrade-phase-2" class="tab-pane" role="tabpanel" aria-labelledby="tab-upgrade-phase-2"><p><h3 id="synopsis">Synopsis</h3><p>Upgrade the control plane instance deployed on this node, if any</p><pre tabindex="0"><code>kubeadm upgrade node phase control-plane [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--certificate-renewal     Default: true</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Perform the renewal of certificates used by component changed during upgrades.</p></td></tr><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Do not change any state, just output the actions that would be performed.</p></td></tr><tr><td colspan="2">--etcd-upgrade     Default: true</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Perform the upgrade of etcd.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for control-plane</p></td></tr><tr><td colspan="2">--kubeconfig string     Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan="2">--patches string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "target" can be one of "kube-apiserver", "kube-controller-manager", "kube-scheduler", "etcd", "kubeletconfiguration", "corednsdeployment". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div><div id="tab-upgrade-phase-3" class="tab-pane" role="tabpanel" aria-labelledby="tab-upgrade-phase-3"><p><h3 id="synopsis">Synopsis</h3><p>Upgrade the kubelet configuration for this node by downloading it from the kubelet-config ConfigMap stored in the cluster</p><pre tabindex="0"><code>kubeadm upgrade node phase kubelet-config [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Do not change any state, just output the actions that would be performed.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for kubelet-config</p></td></tr><tr><td colspan="2">--kubeconfig string     Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan="2">--patches string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "target" can be one of "kube-apiserver", "kube-controller-manager", "kube-scheduler", "etcd", "kubeletconfiguration", "corednsdeployment". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div><div id="tab-upgrade-phase-4" class="tab-pane" role="tabpanel" aria-labelledby="tab-upgrade-phase-4"><p><h3 id="synopsis">Synopsis</h3><p>Upgrade the default kubeadm addons</p><pre tabindex="0"><code>kubeadm upgrade node phase addon [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for addon</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div><div id="tab-upgrade-phase-5" class="tab-pane" role="tabpanel" aria-labelledby="tab-upgrade-phase-5"><p><h3 id="synopsis">Synopsis</h3><p>Run post upgrade tasks</p><pre tabindex="0"><code>kubeadm upgrade node phase post-upgrade [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Do not change any state, just output the actions that would be performed.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for post-upgrade</p></td></tr><tr><td colspan="2">--kubeconfig string     Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div></div><h2 id="what-s-next">What's next</h2><ul><li><a href="/docs/reference/setup-tools/kubeadm/kubeadm-init/">kubeadm init</a> to bootstrap a Kubernetes control-plane node</li><li><a href="/docs/reference/setup-tools/kubeadm/kubeadm-join/">kubeadm join</a> to connect a node to the cluster</li><li><a href="/docs/reference/setup-tools/kubeadm/kubeadm-reset/">kubeadm reset</a> to revert any changes made to this host by <code>kubeadm init</code> or <code>kubeadm join</code></li><li><a href="/docs/reference/setup-tools/kubeadm/kubeadm-upgrade/">kubeadm upgrade</a> to upgrade a kubeadm node</li><li><a href="/docs/reference/setup-tools/kubeadm/kubeadm-alpha/">kubeadm alpha</a> to try experimental functionality</li></ul></div>
<hr>
<div class="td-content"><h1 data-pagefind-weight="10">Kubeadm</h1><p><img src="/images/kubeadm-stacked-color.png" align="right" width="150px"/>Kubeadm is a tool built to provide <code>kubeadm init</code> and <code>kubeadm join</code> as best-practice "fast paths" for creating Kubernetes clusters.</p><p>kubeadm performs the actions necessary to get a minimum viable cluster up and running. By design, it cares only about bootstrapping, not about provisioning machines. Likewise, installing various nice-to-have addons, like the Kubernetes Dashboard, monitoring solutions, and cloud-specific addons, is not in scope.</p><p>Instead, we expect higher-level and more tailored tooling to be built on top of kubeadm, and ideally, using kubeadm as the basis of all deployments will make it easier to create conformant clusters.</p><h2 id="how-to-install">How to install</h2><p>To install kubeadm, see the <a href="/docs/setup/production-environment/tools/kubeadm/install-kubeadm/">installation guide</a>.</p><h2 id="what-s-next">What's next</h2><ul><li><a href="/docs/reference/setup-tools/kubeadm/kubeadm-init/">kubeadm init</a> to bootstrap a Kubernetes control-plane node</li><li><a href="/docs/reference/setup-tools/kubeadm/kubeadm-join/">kubeadm join</a> to bootstrap a Kubernetes worker node and join it to the cluster</li><li><a href="/docs/reference/setup-tools/kubeadm/kubeadm-upgrade/">kubeadm upgrade</a> to upgrade a Kubernetes cluster to a newer version</li><li><a href="/docs/reference/setup-tools/kubeadm/kubeadm-config/">kubeadm config</a> if you initialized your cluster using kubeadm v1.7.x or lower, to configure your cluster for <code>kubeadm upgrade</code></li><li><a href="/docs/reference/setup-tools/kubeadm/kubeadm-token/">kubeadm token</a> to manage tokens for <code>kubeadm join</code></li><li><a href="/docs/reference/setup-tools/kubeadm/kubeadm-reset/">kubeadm reset</a> to revert any changes made to this host by <code>kubeadm init</code> or <code>kubeadm join</code></li><li><a href="/docs/reference/setup-tools/kubeadm/kubeadm-certs/">kubeadm certs</a> to manage Kubernetes certificates</li><li><a href="/docs/reference/setup-tools/kubeadm/kubeadm-kubeconfig/">kubeadm kubeconfig</a> to manage kubeconfig files</li><li><a href="/docs/reference/setup-tools/kubeadm/kubeadm-version/">kubeadm version</a> to print the kubeadm version</li><li><a href="/docs/reference/setup-tools/kubeadm/kubeadm-alpha/">kubeadm alpha</a> to preview a set of features made available for gathering feedback from the community</li></ul><div class="section-index"/></div>
<hr>
<div class="td-content"><h1 data-pagefind-weight="10">kubeadm alpha</h1><div class="alert alert-caution" role="alert"><h4 class="alert-heading">Caution:</h4><code>kubeadm alpha</code> provides a preview of a set of features made available for gathering feedback
from the community. Please try it out and give us feedback!</div><p>Currently there are no experimental commands under <code>kubeadm alpha</code>.</p><h2 id="what-s-next">What's next</h2><ul><li><a href="/docs/reference/setup-tools/kubeadm/kubeadm-init/">kubeadm init</a> to bootstrap a Kubernetes control-plane node</li><li><a href="/docs/reference/setup-tools/kubeadm/kubeadm-join/">kubeadm join</a> to connect a node to the cluster</li><li><a href="/docs/reference/setup-tools/kubeadm/kubeadm-reset/">kubeadm reset</a> to revert any changes made to this host by <code>kubeadm init</code> or <code>kubeadm join</code></li></ul></div>
<hr>
<div class="td-content"><h1 data-pagefind-weight="10">kubeadm join</h1><p>This command initializes a new Kubernetes node and joins it to the existing cluster.</p><p>Run this on any machine you wish to join an existing cluster</p><h3 id="synopsis">Synopsis</h3><p>When joining a kubeadm initialized cluster, we need to establish
bidirectional trust. This is split into discovery (having the Node
trust the Kubernetes Control Plane) and TLS bootstrap (having the
Kubernetes Control Plane trust the Node).</p><p>There are 2 main schemes for discovery. The first is to use a shared
token along with the IP address of the API server. The second is to
provide a file - a subset of the standard kubeconfig file. The
discovery/kubeconfig file supports token, client-go authentication
plugins ("exec"), "tokenFile", and "authProvider". This file can be a
local file or downloaded via an HTTPS URL. The forms are
kubeadm join --discovery-token abcdef.1234567890abcdef 1.2.3.4:6443,
kubeadm join --discovery-file path/to/file.conf, or kubeadm join
--discovery-file https://url/file.conf. Only one form can be used. If
the discovery information is loaded from a URL, HTTPS must be used.
Also, in that case the host installed CA bundle is used to verify
the connection.</p><p>If you use a shared token for discovery, you should also pass the
--discovery-token-ca-cert-hash flag to validate the public key of the
root certificate authority (CA) presented by the Kubernetes Control Plane.
The value of this flag is specified as "&lt;hash-type&gt;:&lt;hex-encoded-value&gt;",
where the supported hash type is "sha256". The hash is calculated over
the bytes of the Subject Public Key Info (SPKI) object (as in RFC7469).
This value is available in the output of "kubeadm init" or can be
calculated using standard tools. The --discovery-token-ca-cert-hash flag
may be repeated multiple times to allow more than one public key.</p><p>If you cannot know the CA public key hash ahead of time, you can pass
the --discovery-token-unsafe-skip-ca-verification flag to disable this
verification. This weakens the kubeadm security model since other nodes
can potentially impersonate the Kubernetes Control Plane.</p><p>The TLS bootstrap mechanism is also driven via a shared token. This is
used to temporarily authenticate with the Kubernetes Control Plane to submit a
certificate signing request (CSR) for a locally created key pair. By
default, kubeadm will set up the Kubernetes Control Plane to automatically
approve these signing requests. This token is passed in with the
--tls-bootstrap-token abcdef.1234567890abcdef flag.</p><p>Often times the same token is used for both parts. In this case, the
--token flag can be used instead of specifying each token individually.</p><p>The "join [api-server-endpoint]" command executes the following phases:</p><pre tabindex="0"><code>preflight              Run join pre-flight checks
control-plane-prepare  Prepare the machine for serving a control plane
  /download-certs        Download certificates shared among control-plane nodes from the kubeadm-certs Secret
  /certs                 Generate the certificates for the new control plane components
  /kubeconfig            Generate the kubeconfig for the new control plane components
  /control-plane         Generate the manifests for the new control plane components
kubelet-start          Write kubelet settings, certificates and (re)start the kubelet
control-plane-join     Join a machine as a control plane instance
  /etcd                  Add a new local etcd member
  /mark-control-plane    Mark a node as a control-plane
wait-control-plane     Wait for the control plane to start
</code></pre><pre tabindex="0"><code>kubeadm join [api-server-endpoint] [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--apiserver-advertise-address string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>If the node should host a new control plane instance, the IP address the API Server will advertise it's listening on. If not set the default network interface will be used.</p></td></tr><tr><td colspan="2">--apiserver-bind-port int32     Default: 6443</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>If the node should host a new control plane instance, the port for the API Server to bind to.</p></td></tr><tr><td colspan="2">--certificate-key string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Use this key to decrypt the certificate secrets uploaded by init. The certificate key is a hex encoded string that is an AES key of size 32 bytes.</p></td></tr><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">--control-plane</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Create a new control plane instance on this node</p></td></tr><tr><td colspan="2">--cri-socket string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to the CRI socket to connect. If empty kubeadm will try to auto-detect this value; use this option only if you have more than one CRI installed or if you have non-standard CRI socket.</p></td></tr><tr><td colspan="2">--discovery-file string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>For file-based discovery, a file or URL from which to load cluster information.</p></td></tr><tr><td colspan="2">--discovery-token string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>For token-based discovery, the token used to validate cluster information fetched from the API server.</p></td></tr><tr><td colspan="2">--discovery-token-ca-cert-hash strings</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>For token-based discovery, validate that the root CA public key matches this hash (format: "&lt;type&gt;:&lt;value&gt;").</p></td></tr><tr><td colspan="2">--discovery-token-unsafe-skip-ca-verification</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>For token-based discovery, allow joining without --discovery-token-ca-cert-hash pinning.</p></td></tr><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for join</p></td></tr><tr><td colspan="2">--ignore-preflight-errors strings</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>A list of checks whose errors will be shown as warnings. Example: 'IsPrivilegedUser,Swap'. Value 'all' ignores errors from all checks.</p></td></tr><tr><td colspan="2">--node-name string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Specify the node name.</p></td></tr><tr><td colspan="2">--patches string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "target" can be one of "kube-apiserver", "kube-controller-manager", "kube-scheduler", "etcd", "kubeletconfiguration", "corednsdeployment". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.</p></td></tr><tr><td colspan="2">--skip-phases strings</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>List of phases to be skipped</p></td></tr><tr><td colspan="2">--tls-bootstrap-token string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Specify the token used to temporarily authenticate with the Kubernetes Control Plane while joining the node.</p></td></tr><tr><td colspan="2">--token string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Use this token for both discovery-token and tls-bootstrap-token when those values are not provided.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table><h3 id="join-workflow">The join workflow</h3><p><code>kubeadm join</code> bootstraps a Kubernetes worker node or a control-plane node and adds it to the cluster.
This action consists of the following steps for worker nodes:</p><ol><li><p>kubeadm downloads necessary cluster information from the API server.
By default, it uses the bootstrap token and the CA key hash to verify the
authenticity of that data. The root CA can also be discovered directly via a
file or URL.</p></li><li><p>Once the cluster information is known, kubelet can start the TLS bootstrapping
process.</p><p>The TLS bootstrap uses the shared token to temporarily authenticate
with the Kubernetes API server to submit a certificate signing request (CSR); by
default the control plane signs this CSR request automatically.</p></li><li><p>Finally, kubeadm configures the local kubelet to connect to the API
server with the definitive identity assigned to the node.</p></li></ol><p>For control-plane nodes additional steps are performed:</p><ol><li><p>Downloading certificates shared among control-plane nodes from the cluster
(if explicitly requested by the user).</p></li><li><p>Generating control-plane component manifests, certificates and kubeconfig.</p></li><li><p>Adding new local etcd member.</p></li></ol><h3 id="join-phases">Using join phases with kubeadm</h3><p>Kubeadm allows you join a node to the cluster in phases using <code>kubeadm join phase</code>.</p><p>To view the ordered list of phases and sub-phases you can call <code>kubeadm join --help</code>. The list will be located
at the top of the help screen and each phase will have a description next to it.
Note that by calling <code>kubeadm join</code> all of the phases and sub-phases will be executed in this exact order.</p><p>Some phases have unique flags, so if you want to have a look at the list of available options add <code>--help</code>, for example:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubeadm join phase kubelet-start --help
</span></span></code></pre></div><p>Similar to the <a href="/docs/reference/setup-tools/kubeadm/kubeadm-init/#init-phases">kubeadm init phase</a>
command, <code>kubeadm join phase</code> allows you to skip a list of phases using the <code>--skip-phases</code> flag.</p><p>For example:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>sudo kubeadm join --skip-phases<span style="color:#666">=</span>preflight --config<span style="color:#666">=</span>config.yaml
</span></span></code></pre></div><div class="feature-state-notice feature-beta"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.22 [beta]</code></div><p>Alternatively, you can use the <code>skipPhases</code> field in <code>JoinConfiguration</code>.</p><h3 id="discovering-what-cluster-ca-to-trust">Discovering what cluster CA to trust</h3><p>The kubeadm discovery has several options, each with security tradeoffs.
The right method for your environment depends on how you provision nodes and the
security expectations you have about your network and node lifecycles.</p><h4 id="token-based-discovery-with-ca-pinning">Token-based discovery with CA pinning</h4><p>This is the default mode in kubeadm. In this mode, kubeadm downloads
the cluster configuration (including root CA) and validates it using the token
as well as validating that the root CA public key matches the provided hash and
that the API server certificate is valid under the root CA.</p><p>The CA key hash has the format <code>sha256:&lt;hex_encoded_hash&gt;</code>.
By default, the hash value is printed at the end of the <code>kubeadm init</code> command or
in the output from the <code>kubeadm token create --print-join-command</code> command.
It is in a standard format (see <a href="https://tools.ietf.org/html/rfc7469#section-2.4">RFC7469</a>)
and can also be calculated by 3rd party tools or provisioning systems.
For example, using the OpenSSL CLI:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2&gt;/dev/null | openssl dgst -sha256 -hex | sed <span style="color:#b44">'s/^.* //'</span>
</span></span></code></pre></div><p><strong>Example <code>kubeadm join</code> commands:</strong></p><p>For worker nodes:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubeadm join --discovery-token abcdef.1234567890abcdef --discovery-token-ca-cert-hash sha256:1234..cdef 1.2.3.4:6443
</span></span></code></pre></div><p>For control-plane nodes:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubeadm join --discovery-token abcdef.1234567890abcdef --discovery-token-ca-cert-hash sha256:1234..cdef --control-plane 1.2.3.4:6443
</span></span></code></pre></div><p>You can also call <code>join</code> for a control-plane node with <code>--certificate-key</code> to copy certificates to this node,
if the <code>kubeadm init</code> command was called with <code>--upload-certs</code>.</p><p><strong>Advantages:</strong></p><ul><li><p>Allows bootstrapping nodes to securely discover a root of trust for the
control-plane node even if other worker nodes or the network are compromised.</p></li><li><p>Convenient to execute manually since all of the information required fits
into a single <code>kubeadm join</code> command.</p></li></ul><p><strong>Disadvantages:</strong></p><ul><li>The CA hash is not normally known until the control-plane node has been provisioned,
which can make it more difficult to build automated provisioning tools that
use kubeadm. By generating your CA in beforehand, you may workaround this
limitation.</li></ul><h4 id="token-based-discovery-without-ca-pinning">Token-based discovery without CA pinning</h4><p>This mode relies only on the symmetric token to sign
(HMAC-SHA256) the discovery information that establishes the root of trust for
the control-plane. To use the mode the joining nodes must skip the hash validation of the
CA public key, using <code>--discovery-token-unsafe-skip-ca-verification</code>. You should consider
using one of the other modes if possible.</p><p><strong>Example <code>kubeadm join</code> command:</strong></p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubeadm join --token abcdef.1234567890abcdef --discovery-token-unsafe-skip-ca-verification 1.2.3.4:6443
</span></span></code></pre></div><p><strong>Advantages:</strong></p><ul><li><p>Still protects against many network-level attacks.</p></li><li><p>The token can be generated ahead of time and shared with the control-plane node and
worker nodes, which can then bootstrap in parallel without coordination. This
allows it to be used in many provisioning scenarios.</p></li></ul><p><strong>Disadvantages:</strong></p><ul><li>If an attacker is able to steal a bootstrap token via some vulnerability,
they can use that token (along with network-level access) to impersonate the
control-plane node to other bootstrapping nodes. This may or may not be an appropriate
tradeoff in your environment.</li></ul><h4 id="file-or-https-based-discovery">File or HTTPS-based discovery</h4><p>This provides an out-of-band way to establish a root of trust between the control-plane node
and bootstrapping nodes. Consider using this mode if you are building automated provisioning
using kubeadm. The format of the discovery file is a regular Kubernetes
<a href="/docs/tasks/access-application-cluster/configure-access-multiple-clusters/">kubeconfig</a> file.</p><p>In case the discovery file does not contain credentials, the TLS discovery token will be used.</p><p><strong>Example <code>kubeadm join</code> commands:</strong></p><ul><li><p><code>kubeadm join --discovery-file path/to/file.conf</code> (local file)</p></li><li><p><code>kubeadm join --discovery-file https://url/file.conf</code> (remote HTTPS URL)</p></li></ul><p><strong>Advantages:</strong></p><ul><li>Allows bootstrapping nodes to securely discover a root of trust for the
control-plane node even if the network or other worker nodes are compromised.</li></ul><p><strong>Disadvantages:</strong></p><ul><li>Requires that you have some way to carry the discovery information from
the control-plane node to the bootstrapping nodes. If the discovery file contains credentials
you must keep it secret and transfer it over a secure channel. This might be possible with your
cloud provider or provisioning tool.</li></ul><h4 id="use-of-custom-kubelet-credentials-with-kubeadm-join">Use of custom kubelet credentials with <code>kubeadm join</code></h4><p>To allow <code>kubeadm join</code> to use predefined kubelet credentials and skip client TLS bootstrap
and CSR approval for a new node:</p><ol><li>From a working control plane node in the cluster that has <code>/etc/kubernetes/pki/ca.key</code>
execute <code>kubeadm kubeconfig user --org system:nodes --client-name system:node:$NODE &gt; kubelet.conf</code>.
<code>$NODE</code> must be set to the name of the new node.</li><li>Modify the resulted <code>kubelet.conf</code> manually to adjust the cluster name and the server endpoint,
or run <code>kubeadm kubeconfig user --config</code> (it accepts <code>InitConfiguration</code>).</li></ol><p>If your cluster does not have the <code>ca.key</code> file, you must sign the embedded certificates in
the <code>kubelet.conf</code> externally. For additional information, see
<a href="/docs/setup/best-practices/certificates/">PKI certificates and requirements</a> and
<a href="/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/#external-ca-mode">Certificate Management with kubeadm</a>.</p><ol><li>Copy the resulting <code>kubelet.conf</code> to <code>/etc/kubernetes/kubelet.conf</code> on the new node.</li><li>Execute <code>kubeadm join</code> with the flag
<code>--ignore-preflight-errors=FileAvailable--etc-kubernetes-kubelet.conf</code> on the new node.</li></ol><h3 id="securing-more">Securing your installation even more</h3><p>The defaults for kubeadm may not work for everyone. This section documents how to tighten up a kubeadm installation
at the cost of some usability.</p><h4 id="turning-off-auto-approval-of-node-client-certificates">Turning off auto-approval of node client certificates</h4><p>By default, there is a CSR auto-approver enabled that basically approves any client certificate request
for a kubelet when a Bootstrap Token was used when authenticating. If you don't want the cluster to
automatically approve kubelet client certs, you can turn it off by executing this command:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl delete clusterrolebinding kubeadm:node-autoapprove-bootstrap
</span></span></code></pre></div><p>After that, <code>kubeadm join</code> will block until the admin has manually approved the CSR in flight:</p><ol><li><p>Using <code>kubectl get csr</code>, you can see that the original CSR is in the Pending state.</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl get csr
</span></span></code></pre></div><p>The output is similar to this:</p><pre tabindex="0"><code>NAME                                                   AGE       REQUESTOR                 CONDITION
node-csr-c69HXe7aYcqkS1bKmH4faEnHAWxn6i2bHZ2mD04jZyQ   18s       system:bootstrap:878f07   Pending
</code></pre></li><li><p><code>kubectl certificate approve</code> allows the admin to approve CSR.This action tells a certificate signing
controller to issue a certificate to the requestor with the attributes requested in the CSR.</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl certificate approve node-csr-c69HXe7aYcqkS1bKmH4faEnHAWxn6i2bHZ2mD04jZyQ
</span></span></code></pre></div><p>The output is similar to this:</p><pre tabindex="0"><code>certificatesigningrequest "node-csr-c69HXe7aYcqkS1bKmH4faEnHAWxn6i2bHZ2mD04jZyQ" approved
</code></pre></li><li><p>This would change the CSR resource to Active state.</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl get csr
</span></span></code></pre></div><p>The output is similar to this:</p><pre tabindex="0"><code>NAME                                                   AGE       REQUESTOR                 CONDITION
node-csr-c69HXe7aYcqkS1bKmH4faEnHAWxn6i2bHZ2mD04jZyQ   1m        system:bootstrap:878f07   Approved,Issued
</code></pre></li></ol><p>This forces the workflow that <code>kubeadm join</code> will only succeed if <code>kubectl certificate approve</code> has been run.</p><h4 id="turning-off-public-access-to-the-cluster-info-configmap">Turning off public access to the <code>cluster-info</code> ConfigMap</h4><p>In order to achieve the joining flow using the token as the only piece of validation information, a
ConfigMap with some data needed for validation of the control-plane node's identity is exposed publicly by
default. While there is no private data in this ConfigMap, some users might wish to turn
it off regardless. Doing so will disable the ability to use the <code>--discovery-token</code> flag of the
<code>kubeadm join</code> flow. Here are the steps to do so:</p><ul><li>Fetch the <code>cluster-info</code> file from the API Server:</li></ul><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl -n kube-public get cm cluster-info -o <span style="color:#b8860b">jsonpath</span><span style="color:#666">=</span><span style="color:#b44">'{.data.kubeconfig}'</span> | tee cluster-info.yaml
</span></span></code></pre></div><p>The output is similar to this:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>Config<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">clusters</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/>- <span style="color:green;font-weight:700">cluster</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">certificate-authority-data</span>:<span style="color:#bbb"> </span>&lt;ca-cert&gt;<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">server</span>:<span style="color:#bbb"> </span>https://&lt;ip&gt;:&lt;port&gt;<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span><span style="color:#b44">""</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">contexts</span>:<span style="color:#bbb"> </span>[]<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">current-context</span>:<span style="color:#bbb"> </span><span style="color:#b44">""</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">preferences</span>:<span style="color:#bbb"> </span>{}<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">users</span>:<span style="color:#bbb"> </span>[]<span style="color:#bbb">
</span></span></span></code></pre></div><ul><li><p>Use the <code>cluster-info.yaml</code> file as an argument to <code>kubeadm join --discovery-file</code>.</p></li><li><p>Turn off public access to the <code>cluster-info</code> ConfigMap:</p></li></ul><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl -n kube-public delete rolebinding kubeadm:bootstrap-signer-clusterinfo
</span></span></code></pre></div><p>These commands should be run after <code>kubeadm init</code> but before <code>kubeadm join</code>.</p><h3 id="config-file">Using kubeadm join with a configuration file</h3><div class="alert alert-caution" role="alert"><h4 class="alert-heading">Caution:</h4>The config file is still considered beta and may change in future versions.</div><p>It's possible to configure <code>kubeadm join</code> with a configuration file instead of command
line flags, and some more advanced features may only be available as
configuration file options. This file is passed using the <code>--config</code> flag and it must
contain a <code>JoinConfiguration</code> structure. Mixing <code>--config</code> with others flags may not be
allowed in some cases.</p><p>The default configuration can be printed out using the
<a href="/docs/reference/setup-tools/kubeadm/kubeadm-config/#cmd-config-print">kubeadm config print</a> command.</p><p>If your configuration is not using the latest version it is <strong>recommended</strong> that you migrate using
the <a href="/docs/reference/setup-tools/kubeadm/kubeadm-config/#cmd-config-migrate">kubeadm config migrate</a> command.</p><p>For more information on the fields and usage of the configuration you can navigate to our
<a href="/docs/reference/config-api/kubeadm-config.v1beta4/">API reference</a>.</p><h2 id="what-s-next">What's next</h2><ul><li><a href="/docs/reference/setup-tools/kubeadm/kubeadm-init/">kubeadm init</a> to bootstrap a Kubernetes control-plane node.</li><li><a href="/docs/reference/setup-tools/kubeadm/kubeadm-token/">kubeadm token</a> to manage tokens for <code>kubeadm join</code>.</li><li><a href="/docs/reference/setup-tools/kubeadm/kubeadm-reset/">kubeadm reset</a> to revert any changes made to this host by <code>kubeadm init</code> or <code>kubeadm join</code>.</li></ul></div>
<hr>
<div class="td-content"><h1 data-pagefind-weight="10">kubeadm join phase</h1><p><code>kubeadm join phase</code> enables you to invoke atomic steps of the join process.
Hence, you can let kubeadm do some of the work and you can fill in the gaps
if you wish to apply customization.</p><p><code>kubeadm join phase</code> is consistent with the <a href="/docs/reference/setup-tools/kubeadm/kubeadm-join/#join-workflow">kubeadm join workflow</a>,
and behind the scene both use the same code.</p><h2 id="cmd-join-phase">kubeadm join phase</h2><ul class="nav nav-tabs" id="tab-phase" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-phase-0" role="tab" aria-controls="tab-phase-0" aria-selected="true">phase</a></li></ul><div class="tab-content" id="tab-phase"><div id="tab-phase-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-phase-0"><p><h3 id="synopsis">Synopsis</h3><p>Use this command to invoke single phase of the "join" workflow</p><pre tabindex="0"><code>kubeadm join phase [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for phase</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div></div><h2 id="cmd-join-phase-preflight">kubeadm join phase preflight</h2><p>Using this phase you can execute preflight checks on a joining node.</p><ul class="nav nav-tabs" id="tab-preflight" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-preflight-0" role="tab" aria-controls="tab-preflight-0" aria-selected="true">preflight</a></li></ul><div class="tab-content" id="tab-preflight"><div id="tab-preflight-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-preflight-0"><p><p>Run join pre-flight checks</p><h3 id="synopsis">Synopsis</h3><p>Run pre-flight checks for kubeadm join.</p><pre tabindex="0"><code>kubeadm join phase preflight [api-server-endpoint] [flags]
</code></pre><h3 id="examples">Examples</h3><pre tabindex="0"><code>  # Run join pre-flight checks using a config file.
  kubeadm join phase preflight --config kubeadm-config.yaml
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--apiserver-advertise-address string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>If the node should host a new control plane instance, the IP address the API Server will advertise it's listening on. If not set the default network interface will be used.</p></td></tr><tr><td colspan="2">--apiserver-bind-port int32     Default: 6443</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>If the node should host a new control plane instance, the port for the API Server to bind to.</p></td></tr><tr><td colspan="2">--certificate-key string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Use this key to decrypt the certificate secrets uploaded by init. The certificate key is a hex encoded string that is an AES key of size 32 bytes.</p></td></tr><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">--control-plane</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Create a new control plane instance on this node</p></td></tr><tr><td colspan="2">--cri-socket string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to the CRI socket to connect. If empty kubeadm will try to auto-detect this value; use this option only if you have more than one CRI installed or if you have non-standard CRI socket.</p></td></tr><tr><td colspan="2">--discovery-file string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>For file-based discovery, a file or URL from which to load cluster information.</p></td></tr><tr><td colspan="2">--discovery-token string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>For token-based discovery, the token used to validate cluster information fetched from the API server.</p></td></tr><tr><td colspan="2">--discovery-token-ca-cert-hash strings</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>For token-based discovery, validate that the root CA public key matches this hash (format: "&lt;type&gt;:&lt;value&gt;").</p></td></tr><tr><td colspan="2">--discovery-token-unsafe-skip-ca-verification</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>For token-based discovery, allow joining without --discovery-token-ca-cert-hash pinning.</p></td></tr><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for preflight</p></td></tr><tr><td colspan="2">--ignore-preflight-errors strings</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>A list of checks whose errors will be shown as warnings. Example: 'IsPrivilegedUser,Swap'. Value 'all' ignores errors from all checks.</p></td></tr><tr><td colspan="2">--node-name string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Specify the node name.</p></td></tr><tr><td colspan="2">--tls-bootstrap-token string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Specify the token used to temporarily authenticate with the Kubernetes Control Plane while joining the node.</p></td></tr><tr><td colspan="2">--token string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Use this token for both discovery-token and tls-bootstrap-token when those values are not provided.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div></div><h2 id="cmd-join-phase-control-plane-prepare">kubeadm join phase control-plane-prepare</h2><p>Using this phase you can prepare a node for serving a control-plane.</p><ul class="nav nav-tabs" id="tab-control-plane-prepare" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-control-plane-prepare-0" role="tab" aria-controls="tab-control-plane-prepare-0" aria-selected="true">control-plane-prepare</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-control-plane-prepare-1" role="tab" aria-controls="tab-control-plane-prepare-1">all</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-control-plane-prepare-2" role="tab" aria-controls="tab-control-plane-prepare-2">download-certs</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-control-plane-prepare-3" role="tab" aria-controls="tab-control-plane-prepare-3">certs</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-control-plane-prepare-4" role="tab" aria-controls="tab-control-plane-prepare-4">kubeconfig</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-control-plane-prepare-5" role="tab" aria-controls="tab-control-plane-prepare-5">control-plane</a></li></ul><div class="tab-content" id="tab-control-plane-prepare"><div id="tab-control-plane-prepare-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-control-plane-prepare-0"><p><h3 id="synopsis">Synopsis</h3><p>Prepare the machine for serving a control plane</p><pre tabindex="0"><code>kubeadm join phase control-plane-prepare [flags]
</code></pre><h3 id="examples">Examples</h3><pre tabindex="0"><code>  # Prepares the machine for serving a control plane
  kubeadm join phase control-plane-prepare all
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for control-plane-prepare</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div><div id="tab-control-plane-prepare-1" class="tab-pane" role="tabpanel" aria-labelledby="tab-control-plane-prepare-1"><p><h3 id="synopsis">Synopsis</h3><p>Prepare the machine for serving a control plane</p><pre tabindex="0"><code>kubeadm join phase control-plane-prepare all [api-server-endpoint] [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--apiserver-advertise-address string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>If the node should host a new control plane instance, the IP address the API Server will advertise it's listening on. If not set the default network interface will be used.</p></td></tr><tr><td colspan="2">--apiserver-bind-port int32     Default: 6443</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>If the node should host a new control plane instance, the port for the API Server to bind to.</p></td></tr><tr><td colspan="2">--certificate-key string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Use this key to decrypt the certificate secrets uploaded by init. The certificate key is a hex encoded string that is an AES key of size 32 bytes.</p></td></tr><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">--control-plane</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Create a new control plane instance on this node</p></td></tr><tr><td colspan="2">--discovery-file string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>For file-based discovery, a file or URL from which to load cluster information.</p></td></tr><tr><td colspan="2">--discovery-token string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>For token-based discovery, the token used to validate cluster information fetched from the API server.</p></td></tr><tr><td colspan="2">--discovery-token-ca-cert-hash strings</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>For token-based discovery, validate that the root CA public key matches this hash (format: "&lt;type&gt;:&lt;value&gt;").</p></td></tr><tr><td colspan="2">--discovery-token-unsafe-skip-ca-verification</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>For token-based discovery, allow joining without --discovery-token-ca-cert-hash pinning.</p></td></tr><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for all</p></td></tr><tr><td colspan="2">--node-name string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Specify the node name.</p></td></tr><tr><td colspan="2">--patches string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "target" can be one of "kube-apiserver", "kube-controller-manager", "kube-scheduler", "etcd", "kubeletconfiguration", "corednsdeployment". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.</p></td></tr><tr><td colspan="2">--tls-bootstrap-token string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Specify the token used to temporarily authenticate with the Kubernetes Control Plane while joining the node.</p></td></tr><tr><td colspan="2">--token string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Use this token for both discovery-token and tls-bootstrap-token when those values are not provided.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div><div id="tab-control-plane-prepare-2" class="tab-pane" role="tabpanel" aria-labelledby="tab-control-plane-prepare-2"><p><h3 id="synopsis">Synopsis</h3><p>Download certificates shared among control-plane nodes from the kubeadm-certs Secret</p><pre tabindex="0"><code>kubeadm join phase control-plane-prepare download-certs [api-server-endpoint] [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--certificate-key string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Use this key to decrypt the certificate secrets uploaded by init. The certificate key is a hex encoded string that is an AES key of size 32 bytes.</p></td></tr><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">--control-plane</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Create a new control plane instance on this node</p></td></tr><tr><td colspan="2">--discovery-file string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>For file-based discovery, a file or URL from which to load cluster information.</p></td></tr><tr><td colspan="2">--discovery-token string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>For token-based discovery, the token used to validate cluster information fetched from the API server.</p></td></tr><tr><td colspan="2">--discovery-token-ca-cert-hash strings</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>For token-based discovery, validate that the root CA public key matches this hash (format: "&lt;type&gt;:&lt;value&gt;").</p></td></tr><tr><td colspan="2">--discovery-token-unsafe-skip-ca-verification</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>For token-based discovery, allow joining without --discovery-token-ca-cert-hash pinning.</p></td></tr><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for download-certs</p></td></tr><tr><td colspan="2">--tls-bootstrap-token string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Specify the token used to temporarily authenticate with the Kubernetes Control Plane while joining the node.</p></td></tr><tr><td colspan="2">--token string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Use this token for both discovery-token and tls-bootstrap-token when those values are not provided.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div><div id="tab-control-plane-prepare-3" class="tab-pane" role="tabpanel" aria-labelledby="tab-control-plane-prepare-3"><p><h3 id="synopsis">Synopsis</h3><p>Generate the certificates for the new control plane components</p><pre tabindex="0"><code>kubeadm join phase control-plane-prepare certs [api-server-endpoint] [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--apiserver-advertise-address string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>If the node should host a new control plane instance, the IP address the API Server will advertise it's listening on. If not set the default network interface will be used.</p></td></tr><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">--control-plane</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Create a new control plane instance on this node</p></td></tr><tr><td colspan="2">--discovery-file string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>For file-based discovery, a file or URL from which to load cluster information.</p></td></tr><tr><td colspan="2">--discovery-token string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>For token-based discovery, the token used to validate cluster information fetched from the API server.</p></td></tr><tr><td colspan="2">--discovery-token-ca-cert-hash strings</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>For token-based discovery, validate that the root CA public key matches this hash (format: "&lt;type&gt;:&lt;value&gt;").</p></td></tr><tr><td colspan="2">--discovery-token-unsafe-skip-ca-verification</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>For token-based discovery, allow joining without --discovery-token-ca-cert-hash pinning.</p></td></tr><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for certs</p></td></tr><tr><td colspan="2">--node-name string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Specify the node name.</p></td></tr><tr><td colspan="2">--tls-bootstrap-token string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Specify the token used to temporarily authenticate with the Kubernetes Control Plane while joining the node.</p></td></tr><tr><td colspan="2">--token string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Use this token for both discovery-token and tls-bootstrap-token when those values are not provided.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div><div id="tab-control-plane-prepare-4" class="tab-pane" role="tabpanel" aria-labelledby="tab-control-plane-prepare-4"><p><h3 id="synopsis">Synopsis</h3><p>Generate the kubeconfig for the new control plane components</p><pre tabindex="0"><code>kubeadm join phase control-plane-prepare kubeconfig [api-server-endpoint] [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--certificate-key string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Use this key to decrypt the certificate secrets uploaded by init. The certificate key is a hex encoded string that is an AES key of size 32 bytes.</p></td></tr><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">--control-plane</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Create a new control plane instance on this node</p></td></tr><tr><td colspan="2">--discovery-file string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>For file-based discovery, a file or URL from which to load cluster information.</p></td></tr><tr><td colspan="2">--discovery-token string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>For token-based discovery, the token used to validate cluster information fetched from the API server.</p></td></tr><tr><td colspan="2">--discovery-token-ca-cert-hash strings</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>For token-based discovery, validate that the root CA public key matches this hash (format: "&lt;type&gt;:&lt;value&gt;").</p></td></tr><tr><td colspan="2">--discovery-token-unsafe-skip-ca-verification</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>For token-based discovery, allow joining without --discovery-token-ca-cert-hash pinning.</p></td></tr><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for kubeconfig</p></td></tr><tr><td colspan="2">--tls-bootstrap-token string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Specify the token used to temporarily authenticate with the Kubernetes Control Plane while joining the node.</p></td></tr><tr><td colspan="2">--token string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Use this token for both discovery-token and tls-bootstrap-token when those values are not provided.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div><div id="tab-control-plane-prepare-5" class="tab-pane" role="tabpanel" aria-labelledby="tab-control-plane-prepare-5"><p><h3 id="synopsis">Synopsis</h3><p>Generate the manifests for the new control plane components</p><pre tabindex="0"><code>kubeadm join phase control-plane-prepare control-plane [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--apiserver-advertise-address string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>If the node should host a new control plane instance, the IP address the API Server will advertise it's listening on. If not set the default network interface will be used.</p></td></tr><tr><td colspan="2">--apiserver-bind-port int32     Default: 6443</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>If the node should host a new control plane instance, the port for the API Server to bind to.</p></td></tr><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">--control-plane</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Create a new control plane instance on this node</p></td></tr><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for control-plane</p></td></tr><tr><td colspan="2">--patches string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "target" can be one of "kube-apiserver", "kube-controller-manager", "kube-scheduler", "etcd", "kubeletconfiguration", "corednsdeployment". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div></div><h2 id="cmd-join-phase-kubelet-start">kubeadm join phase kubelet-start</h2><p>Using this phase you can write the kubelet settings, certificates and (re)start the kubelet.</p><ul class="nav nav-tabs" id="tab-kubelet-start" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-kubelet-start-0" role="tab" aria-controls="tab-kubelet-start-0" aria-selected="true">kubelet-start</a></li></ul><div class="tab-content" id="tab-kubelet-start"><div id="tab-kubelet-start-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-kubelet-start-0"><p><p>Write kubelet settings, certificates and (re)start the kubelet</p><h3 id="synopsis">Synopsis</h3><p>Write a file with KubeletConfiguration and an environment file with node specific kubelet settings, and then (re)start kubelet.</p><pre tabindex="0"><code>kubeadm join phase kubelet-start [api-server-endpoint] [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">--cri-socket string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to the CRI socket to connect. If empty kubeadm will try to auto-detect this value; use this option only if you have more than one CRI installed or if you have non-standard CRI socket.</p></td></tr><tr><td colspan="2">--discovery-file string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>For file-based discovery, a file or URL from which to load cluster information.</p></td></tr><tr><td colspan="2">--discovery-token string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>For token-based discovery, the token used to validate cluster information fetched from the API server.</p></td></tr><tr><td colspan="2">--discovery-token-ca-cert-hash strings</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>For token-based discovery, validate that the root CA public key matches this hash (format: "&lt;type&gt;:&lt;value&gt;").</p></td></tr><tr><td colspan="2">--discovery-token-unsafe-skip-ca-verification</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>For token-based discovery, allow joining without --discovery-token-ca-cert-hash pinning.</p></td></tr><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for kubelet-start</p></td></tr><tr><td colspan="2">--node-name string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Specify the node name.</p></td></tr><tr><td colspan="2">--patches string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "target" can be one of "kube-apiserver", "kube-controller-manager", "kube-scheduler", "etcd", "kubeletconfiguration", "corednsdeployment". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.</p></td></tr><tr><td colspan="2">--tls-bootstrap-token string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Specify the token used to temporarily authenticate with the Kubernetes Control Plane while joining the node.</p></td></tr><tr><td colspan="2">--token string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Use this token for both discovery-token and tls-bootstrap-token when those values are not provided.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div></div><h2 id="cmd-join-phase-control-plane-join">kubeadm join phase control-plane-join</h2><p>Using this phase you can join a node as a control-plane instance.</p><ul class="nav nav-tabs" id="tab-control-plane-join" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-control-plane-join-0" role="tab" aria-controls="tab-control-plane-join-0" aria-selected="true">control-plane-join</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-control-plane-join-1" role="tab" aria-controls="tab-control-plane-join-1">all</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-control-plane-join-2" role="tab" aria-controls="tab-control-plane-join-2">etcd</a></li><li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-control-plane-join-3" role="tab" aria-controls="tab-control-plane-join-3">mark-control-plane</a></li></ul><div class="tab-content" id="tab-control-plane-join"><div id="tab-control-plane-join-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-control-plane-join-0"><p><h3 id="synopsis">Synopsis</h3><p>Join a machine as a control plane instance</p><pre tabindex="0"><code>kubeadm join phase control-plane-join [flags]
</code></pre><h3 id="examples">Examples</h3><pre tabindex="0"><code>  # Joins a machine as a control plane instance
  kubeadm join phase control-plane-join all
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for control-plane-join</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div><div id="tab-control-plane-join-1" class="tab-pane" role="tabpanel" aria-labelledby="tab-control-plane-join-1"><p><h3 id="synopsis">Synopsis</h3><p>Join a machine as a control plane instance</p><pre tabindex="0"><code>kubeadm join phase control-plane-join all [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--apiserver-advertise-address string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>If the node should host a new control plane instance, the IP address the API Server will advertise it's listening on. If not set the default network interface will be used.</p></td></tr><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">--control-plane</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Create a new control plane instance on this node</p></td></tr><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for all</p></td></tr><tr><td colspan="2">--node-name string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Specify the node name.</p></td></tr><tr><td colspan="2">--patches string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "target" can be one of "kube-apiserver", "kube-controller-manager", "kube-scheduler", "etcd", "kubeletconfiguration", "corednsdeployment". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div><div id="tab-control-plane-join-2" class="tab-pane" role="tabpanel" aria-labelledby="tab-control-plane-join-2"><p><h3 id="synopsis">Synopsis</h3><p>Add a new local etcd member</p><pre tabindex="0"><code>kubeadm join phase control-plane-join etcd [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--apiserver-advertise-address string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>If the node should host a new control plane instance, the IP address the API Server will advertise it's listening on. If not set the default network interface will be used.</p></td></tr><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">--control-plane</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Create a new control plane instance on this node</p></td></tr><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for etcd</p></td></tr><tr><td colspan="2">--node-name string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Specify the node name.</p></td></tr><tr><td colspan="2">--patches string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "target" can be one of "kube-apiserver", "kube-controller-manager", "kube-scheduler", "etcd", "kubeletconfiguration", "corednsdeployment". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div><div id="tab-control-plane-join-3" class="tab-pane" role="tabpanel" aria-labelledby="tab-control-plane-join-3"><p><h3 id="synopsis">Synopsis</h3><p>Mark a node as a control-plane</p><pre tabindex="0"><code>kubeadm join phase control-plane-join mark-control-plane [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">--control-plane</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Create a new control plane instance on this node</p></td></tr><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for mark-control-plane</p></td></tr><tr><td colspan="2">--node-name string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Specify the node name.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table></p></div></div><h2 id="what-s-next">What's next</h2><ul><li><a href="/docs/reference/setup-tools/kubeadm/kubeadm-init/">kubeadm init</a> to bootstrap a Kubernetes control-plane node</li><li><a href="/docs/reference/setup-tools/kubeadm/kubeadm-join/">kubeadm join</a> to connect a node to the cluster</li><li><a href="/docs/reference/setup-tools/kubeadm/kubeadm-reset/">kubeadm reset</a> to revert any changes made to this host by <code>kubeadm init</code> or <code>kubeadm join</code></li><li><a href="/docs/reference/setup-tools/kubeadm/kubeadm-alpha/">kubeadm alpha</a> to try experimental functionality</li></ul></div>
<hr>
<div class="td-content"><h1 data-pagefind-weight="10">kubeadm init</h1><p>This command initializes a Kubernetes control plane node.</p><h3 id="synopsis">Synopsis</h3><p>Run this command in order to set up the Kubernetes control plane</p><p>The "init" command executes the following phases:</p><pre tabindex="0"><code>preflight                     Run pre-flight checks
certs                         Certificate generation
  /ca                           Generate the self-signed Kubernetes CA to provision identities for other Kubernetes components
  /apiserver                    Generate the certificate for serving the Kubernetes API
  /apiserver-kubelet-client     Generate the certificate for the API server to connect to kubelet
  /front-proxy-ca               Generate the self-signed CA to provision identities for front proxy
  /front-proxy-client           Generate the certificate for the front proxy client
  /etcd-ca                      Generate the self-signed CA to provision identities for etcd
  /etcd-server                  Generate the certificate for serving etcd
  /etcd-peer                    Generate the certificate for etcd nodes to communicate with each other
  /etcd-healthcheck-client      Generate the certificate for liveness probes to healthcheck etcd
  /apiserver-etcd-client        Generate the certificate the apiserver uses to access etcd
  /sa                           Generate a private key for signing service account tokens along with its public key
kubeconfig                    Generate all kubeconfig files necessary to establish the control plane and the admin kubeconfig file
  /admin                        Generate a kubeconfig file for the admin to use and for kubeadm itself
  /super-admin                  Generate a kubeconfig file for the super-admin
  /kubelet                      Generate a kubeconfig file for the kubelet to use *only* for cluster bootstrapping purposes
  /controller-manager           Generate a kubeconfig file for the controller manager to use
  /scheduler                    Generate a kubeconfig file for the scheduler to use
etcd                          Generate static Pod manifest file for local etcd
  /local                        Generate the static Pod manifest file for a local, single-node local etcd instance
control-plane                 Generate all static Pod manifest files necessary to establish the control plane
  /apiserver                    Generates the kube-apiserver static Pod manifest
  /controller-manager           Generates the kube-controller-manager static Pod manifest
  /scheduler                    Generates the kube-scheduler static Pod manifest
kubelet-start                 Write kubelet settings and (re)start the kubelet
wait-control-plane            Wait for the control plane to start
upload-config                 Upload the kubeadm and kubelet configuration to a ConfigMap
  /kubeadm                      Upload the kubeadm ClusterConfiguration to a ConfigMap
  /kubelet                      Upload the kubelet component config to a ConfigMap
upload-certs                  Upload certificates to kubeadm-certs
mark-control-plane            Mark a node as a control-plane
bootstrap-token               Generates bootstrap tokens used to join a node to a cluster
kubelet-finalize              Updates settings relevant to the kubelet after TLS bootstrap
  /enable-client-cert-rotation  Enable kubelet client certificate rotation
addon                         Install required addons for passing conformance tests
  /coredns                      Install the CoreDNS addon to a Kubernetes cluster
  /kube-proxy                   Install the kube-proxy addon to a Kubernetes cluster
show-join-command             Show the join command for control-plane and worker node
</code></pre><pre tabindex="0"><code>kubeadm init [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--apiserver-advertise-address string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.</p></td></tr><tr><td colspan="2">--apiserver-bind-port int32     Default: 6443</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Port for the API Server to bind to.</p></td></tr><tr><td colspan="2">--apiserver-cert-extra-sans strings</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Optional extra Subject Alternative Names (SANs) to use for the API Server serving certificate. Can be both IP addresses and DNS names.</p></td></tr><tr><td colspan="2">--cert-dir string     Default: "/etc/kubernetes/pki"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan="2">--certificate-key string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Key used to encrypt the control-plane certificates in the kubeadm-certs Secret. The certificate key is a hex encoded string that is an AES key of size 32 bytes.</p></td></tr><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">--control-plane-endpoint string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Specify a stable IP address or DNS name for the control plane.</p></td></tr><tr><td colspan="2">--cri-socket string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to the CRI socket to connect. If empty kubeadm will try to auto-detect this value; use this option only if you have more than one CRI installed or if you have non-standard CRI socket.</p></td></tr><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan="2">--feature-gates string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>A set of key=value pairs that describe feature gates for various features. Options are:<br/>ControlPlaneKubeletLocalMode=true|false (BETA - default=true)<br/>NodeLocalCRISocket=true|false (BETA - default=true)<br/>PublicKeysECDSA=true|false (DEPRECATED - default=false)<br/>RootlessControlPlane=true|false (ALPHA - default=false)<br/>WaitForAllControlPlaneComponents=true|false (default=true)</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for init</p></td></tr><tr><td colspan="2">--ignore-preflight-errors strings</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>A list of checks whose errors will be shown as warnings. Example: 'IsPrivilegedUser,Swap'. Value 'all' ignores errors from all checks.</p></td></tr><tr><td colspan="2">--image-repository string     Default: "registry.k8s.io"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Choose a container registry to pull control plane images from</p></td></tr><tr><td colspan="2">--kubernetes-version string     Default: "stable-1"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Choose a specific Kubernetes version for the control plane.</p></td></tr><tr><td colspan="2">--node-name string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Specify the node name.</p></td></tr><tr><td colspan="2">--patches string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "target" can be one of "kube-apiserver", "kube-controller-manager", "kube-scheduler", "etcd", "kubeletconfiguration", "corednsdeployment". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.</p></td></tr><tr><td colspan="2">--pod-network-cidr string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Specify range of IP addresses for the pod network. If set, the control plane will automatically allocate CIDRs for every node.</p></td></tr><tr><td colspan="2">--service-cidr string     Default: "10.96.0.0/12"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Use alternative range of IP address for service VIPs.</p></td></tr><tr><td colspan="2">--service-dns-domain string     Default: "cluster.local"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Use alternative domain for services, e.g. "myorg.internal".</p></td></tr><tr><td colspan="2">--skip-certificate-key-print</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Don't print the key used to encrypt the control-plane certificates.</p></td></tr><tr><td colspan="2">--skip-phases strings</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>List of phases to be skipped</p></td></tr><tr><td colspan="2">--skip-token-print</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Skip printing of the default bootstrap token generated by 'kubeadm init'.</p></td></tr><tr><td colspan="2">--token string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The token to use for establishing bidirectional trust between nodes and control-plane nodes. The format is [a-z0-9]{6}.[a-z0-9]{16} - e.g. abcdef.0123456789abcdef</p></td></tr><tr><td colspan="2">--token-ttl duration     Default: 24h0m0s</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The duration before the token is automatically deleted (e.g. 1s, 2m, 3h). If set to '0', the token will never expire</p></td></tr><tr><td colspan="2">--upload-certs</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Upload control-plane certificates to the kubeadm-certs Secret.</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table><h3 id="init-workflow">Init workflow</h3><p><code>kubeadm init</code> bootstraps a Kubernetes control plane node by executing the
following steps:</p><ol><li><p>Runs a series of pre-flight checks to validate the system state
before making changes. Some checks only trigger warnings, others are
considered errors and will exit kubeadm until the problem is corrected or the
user specifies <code>--ignore-preflight-errors=&lt;list-of-errors&gt;</code>.</p></li><li><p>Generates a self-signed CA to set up identities for each component in the cluster. The user can provide their
own CA cert and/or key by dropping it in the cert directory configured via <code>--cert-dir</code>
(<code>/etc/kubernetes/pki</code> by default).
The API server certs will have additional SAN entries for any <code>--apiserver-cert-extra-sans</code>
arguments, lowercased if necessary.</p></li><li><p>Writes kubeconfig files in <code>/etc/kubernetes/</code> for the kubelet, the controller-manager, and the
scheduler to connect to the API server, each with its own identity. Also
additional kubeconfig files are written, for kubeadm as administrative entity (<code>admin.conf</code>)
and for a super admin user that can bypass RBAC (<code>super-admin.conf</code>).</p></li><li><p>Generates static Pod manifests for the API server,
controller-manager and scheduler. In case an external etcd is not provided,
an additional static Pod manifest is generated for etcd.</p><p>Static Pod manifests are written to <code>/etc/kubernetes/manifests</code>; the kubelet
watches this directory for Pods to create on startup.</p><p>Once control plane Pods are up and running, the <code>kubeadm init</code> sequence can continue.</p></li><li><p>Apply labels and taints to the control plane node so that no additional workloads will
run there.</p></li><li><p>Generates the token that additional nodes can use to register
themselves with a control plane in the future. Optionally, the user can provide a
token via <code>--token</code>, as described in the
<a href="/docs/reference/setup-tools/kubeadm/kubeadm-token/">kubeadm token</a> documents.</p></li><li><p>Makes all the necessary configurations for allowing node joining with the
<a href="/docs/reference/access-authn-authz/bootstrap-tokens/">Bootstrap Tokens</a> and
<a href="/docs/reference/access-authn-authz/kubelet-tls-bootstrapping/">TLS Bootstrap</a>
mechanism:</p><ul><li><p>Write a ConfigMap for making available all the information required
for joining, and set up related RBAC access rules.</p></li><li><p>Let Bootstrap Tokens access the CSR signing API.</p></li><li><p>Configure auto-approval for new CSR requests.</p></li></ul><p>See <a href="/docs/reference/setup-tools/kubeadm/kubeadm-join/">kubeadm join</a> for additional information.</p></li><li><p>Installs a DNS server (CoreDNS) and the kube-proxy addon components via the API server.
In Kubernetes version 1.11 and later CoreDNS is the default DNS server.
Please note that although the DNS server is deployed, it will not be scheduled until CNI is installed.</p><div class="alert alert-danger" role="alert"><h4 class="alert-heading">Warning:</h4>kube-dns usage with kubeadm is deprecated as of v1.18 and is removed in v1.21.</div></li></ol><h3 id="init-phases">Using init phases with kubeadm</h3><p>kubeadm allows you to create a control plane node in phases using the <code>kubeadm init phase</code> command.</p><p>To view the ordered list of phases and sub-phases you can call <code>kubeadm init --help</code>. The list
will be located at the top of the help screen and each phase will have a description next to it.
Note that by calling <code>kubeadm init</code> all of the phases and sub-phases will be executed in this exact order.</p><p>Some phases have unique flags, so if you want to have a look at the list of available options add
<code>--help</code>, for example:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>sudo kubeadm init phase control-plane controller-manager --help
</span></span></code></pre></div><p>You can also use <code>--help</code> to see the list of sub-phases for a certain parent phase:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>sudo kubeadm init phase control-plane --help
</span></span></code></pre></div><p><code>kubeadm init</code> also exposes a flag called <code>--skip-phases</code> that can be used to skip certain phases.
The flag accepts a list of phase names and the names can be taken from the above ordered list.</p><p>An example:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>sudo kubeadm init phase control-plane all --config<span style="color:#666">=</span>configfile.yaml
</span></span><span style="display:flex"><span>sudo kubeadm init phase etcd <span style="color:#a2f">local</span> --config<span style="color:#666">=</span>configfile.yaml
</span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"># you can now modify the control plane and etcd manifest files</span>
</span></span><span style="display:flex"><span>sudo kubeadm init --skip-phases<span style="color:#666">=</span>control-plane,etcd --config<span style="color:#666">=</span>configfile.yaml
</span></span></code></pre></div><p>What this example would do is write the manifest files for the control plane and etcd in
<code>/etc/kubernetes/manifests</code> based on the configuration in <code>configfile.yaml</code>. This allows you to
modify the files and then skip these phases using <code>--skip-phases</code>. By calling the last command you
will create a control plane node with the custom manifest files.</p><div class="feature-state-notice feature-beta"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.22 [beta]</code></div><p>Alternatively, you can use the <code>skipPhases</code> field under <code>InitConfiguration</code>.</p><h3 id="config-file">Using kubeadm init with a configuration file</h3><div class="alert alert-caution" role="alert"><h4 class="alert-heading">Caution:</h4>The configuration file is still considered beta and may change in future versions.</div><p>It's possible to configure <code>kubeadm init</code> with a configuration file instead of command
line flags, and some more advanced features may only be available as
configuration file options. This file is passed using the <code>--config</code> flag and it must
contain a <code>ClusterConfiguration</code> structure and optionally more structures separated by <code>---\n</code>.
Mixing <code>--config</code> with others flags may not be allowed in some cases.</p><p>The default configuration can be printed out using the
<a href="/docs/reference/setup-tools/kubeadm/kubeadm-config/">kubeadm config print</a> command.</p><p>If your configuration is not using the latest version it is <strong>recommended</strong> that you migrate using
the <a href="/docs/reference/setup-tools/kubeadm/kubeadm-config/">kubeadm config migrate</a> command.</p><p>For more information on the fields and usage of the configuration you can navigate to our
<a href="/docs/reference/config-api/kubeadm-config.v1beta4/">API reference page</a>.</p><h3 id="feature-gates">Using kubeadm init with feature gates</h3><p>kubeadm supports a set of feature gates that are unique to kubeadm and can only be applied
during cluster creation with <code>kubeadm init</code>. These features can control the behavior
of the cluster. Feature gates are removed after a feature graduates to GA.</p><p>To pass a feature gate you can either use the <code>--feature-gates</code> flag for
<code>kubeadm init</code>, or you can add items into the <code>featureGates</code> field when you pass
a <a href="/docs/reference/config-api/kubeadm-config.v1beta4/#kubeadm-k8s-io-v1beta4-ClusterConfiguration">configuration file</a>
using <code>--config</code>.</p><p>Passing <a href="/docs/reference/command-line-tools-reference/feature-gates/">feature gates for core Kubernetes components</a>
directly to kubeadm is not supported. Instead, it is possible to pass them by
<a href="/docs/setup/production-environment/tools/kubeadm/control-plane-flags/">Customizing components with the kubeadm API</a>.</p><p>List of feature gates:</p><table><caption style="display:none">kubeadm feature gates</caption><thead><tr><th style="text-align:left">Feature</th><th style="text-align:left">Default</th><th style="text-align:left">Alpha</th><th style="text-align:left">Beta</th><th style="text-align:left">GA</th></tr></thead><tbody><tr><td style="text-align:left"><code>ControlPlaneKubeletLocalMode</code></td><td style="text-align:left"><code>true</code></td><td style="text-align:left">1.31</td><td style="text-align:left">1.33</td><td style="text-align:left">-</td></tr><tr><td style="text-align:left"><code>NodeLocalCRISocket</code></td><td style="text-align:left"><code>true</code></td><td style="text-align:left">1.32</td><td style="text-align:left">1.34</td><td style="text-align:left">-</td></tr><tr><td style="text-align:left"><code>WaitForAllControlPlaneComponents</code></td><td style="text-align:left"><code>true</code></td><td style="text-align:left">1.30</td><td style="text-align:left">1.33</td><td style="text-align:left">1.34</td></tr></tbody></table><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>Once a feature gate goes GA its value becomes locked to <code>true</code> by default.</div><p>Feature gate descriptions:</p><dl><dt><code>ControlPlaneKubeletLocalMode</code></dt><dd>With this feature gate enabled, when joining a new control plane node, kubeadm will configure the kubelet
to connect to the local kube-apiserver. This ensures that there will not be a violation of the version skew
policy during rolling upgrades.</dd><dt><code>NodeLocalCRISocket</code></dt><dd>With this feature gate enabled, kubeadm will read/write the CRI socket for each node from/to the file
<code>/var/lib/kubelet/instance-config.yaml</code> instead of reading/writing it from/to the annotation
<code>kubeadm.alpha.kubernetes.io/cri-socket</code> on the Node object. The new file is applied as an instance
configuration patch, before any other user managed patches are applied when the <code>--patches</code> flag
is used. It contains a single field <code>containerRuntimeEndpoint</code> from the
<a href="/docs/reference/config-api/kubelet-config.v1beta1/">KubeletConfiguration file format</a>. If the feature gate
is enabled during upgrade, but the file <code>/var/lib/kubelet/instance-config.yaml</code> does not exist yet,
kubeadm will attempt to read the CRI socket value from the file <code>/var/lib/kubelet/kubeadm-flags.env</code>.</dd><dt><code>WaitForAllControlPlaneComponents</code></dt><dd>With this feature gate enabled, kubeadm will wait for all control plane components (kube-apiserver,
kube-controller-manager, kube-scheduler) on a control plane node to report status 200 on their <code>/livez</code>
or <code>/healthz</code> endpoints. These checks are performed on <code>https://ADDRESS:PORT/ENDPOINT</code>.<ul><li><code>PORT</code> is taken from <code>--secure-port</code> of a component.</li><li><code>ADDRESS</code> is <code>--advertise-address</code> for kube-apiserver and <code>--bind-address</code> for the
kube-controller-manager and kube-scheduler.</li><li><code>ENDPOINT</code> is only <code>/healthz</code> for kube-controller-manager until it supports <code>/livez</code> as well.</li></ul><p>If you specify custom <code>ADDRESS</code> or <code>PORT</code> in the kubeadm configuration they will be respected.
Without the feature gate enabled, kubeadm will only wait for the kube-apiserver
on a control plane node to become ready. The wait process starts right after the kubelet on the host
is started by kubeadm. You are advised to enable this feature gate in case you wish to observe a ready
state from all control plane components during the <code>kubeadm init</code> or <code>kubeadm join</code> command execution.</p></dd></dl><p>List of deprecated feature gates:</p><table><caption style="display:none">kubeadm deprecated feature gates</caption><thead><tr><th style="text-align:left">Feature</th><th style="text-align:left">Default</th><th style="text-align:left">Alpha</th><th style="text-align:left">Beta</th><th style="text-align:left">GA</th><th style="text-align:left">Deprecated</th></tr></thead><tbody><tr><td style="text-align:left"><code>PublicKeysECDSA</code></td><td style="text-align:left"><code>false</code></td><td style="text-align:left">1.19</td><td style="text-align:left">-</td><td style="text-align:left">-</td><td style="text-align:left">1.31</td></tr><tr><td style="text-align:left"><code>RootlessControlPlane</code></td><td style="text-align:left"><code>false</code></td><td style="text-align:left">1.22</td><td style="text-align:left">-</td><td style="text-align:left">-</td><td style="text-align:left">1.31</td></tr></tbody></table><p>Feature gate descriptions:</p><dl><dt><code>PublicKeysECDSA</code></dt><dd>Can be used to create a cluster that uses ECDSA certificates instead of the default RSA algorithm.
Renewal of existing ECDSA certificates is also supported using <code>kubeadm certs renew</code>, but you cannot
switch between the RSA and ECDSA algorithms on the fly or during upgrades. Kubernetes versions before v1.31
had a bug where keys in generated kubeconfig files were set use RSA, even when you had enabled the
<code>PublicKeysECDSA</code> feature gate. This feature gate is deprecated in favor of the <code>encryptionAlgorithm</code>
functionality available in kubeadm v1beta4.</dd><dt><code>RootlessControlPlane</code></dt><dd>Setting this flag configures the kubeadm deployed control plane component static Pod containers
for <code>kube-apiserver</code>, <code>kube-controller-manager</code>, <code>kube-scheduler</code> and <code>etcd</code> to run as non-root users.
If the flag is not set, those components run as root. You can change the value of this feature gate before
you upgrade to a newer version of Kubernetes.</dd></dl><p>List of removed feature gates:</p><table><caption style="display:none">kubeadm removed feature gates</caption><thead><tr><th style="text-align:left">Feature</th><th style="text-align:left">Alpha</th><th style="text-align:left">Beta</th><th style="text-align:left">GA</th><th style="text-align:left">Removed</th></tr></thead><tbody><tr><td style="text-align:left"><code>EtcdLearnerMode</code></td><td style="text-align:left">1.27</td><td style="text-align:left">1.29</td><td style="text-align:left">1.32</td><td style="text-align:left">1.33</td></tr><tr><td style="text-align:left"><code>IPv6DualStack</code></td><td style="text-align:left">1.16</td><td style="text-align:left">1.21</td><td style="text-align:left">1.23</td><td style="text-align:left">1.24</td></tr><tr><td style="text-align:left"><code>UnversionedKubeletConfigMap</code></td><td style="text-align:left">1.22</td><td style="text-align:left">1.23</td><td style="text-align:left">1.25</td><td style="text-align:left">1.26</td></tr><tr><td style="text-align:left"><code>UpgradeAddonsBeforeControlPlane</code></td><td style="text-align:left">1.28</td><td style="text-align:left">-</td><td style="text-align:left">-</td><td style="text-align:left">1.31</td></tr></tbody></table><p>Feature gate descriptions:</p><dl><dt><code>EtcdLearnerMode</code></dt><dd>When joining a new control plane node, a new etcd member will be created
as a learner and promoted to a voting member only after the etcd data are fully aligned.</dd><dt><code>IPv6DualStack</code></dt><dd>This flag helps to configure components dual stack when the feature is in progress. For more details on Kubernetes
dual-stack support see <a href="/docs/setup/production-environment/tools/kubeadm/dual-stack-support/">Dual-stack support with kubeadm</a>.</dd><dt><code>UnversionedKubeletConfigMap</code></dt><dd>This flag controls the name of the <a class="glossary-tooltip" title="An API object used to store non-confidential data in key-value pairs. Can be consumed as environment variables, command-line arguments, or configuration files in a volume." data-toggle="tooltip" data-placement="top" href="/docs/concepts/configuration/configmap/" target="_blank" aria-label="ConfigMap">ConfigMap</a> where kubeadm stores
kubelet configuration data. With this flag not specified or set to <code>true</code>, the ConfigMap is named <code>kubelet-config</code>.
If you set this flag to <code>false</code>, the name of the ConfigMap includes the major and minor version for Kubernetes
(for example: <code>kubelet-config-1.34</code>). Kubeadm ensures that RBAC rules for reading and writing
that ConfigMap are appropriate for the value you set. When kubeadm writes this ConfigMap (during <code>kubeadm init</code>
or <code>kubeadm upgrade apply</code>), kubeadm respects the value of <code>UnversionedKubeletConfigMap</code>. When reading that ConfigMap
(during <code>kubeadm join</code>, <code>kubeadm reset</code>, <code>kubeadm upgrade</code>...), kubeadm attempts to use unversioned ConfigMap name first.
If that does not succeed, kubeadm falls back to using the legacy (versioned) name for that ConfigMap.</dd><dt><code>UpgradeAddonsBeforeControlPlane</code></dt><dd>This feature gate has been removed. It was introduced in v1.28 as a deprecated feature and then removed in v1.31.
For documentation on older versions, please switch to the corresponding website version.</dd></dl><h3 id="kube-proxy">Adding kube-proxy parameters</h3><p>For information about kube-proxy parameters in the kubeadm configuration see:</p><ul><li><a href="/docs/reference/config-api/kube-proxy-config.v1alpha1/">kube-proxy reference</a></li></ul><p>For information about enabling IPVS mode with kubeadm see:</p><ul><li><a href="https://github.com/kubernetes/kubernetes/blob/master/pkg/proxy/ipvs/README.md">IPVS</a></li></ul><h3 id="control-plane-flags">Passing custom flags to control plane components</h3><p>For information about passing flags to control plane components see:</p><ul><li><a href="/docs/setup/production-environment/tools/kubeadm/control-plane-flags/">control-plane-flags</a></li></ul><h3 id="without-internet-connection">Running kubeadm without an Internet connection</h3><p>For running kubeadm without an Internet connection you have to pre-pull the required control plane images.</p><p>You can list and pull the images using the <code>kubeadm config images</code> sub-command:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubeadm config images list
</span></span><span style="display:flex"><span>kubeadm config images pull
</span></span></code></pre></div><p>You can pass <code>--config</code> to the above commands with a <a href="#config-file">kubeadm configuration file</a>
to control the <code>kubernetesVersion</code> and <code>imageRepository</code> fields.</p><p>All default <code>registry.k8s.io</code> images that kubeadm requires support multiple architectures.</p><h3 id="custom-images">Using custom images</h3><p>By default, kubeadm pulls images from <code>registry.k8s.io</code>. If the
requested Kubernetes version is a CI label (such as <code>ci/latest</code>)
<code>gcr.io/k8s-staging-ci-images</code> is used.</p><p>You can override this behavior by using <a href="#config-file">kubeadm with a configuration file</a>.
Allowed customization are:</p><ul><li>To provide <code>kubernetesVersion</code> which affects the version of the images.</li><li>To provide an alternative <code>imageRepository</code> to be used instead of
<code>registry.k8s.io</code>.</li><li>To provide a specific <code>imageRepository</code> and <code>imageTag</code> for etcd or CoreDNS.</li></ul><p>Image paths between the default <code>registry.k8s.io</code> and a custom repository specified using
<code>imageRepository</code> may differ for backwards compatibility reasons. For example,
one image might have a subpath at <code>registry.k8s.io/subpath/image</code>, but be defaulted
to <code>my.customrepository.io/image</code> when using a custom repository.</p><p>To ensure you push the images to your custom repository in paths that kubeadm
can consume, you must:</p><ul><li>Pull images from the defaults paths at <code>registry.k8s.io</code> using <code>kubeadm config images {list|pull}</code>.</li><li>Push images to the paths from <code>kubeadm config images list --config=config.yaml</code>,
where <code>config.yaml</code> contains the custom <code>imageRepository</code>, and/or <code>imageTag</code> for etcd and CoreDNS.</li><li>Pass the same <code>config.yaml</code> to <code>kubeadm init</code>.</li></ul><h4 id="custom-pause-image">Custom sandbox (pause) images</h4><p>To set a custom image for these you need to configure this in your
<a class="glossary-tooltip" title="The container runtime is the software that is responsible for running containers." data-toggle="tooltip" data-placement="top" href="/docs/setup/production-environment/container-runtimes" target="_blank" aria-label="container runtime">container runtime</a> to use the image.
Consult the documentation for your container runtime to find out how to change this setting;
for selected container runtimes, you can also find advice within the
<a href="/docs/setup/production-environment/container-runtimes/">Container Runtimes</a> topic.</p><h3 id="uploading-control-plane-certificates-to-the-cluster">Uploading control plane certificates to the cluster</h3><p>By adding the flag <code>--upload-certs</code> to <code>kubeadm init</code> you can temporary upload
the control plane certificates to a Secret in the cluster. Please note that this Secret
will expire automatically after 2 hours. The certificates are encrypted using
a 32byte key that can be specified using <code>--certificate-key</code>. The same key can be used
to download the certificates when additional control plane nodes are joining, by passing
<code>--control-plane</code> and <code>--certificate-key</code> to <code>kubeadm join</code>.</p><p>The following phase command can be used to re-upload the certificates after expiration:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubeadm init phase upload-certs --upload-certs --config<span style="color:#666">=</span>SOME_YAML_FILE
</span></span></code></pre></div><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>A predefined <code>certificateKey</code> can be provided in <code>InitConfiguration</code> when passing the
<a href="/docs/reference/config-api/kubeadm-config.v1beta4/">configuration file</a> with <code>--config</code>.</div><p>If a predefined certificate key is not passed to <code>kubeadm init</code> and
<code>kubeadm init phase upload-certs</code> a new key will be generated automatically.</p><p>The following command can be used to generate a new key on demand:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubeadm certs certificate-key
</span></span></code></pre></div><h3 id="certificate-management-with-kubeadm">Certificate management with kubeadm</h3><p>For detailed information on certificate management with kubeadm see
<a href="/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/">Certificate Management with kubeadm</a>.
The document includes information about using external CA, custom certificates
and certificate renewal.</p><h3 id="kubelet-drop-in">Managing the kubeadm drop-in file for the kubelet</h3><p>The <code>kubeadm</code> package ships with a configuration file for running the <code>kubelet</code> by <code>systemd</code>.
Note that the kubeadm CLI never touches this drop-in file. This drop-in file is part of the kubeadm
DEB/RPM package.</p><p>For further information, see
<a href="/docs/setup/production-environment/tools/kubeadm/kubelet-integration/#the-kubelet-drop-in-file-for-systemd">Managing the kubeadm drop-in file for systemd</a>.</p><h3 id="use-kubeadm-with-cri-runtimes">Use kubeadm with CRI runtimes</h3><p>By default, kubeadm attempts to detect your container runtime. For more details on this detection,
see the <a href="/docs/setup/production-environment/tools/kubeadm/install-kubeadm/#installing-runtime">kubeadm CRI installation guide</a>.</p><h3 id="setting-the-node-name">Setting the node name</h3><p>By default, kubeadm assigns a node name based on a machine's host address.
You can override this setting with the <code>--node-name</code> flag.
The flag passes the appropriate <a href="/docs/reference/command-line-tools-reference/kubelet/#options"><code>--hostname-override</code></a>
value to the kubelet.</p><p>Be aware that overriding the hostname can
<a href="https://github.com/kubernetes/website/pull/8873">interfere with cloud providers</a>.</p><h3 id="automating-kubeadm">Automating kubeadm</h3><p>Rather than copying the token you obtained from <code>kubeadm init</code> to each node, as
in the <a href="/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/">basic kubeadm tutorial</a>,
you can parallelize the token distribution for easier automation. To implement this automation,
you must know the IP address that the control plane node will have after it is started, or use a
DNS name or an address of a load balancer.</p><ol><li><p>Generate a token. This token must have the form <code>&lt;6 character string&gt;.&lt;16 character string&gt;</code>.
More formally, it must match the regex: <code>[a-z0-9]{6}\.[a-z0-9]{16}</code>.</p><p>kubeadm can generate a token for you:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubeadm token generate
</span></span></code></pre></div></li><li><p>Start both the control plane node and the worker nodes concurrently with this token.
As they come up they should find each other and form the cluster. The same
<code>--token</code> argument can be used on both <code>kubeadm init</code> and <code>kubeadm join</code>.</p></li><li><p>Similar can be done for <code>--certificate-key</code> when joining additional control plane
nodes. The key can be generated using:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubeadm certs certificate-key
</span></span></code></pre></div></li></ol><p>Once the cluster is up, you can use the <code>/etc/kubernetes/admin.conf</code> file from
a control plane node to talk to the cluster with administrator credentials or
<a href="/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/#kubeconfig-additional-users">Generating kubeconfig files for additional users</a>.</p><p>Note that this style of bootstrap has some relaxed security guarantees because
it does not allow the root CA hash to be validated with
<code>--discovery-token-ca-cert-hash</code> (since it's not generated when the nodes are provisioned).
For details, see the <a href="/docs/reference/setup-tools/kubeadm/kubeadm-join/">kubeadm join</a>.</p><h2 id="what-s-next">What's next</h2><ul><li><a href="/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/">kubeadm init phase</a> to understand more about
<code>kubeadm init</code> phases</li><li><a href="/docs/reference/setup-tools/kubeadm/kubeadm-join/">kubeadm join</a> to bootstrap a Kubernetes
worker node and join it to the cluster</li><li><a href="/docs/reference/setup-tools/kubeadm/kubeadm-upgrade/">kubeadm upgrade</a> to upgrade a Kubernetes
cluster to a newer version</li><li><a href="/docs/reference/setup-tools/kubeadm/kubeadm-reset/">kubeadm reset</a> to revert any changes made
to this host by <code>kubeadm init</code> or <code>kubeadm join</code></li></ul></div>
<hr>
<div class="td-content"><h1>Setup tools</h1><div class="section-index"><hr class="panel-line"/><div class="entry"><h5><a href="/docs/reference/setup-tools/kubeadm/">Kubeadm</a></h5><p/></div></div></div>
<hr>
<div class="td-content"><h1 data-pagefind-weight="10">kubeadm reset</h1><p>Performs a best effort revert of changes made by <code>kubeadm init</code> or <code>kubeadm join</code>.</p><h3 id="synopsis">Synopsis</h3><p>Performs a best effort revert of changes made to this host by 'kubeadm init' or 'kubeadm join'</p><p>The "reset" command executes the following phases:</p><pre tabindex="0"><code>preflight           Run reset pre-flight checks
remove-etcd-member  Remove a local etcd member.
cleanup-node        Run cleanup node.
</code></pre><pre tabindex="0"><code>kubeadm reset [flags]
</code></pre><h3 id="options">Options</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--cert-dir string     Default: "/etc/kubernetes/pki"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the directory where the certificates are stored. If specified, clean this directory.</p></td></tr><tr><td colspan="2">--cleanup-tmp-dir</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Cleanup the "/etc/kubernetes/tmp" directory</p></td></tr><tr><td colspan="2">--config string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan="2">--cri-socket string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Path to the CRI socket to connect. If empty kubeadm will try to auto-detect this value; use this option only if you have more than one CRI installed or if you have non-standard CRI socket.</p></td></tr><tr><td colspan="2">--dry-run</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan="2">-f, --force</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>Reset the node without prompting for confirmation.</p></td></tr><tr><td colspan="2">-h, --help</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>help for reset</p></td></tr><tr><td colspan="2">--ignore-preflight-errors strings</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>A list of checks whose errors will be shown as warnings. Example: 'IsPrivilegedUser,Swap'. Value 'all' ignores errors from all checks.</p></td></tr><tr><td colspan="2">--kubeconfig string     Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan="2">--skip-phases strings</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>List of phases to be skipped</p></td></tr></tbody></table><h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3><table style="width:100%;table-layout:fixed"><col span="1" style="width:10px"/><col span="1"/><tbody><tr><td colspan="2">--rootfs string</td></tr><tr><td/><td style="line-height:130%;word-wrap:break-word"><p>The path to the 'real' host root filesystem. This will cause kubeadm to chroot into the provided path.</p></td></tr></tbody></table><h3 id="reset-workflow">Reset workflow</h3><p><code>kubeadm reset</code> is responsible for cleaning up a node local file system from files that were created using
the <code>kubeadm init</code> or <code>kubeadm join</code> commands. For control-plane nodes <code>reset</code> also removes the local stacked
etcd member of this node from the etcd cluster.</p><p><code>kubeadm reset phase</code> can be used to execute the separate phases of the above workflow.
To skip a list of phases you can use the <code>--skip-phases</code> flag, which works in a similar way to
the <code>kubeadm join</code> and <code>kubeadm init</code> phase runners.</p><p><code>kubeadm reset</code> also supports the <code>--config</code> flag for passing
a <a href="/docs/reference/config-api/kubeadm-config.v1beta4/"><code>ResetConfiguration</code> structure</a>.</p><h3 id="cleanup-of-external-etcd-members">Cleanup of external etcd members</h3><p><code>kubeadm reset</code> will not delete any etcd data if external etcd is used. This means that if you run <code>kubeadm init</code> again using the same etcd endpoints, you will see state from previous clusters.</p><p>To wipe etcd data it is recommended you use a client like etcdctl, such as:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="display:flex"><span>etcdctl del <span style="color:#b44">""</span> --prefix
</span></span></code></pre></div><p>See the <a href="https://github.com/coreos/etcd/tree/master/etcdctl">etcd documentation</a> for more information.</p><h3 id="cleanup-of-cni-configuration">Cleanup of CNI configuration</h3><p>CNI plugins use the directory <code>/etc/cni/net.d</code> to store their configuration.
The <code>kubeadm reset</code> command does not cleanup that directory. Leaving the configuration
of a CNI plugin on a host can be problematic if the same host is later used
as a new Kubernetes node and a different CNI plugin happens to be deployed in that cluster.
It can result in a configuration conflict between CNI plugins.</p><p>To cleanup the directory, backup its contents if needed and then execute
the following command:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="display:flex"><span>sudo rm -rf /etc/cni/net.d
</span></span></code></pre></div><h3 id="cleanup-of-network-traffic-rules">Cleanup of network traffic rules</h3><p>The <code>kubeadm reset</code> command does not clean any iptables, nftables or IPVS rules applied
to the host by kube-proxy. A control loop in kube-proxy ensures that the rules on each node
host are synchronized. For additional details please see
<a href="/docs/reference/networking/virtual-ips/">Virtual IPs and Service Proxies</a>.</p><p>Leaving the rules without cleanup should not cause any issues if the host is
later reused as a Kubernetes node or if it will serve a different purpose.</p><p>If you wish to perform this cleanup, you can use the same kube-proxy container
which was used in your cluster and the <code>--cleanup</code> flag of the
<code>kube-proxy</code> binary:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="display:flex"><span>docker run --privileged --rm registry.k8s.io/kube-proxy:v1.34.0 sh -c <span style="color:#b44">"kube-proxy --cleanup &amp;&amp; echo DONE"</span>
</span></span></code></pre></div><p>The output of the above command should print <code>DONE</code> at the end.
Instead of Docker, you can use your preferred container runtime to start the container.</p><h3 id="cleanup-of-home-kube">Cleanup of $HOME/.kube</h3><p>The <code>$HOME/.kube</code> directory typically contains configuration files and kubectl cache.
While not cleaning the contents of <code>$HOME/.kube/cache</code> is not an issue, there is one important
file in the directory. That is <code>$HOME/.kube/config</code> and it is used by kubectl to authenticate
to the Kubernetes API server. After <code>kubeadm init</code> finishes, the user is instructed to copy the
<code>/etc/kubernetes/admin.conf</code> file to the <code>$HOME/.kube/config</code> location and grant the current
user access to it.</p><p>The <code>kubeadm reset</code> command does not clean any of the contents of the <code>$HOME/.kube</code> directory.
Leaving the <code>$HOME/.kube/config</code> file without deleting it, can be problematic depending
on who will have access to this host after <code>kubeadm reset</code> was called.
If the same cluster continues to exist, it is highly recommended to delete the file,
as the admin credentials stored in it will continue to be valid.</p><p>To cleanup the directory, examine its contents, perform backup if needed and execute
the following command:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="display:flex"><span>rm -rf <span style="color:#b8860b">$HOME</span>/.kube
</span></span></code></pre></div><h3 id="graceful-kube-apiserver-shutdown">Graceful kube-apiserver shutdown</h3><p>If you have your <code>kube-apiserver</code> configured with the <code>--shutdown-delay-duration</code> flag,
you can run the following commands to attempt a graceful shutdown for the running API server Pod,
before you run <code>kubeadm reset</code>:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="display:flex"><span>yq <span style="color:#a2f">eval</span> -i <span style="color:#b44">'.spec.containers[0].command = []'</span> /etc/kubernetes/manifests/kube-apiserver.yaml
</span></span><span style="display:flex"><span>timeout <span style="color:#666">60</span> sh -c <span style="color:#b44">'while pgrep kube-apiserver &gt;/dev/null; do sleep 1; done'</span> <span style="color:#666">||</span> <span style="color:#a2f">true</span>
</span></span></code></pre></div><h2 id="what-s-next">What's next</h2><ul><li><a href="/docs/reference/setup-tools/kubeadm/kubeadm-init/">kubeadm init</a> to bootstrap a Kubernetes control-plane node</li><li><a href="/docs/reference/setup-tools/kubeadm/kubeadm-join/">kubeadm join</a> to bootstrap a Kubernetes worker node and join it to the cluster</li></ul></div>