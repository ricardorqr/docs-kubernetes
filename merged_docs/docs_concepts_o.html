<hr>
<div class="td-content"><h1 data-pagefind-weight="10">The Kubernetes API</h1><div class="lead">The Kubernetes API lets you query and manipulate the state of objects in Kubernetes. The core of Kubernetes' control plane is the API server and the HTTP API that it exposes. Users, the different parts of your cluster, and external components all communicate with one another through the API server.</div><p>The core of Kubernetes' <a class="glossary-tooltip" title="The container orchestration layer that exposes the API and interfaces to define, deploy, and manage the lifecycle of containers." data-toggle="tooltip" data-placement="top" href="/docs/reference/glossary/?all=true#term-control-plane" target="_blank" aria-label="control plane">control plane</a>
is the <a class="glossary-tooltip" title="Control plane component that serves the Kubernetes API." data-toggle="tooltip" data-placement="top" href="/docs/concepts/architecture/#kube-apiserver" target="_blank" aria-label="API server">API server</a>. The API server
exposes an HTTP API that lets end users, different parts of your cluster, and
external components communicate with one another.</p><p>The Kubernetes API lets you query and manipulate the state of API objects in Kubernetes
(for example: Pods, Namespaces, ConfigMaps, and Events).</p><p>Most operations can be performed through the <a href="/docs/reference/kubectl/">kubectl</a>
command-line interface or other command-line tools, such as
<a href="/docs/reference/setup-tools/kubeadm/">kubeadm</a>, which in turn use the API.
However, you can also access the API directly using REST calls. Kubernetes
provides a set of <a href="/docs/reference/using-api/client-libraries/">client libraries</a>
for those looking to
write applications using the Kubernetes API.</p><p>Each Kubernetes cluster publishes the specification of the APIs that the cluster serves.
There are two mechanisms that Kubernetes uses to publish these API specifications; both are useful
to enable automatic interoperability. For example, the <code>kubectl</code> tool fetches and caches the API
specification for enabling command-line completion and other features.
The two supported mechanisms are as follows:</p><ul><li><p><a href="#discovery-api">The Discovery API</a> provides information about the Kubernetes APIs:
API names, resources, versions, and supported operations. This is a Kubernetes
specific term as it is a separate API from the Kubernetes OpenAPI.
It is intended to be a brief summary of the available resources and it does not
detail specific schema for the resources. For reference about resource schemas,
please refer to the OpenAPI document.</p></li><li><p>The <a href="#openapi-interface-definition">Kubernetes OpenAPI Document</a> provides (full)
<a href="https://www.openapis.org/">OpenAPI v2.0 and 3.0 schemas</a> for all Kubernetes API
endpoints.
The OpenAPI v3 is the preferred method for accessing OpenAPI as it
provides
a more comprehensive and accurate view of the API. It includes all the available
API paths, as well as all resources consumed and produced for every operations
on every endpoints. It also includes any extensibility components that a cluster supports.
The data is a complete specification and is significantly larger than that from the
Discovery API.</p></li></ul><h2 id="discovery-api">Discovery API</h2><p>Kubernetes publishes a list of all group versions and resources supported via
the Discovery API. This includes the following for each resource:</p><ul><li>Name</li><li>Cluster or namespaced scope</li><li>Endpoint URL and supported verbs</li><li>Alternative names</li><li>Group, version, kind</li></ul><p>The API is available in both aggregated and unaggregated form. The aggregated
discovery serves two endpoints, while the unaggregated discovery serves a
separate endpoint for each group version.</p><h3 id="aggregated-discovery">Aggregated discovery</h3><div class="feature-state-notice feature-stable" title="Feature Gate: AggregatedDiscoveryEndpoint"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.30 [stable]</code> (enabled by default: true)</div><p>Kubernetes offers stable support for <em>aggregated discovery</em>, publishing
all resources supported by a cluster through two endpoints (<code>/api</code> and
<code>/apis</code>). Requesting this
endpoint drastically reduces the number of requests sent to fetch the
discovery data from the cluster. You can access the data by
requesting the respective endpoints with an <code>Accept</code> header indicating
the aggregated discovery resource:
<code>Accept: application/json;v=v2;g=apidiscovery.k8s.io;as=APIGroupDiscoveryList</code>.</p><p>Without indicating the resource type using the <code>Accept</code> header, the default
response for the <code>/api</code> and <code>/apis</code> endpoint is an unaggregated discovery
document.</p><p>The <a href="https://github.com/kubernetes/kubernetes/blob/release-1.34/api/discovery/aggregated_v2.json">discovery document</a>
for the built-in resources can be found in the Kubernetes GitHub repository.
This Github document can be used as a reference of the base set of the available resources
if a Kubernetes cluster is not available to query.</p><p>The endpoint also supports ETag and protobuf encoding.</p><h3 id="unaggregated-discovery">Unaggregated discovery</h3><p>Without discovery aggregation, discovery is published in levels, with the root
endpoints publishing discovery information for downstream documents.</p><p>A list of all group versions supported by a cluster is published at
the <code>/api</code> and <code>/apis</code> endpoints. Example:</p><pre tabindex="0"><code>{
  "kind": "APIGroupList",
  "apiVersion": "v1",
  "groups": [
    {
      "name": "apiregistration.k8s.io",
      "versions": [
        {
          "groupVersion": "apiregistration.k8s.io/v1",
          "version": "v1"
        }
      ],
      "preferredVersion": {
        "groupVersion": "apiregistration.k8s.io/v1",
        "version": "v1"
      }
    },
    {
      "name": "apps",
      "versions": [
        {
          "groupVersion": "apps/v1",
          "version": "v1"
        }
      ],
      "preferredVersion": {
        "groupVersion": "apps/v1",
        "version": "v1"
      }
    },
    ...
}
</code></pre><p>Additional requests are needed to obtain the discovery document for each group version at
<code>/apis/&lt;group&gt;/&lt;version&gt;</code> (for example:
<code>/apis/rbac.authorization.k8s.io/v1alpha1</code>), which advertises the list of
resources served under a particular group version. These endpoints are used by
kubectl to fetch the list of resources supported by a cluster.</p><a id="#api-specification"><h2 id="openapi-interface-definition">OpenAPI interface definition</h2><p>For details about the OpenAPI specifications, see the <a href="https://www.openapis.org/">OpenAPI documentation</a>.</p><p>Kubernetes serves both OpenAPI v2.0 and OpenAPI v3.0. OpenAPI v3 is the
preferred method of accessing the OpenAPI because it offers a more comprehensive
(lossless) representation of Kubernetes resources. Due to limitations of OpenAPI
version 2, certain fields are dropped from the published OpenAPI including but not
limited to <code>default</code>, <code>nullable</code>, <code>oneOf</code>.</p><h3 id="openapi-v2">OpenAPI V2</h3><p>The Kubernetes API server serves an aggregated OpenAPI v2 spec via the
<code>/openapi/v2</code> endpoint. You can request the response format using
request headers as follows:</p><table><caption style="display:none">Valid request header values for OpenAPI v2 queries</caption><thead><tr><th>Header</th><th style="min-width:50%">Possible values</th><th>Notes</th></tr></thead><tbody><tr><td><code>Accept-Encoding</code></td><td><code>gzip</code></td><td><em>not supplying this header is also acceptable</em></td></tr><tr><td rowspan="3"><code>Accept</code></td><td><code>application/com.github.proto-openapi.spec.v2@v1.0+protobuf</code></td><td><em>mainly for intra-cluster use</em></td></tr><tr><td><code>application/json</code></td><td><em>default</em></td></tr><tr><td><code>*</code></td><td><em>serves </em><code>application/json</code></td></tr></tbody></table><div class="alert alert-danger" role="alert"><h4 class="alert-heading">Warning:</h4>The validation rules published as part of OpenAPI schemas may not be complete, and usually aren't.
Additional validation occurs within the API server. If you want precise and complete verification,
a <code>kubectl apply --dry-run=server</code> runs all the applicable validation (and also activates admission-time
checks).</div><h3 id="openapi-v3">OpenAPI V3</h3><div class="feature-state-notice feature-stable" title="Feature Gate: OpenAPIV3"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.27 [stable]</code> (enabled by default: true)</div><p>Kubernetes supports publishing a description of its APIs as OpenAPI v3.</p><p>A discovery endpoint <code>/openapi/v3</code> is provided to see a list of all
group/versions available. This endpoint only returns JSON. These
group/versions are provided in the following format:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span>{<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">"paths": </span>{<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span>...,<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">"api/v1": </span>{<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">            </span><span style="color:green;font-weight:700">"serverRelativeURL": </span><span style="color:#b44">"/openapi/v3/api/v1?hash=CC0E9BFD992D8C59AEC98A1E2336F899E8318D3CF4C68944C3DEC640AF5AB52D864AC50DAA8D145B3494F75FA3CFF939FCBDDA431DAD3CA79738B297795818CF"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span>},<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">"apis/admissionregistration.k8s.io/v1": </span>{<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">            </span><span style="color:green;font-weight:700">"serverRelativeURL": </span><span style="color:#b44">"/openapi/v3/apis/admissionregistration.k8s.io/v1?hash=E19CC93A116982CE5422FC42B590A8AFAD92CDE9AE4D59B5CAAD568F083AD07946E6CB5817531680BCE6E215C16973CD39003B0425F3477CFD854E89A9DB6597"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span>},<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span>....<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span>}<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/>}<span style="color:#bbb">
</span></span></span></code></pre></div><p>The relative URLs are pointing to immutable OpenAPI descriptions, in
order to improve client-side caching. The proper HTTP caching headers
are also set by the API server for that purpose (<code>Expires</code> to 1 year in
the future, and <code>Cache-Control</code> to <code>immutable</code>). When an obsolete URL is
used, the API server returns a redirect to the newest URL.</p><p>The Kubernetes API server publishes an OpenAPI v3 spec per Kubernetes
group version at the <code>/openapi/v3/apis/&lt;group&gt;/&lt;version&gt;?hash=&lt;hash&gt;</code>
endpoint.</p><p>Refer to the table below for accepted request headers.</p><table><caption style="display:none">Valid request header values for OpenAPI v3 queries</caption><thead><tr><th>Header</th><th style="min-width:50%">Possible values</th><th>Notes</th></tr></thead><tbody><tr><td><code>Accept-Encoding</code></td><td><code>gzip</code></td><td><em>not supplying this header is also acceptable</em></td></tr><tr><td rowspan="3"><code>Accept</code></td><td><code>application/com.github.proto-openapi.spec.v3@v1.0+protobuf</code></td><td><em>mainly for intra-cluster use</em></td></tr><tr><td><code>application/json</code></td><td><em>default</em></td></tr><tr><td><code>*</code></td><td><em>serves </em><code>application/json</code></td></tr></tbody></table><p>A Golang implementation to fetch the OpenAPI V3 is provided in the package
<a href="https://pkg.go.dev/k8s.io/client-go/openapi3"><code>k8s.io/client-go/openapi3</code></a>.</p><p>Kubernetes 1.34 publishes
OpenAPI v2.0 and v3.0; there are no plans to support 3.1 in the near future.</p><h3 id="protobuf-serialization">Protobuf serialization</h3><p>Kubernetes implements an alternative Protobuf based serialization format that
is primarily intended for intra-cluster communication. For more information
about this format, see the <a href="https://git.k8s.io/design-proposals-archive/api-machinery/protobuf.md">Kubernetes Protobuf serialization</a>
design proposal and the
Interface Definition Language (IDL) files for each schema located in the Go
packages that define the API objects.</p><h2 id="persistence">Persistence</h2><p>Kubernetes stores the serialized state of objects by writing them into
<a class="glossary-tooltip" title="Consistent and highly-available key value store used as backing store of Kubernetes for all cluster data." data-toggle="tooltip" data-placement="top" href="/docs/tasks/administer-cluster/configure-upgrade-etcd/" target="_blank" aria-label="etcd">etcd</a>.</p><h2 id="api-groups-and-versioning">API groups and versioning</h2><p>To make it easier to eliminate fields or restructure resource representations,
Kubernetes supports multiple API versions, each at a different API path, such
as <code>/api/v1</code> or <code>/apis/rbac.authorization.k8s.io/v1alpha1</code>.</p><p>Versioning is done at the API level rather than at the resource or field level
to ensure that the API presents a clear, consistent view of system resources
and behavior, and to enable controlling access to end-of-life and/or
experimental APIs.</p><p>To make it easier to evolve and to extend its API, Kubernetes implements
<a href="/docs/reference/using-api/#api-groups">API groups</a> that can be
<a href="/docs/reference/using-api/#enabling-or-disabling">enabled or disabled</a>.</p><p>API resources are distinguished by their API group, resource type, namespace
(for namespaced resources), and name. The API server handles the conversion between
API versions transparently: all the different versions are actually representations
of the same persisted data. The API server may serve the same underlying data
through multiple API versions.</p><p>For example, suppose there are two API versions, <code>v1</code> and <code>v1beta1</code>, for the same
resource. If you originally created an object using the <code>v1beta1</code> version of its
API, you can later read, update, or delete that object using either the <code>v1beta1</code>
or the <code>v1</code> API version, until the <code>v1beta1</code> version is deprecated and removed.
At that point you can continue accessing and modifying the object using the <code>v1</code> API.</p><h3 id="api-changes">API changes</h3><p>Any system that is successful needs to grow and change as new use cases emerge or existing ones change.
Therefore, Kubernetes has designed the Kubernetes API to continuously change and grow.
The Kubernetes project aims to <em>not</em> break compatibility with existing clients, and to maintain that
compatibility for a length of time so that other projects have an opportunity to adapt.</p><p>In general, new API resources and new resource fields can be added often and frequently.
Elimination of resources or fields requires following the
<a href="/docs/reference/using-api/deprecation-policy/">API deprecation policy</a>.</p><p>Kubernetes makes a strong commitment to maintain compatibility for official Kubernetes APIs
once they reach general availability (GA), typically at API version <code>v1</code>. Additionally,
Kubernetes maintains compatibility with data persisted via <em>beta</em> API versions of official Kubernetes APIs,
and ensures that data can be converted and accessed via GA API versions when the feature goes stable.</p><p>If you adopt a beta API version, you will need to transition to a subsequent beta or stable API version
once the API graduates. The best time to do this is while the beta API is in its deprecation period,
since objects are simultaneously accessible via both API versions. Once the beta API completes its
deprecation period and is no longer served, the replacement API version must be used.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>Although Kubernetes also aims to maintain compatibility for <em>alpha</em> APIs versions, in some
circumstances this is not possible. If you use any alpha API versions, check the release notes
for Kubernetes when upgrading your cluster, in case the API did change in incompatible
ways that require deleting all existing alpha objects prior to upgrade.</div><p>Refer to <a href="/docs/reference/using-api/#api-versioning">API versions reference</a>
for more details on the API version level definitions.</p><h2 id="api-extension">API Extension</h2><p>The Kubernetes API can be extended in one of two ways:</p><ol><li><a href="/docs/concepts/extend-kubernetes/api-extension/custom-resources/">Custom resources</a>
let you declaratively define how the API server should provide your chosen resource API.</li><li>You can also extend the Kubernetes API by implementing an
<a href="/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/">aggregation layer</a>.</li></ol><h2 id="what-s-next">What's next</h2><ul><li>Learn how to extend the Kubernetes API by adding your own
<a href="/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/">CustomResourceDefinition</a>.</li><li><a href="/docs/concepts/security/controlling-access/">Controlling Access To The Kubernetes API</a> describes
how the cluster manages authentication and authorization for API access.</li><li>Learn about API endpoints, resource types and samples by reading
<a href="/docs/reference/kubernetes-api/">API Reference</a>.</li><li>Learn about what constitutes a compatible change, and how to change the API, from
<a href="https://git.k8s.io/community/contributors/devel/sig-architecture/api_changes.md#readme">API changes</a>.</li></ul></a></div>
<hr>
<div class="td-content"><h1 data-pagefind-weight="10">Kubernetes Components</h1><div class="lead">An overview of the key components that make up a Kubernetes cluster.</div><p>This page provides a high-level overview of the essential components that make up a Kubernetes cluster.</p><figure class="diagram-large clickable-zoom"><img src="/images/docs/components-of-kubernetes.svg" alt="Components of Kubernetes"/><figcaption><p>The components of a Kubernetes cluster</p></figcaption></figure><h2 id="core-components">Core Components</h2><p>A Kubernetes cluster consists of a control plane and one or more worker nodes.
Here's a brief overview of the main components:</p><h3 id="control-plane-components">Control Plane Components</h3><p>Manage the overall state of the cluster:</p><dl><dt><a href="/docs/concepts/architecture/#kube-apiserver">kube-apiserver</a></dt><dd>The core component server that exposes the Kubernetes HTTP API.</dd><dt><a href="/docs/concepts/architecture/#etcd">etcd</a></dt><dd>Consistent and highly-available key value store for all API server data.</dd><dt><a href="/docs/concepts/architecture/#kube-scheduler">kube-scheduler</a></dt><dd>Looks for Pods not yet bound to a node, and assigns each Pod to a suitable node.</dd><dt><a href="/docs/concepts/architecture/#kube-controller-manager">kube-controller-manager</a></dt><dd>Runs <a class="glossary-tooltip" title="A control loop that watches the shared state of the cluster through the apiserver and makes changes attempting to move the current state towards the desired state." data-toggle="tooltip" data-placement="top" href="/docs/concepts/architecture/controller/" target="_blank" aria-label="controllers">controllers</a> to implement Kubernetes API behavior.</dd><dt><a href="/docs/concepts/architecture/#cloud-controller-manager">cloud-controller-manager</a> (optional)</dt><dd>Integrates with underlying cloud provider(s).</dd></dl><h3 id="node-components">Node Components</h3><p>Run on every node, maintaining running pods and providing the Kubernetes runtime environment:</p><dl><dt><a href="/docs/concepts/architecture/#kubelet">kubelet</a></dt><dd>Ensures that Pods are running, including their containers.</dd><dt><a href="/docs/concepts/architecture/#kube-proxy">kube-proxy</a> (optional)</dt><dd>Maintains network rules on nodes to implement <a class="glossary-tooltip" title="A way to expose an application running on a set of Pods as a network service." data-toggle="tooltip" data-placement="top" href="/docs/concepts/services-networking/service/" target="_blank" aria-label="Services">Services</a>.</dd><dt><a href="/docs/concepts/architecture/#container-runtime">Container runtime</a></dt><dd>Software responsible for running containers. Read
<a href="/docs/setup/production-environment/container-runtimes/">Container Runtimes</a> to learn more.</dd></dl><div class="alert alert-secondary callout third-party-content" role="alert">ðŸ›‡ This item links to a third party project or product that is not part of Kubernetes itself. <a class="alert-more-info" href="#third-party-content-disclaimer">More information</a></div><p>Your cluster may require additional software on each node; for example, you might also
run <a href="https://systemd.io/">systemd</a> on a Linux node to supervise local components.</p><h2 id="addons">Addons</h2><p>Addons extend the functionality of Kubernetes. A few important examples include:</p><dl><dt><a href="/docs/concepts/architecture/#dns">DNS</a></dt><dd>For cluster-wide DNS resolution.</dd><dt><a href="/docs/concepts/architecture/#web-ui-dashboard">Web UI</a> (Dashboard)</dt><dd>For cluster management via a web interface.</dd><dt><a href="/docs/concepts/architecture/#container-resource-monitoring">Container Resource Monitoring</a></dt><dd>For collecting and storing container metrics.</dd><dt><a href="/docs/concepts/architecture/#cluster-level-logging">Cluster-level Logging</a></dt><dd>For saving container logs to a central log store.</dd></dl><h2 id="flexibility-in-architecture">Flexibility in Architecture</h2><p>Kubernetes allows for flexibility in how these components are deployed and managed.
The architecture can be adapted to various needs, from small development environments
to large-scale production deployments.</p><p>For more detailed information about each component and various ways to configure your
cluster architecture, see the <a href="/docs/concepts/architecture/">Cluster Architecture</a> page.</p></div>
<hr>
<div class="td-content"><h1 data-pagefind-weight="10">Annotations</h1><p>You can use Kubernetes annotations to attach arbitrary non-identifying metadata
to <a class="glossary-tooltip" title="An entity in the Kubernetes system, representing part of the state of your cluster." data-toggle="tooltip" data-placement="top" href="/docs/concepts/overview/working-with-objects/#kubernetes-objects" target="_blank" aria-label="objects">objects</a>.
Clients such as tools and libraries can retrieve this metadata.</p><h2 id="attaching-metadata-to-objects">Attaching metadata to objects</h2><p>You can use either labels or annotations to attach metadata to Kubernetes
objects. Labels can be used to select objects and to find
collections of objects that satisfy certain conditions. In contrast, annotations
are not used to identify and select objects. The metadata
in an annotation can be small or large, structured or unstructured, and can
include characters not permitted by labels. It is possible to use labels as
well as annotations in the metadata of the same object.</p><p>Annotations, like labels, are key/value maps:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json"><span style="display:flex"><span><span style="color:#b44">"metadata"</span><span>:</span> {
</span></span><span style="display:flex"><span>  <span style="color:green;font-weight:700">"annotations"</span>: {
</span></span><span style="display:flex"><span>    <span style="color:green;font-weight:700">"key1"</span> : <span style="color:#b44">"value1"</span>,
</span></span><span style="display:flex"><span>    <span style="color:green;font-weight:700">"key2"</span> : <span style="color:#b44">"value2"</span>
</span></span><span style="display:flex"><span>  }
</span></span><span style="display:flex"><span>}
</span></span></code></pre></div><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>The keys and the values in the map must be strings. In other words, you cannot use
numeric, boolean, list or other types for either the keys or the values.</div><p>Here are some examples of information that could be recorded in annotations:</p><ul><li><p>Fields managed by a declarative configuration layer. Attaching these fields
as annotations distinguishes them from default values set by clients or
servers, and from auto-generated fields and fields set by
auto-sizing or auto-scaling systems.</p></li><li><p>Build, release, or image information like timestamps, release IDs, git branch,
PR numbers, image hashes, and registry address.</p></li><li><p>Pointers to logging, monitoring, analytics, or audit repositories.</p></li><li><p>Client library or tool information that can be used for debugging purposes:
for example, name, version, and build information.</p></li><li><p>User or tool/system provenance information, such as URLs of related objects
from other ecosystem components.</p></li><li><p>Lightweight rollout tool metadata: for example, config or checkpoints.</p></li><li><p>Phone or pager numbers of persons responsible, or directory entries that
specify where that information can be found, such as a team web site.</p></li><li><p>Directives from the end-user to the implementations to modify behavior or
engage non-standard features.</p></li></ul><p>Instead of using annotations, you could store this type of information in an
external database or directory, but that would make it much harder to produce
shared client libraries and tools for deployment, management, introspection,
and the like.</p><h2 id="syntax-and-character-set">Syntax and character set</h2><p><em>Annotations</em> are key/value pairs. Valid annotation keys have two segments: an optional prefix and name, separated by a slash (<code>/</code>). The name segment is required and must be 63 characters or less, beginning and ending with an alphanumeric character (<code>[a-z0-9A-Z]</code>) with dashes (<code>-</code>), underscores (<code>_</code>), dots (<code>.</code>), and alphanumerics between. The prefix is optional. If specified, the prefix must be a DNS subdomain: a series of DNS labels separated by dots (<code>.</code>), not longer than 253 characters in total, followed by a slash (<code>/</code>).</p><p>If the prefix is omitted, the annotation Key is presumed to be private to the user. Automated system components (e.g. <code>kube-scheduler</code>, <code>kube-controller-manager</code>, <code>kube-apiserver</code>, <code>kubectl</code>, or other third-party automation) which add annotations to end-user objects must specify a prefix.</p><p>The <code>kubernetes.io/</code> and <code>k8s.io/</code> prefixes are reserved for Kubernetes core components.</p><p>For example, here's a manifest for a Pod that has the annotation <code>imageregistry: https://hub.docker.com/</code> :</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>Pod<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">metadata</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>annotations-demo<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">annotations</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">imageregistry</span>:<span style="color:#bbb"> </span><span style="color:#b44">"https://hub.docker.com/"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">spec</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">containers</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">image</span>:<span style="color:#bbb"> </span>nginx:1.14.2<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">ports</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span>- <span style="color:green;font-weight:700">containerPort</span>:<span style="color:#bbb"> </span><span style="color:#666">80</span><span style="color:#bbb">
</span></span></span></code></pre></div><h2 id="what-s-next">What's next</h2><ul><li>Learn more about <a href="/docs/concepts/overview/working-with-objects/labels/">Labels and Selectors</a>.</li><li>Find <a href="/docs/reference/labels-annotations-taints/">Well-known labels, Annotations and Taints</a></li></ul></div>
<hr>
<div class="td-content"><h1 data-pagefind-weight="10">Recommended Labels</h1><p>You can visualize and manage Kubernetes objects with more tools than kubectl and
the dashboard. A common set of labels allows tools to work interoperably, describing
objects in a common manner that all tools can understand.</p><p>In addition to supporting tooling, the recommended labels describe applications
in a way that can be queried.</p><p>The metadata is organized around the concept of an <em>application</em>. Kubernetes is not
a platform as a service (PaaS) and doesn't have or enforce a formal notion of an application.
Instead, applications are informal and described with metadata. The definition of
what an application contains is loose.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>These are recommended labels. They make it easier to manage applications
but aren't required for any core tooling.</div><p>Shared labels and annotations share a common prefix: <code>app.kubernetes.io</code>. Labels
without a prefix are private to users. The shared prefix ensures that shared labels
do not interfere with custom user labels.</p><h2 id="labels">Labels</h2><p>In order to take full advantage of using these labels, they should be applied
on every resource object.</p><table><thead><tr><th>Key</th><th>Description</th><th>Example</th><th>Type</th></tr></thead><tbody><tr><td><code>app.kubernetes.io/name</code></td><td>The name of the application</td><td><code>mysql</code></td><td>string</td></tr><tr><td><code>app.kubernetes.io/instance</code></td><td>A unique name identifying the instance of an application</td><td><code>mysql-abcxyz</code></td><td>string</td></tr><tr><td><code>app.kubernetes.io/version</code></td><td>The current version of the application (e.g., a <a href="https://semver.org/spec/v1.0.0.html">SemVer 1.0</a>, revision hash, etc.)</td><td><code>5.7.21</code></td><td>string</td></tr><tr><td><code>app.kubernetes.io/component</code></td><td>The component within the architecture</td><td><code>database</code></td><td>string</td></tr><tr><td><code>app.kubernetes.io/part-of</code></td><td>The name of a higher level application this one is part of</td><td><code>wordpress</code></td><td>string</td></tr><tr><td><code>app.kubernetes.io/managed-by</code></td><td>The tool being used to manage the operation of an application</td><td><code>Helm</code></td><td>string</td></tr></tbody></table><p>To illustrate these labels in action, consider the following <a class="glossary-tooltip" title="A StatefulSet manages deployment and scaling of a set of Pods, with durable storage and persistent identifiers for each Pod." data-toggle="tooltip" data-placement="top" href="/docs/concepts/workloads/controllers/statefulset/" target="_blank" aria-label="StatefulSet">StatefulSet</a> object:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:#080;font-style:italic"># This is an excerpt</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>apps/v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>StatefulSet<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">metadata</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">labels</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">app.kubernetes.io/name</span>:<span style="color:#bbb"> </span>mysql<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">app.kubernetes.io/instance</span>:<span style="color:#bbb"> </span>mysql-abcxyz<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">app.kubernetes.io/version</span>:<span style="color:#bbb"> </span><span style="color:#b44">"5.7.21"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">app.kubernetes.io/component</span>:<span style="color:#bbb"> </span>database<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">app.kubernetes.io/part-of</span>:<span style="color:#bbb"> </span>wordpress<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">app.kubernetes.io/managed-by</span>:<span style="color:#bbb"> </span>Helm<span style="color:#bbb">
</span></span></span></code></pre></div><h2 id="applications-and-instances-of-applications">Applications And Instances Of Applications</h2><p>An application can be installed one or more times into a Kubernetes cluster and,
in some cases, the same namespace. For example, WordPress can be installed more
than once where different websites are different installations of WordPress.</p><p>The name of an application and the instance name are recorded separately. For
example, WordPress has a <code>app.kubernetes.io/name</code> of <code>wordpress</code> while it has
an instance name, represented as <code>app.kubernetes.io/instance</code> with a value of
<code>wordpress-abcxyz</code>. This enables the application and instance of the application
to be identifiable. Every instance of an application must have a unique name.</p><h2 id="examples">Examples</h2><p>To illustrate different ways to use these labels the following examples have varying complexity.</p><h3 id="a-simple-stateless-service">A Simple Stateless Service</h3><p>Consider the case for a simple stateless service deployed using <code>Deployment</code> and <code>Service</code> objects. The following two snippets represent how the labels could be used in their simplest form.</p><p>The <code>Deployment</code> is used to oversee the pods running the application itself.</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>apps/v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>Deployment<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">metadata</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">labels</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">app.kubernetes.io/name</span>:<span style="color:#bbb"> </span>myservice<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">app.kubernetes.io/instance</span>:<span style="color:#bbb"> </span>myservice-abcxyz<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:#00f;font-weight:700">...</span><span style="color:#bbb">
</span></span></span></code></pre></div><p>The <code>Service</code> is used to expose the application.</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>Service<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">metadata</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">labels</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">app.kubernetes.io/name</span>:<span style="color:#bbb"> </span>myservice<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">app.kubernetes.io/instance</span>:<span style="color:#bbb"> </span>myservice-abcxyz<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:#00f;font-weight:700">...</span><span style="color:#bbb">
</span></span></span></code></pre></div><h3 id="web-application-with-a-database">Web Application With A Database</h3><p>Consider a slightly more complicated application: a web application (WordPress)
using a database (MySQL), installed using Helm. The following snippets illustrate
the start of objects used to deploy this application.</p><p>The start to the following <code>Deployment</code> is used for WordPress:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>apps/v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>Deployment<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">metadata</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">labels</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">app.kubernetes.io/name</span>:<span style="color:#bbb"> </span>wordpress<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">app.kubernetes.io/instance</span>:<span style="color:#bbb"> </span>wordpress-abcxyz<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">app.kubernetes.io/version</span>:<span style="color:#bbb"> </span><span style="color:#b44">"4.9.4"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">app.kubernetes.io/managed-by</span>:<span style="color:#bbb"> </span>Helm<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">app.kubernetes.io/component</span>:<span style="color:#bbb"> </span>server<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">app.kubernetes.io/part-of</span>:<span style="color:#bbb"> </span>wordpress<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:#00f;font-weight:700">...</span><span style="color:#bbb">
</span></span></span></code></pre></div><p>The <code>Service</code> is used to expose WordPress:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>Service<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">metadata</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">labels</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">app.kubernetes.io/name</span>:<span style="color:#bbb"> </span>wordpress<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">app.kubernetes.io/instance</span>:<span style="color:#bbb"> </span>wordpress-abcxyz<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">app.kubernetes.io/version</span>:<span style="color:#bbb"> </span><span style="color:#b44">"4.9.4"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">app.kubernetes.io/managed-by</span>:<span style="color:#bbb"> </span>Helm<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">app.kubernetes.io/component</span>:<span style="color:#bbb"> </span>server<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">app.kubernetes.io/part-of</span>:<span style="color:#bbb"> </span>wordpress<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:#00f;font-weight:700">...</span><span style="color:#bbb">
</span></span></span></code></pre></div><p>MySQL is exposed as a <code>StatefulSet</code> with metadata for both it and the larger application it belongs to:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>apps/v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>StatefulSet<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">metadata</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">labels</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">app.kubernetes.io/name</span>:<span style="color:#bbb"> </span>mysql<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">app.kubernetes.io/instance</span>:<span style="color:#bbb"> </span>mysql-abcxyz<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">app.kubernetes.io/version</span>:<span style="color:#bbb"> </span><span style="color:#b44">"5.7.21"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">app.kubernetes.io/managed-by</span>:<span style="color:#bbb"> </span>Helm<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">app.kubernetes.io/component</span>:<span style="color:#bbb"> </span>database<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">app.kubernetes.io/part-of</span>:<span style="color:#bbb"> </span>wordpress<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:#00f;font-weight:700">...</span><span style="color:#bbb">
</span></span></span></code></pre></div><p>The <code>Service</code> is used to expose MySQL as part of WordPress:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>Service<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">metadata</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">labels</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">app.kubernetes.io/name</span>:<span style="color:#bbb"> </span>mysql<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">app.kubernetes.io/instance</span>:<span style="color:#bbb"> </span>mysql-abcxyz<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">app.kubernetes.io/version</span>:<span style="color:#bbb"> </span><span style="color:#b44">"5.7.21"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">app.kubernetes.io/managed-by</span>:<span style="color:#bbb"> </span>Helm<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">app.kubernetes.io/component</span>:<span style="color:#bbb"> </span>database<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">app.kubernetes.io/part-of</span>:<span style="color:#bbb"> </span>wordpress<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:#00f;font-weight:700">...</span><span style="color:#bbb">
</span></span></span></code></pre></div><p>With the MySQL <code>StatefulSet</code> and <code>Service</code> you'll notice information about both MySQL and WordPress, the broader application, are included.</p></div>
<hr>
<div class="td-content"><h1 data-pagefind-weight="10">Finalizers</h1><p>Finalizers are namespaced keys that tell Kubernetes to wait until specific
conditions are met before it fully deletes <a class="glossary-tooltip" title="A Kubernetes entity, representing an endpoint on the Kubernetes API server." data-toggle="tooltip" data-placement="top" href="/docs/reference/using-api/api-concepts/#standard-api-terminology" target="_blank" aria-label="resources">resources</a>
that are marked for deletion.
Finalizers alert <a class="glossary-tooltip" title="A control loop that watches the shared state of the cluster through the apiserver and makes changes attempting to move the current state towards the desired state." data-toggle="tooltip" data-placement="top" href="/docs/concepts/architecture/controller/" target="_blank" aria-label="controllers">controllers</a>
to clean up resources the deleted object owned.</p><p>When you tell Kubernetes to delete an object that has finalizers specified for
it, the Kubernetes API marks the object for deletion by populating <code>.metadata.deletionTimestamp</code>,
and returns a <code>202</code> status code (HTTP "Accepted"). The target object remains in a terminating state while the
control plane, or other components, take the actions defined by the finalizers.
After these actions are complete, the controller removes the relevant finalizers
from the target object. When the <code>metadata.finalizers</code> field is empty,
Kubernetes considers the deletion complete and deletes the object.</p><p>You can use finalizers to control <a class="glossary-tooltip" title="A collective term for the various mechanisms Kubernetes uses to clean up cluster resources." data-toggle="tooltip" data-placement="top" href="/docs/concepts/architecture/garbage-collection/" target="_blank" aria-label="garbage collection">garbage collection</a>
of resources. For example, you can define a finalizer to clean up related
<a class="glossary-tooltip" title="A Kubernetes entity, representing an endpoint on the Kubernetes API server." data-toggle="tooltip" data-placement="top" href="/docs/reference/using-api/api-concepts/#standard-api-terminology" target="_blank" aria-label="API resources">API resources</a> or infrastructure before the controller
deletes the object being finalized.</p><p>You can use finalizers to control <a class="glossary-tooltip" title="A collective term for the various mechanisms Kubernetes uses to clean up cluster resources." data-toggle="tooltip" data-placement="top" href="/docs/concepts/architecture/garbage-collection/" target="_blank" aria-label="garbage collection">garbage collection</a>
of <a class="glossary-tooltip" title="An entity in the Kubernetes system, representing part of the state of your cluster." data-toggle="tooltip" data-placement="top" href="/docs/concepts/overview/working-with-objects/#kubernetes-objects" target="_blank" aria-label="objects">objects</a> by alerting <a class="glossary-tooltip" title="A control loop that watches the shared state of the cluster through the apiserver and makes changes attempting to move the current state towards the desired state." data-toggle="tooltip" data-placement="top" href="/docs/concepts/architecture/controller/" target="_blank" aria-label="controllers">controllers</a>
to perform specific cleanup tasks before deleting the target resource.</p><p>Finalizers don't usually specify the code to execute. Instead, they are
typically lists of keys on a specific resource similar to annotations.
Kubernetes specifies some finalizers automatically, but you can also specify
your own.</p><h2 id="how-finalizers-work">How finalizers work</h2><p>When you create a resource using a manifest file, you can specify finalizers in
the <code>metadata.finalizers</code> field. When you attempt to delete the resource, the
API server handling the delete request notices the values in the <code>finalizers</code> field
and does the following:</p><ul><li>Modifies the object to add a <code>metadata.deletionTimestamp</code> field with the
time you started the deletion.</li><li>Prevents the object from being removed until all items are removed from its <code>metadata.finalizers</code> field</li><li>Returns a <code>202</code> status code (HTTP "Accepted")</li></ul><p>The controller managing that finalizer notices the update to the object setting the
<code>metadata.deletionTimestamp</code>, indicating deletion of the object has been requested.
The controller then attempts to satisfy the requirements of the finalizers
specified for that resource. Each time a finalizer condition is satisfied, the
controller removes that key from the resource's <code>finalizers</code> field. When the
<code>finalizers</code> field is emptied, an object with a <code>deletionTimestamp</code> field set
is automatically deleted. You can also use finalizers to prevent deletion of unmanaged resources.</p><p>A common example of a finalizer is <code>kubernetes.io/pv-protection</code>, which prevents
accidental deletion of <code>PersistentVolume</code> objects. When a <code>PersistentVolume</code>
object is in use by a Pod, Kubernetes adds the <code>pv-protection</code> finalizer. If you
try to delete the <code>PersistentVolume</code>, it enters a <code>Terminating</code> status, but the
controller can't delete it because the finalizer exists. When the Pod stops
using the <code>PersistentVolume</code>, Kubernetes clears the <code>pv-protection</code> finalizer,
and the controller deletes the volume.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4><ul><li><p>When you <code>DELETE</code> an object, Kubernetes adds the deletion timestamp for that object and then
immediately starts to restrict changes to the <code>.metadata.finalizers</code> field for the object that is
now pending deletion. You can remove existing finalizers (deleting an entry from the <code>finalizers</code>
list) but you cannot add a new finalizer. You also cannot modify the <code>deletionTimestamp</code> for an
object once it is set.</p></li><li><p>After the deletion is requested, you can not resurrect this object. The only way is to delete it and make a new similar object.</p></li></ul></div><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>Custom finalizer names <strong>must</strong> be publicly qualified finalizer names, such as <code>example.com/finalizer-name</code>.
Kubernetes enforces this format; the API server rejects writes to objects where the change does not use qualified finalizer names for any custom finalizer.</div><h2 id="owners-labels-finalizers">Owner references, labels, and finalizers</h2><p>Like <a class="glossary-tooltip" title="Tags objects with identifying attributes that are meaningful and relevant to users." data-toggle="tooltip" data-placement="top" href="/docs/concepts/overview/working-with-objects/labels" target="_blank" aria-label="labels">labels</a>,
<a href="/docs/concepts/overview/working-with-objects/owners-dependents/">owner references</a>
describe the relationships between objects in Kubernetes, but are used for a
different purpose. When a
<a class="glossary-tooltip" title="A control loop that watches the shared state of the cluster through the apiserver and makes changes attempting to move the current state towards the desired state." data-toggle="tooltip" data-placement="top" href="/docs/concepts/architecture/controller/" target="_blank" aria-label="controller">controller</a> manages objects
like Pods, it uses labels to track changes to groups of related objects. For
example, when a <a class="glossary-tooltip" title="A finite or batch task that runs to completion." data-toggle="tooltip" data-placement="top" href="/docs/concepts/workloads/controllers/job/" target="_blank" aria-label="Job">Job</a> creates one or
more Pods, the Job controller applies labels to those pods and tracks changes to
any Pods in the cluster with the same label.</p><p>The Job controller also adds <em>owner references</em> to those Pods, pointing at the
Job that created the Pods. If you delete the Job while these Pods are running,
Kubernetes uses the owner references (not labels) to determine which Pods in the
cluster need cleanup.</p><p>Kubernetes also processes finalizers when it identifies owner references on a
resource targeted for deletion.</p><p>In some situations, finalizers can block the deletion of dependent objects,
which can cause the targeted owner object to remain for
longer than expected without being fully deleted. In these situations, you
should check finalizers and owner references on the target owner and dependent
objects to troubleshoot the cause.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>In cases where objects are stuck in a deleting state, avoid manually
removing finalizers to allow deletion to continue. Finalizers are usually added
to resources for a reason, so forcefully removing them can lead to issues in
your cluster. This should only be done when the purpose of the finalizer is
understood and is accomplished in another way (for example, manually cleaning
up some dependent object).</div><h2 id="what-s-next">What's next</h2><ul><li>Read <a href="/blog/2021/05/14/using-finalizers-to-control-deletion/">Using Finalizers to Control Deletion</a>
on the Kubernetes blog.</li></ul></div>
<hr>
<div class="td-content"><h1 data-pagefind-weight="10">Field Selectors</h1><p><em>Field selectors</em> let you select Kubernetes <a class="glossary-tooltip" title="An entity in the Kubernetes system, representing part of the state of your cluster." data-toggle="tooltip" data-placement="top" href="/docs/concepts/overview/working-with-objects/#kubernetes-objects" target="_blank" aria-label="objects">objects</a> based on the
value of one or more resource fields. Here are some examples of field selector queries:</p><ul><li><code>metadata.name=my-service</code></li><li><code>metadata.namespace!=default</code></li><li><code>status.phase=Pending</code></li></ul><p>This <code>kubectl</code> command selects all Pods for which the value of the <a href="/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase"><code>status.phase</code></a> field is <code>Running</code>:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl get pods --field-selector status.phase<span style="color:#666">=</span>Running
</span></span></code></pre></div><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>Field selectors are essentially resource <em>filters</em>. By default, no selectors/filters are applied, meaning that all resources of the specified type are selected. This makes the <code>kubectl</code> queries <code>kubectl get pods</code> and <code>kubectl get pods --field-selector ""</code> equivalent.</div><h2 id="supported-fields">Supported fields</h2><p>Supported field selectors vary by Kubernetes resource type. All resource types support the <code>metadata.name</code> and <code>metadata.namespace</code> fields. Using unsupported field selectors produces an error. For example:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl get ingress --field-selector foo.bar<span style="color:#666">=</span>baz
</span></span></code></pre></div><pre tabindex="0"><code>Error from server (BadRequest): Unable to find "ingresses" that match label selector "", field selector "foo.bar=baz": "foo.bar" is not a known field selector: only "metadata.name", "metadata.namespace"
</code></pre><h3 id="list-of-supported-fields">List of supported fields</h3><table><thead><tr><th>Kind</th><th>Fields</th></tr></thead><tbody><tr><td>Pod</td><td><code>spec.nodeName</code><br/><code>spec.restartPolicy</code><br/><code>spec.schedulerName</code><br/><code>spec.serviceAccountName</code><br/><code>spec.hostNetwork</code><br/><code>status.phase</code><br/><code>status.podIP</code><br/><code>status.podIPs</code><br/><code>status.nominatedNodeName</code></td></tr><tr><td>Event</td><td><code>involvedObject.kind</code><br/><code>involvedObject.namespace</code><br/><code>involvedObject.name</code><br/><code>involvedObject.uid</code><br/><code>involvedObject.apiVersion</code><br/><code>involvedObject.resourceVersion</code><br/><code>involvedObject.fieldPath</code><br/><code>reason</code><br/><code>reportingComponent</code><br/><code>source</code><br/><code>type</code></td></tr><tr><td>Secret</td><td><code>type</code></td></tr><tr><td>Namespace</td><td><code>status.phase</code></td></tr><tr><td>ReplicaSet</td><td><code>status.replicas</code></td></tr><tr><td>ReplicationController</td><td><code>status.replicas</code></td></tr><tr><td>Job</td><td><code>status.successful</code></td></tr><tr><td>Node</td><td><code>spec.unschedulable</code></td></tr><tr><td>CertificateSigningRequest</td><td><code>spec.signerName</code></td></tr></tbody></table><h3 id="custom-resources-fields">Custom resources fields</h3><p>All custom resource types support the <code>metadata.name</code> and <code>metadata.namespace</code> fields.</p><p>Additionally, the <code>spec.versions[*].selectableFields</code> field of a <a class="glossary-tooltip" title="Custom code that defines a resource to add to your Kubernetes API server without building a complete custom server." data-toggle="tooltip" data-placement="top" href="/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/" target="_blank" aria-label="CustomResourceDefinition">CustomResourceDefinition</a>
declares which other fields in a custom resource may be used in field selectors. See <a href="/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#crd-selectable-fields">selectable fields for custom resources</a>
for more information about how to use field selectors with CustomResourceDefinitions.</p><h2 id="supported-operators">Supported operators</h2><p>You can use the <code>=</code>, <code>==</code>, and <code>!=</code> operators with field selectors (<code>=</code> and <code>==</code> mean the same thing). This <code>kubectl</code> command, for example, selects all Kubernetes Services that aren't in the <code>default</code> namespace:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl get services  --all-namespaces --field-selector metadata.namespace!<span style="color:#666">=</span>default
</span></span></code></pre></div><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4><a href="/docs/concepts/overview/working-with-objects/labels/#set-based-requirement">Set-based operators</a>
(<code>in</code>, <code>notin</code>, <code>exists</code>) are not supported for field selectors.</div><h2 id="chained-selectors">Chained selectors</h2><p>As with <a href="/docs/concepts/overview/working-with-objects/labels/">label</a> and other selectors, field selectors can be chained together as a comma-separated list. This <code>kubectl</code> command selects all Pods for which the <code>status.phase</code> does not equal <code>Running</code> and the <code>spec.restartPolicy</code> field equals <code>Always</code>:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl get pods --field-selector<span style="color:#666">=</span>status.phase!<span style="color:#666">=</span>Running,spec.restartPolicy<span style="color:#666">=</span>Always
</span></span></code></pre></div><h2 id="multiple-resource-types">Multiple resource types</h2><p>You can use field selectors across multiple resource types. This <code>kubectl</code> command selects all Statefulsets and Services that are not in the <code>default</code> namespace:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl get statefulsets,services --all-namespaces --field-selector metadata.namespace!<span style="color:#666">=</span>default
</span></span></code></pre></div></div>
<hr>
<div class="td-content"><h1 data-pagefind-weight="10">Labels and Selectors</h1><p><em>Labels</em> are key/value pairs that are attached to
<a class="glossary-tooltip" title="An entity in the Kubernetes system, representing part of the state of your cluster." data-toggle="tooltip" data-placement="top" href="/docs/concepts/overview/working-with-objects/#kubernetes-objects" target="_blank" aria-label="objects">objects</a> such as Pods.
Labels are intended to be used to specify identifying attributes of objects
that are meaningful and relevant to users, but do not directly imply semantics
to the core system. Labels can be used to organize and to select subsets of
objects. Labels can be attached to objects at creation time and subsequently
added and modified at any time. Each object can have a set of key/value labels
defined. Each Key must be unique for a given object.</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json"><span style="display:flex"><span><span style="color:#b44">"metadata"</span><span>:</span> {
</span></span><span style="display:flex"><span>  <span style="color:green;font-weight:700">"labels"</span>: {
</span></span><span style="display:flex"><span>    <span style="color:green;font-weight:700">"key1"</span> : <span style="color:#b44">"value1"</span>,
</span></span><span style="display:flex"><span>    <span style="color:green;font-weight:700">"key2"</span> : <span style="color:#b44">"value2"</span>
</span></span><span style="display:flex"><span>  }
</span></span><span style="display:flex"><span>}
</span></span></code></pre></div><p>Labels allow for efficient queries and watches and are ideal for use in UIs
and CLIs. Non-identifying information should be recorded using
<a href="/docs/concepts/overview/working-with-objects/annotations/">annotations</a>.</p><h2 id="motivation">Motivation</h2><p>Labels enable users to map their own organizational structures onto system objects
in a loosely coupled fashion, without requiring clients to store these mappings.</p><p>Service deployments and batch processing pipelines are often multi-dimensional entities
(e.g., multiple partitions or deployments, multiple release tracks, multiple tiers,
multiple micro-services per tier). Management often requires cross-cutting operations,
which breaks encapsulation of strictly hierarchical representations, especially rigid
hierarchies determined by the infrastructure rather than by users.</p><p>Example labels:</p><ul><li><code>"release" : "stable"</code>, <code>"release" : "canary"</code></li><li><code>"environment" : "dev"</code>, <code>"environment" : "qa"</code>, <code>"environment" : "production"</code></li><li><code>"tier" : "frontend"</code>, <code>"tier" : "backend"</code>, <code>"tier" : "cache"</code></li><li><code>"partition" : "customerA"</code>, <code>"partition" : "customerB"</code></li><li><code>"track" : "daily"</code>, <code>"track" : "weekly"</code></li></ul><p>These are examples of
<a href="/docs/concepts/overview/working-with-objects/common-labels/">commonly used labels</a>;
you are free to develop your own conventions.
Keep in mind that label Key must be unique for a given object.</p><h2 id="syntax-and-character-set">Syntax and character set</h2><p><em>Labels</em> are key/value pairs. Valid label keys have two segments: an optional
prefix and name, separated by a slash (<code>/</code>). The name segment is required and
must be 63 characters or less, beginning and ending with an alphanumeric
character (<code>[a-z0-9A-Z]</code>) with dashes (<code>-</code>), underscores (<code>_</code>), dots (<code>.</code>),
and alphanumerics between. The prefix is optional. If specified, the prefix
must be a DNS subdomain: a series of DNS labels separated by dots (<code>.</code>),
not longer than 253 characters in total, followed by a slash (<code>/</code>).</p><p>If the prefix is omitted, the label Key is presumed to be private to the user.
Automated system components (e.g. <code>kube-scheduler</code>, <code>kube-controller-manager</code>,
<code>kube-apiserver</code>, <code>kubectl</code>, or other third-party automation) which add labels
to end-user objects must specify a prefix.</p><p>The <code>kubernetes.io/</code> and <code>k8s.io/</code> prefixes are
<a href="/docs/reference/labels-annotations-taints/">reserved</a> for Kubernetes core components.</p><p>Valid label value:</p><ul><li>must be 63 characters or less (can be empty),</li><li>unless empty, must begin and end with an alphanumeric character (<code>[a-z0-9A-Z]</code>),</li><li>could contain dashes (<code>-</code>), underscores (<code>_</code>), dots (<code>.</code>), and alphanumerics between.</li></ul><p>For example, here's a manifest for a Pod that has two labels
<code>environment: production</code> and <code>app: nginx</code>:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>Pod<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">metadata</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>label-demo<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">labels</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">environment</span>:<span style="color:#bbb"> </span>production<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">app</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">spec</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">containers</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">image</span>:<span style="color:#bbb"> </span>nginx:1.14.2<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">ports</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span>- <span style="color:green;font-weight:700">containerPort</span>:<span style="color:#bbb"> </span><span style="color:#666">80</span><span style="color:#bbb">
</span></span></span></code></pre></div><h2 id="label-selectors">Label selectors</h2><p>Unlike <a href="/docs/concepts/overview/working-with-objects/names/">names and UIDs</a>, labels
do not provide uniqueness. In general, we expect many objects to carry the same label(s).</p><p>Via a <em>label selector</em>, the client/user can identify a set of objects.
The label selector is the core grouping primitive in Kubernetes.</p><p>The API currently supports two types of selectors: <em>equality-based</em> and <em>set-based</em>.
A label selector can be made of multiple <em>requirements</em> which are comma-separated.
In the case of multiple requirements, all must be satisfied so the comma separator
acts as a logical <em>AND</em> (<code>&amp;&amp;</code>) operator.</p><p>The semantics of empty or non-specified selectors are dependent on the context,
and API types that use selectors should document the validity and meaning of
them.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>For some API types, such as ReplicaSets, the label selectors of two instances must
not overlap within a namespace, or the controller can see that as conflicting
instructions and fail to determine how many replicas should be present.</div><div class="alert alert-caution" role="alert"><h4 class="alert-heading">Caution:</h4>For both equality-based and set-based conditions there is no logical <em>OR</em> (<code>||</code>) operator.
Ensure your filter statements are structured accordingly.</div><h3 id="equality-based-requirement"><em>Equality-based</em> requirement</h3><p><em>Equality-</em> or <em>inequality-based</em> requirements allow filtering by label keys and values.
Matching objects must satisfy all of the specified label constraints, though they may
have additional labels as well. Three kinds of operators are admitted <code>=</code>,<code>==</code>,<code>!=</code>.
The first two represent <em>equality</em> (and are synonyms), while the latter represents <em>inequality</em>.
For example:</p><pre tabindex="0"><code>environment = production
tier != frontend
</code></pre><p>The former selects all resources with key equal to <code>environment</code> and value equal to <code>production</code>.
The latter selects all resources with key equal to <code>tier</code> and value distinct from <code>frontend</code>,
and all resources with no labels with the <code>tier</code> key. One could filter for resources in <code>production</code>
excluding <code>frontend</code> using the comma operator: <code>environment=production,tier!=frontend</code></p><p>One usage scenario for equality-based label requirement is for Pods to specify
node selection criteria. For example, the sample Pod below selects nodes where
the <code>accelerator</code> label exists and is set to <code>nvidia-tesla-p100</code>.</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>Pod<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">metadata</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>cuda-test<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">spec</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">containers</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>cuda-test<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">image</span>:<span style="color:#bbb"> </span><span style="color:#b44">"registry.k8s.io/cuda-vector-add:v0.1"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">resources</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">limits</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">          </span><span style="color:green;font-weight:700">nvidia.com/gpu</span>:<span style="color:#bbb"> </span><span style="color:#666">1</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">nodeSelector</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">accelerator</span>:<span style="color:#bbb"> </span>nvidia-tesla-p100<span style="color:#bbb">
</span></span></span></code></pre></div><h3 id="set-based-requirement"><em>Set-based</em> requirement</h3><p><em>Set-based</em> label requirements allow filtering keys according to a set of values.
Three kinds of operators are supported: <code>in</code>,<code>notin</code> and <code>exists</code> (only the key identifier).
For example:</p><pre tabindex="0"><code>environment in (production, qa)
tier notin (frontend, backend)
partition
!partition
</code></pre><ul><li>The first example selects all resources with key equal to <code>environment</code> and value
equal to <code>production</code> or <code>qa</code>.</li><li>The second example selects all resources with key equal to <code>tier</code> and values other
than <code>frontend</code> and <code>backend</code>, and all resources with no labels with the <code>tier</code> key.</li><li>The third example selects all resources including a label with key <code>partition</code>;
no values are checked.</li><li>The fourth example selects all resources without a label with key <code>partition</code>;
no values are checked.</li></ul><p>Similarly the comma separator acts as an <em>AND</em> operator. So filtering resources
with a <code>partition</code> key (no matter the value) and with <code>environment</code> different
than <code>qa</code> can be achieved using <code>partition,environment notin (qa)</code>.
The <em>set-based</em> label selector is a general form of equality since
<code>environment=production</code> is equivalent to <code>environment in (production)</code>;
similarly for <code>!=</code> and <code>notin</code>.</p><p><em>Set-based</em> requirements can be mixed with <em>equality-based</em> requirements.
For example: <code>partition in (customerA, customerB),environment!=qa</code>.</p><h2 id="api">API</h2><h3 id="list-and-watch-filtering">LIST and WATCH filtering</h3><p>For <strong>list</strong> and <strong>watch</strong> operations, you can specify label selectors to filter the sets of objects
returned; you specify the filter using a query parameter.
(To learn in detail about watches in Kubernetes, read
<a href="/docs/reference/using-api/api-concepts/#efficient-detection-of-changes">efficient detection of changes</a>).
Both requirements are permitted
(presented here as they would appear in a URL query string):</p><ul><li><em>equality-based</em> requirements: <code>?labelSelector=environment%3Dproduction,tier%3Dfrontend</code></li><li><em>set-based</em> requirements: <code>?labelSelector=environment+in+%28production%2Cqa%29%2Ctier+in+%28frontend%29</code></li></ul><p>Both label selector styles can be used to list or watch resources via a REST client.
For example, targeting <code>apiserver</code> with <code>kubectl</code> and using <em>equality-based</em> one may write:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl get pods -l <span style="color:#b8860b">environment</span><span style="color:#666">=</span>production,tier<span style="color:#666">=</span>frontend
</span></span></code></pre></div><p>or using <em>set-based</em> requirements:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl get pods -l <span style="color:#b44">'environment in (production),tier in (frontend)'</span>
</span></span></code></pre></div><p>As already mentioned <em>set-based</em> requirements are more expressive.
For instance, they can implement the <em>OR</em> operator on values:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl get pods -l <span style="color:#b44">'environment in (production, qa)'</span>
</span></span></code></pre></div><p>or restricting negative matching via <em>notin</em> operator:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl get pods -l <span style="color:#b44">'environment,environment notin (frontend)'</span>
</span></span></code></pre></div><h3 id="set-references-in-api-objects">Set references in API objects</h3><p>Some Kubernetes objects, such as <a href="/docs/concepts/services-networking/service/"><code>services</code></a>
and <a href="/docs/concepts/workloads/controllers/replicationcontroller/"><code>replicationcontrollers</code></a>,
also use label selectors to specify sets of other resources, such as
<a href="/docs/concepts/workloads/pods/">pods</a>.</p><h4 id="service-and-replicationcontroller">Service and ReplicationController</h4><p>The set of pods that a <code>service</code> targets is defined with a label selector.
Similarly, the population of pods that a <code>replicationcontroller</code> should
manage is also defined with a label selector.</p><p>Label selectors for both objects are defined in <code>json</code> or <code>yaml</code> files using maps,
and only <em>equality-based</em> requirement selectors are supported:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json"><span style="display:flex"><span><span style="color:#b44">"selector"</span><span>:</span> {
</span></span><span style="display:flex"><span>    <span style="color:green;font-weight:700">"component"</span> : <span style="color:#b44">"redis"</span>,
</span></span><span style="display:flex"><span>}
</span></span></code></pre></div><p>or</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">selector</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">component</span>:<span style="color:#bbb"> </span>redis<span style="color:#bbb">
</span></span></span></code></pre></div><p>This selector (respectively in <code>json</code> or <code>yaml</code> format) is equivalent to
<code>component=redis</code> or <code>component in (redis)</code>.</p><h4 id="resources-that-support-set-based-requirements">Resources that support set-based requirements</h4><p>Newer resources, such as <a href="/docs/concepts/workloads/controllers/job/"><code>Job</code></a>,
<a href="/docs/concepts/workloads/controllers/deployment/"><code>Deployment</code></a>,
<a href="/docs/concepts/workloads/controllers/replicaset/"><code>ReplicaSet</code></a>, and
<a href="/docs/concepts/workloads/controllers/daemonset/"><code>DaemonSet</code></a>,
support <em>set-based</em> requirements as well.</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">selector</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">matchLabels</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">component</span>:<span style="color:#bbb"> </span>redis<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">matchExpressions</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span>- {<span style="color:#bbb"> </span><span style="color:green;font-weight:700">key: tier, operator: In, values</span>:<span style="color:#bbb"> </span>[cache] }<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span>- {<span style="color:#bbb"> </span><span style="color:green;font-weight:700">key: environment, operator: NotIn, values</span>:<span style="color:#bbb"> </span>[dev] }<span style="color:#bbb">
</span></span></span></code></pre></div><p><code>matchLabels</code> is a map of <code>{key,value}</code> pairs. A single <code>{key,value}</code> in the
<code>matchLabels</code> map is equivalent to an element of <code>matchExpressions</code>, whose <code>key</code>
field is "key", the <code>operator</code> is "In", and the <code>values</code> array contains only "value".
<code>matchExpressions</code> is a list of pod selector requirements. Valid operators include
In, NotIn, Exists, and DoesNotExist. The values set must be non-empty in the case of
In and NotIn. All of the requirements, from both <code>matchLabels</code> and <code>matchExpressions</code>
are ANDed together -- they must all be satisfied in order to match.</p><h4 id="selecting-sets-of-nodes">Selecting sets of nodes</h4><p>One use case for selecting over labels is to constrain the set of nodes onto which
a pod can schedule. See the documentation on
<a href="/docs/concepts/scheduling-eviction/assign-pod-node/">node selection</a> for more information.</p><h2 id="using-labels-effectively">Using labels effectively</h2><p>You can apply a single label to any resources, but this is not always the
best practice. There are many scenarios where multiple labels should be used to
distinguish resource sets from one another.</p><p>For instance, different applications would use different values for the <code>app</code> label, but a
multi-tier application, such as the <a href="https://github.com/kubernetes/examples/tree/master/web/guestbook/">guestbook example</a>,
would additionally need to distinguish each tier. The frontend could carry the following labels:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">labels</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">app</span>:<span style="color:#bbb"> </span>guestbook<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">tier</span>:<span style="color:#bbb"> </span>frontend<span style="color:#bbb">
</span></span></span></code></pre></div><p>while the Redis master and replica would have different <code>tier</code> labels, and perhaps even an
additional <code>role</code> label:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">labels</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">app</span>:<span style="color:#bbb"> </span>guestbook<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">tier</span>:<span style="color:#bbb"> </span>backend<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">role</span>:<span style="color:#bbb"> </span>master<span style="color:#bbb">
</span></span></span></code></pre></div><p>and</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">labels</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">app</span>:<span style="color:#bbb"> </span>guestbook<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">tier</span>:<span style="color:#bbb"> </span>backend<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">role</span>:<span style="color:#bbb"> </span>replica<span style="color:#bbb">
</span></span></span></code></pre></div><p>The labels allow for slicing and dicing the resources along any dimension specified by a label:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl apply -f examples/guestbook/all-in-one/guestbook-all-in-one.yaml
</span></span><span style="display:flex"><span>kubectl get pods -Lapp -Ltier -Lrole
</span></span></code></pre></div><pre tabindex="0"><code class="language-none" data-lang="none">NAME                           READY  STATUS    RESTARTS   AGE   APP         TIER       ROLE
guestbook-fe-4nlpb             1/1    Running   0          1m    guestbook   frontend   &lt;none&gt;
guestbook-fe-ght6d             1/1    Running   0          1m    guestbook   frontend   &lt;none&gt;
guestbook-fe-jpy62             1/1    Running   0          1m    guestbook   frontend   &lt;none&gt;
guestbook-redis-master-5pg3b   1/1    Running   0          1m    guestbook   backend    master
guestbook-redis-replica-2q2yf  1/1    Running   0          1m    guestbook   backend    replica
guestbook-redis-replica-qgazl  1/1    Running   0          1m    guestbook   backend    replica
my-nginx-divi2                 1/1    Running   0          29m   nginx       &lt;none&gt;     &lt;none&gt;
my-nginx-o0ef1                 1/1    Running   0          29m   nginx       &lt;none&gt;     &lt;none&gt;
</code></pre><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl get pods -lapp<span style="color:#666">=</span>guestbook,role<span style="color:#666">=</span>replica
</span></span></code></pre></div><pre tabindex="0"><code class="language-none" data-lang="none">NAME                           READY  STATUS   RESTARTS  AGE
guestbook-redis-replica-2q2yf  1/1    Running  0         3m
guestbook-redis-replica-qgazl  1/1    Running  0         3m
</code></pre><h2 id="updating-labels">Updating labels</h2><p>Sometimes you may want to relabel existing pods and other resources before creating
new resources. This can be done with <code>kubectl label</code>.
For example, if you want to label all your NGINX Pods as frontend tier, run:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl label pods -l <span style="color:#b8860b">app</span><span style="color:#666">=</span>nginx <span style="color:#b8860b">tier</span><span style="color:#666">=</span>fe
</span></span></code></pre></div><pre tabindex="0"><code class="language-none" data-lang="none">pod/my-nginx-2035384211-j5fhi labeled
pod/my-nginx-2035384211-u2c7e labeled
pod/my-nginx-2035384211-u3t6x labeled
</code></pre><p>This first filters all pods with the label "app=nginx", and then labels them with the "tier=fe".
To see the pods you labeled, run:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl get pods -l <span style="color:#b8860b">app</span><span style="color:#666">=</span>nginx -L tier
</span></span></code></pre></div><pre tabindex="0"><code class="language-none" data-lang="none">NAME                        READY     STATUS    RESTARTS   AGE       TIER
my-nginx-2035384211-j5fhi   1/1       Running   0          23m       fe
my-nginx-2035384211-u2c7e   1/1       Running   0          23m       fe
my-nginx-2035384211-u3t6x   1/1       Running   0          23m       fe
</code></pre><p>This outputs all "app=nginx" pods, with an additional label column of pods' tier
(specified with <code>-L</code> or <code>--label-columns</code>).</p><p>For more information, please see <a href="/docs/reference/generated/kubectl/kubectl-commands/#label">kubectl label</a>.</p><h2 id="what-s-next">What's next</h2><ul><li>Learn how to <a href="/docs/tasks/configure-pod-container/assign-pods-nodes/#add-a-label-to-a-node">add a label to a node</a></li><li>Find <a href="/docs/reference/labels-annotations-taints/">Well-known labels, Annotations and Taints</a></li><li>See <a href="/docs/concepts/overview/working-with-objects/common-labels/">Recommended labels</a></li><li><a href="/docs/tasks/configure-pod-container/enforce-standards-namespace-labels/">Enforce Pod Security Standards with Namespace Labels</a></li><li>Read a blog on <a href="/blog/2021/06/21/writing-a-controller-for-pod-labels/">Writing a Controller for Pod Labels</a></li></ul></div>
<hr>
<div class="td-content"><h1 data-pagefind-weight="10">Overview</h1><div class="lead">Kubernetes is a portable, extensible, open source platform for managing containerized workloads and services, that facilitates both declarative configuration and automation. It has a large, rapidly growing ecosystem. Kubernetes services, support, and tools are widely available.</div><p>This page is an overview of Kubernetes.</p><p>The name Kubernetes originates from Greek, meaning helmsman or pilot. K8s as an abbreviation
results from counting the eight letters between the "K" and the "s". Google open-sourced the
Kubernetes project in 2014. Kubernetes combines
<a href="/blog/2015/04/borg-predecessor-to-kubernetes/">over 15 years of Google's experience</a> running
production workloads at scale with best-of-breed ideas and practices from the community.</p><h2 id="why-you-need-kubernetes-and-what-can-it-do">Why you need Kubernetes and what it can do</h2><p>Containers are a good way to bundle and run your applications. In a production
environment, you need to manage the containers that run the applications and
ensure that there is no downtime. For example, if a container goes down, another
container needs to start. Wouldn't it be easier if this behavior was handled by a system?</p><p>That's how Kubernetes comes to the rescue! Kubernetes provides you with a framework
to run distributed systems resiliently. It takes care of scaling and failover for
your application, provides deployment patterns, and more. For example: Kubernetes
can easily manage a canary deployment for your system.</p><p>Kubernetes provides you with:</p><ul><li><strong>Service discovery and load balancing</strong>
Kubernetes can expose a container using the DNS name or using their own IP address.
If traffic to a container is high, Kubernetes is able to load balance and distribute
the network traffic so that the deployment is stable.</li><li><strong>Storage orchestration</strong>
Kubernetes allows you to automatically mount a storage system of your choice, such as
local storages, public cloud providers, and more.</li><li><strong>Automated rollouts and rollbacks</strong>
You can describe the desired state for your deployed containers using Kubernetes,
and it can change the actual state to the desired state at a controlled rate.
For example, you can automate Kubernetes to create new containers for your
deployment, remove existing containers and adopt all their resources to the new container.</li><li><strong>Automatic bin packing</strong>
You provide Kubernetes with a cluster of nodes that it can use to run containerized tasks.
You tell Kubernetes how much CPU and memory (RAM) each container needs. Kubernetes can fit
containers onto your nodes to make the best use of your resources.</li><li><strong>Self-healing</strong>
Kubernetes restarts containers that fail, replaces containers, kills containers that don't
respond to your user-defined health check, and doesn't advertise them to clients until they
are ready to serve.</li><li><strong>Secret and configuration management</strong>
Kubernetes lets you store and manage sensitive information, such as passwords, OAuth tokens,
and SSH keys. You can deploy and update secrets and application configuration without
rebuilding your container images, and without exposing secrets in your stack configuration.</li><li><strong>Batch execution</strong>
In addition to services, Kubernetes can manage your batch and CI workloads, replacing containers that fail, if desired.</li><li><strong>Horizontal scaling</strong>
Scale your application up and down with a simple command, with a UI, or automatically based on CPU usage.</li><li><strong>IPv4/IPv6 dual-stack</strong>
Allocation of IPv4 and IPv6 addresses to Pods and Services</li><li><strong>Designed for extensibility</strong>
Add features to your Kubernetes cluster without changing upstream source code.</li></ul><h2 id="what-kubernetes-is-not">What Kubernetes is not</h2><p>Kubernetes is not a traditional, all-inclusive PaaS (Platform as a Service) system.
Since Kubernetes operates at the container level rather than at the hardware level,
it provides some generally applicable features common to PaaS offerings, such as
deployment, scaling, load balancing, and lets users integrate their logging, monitoring,
and alerting solutions. However, Kubernetes is not monolithic, and these default solutions
are optional and pluggable. Kubernetes provides the building blocks for building developer
platforms, but preserves user choice and flexibility where it is important.</p><p>Kubernetes:</p><ul><li>Does not limit the types of applications supported. Kubernetes aims to support an
extremely diverse variety of workloads, including stateless, stateful, and data-processing
workloads. If an application can run in a container, it should run great on Kubernetes.</li><li>Does not deploy source code and does not build your application. Continuous Integration,
Delivery, and Deployment (CI/CD) workflows are determined by organization cultures and
preferences as well as technical requirements.</li><li>Does not provide application-level services, such as middleware (for example, message buses),
data-processing frameworks (for example, Spark), databases (for example, MySQL), caches, nor
cluster storage systems (for example, Ceph) as built-in services. Such components can run on
Kubernetes, and/or can be accessed by applications running on Kubernetes through portable
mechanisms, such as the <a href="https://openservicebrokerapi.org/">Open Service Broker</a>.</li><li>Does not dictate logging, monitoring, or alerting solutions. It provides some integrations
as proof of concept, and mechanisms to collect and export metrics.</li><li>Does not provide nor mandate a configuration language/system (for example, Jsonnet). It provides
a declarative API that may be targeted by arbitrary forms of declarative specifications.</li><li>Does not provide nor adopt any comprehensive machine configuration, maintenance, management,
or self-healing systems.</li><li>Additionally, Kubernetes is not a mere orchestration system. In fact, it eliminates the need
for orchestration. The technical definition of orchestration is execution of a defined workflow:
first do A, then B, then C. In contrast, Kubernetes comprises a set of independent, composable
control processes that continuously drive the current state towards the provided desired state.
It shouldn't matter how you get from A to C. Centralized control is also not required. This
results in a system that is easier to use and more powerful, robust, resilient, and extensible.</li></ul><h2 id="going-back-in-time">Historical context for Kubernetes</h2><p>Let's take a look at why Kubernetes is so useful by going back in time.</p><p><img alt="Deployment evolution" src="/images/docs/Container_Evolution.svg"/></p><p><strong>Traditional deployment era:</strong></p><p>Early on, organizations ran applications on physical servers. There was no way to define
resource boundaries for applications in a physical server, and this caused resource
allocation issues. For example, if multiple applications run on a physical server, there
can be instances where one application would take up most of the resources, and as a result,
the other applications would underperform. A solution for this would be to run each application
on a different physical server. But this did not scale as resources were underutilized, and it
was expensive for organizations to maintain many physical servers.</p><p><strong>Virtualized deployment era:</strong></p><p>As a solution, virtualization was introduced. It allows you
to run multiple Virtual Machines (VMs) on a single physical server's CPU. Virtualization
allows applications to be isolated between VMs and provides a level of security as the
information of one application cannot be freely accessed by another application.</p><p>Virtualization allows better utilization of resources in a physical server and allows
better scalability because an application can be added or updated easily, reduces
hardware costs, and much more. With virtualization you can present a set of physical
resources as a cluster of disposable virtual machines.</p><p>Each VM is a full machine running all the components, including its own operating
system, on top of the virtualized hardware.</p><p><strong>Container deployment era:</strong></p><p>Containers are similar to VMs, but they have relaxed
isolation properties to share the Operating System (OS) among the applications.
Therefore, containers are considered lightweight. Similar to a VM, a container
has its own filesystem, share of CPU, memory, process space, and more. As they
are decoupled from the underlying infrastructure, they are portable across clouds
and OS distributions.</p><p>Containers have become popular because they provide extra benefits, such as:</p><ul><li>Agile application creation and deployment: increased ease and efficiency of
container image creation compared to VM image use.</li><li>Continuous development, integration, and deployment: provides for reliable
and frequent container image build and deployment with quick and efficient
rollbacks (due to image immutability).</li><li>Dev and Ops separation of concerns: create application container images at
build/release time rather than deployment time, thereby decoupling
applications from infrastructure.</li><li>Observability: not only surfaces OS-level information and metrics, but also
application health and other signals.</li><li>Environmental consistency across development, testing, and production: runs
the same on a laptop as it does in the cloud.</li><li>Cloud and OS distribution portability: runs on Ubuntu, RHEL, CoreOS, on-premises,
on major public clouds, and anywhere else.</li><li>Application-centric management: raises the level of abstraction from running an
OS on virtual hardware to running an application on an OS using logical resources.</li><li>Loosely coupled, distributed, elastic, liberated micro-services: applications are
broken into smaller, independent pieces and can be deployed and managed dynamically â€“
not a monolithic stack running on one big single-purpose machine.</li><li>Resource isolation: predictable application performance.</li><li>Resource utilization: high efficiency and density.</li></ul><h2 id="what-s-next">What's next</h2><ul><li>Take a look at the <a href="/docs/concepts/overview/components/">Kubernetes Components</a></li><li>Take a look at the <a href="/docs/concepts/overview/kubernetes-api/">The Kubernetes API</a></li><li>Take a look at the <a href="/docs/concepts/architecture/">Cluster Architecture</a></li><li>Ready to <a href="/docs/setup/">Get Started</a>?</li></ul><div class="section-index"/></div>
<hr>
<div class="td-content"><h1 data-pagefind-weight="10">Objects In Kubernetes</h1><div class="lead">Kubernetes objects are persistent entities in the Kubernetes system. Kubernetes uses these entities to represent the state of your cluster. Learn about the Kubernetes object model and how to work with these objects.</div><p>This page explains how Kubernetes objects are represented in the Kubernetes API, and how you can
express them in <code>.yaml</code> format.</p><h2 id="kubernetes-objects">Understanding Kubernetes objects</h2><p><em>Kubernetes objects</em> are persistent entities in the Kubernetes system. Kubernetes uses these
entities to represent the state of your cluster. Specifically, they can describe:</p><ul><li>What containerized applications are running (and on which nodes)</li><li>The resources available to those applications</li><li>The policies around how those applications behave, such as restart policies, upgrades, and fault-tolerance</li></ul><p>A Kubernetes object is a "record of intent"--once you create the object, the Kubernetes system
will constantly work to ensure that the object exists. By creating an object, you're effectively
telling the Kubernetes system what you want your cluster's workload to look like; this is your
cluster's <em>desired state</em>.</p><p>To work with Kubernetes objectsâ€”whether to create, modify, or delete themâ€”you'll need to use the
<a href="/docs/concepts/overview/kubernetes-api/">Kubernetes API</a>. When you use the <code>kubectl</code> command-line
interface, for example, the CLI makes the necessary Kubernetes API calls for you. You can also use
the Kubernetes API directly in your own programs using one of the
<a href="/docs/reference/using-api/client-libraries/">Client Libraries</a>.</p><h3 id="object-spec-and-status">Object spec and status</h3><p>Almost every Kubernetes object includes two nested object fields that govern
the object's configuration: the object <em><code>spec</code></em> and the object <em><code>status</code></em>.
For objects that have a <code>spec</code>, you have to set this when you create the object,
providing a description of the characteristics you want the resource to have:
its <em>desired state</em>.</p><p>The <code>status</code> describes the <em>current state</em> of the object, supplied and updated
by the Kubernetes system and its components. The Kubernetes
<a class="glossary-tooltip" title="The container orchestration layer that exposes the API and interfaces to define, deploy, and manage the lifecycle of containers." data-toggle="tooltip" data-placement="top" href="/docs/reference/glossary/?all=true#term-control-plane" target="_blank" aria-label="control plane">control plane</a> continually
and actively manages every object's actual state to match the desired state you
supplied.</p><p>For example: in Kubernetes, a Deployment is an object that can represent an
application running on your cluster. When you create the Deployment, you
might set the Deployment <code>spec</code> to specify that you want three replicas of
the application to be running. The Kubernetes system reads the Deployment
spec and starts three instances of your desired application--updating
the status to match your spec. If any of those instances should fail
(a status change), the Kubernetes system responds to the difference
between spec and status by making a correction--in this case, starting
a replacement instance.</p><p>For more information on the object spec, status, and metadata, see the
<a href="https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md">Kubernetes API Conventions</a>.</p><h3 id="describing-a-kubernetes-object">Describing a Kubernetes object</h3><p>When you create an object in Kubernetes, you must provide the object spec that describes its
desired state, as well as some basic information about the object (such as a name). When you use
the Kubernetes API to create the object (either directly or via <code>kubectl</code>), that API request must
include that information as JSON in the request body.
Most often, you provide the information to <code>kubectl</code> in a file known as a <em>manifest</em>.
By convention, manifests are YAML (you could also use JSON format).
Tools such as <code>kubectl</code> convert the information from a manifest into JSON or another supported
serialization format when making the API request over HTTP.</p><p>Here's an example manifest that shows the required fields and object spec for a Kubernetes
Deployment:</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/application/deployment.yaml" download="application/deployment.yaml"><code>application/deployment.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" onclick="copyCode(&quot;application-deployment-yaml&quot;)" title="Copy application/deployment.yaml to clipboard"/></div><div class="includecode" id="application-deployment-yaml"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>apps/v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>Deployment<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">metadata</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>nginx-deployment<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">spec</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">selector</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">matchLabels</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">app</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">replicas</span>:<span style="color:#bbb"> </span><span style="color:#666">2</span><span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># tells deployment to run 2 pods matching the template</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">template</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">metadata</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">labels</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">app</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">spec</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">containers</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">image</span>:<span style="color:#bbb"> </span>nginx:1.14.2<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">ports</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span>- <span style="color:green;font-weight:700">containerPort</span>:<span style="color:#bbb"> </span><span style="color:#666">80</span><span style="color:#bbb">
</span></span></span></code></pre></div></div></div><p>One way to create a Deployment using a manifest file like the one above is to use the
<a href="/docs/reference/generated/kubectl/kubectl-commands#apply"><code>kubectl apply</code></a> command
in the <code>kubectl</code> command-line interface, passing the <code>.yaml</code> file as an argument. Here's an example:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl apply -f https://k8s.io/examples/application/deployment.yaml
</span></span></code></pre></div><p>The output is similar to this:</p><pre tabindex="0"><code>deployment.apps/nginx-deployment created
</code></pre><h3 id="required-fields">Required fields</h3><p>In the manifest (YAML or JSON file) for the Kubernetes object you want to create, you'll need to set values for
the following fields:</p><ul><li><code>apiVersion</code> - Which version of the Kubernetes API you're using to create this object</li><li><code>kind</code> - What kind of object you want to create</li><li><code>metadata</code> - Data that helps uniquely identify the object, including a <code>name</code> string, <code>UID</code>, and optional <code>namespace</code></li><li><code>spec</code> - What state you desire for the object</li></ul><p>The precise format of the object <code>spec</code> is different for every Kubernetes object, and contains
nested fields specific to that object. The <a href="/docs/reference/kubernetes-api/">Kubernetes API Reference</a>
can help you find the spec format for all of the objects you can create using Kubernetes.</p><p>For example, see the <a href="/docs/reference/kubernetes-api/workload-resources/pod-v1/#PodSpec"><code>spec</code> field</a>
for the Pod API reference.
For each Pod, the <code>.spec</code> field specifies the pod and its desired state (such as the container image name for
each container within that pod).
Another example of an object specification is the
<a href="/docs/reference/kubernetes-api/workload-resources/stateful-set-v1/#StatefulSetSpec"><code>spec</code> field</a>
for the StatefulSet API. For StatefulSet, the <code>.spec</code> field specifies the StatefulSet and
its desired state.
Within the <code>.spec</code> of a StatefulSet is a <a href="/docs/concepts/workloads/pods/#pod-templates">template</a>
for Pod objects. That template describes Pods that the StatefulSet controller will create in order to
satisfy the StatefulSet specification.
Different kinds of objects can also have different <code>.status</code>; again, the API reference pages
detail the structure of that <code>.status</code> field, and its content for each different type of object.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>See <a href="/docs/concepts/configuration/overview/">Configuration Best Practices</a> for additional
information on writing YAML configuration files.</div><h2 id="server-side-field-validation">Server side field validation</h2><p>Starting with Kubernetes v1.25, the API server offers server side
<a href="/docs/reference/using-api/api-concepts/#field-validation">field validation</a>
that detects unrecognized or duplicate fields in an object. It provides all the functionality
of <code>kubectl --validate</code> on the server side.</p><p>The <code>kubectl</code> tool uses the <code>--validate</code> flag to set the level of field validation. It accepts the
values <code>ignore</code>, <code>warn</code>, and <code>strict</code> while also accepting the values <code>true</code> (equivalent to <code>strict</code>)
and <code>false</code> (equivalent to <code>ignore</code>). The default validation setting for <code>kubectl</code> is <code>--validate=true</code>.</p><dl><dt><code>Strict</code></dt><dd>Strict field validation, errors on validation failure</dd><dt><code>Warn</code></dt><dd>Field validation is performed, but errors are exposed as warnings rather than failing the request</dd><dt><code>Ignore</code></dt><dd>No server side field validation is performed</dd></dl><p>When <code>kubectl</code> cannot connect to an API server that supports field validation it will fall back
to using client-side validation. Kubernetes 1.27 and later versions always offer field validation;
older Kubernetes releases might not. If your cluster is older than v1.27, check the documentation
for your version of Kubernetes.</p><h2 id="what-s-next">What's next</h2><p>If you're new to Kubernetes, read more about the following:</p><ul><li><a href="/docs/concepts/workloads/pods/">Pods</a> which are the most important basic Kubernetes objects.</li><li><a href="/docs/concepts/workloads/controllers/deployment/">Deployment</a> objects.</li><li><a href="/docs/concepts/architecture/controller/">Controllers</a> in Kubernetes.</li><li><a href="/docs/reference/kubectl/">kubectl</a> and <a href="/docs/reference/generated/kubectl/kubectl-commands">kubectl commands</a>.</li></ul><p><a href="/docs/concepts/overview/working-with-objects/object-management/">Kubernetes Object Management</a>
explains how to use <code>kubectl</code> to manage objects.
You might need to <a href="/docs/tasks/tools/#kubectl">install kubectl</a> if you don't already have it available.</p><p>To learn about the Kubernetes API in general, visit:</p><ul><li><a href="/docs/reference/using-api/">Kubernetes API overview</a></li></ul><p>To learn about objects in Kubernetes in more depth, read other pages in this section:</p><div class="section-index"><ul><li><a href="/docs/concepts/overview/working-with-objects/object-management/">Kubernetes Object Management</a></li><li><a href="/docs/concepts/overview/working-with-objects/names/">Object Names and IDs</a></li><li><a href="/docs/concepts/overview/working-with-objects/labels/">Labels and Selectors</a></li><li><a href="/docs/concepts/overview/working-with-objects/namespaces/">Namespaces</a></li><li><a href="/docs/concepts/overview/working-with-objects/annotations/">Annotations</a></li><li><a href="/docs/concepts/overview/working-with-objects/field-selectors/">Field Selectors</a></li><li><a href="/docs/concepts/overview/working-with-objects/finalizers/">Finalizers</a></li><li><a href="/docs/concepts/overview/working-with-objects/owners-dependents/">Owners and Dependents</a></li><li><a href="/docs/concepts/overview/working-with-objects/common-labels/">Recommended Labels</a></li></ul></div></div>
<hr>
<div class="td-content"><h1 data-pagefind-weight="10">Owners and Dependents</h1><p>In Kubernetes, some <a class="glossary-tooltip" title="An entity in the Kubernetes system, representing part of the state of your cluster." data-toggle="tooltip" data-placement="top" href="/docs/concepts/overview/working-with-objects/#kubernetes-objects" target="_blank" aria-label="objects">objects</a> are
<em>owners</em> of other objects. For example, a
<a class="glossary-tooltip" title="ReplicaSet ensures that a specified number of Pod replicas are running at one time" data-toggle="tooltip" data-placement="top" href="/docs/concepts/workloads/controllers/replicaset/" target="_blank" aria-label="ReplicaSet">ReplicaSet</a> is the owner
of a set of Pods. These owned objects are <em>dependents</em> of their owner.</p><p>Ownership is different from the <a href="/docs/concepts/overview/working-with-objects/labels/">labels and selectors</a>
mechanism that some resources also use. For example, consider a Service that
creates <code>EndpointSlice</code> objects. The Service uses <a class="glossary-tooltip" title="Tags objects with identifying attributes that are meaningful and relevant to users." data-toggle="tooltip" data-placement="top" href="/docs/concepts/overview/working-with-objects/labels" target="_blank" aria-label="labels">labels</a> to allow the control plane to
determine which <code>EndpointSlice</code> objects are used for that Service. In addition
to the labels, each <code>EndpointSlice</code> that is managed on behalf of a Service has
an owner reference. Owner references help different parts of Kubernetes avoid
interfering with objects they donâ€™t control.</p><h2 id="owner-references-in-object-specifications">Owner references in object specifications</h2><p>Dependent objects have a <code>metadata.ownerReferences</code> field that references their
owner object. A valid owner reference consists of the object name and a <a class="glossary-tooltip" title="A Kubernetes systems-generated string to uniquely identify objects." data-toggle="tooltip" data-placement="top" href="/docs/concepts/overview/working-with-objects/names" target="_blank" aria-label="UID">UID</a>
within the same <a class="glossary-tooltip" title="An abstraction used by Kubernetes to support isolation of groups of resources within a single cluster." data-toggle="tooltip" data-placement="top" href="/docs/concepts/overview/working-with-objects/namespaces" target="_blank" aria-label="namespace">namespace</a> as the dependent object. Kubernetes sets the value of
this field automatically for objects that are dependents of other objects like
ReplicaSets, DaemonSets, Deployments, Jobs and CronJobs, and ReplicationControllers.
You can also configure these relationships manually by changing the value of
this field. However, you usually don't need to and can allow Kubernetes to
automatically manage the relationships.</p><p>Dependent objects also have an <code>ownerReferences.blockOwnerDeletion</code> field that
takes a boolean value and controls whether specific dependents can block garbage
collection from deleting their owner object. Kubernetes automatically sets this
field to <code>true</code> if a <a class="glossary-tooltip" title="A control loop that watches the shared state of the cluster through the apiserver and makes changes attempting to move the current state towards the desired state." data-toggle="tooltip" data-placement="top" href="/docs/concepts/architecture/controller/" target="_blank" aria-label="controller">controller</a>
(for example, the Deployment controller) sets the value of the
<code>metadata.ownerReferences</code> field. You can also set the value of the
<code>blockOwnerDeletion</code> field manually to control which dependents block garbage
collection.</p><p>A Kubernetes admission controller controls user access to change this field for
dependent resources, based on the delete permissions of the owner. This control
prevents unauthorized users from delaying owner object deletion.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4><p>Cross-namespace owner references are disallowed by design.
Namespaced dependents can specify cluster-scoped or namespaced owners.
A namespaced owner <strong>must</strong> exist in the same namespace as the dependent.
If it does not, the owner reference is treated as absent, and the dependent
is subject to deletion once all owners are verified absent.</p><p>Cluster-scoped dependents can only specify cluster-scoped owners.
In v1.20+, if a cluster-scoped dependent specifies a namespaced kind as an owner,
it is treated as having an unresolvable owner reference, and is not able to be garbage collected.</p><p>In v1.20+, if the garbage collector detects an invalid cross-namespace <code>ownerReference</code>,
or a cluster-scoped dependent with an <code>ownerReference</code> referencing a namespaced kind, a warning Event
with a reason of <code>OwnerRefInvalidNamespace</code> and an <code>involvedObject</code> of the invalid dependent is reported.
You can check for that kind of Event by running
<code>kubectl get events -A --field-selector=reason=OwnerRefInvalidNamespace</code>.</p></div><h2 id="ownership-and-finalizers">Ownership and finalizers</h2><p>When you tell Kubernetes to delete a resource, the API server allows the
managing controller to process any <a href="/docs/concepts/overview/working-with-objects/finalizers/">finalizer rules</a>
for the resource. <a class="glossary-tooltip" title="A namespaced key that tells Kubernetes to wait until specific conditions are met before it fully deletes an object marked for deletion." data-toggle="tooltip" data-placement="top" href="/docs/concepts/overview/working-with-objects/finalizers/" target="_blank" aria-label="Finalizers">Finalizers</a>
prevent accidental deletion of resources your cluster may still need to function
correctly. For example, if you try to delete a <a href="/docs/concepts/storage/persistent-volumes/">PersistentVolume</a> that is still
in use by a Pod, the deletion does not happen immediately because the
<code>PersistentVolume</code> has the <code>kubernetes.io/pv-protection</code> finalizer on it.
Instead, the <a href="/docs/concepts/storage/volumes/">volume</a> remains in the <code>Terminating</code> status until Kubernetes clears
the finalizer, which only happens after the <code>PersistentVolume</code> is no longer
bound to a Pod.</p><p>Kubernetes also adds finalizers to an owner resource when you use either
<a href="/docs/concepts/architecture/garbage-collection/#cascading-deletion">foreground or orphan cascading deletion</a>.
In foreground deletion, it adds the <code>foreground</code> finalizer so that the
controller must delete dependent resources that also have
<code>ownerReferences.blockOwnerDeletion=true</code> before it deletes the owner. If you
specify an orphan deletion policy, Kubernetes adds the <code>orphan</code> finalizer so
that the controller ignores dependent resources after it deletes the owner
object.</p><h2 id="what-s-next">What's next</h2><ul><li>Learn more about <a href="/docs/concepts/overview/working-with-objects/finalizers/">Kubernetes finalizers</a>.</li><li>Learn about <a href="/docs/concepts/architecture/garbage-collection/">garbage collection</a>.</li><li>Read the API reference for <a href="/docs/reference/kubernetes-api/common-definitions/object-meta/#System">object metadata</a>.</li></ul></div>
<hr>
<div class="td-content"><h1 data-pagefind-weight="10">Kubernetes Object Management</h1><p>The <code>kubectl</code> command-line tool supports several different ways to create and manage
Kubernetes <a class="glossary-tooltip" title="An entity in the Kubernetes system, representing part of the state of your cluster." data-toggle="tooltip" data-placement="top" href="/docs/concepts/overview/working-with-objects/#kubernetes-objects" target="_blank" aria-label="objects">objects</a>. This document provides an overview of the different
approaches. Read the <a href="https://kubectl.docs.kubernetes.io">Kubectl book</a> for
details of managing objects by Kubectl.</p><h2 id="management-techniques">Management techniques</h2><div class="alert alert-danger" role="alert"><h4 class="alert-heading">Warning:</h4>A Kubernetes object should be managed using only one technique. Mixing
and matching techniques for the same object results in undefined behavior.</div><table><thead><tr><th>Management technique</th><th>Operates on</th><th>Recommended environment</th><th>Supported writers</th><th>Learning curve</th></tr></thead><tbody><tr><td>Imperative commands</td><td>Live objects</td><td>Development projects</td><td>1+</td><td>Lowest</td></tr><tr><td>Imperative object configuration</td><td>Individual files</td><td>Production projects</td><td>1</td><td>Moderate</td></tr><tr><td>Declarative object configuration</td><td>Directories of files</td><td>Production projects</td><td>1+</td><td>Highest</td></tr></tbody></table><h2 id="imperative-commands">Imperative commands</h2><p>When using imperative commands, a user operates directly on live objects
in a cluster. The user provides operations to
the <code>kubectl</code> command as arguments or flags.</p><p>This is the recommended way to get started or to run a one-off task in
a cluster. Because this technique operates directly on live
objects, it provides no history of previous configurations.</p><h3 id="examples">Examples</h3><p>Run an instance of the nginx container by creating a Deployment object:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="display:flex"><span>kubectl create deployment nginx --image nginx
</span></span></code></pre></div><h3 id="trade-offs">Trade-offs</h3><p>Advantages compared to object configuration:</p><ul><li>Commands are expressed as a single action word.</li><li>Commands require only a single step to make changes to the cluster.</li></ul><p>Disadvantages compared to object configuration:</p><ul><li>Commands do not integrate with change review processes.</li><li>Commands do not provide an audit trail associated with changes.</li><li>Commands do not provide a source of records except for what is live.</li><li>Commands do not provide a template for creating new objects.</li></ul><h2 id="imperative-object-configuration">Imperative object configuration</h2><p>In imperative object configuration, the kubectl command specifies the
operation (create, replace, etc.), optional flags and at least one file
name. The file specified must contain a full definition of the object
in YAML or JSON format.</p><p>See the <a href="/docs/reference/generated/kubernetes-api/v1.34/">API reference</a>
for more details on object definitions.</p><div class="alert alert-danger" role="alert"><h4 class="alert-heading">Warning:</h4>The imperative <code>replace</code> command replaces the existing
spec with the newly provided one, dropping all changes to the object missing from
the configuration file. This approach should not be used with resource
types whose specs are updated independently of the configuration file.
Services of type <code>LoadBalancer</code>, for example, have their <code>externalIPs</code> field updated
independently from the configuration by the cluster.</div><h3 id="examples-1">Examples</h3><p>Create the objects defined in a configuration file:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="display:flex"><span>kubectl create -f nginx.yaml
</span></span></code></pre></div><p>Delete the objects defined in two configuration files:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="display:flex"><span>kubectl delete -f nginx.yaml -f redis.yaml
</span></span></code></pre></div><p>Update the objects defined in a configuration file by overwriting
the live configuration:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="display:flex"><span>kubectl replace -f nginx.yaml
</span></span></code></pre></div><h3 id="trade-offs-1">Trade-offs</h3><p>Advantages compared to imperative commands:</p><ul><li>Object configuration can be stored in a source control system such as Git.</li><li>Object configuration can integrate with processes such as reviewing changes before push and audit trails.</li><li>Object configuration provides a template for creating new objects.</li></ul><p>Disadvantages compared to imperative commands:</p><ul><li>Object configuration requires basic understanding of the object schema.</li><li>Object configuration requires the additional step of writing a YAML file.</li></ul><p>Advantages compared to declarative object configuration:</p><ul><li>Imperative object configuration behavior is simpler and easier to understand.</li><li>As of Kubernetes version 1.5, imperative object configuration is more mature.</li></ul><p>Disadvantages compared to declarative object configuration:</p><ul><li>Imperative object configuration works best on files, not directories.</li><li>Updates to live objects must be reflected in configuration files, or they will be lost during the next replacement.</li></ul><h2 id="declarative-object-configuration">Declarative object configuration</h2><p>When using declarative object configuration, a user operates on object
configuration files stored locally, however the user does not define the
operations to be taken on the files. Create, update, and delete operations
are automatically detected per-object by <code>kubectl</code>. This enables working on
directories, where different operations might be needed for different objects.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>Declarative object configuration retains changes made by other
writers, even if the changes are not merged back to the object configuration file.
This is possible by using the <code>patch</code> API operation to write only
observed differences, instead of using the <code>replace</code>
API operation to replace the entire object configuration.</div><h3 id="examples-2">Examples</h3><p>Process all object configuration files in the <code>configs</code> directory, and create or
patch the live objects. You can first <code>diff</code> to see what changes are going to be
made, and then apply:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="display:flex"><span>kubectl diff -f configs/
</span></span><span style="display:flex"><span>kubectl apply -f configs/
</span></span></code></pre></div><p>Recursively process directories:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="display:flex"><span>kubectl diff -R -f configs/
</span></span><span style="display:flex"><span>kubectl apply -R -f configs/
</span></span></code></pre></div><h3 id="trade-offs-2">Trade-offs</h3><p>Advantages compared to imperative object configuration:</p><ul><li>Changes made directly to live objects are retained, even if they are not merged back into the configuration files.</li><li>Declarative object configuration has better support for operating on directories and automatically detecting operation types (create, patch, delete) per-object.</li></ul><p>Disadvantages compared to imperative object configuration:</p><ul><li>Declarative object configuration is harder to debug and understand results when they are unexpected.</li><li>Partial updates using diffs create complex merge and patch operations.</li></ul><h2 id="what-s-next">What's next</h2><ul><li><a href="/docs/tasks/manage-kubernetes-objects/imperative-command/">Managing Kubernetes Objects Using Imperative Commands</a></li><li><a href="/docs/tasks/manage-kubernetes-objects/imperative-config/">Imperative Management of Kubernetes Objects Using Configuration Files</a></li><li><a href="/docs/tasks/manage-kubernetes-objects/declarative-config/">Declarative Management of Kubernetes Objects Using Configuration Files</a></li><li><a href="/docs/tasks/manage-kubernetes-objects/kustomization/">Declarative Management of Kubernetes Objects Using Kustomize</a></li><li><a href="/docs/reference/generated/kubectl/kubectl-commands/">Kubectl Command Reference</a></li><li><a href="https://kubectl.docs.kubernetes.io">Kubectl Book</a></li><li><a href="/docs/reference/generated/kubernetes-api/v1.34/">Kubernetes API Reference</a></li></ul></div>
<hr>
<div class="td-content"><h1 data-pagefind-weight="10">Object Names and IDs</h1><p>Each <a class="glossary-tooltip" title="An entity in the Kubernetes system, representing part of the state of your cluster." data-toggle="tooltip" data-placement="top" href="/docs/concepts/overview/working-with-objects/#kubernetes-objects" target="_blank" aria-label="object">object</a> in your cluster has a <a href="#names"><em>Name</em></a> that is unique for that type of resource.
Every Kubernetes object also has a <a href="#uids"><em>UID</em></a> that is unique across your whole cluster.</p><p>For example, you can only have one Pod named <code>myapp-1234</code> within the same <a href="/docs/concepts/overview/working-with-objects/namespaces/">namespace</a>, but you can have one Pod and one Deployment that are each named <code>myapp-1234</code>.</p><p>For non-unique user-provided attributes, Kubernetes provides <a href="/docs/concepts/overview/working-with-objects/labels/">labels</a> and <a href="/docs/concepts/overview/working-with-objects/annotations/">annotations</a>.</p><h2 id="names">Names</h2><p>A client-provided string that refers to an object in a <a class="glossary-tooltip" title="A Kubernetes entity, representing an endpoint on the Kubernetes API server." data-toggle="tooltip" data-placement="top" href="/docs/reference/using-api/api-concepts/#standard-api-terminology" target="_blank" aria-label="resource">resource</a>
URL, such as <code>/api/v1/pods/some-name</code>.</p><p>Only one object of a given kind can have a given name at a time. However, if you delete the object, you can make a new object with the same name.</p><p><strong>Names must be unique across all <a href="/docs/concepts/overview/kubernetes-api/#api-groups-and-versioning">API versions</a>
of the same resource. API resources are distinguished by their API group, resource type, namespace
(for namespaced resources), and name. In other words, API version is irrelevant in this context.</strong></p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>In cases when objects represent a physical entity, like a Node representing a physical host, when the host is re-created under the same name without deleting and re-creating the Node, Kubernetes treats the new host as the old one, which may lead to inconsistencies.</div><p>The server may generate a name when <code>generateName</code> is provided instead of <code>name</code> in a resource create request.
When <code>generateName</code> is used, the provided value is used as a name prefix, which server appends a generated suffix
to. Even though the name is generated, it may conflict with existing names resulting in an HTTP 409 response. This
became far less likely to happen in Kubernetes v1.31 and later, since the server will make up to 8 attempts to generate a
unique name before returning an HTTP 409 response.</p><p>Below are four types of commonly used name constraints for resources.</p><h3 id="dns-subdomain-names">DNS Subdomain Names</h3><p>Most resource types require a name that can be used as a DNS subdomain name
as defined in <a href="https://tools.ietf.org/html/rfc1123">RFC 1123</a>.
This means the name must:</p><ul><li>contain no more than 253 characters</li><li>contain only lowercase alphanumeric characters, '-' or '.'</li><li>start with an alphanumeric character</li><li>end with an alphanumeric character</li></ul><h3 id="dns-label-names">RFC 1123 Label Names</h3><p>Some resource types require their names to follow the DNS
label standard as defined in <a href="https://tools.ietf.org/html/rfc1123">RFC 1123</a>.
This means the name must:</p><ul><li>contain at most 63 characters</li><li>contain only lowercase alphanumeric characters or '-'</li><li>start with an alphabetic character</li><li>end with an alphanumeric character</li></ul><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>When the <code>RelaxedServiceNameValidation</code> feature gate is enabled,
Service object names are allowed to start with a digit.</div><h3 id="rfc-1035-label-names">RFC 1035 Label Names</h3><p>Some resource types require their names to follow the DNS
label standard as defined in <a href="https://tools.ietf.org/html/rfc1035">RFC 1035</a>.
This means the name must:</p><ul><li>contain at most 63 characters</li><li>contain only lowercase alphanumeric characters or '-'</li><li>start with an alphabetic character</li><li>end with an alphanumeric character</li></ul><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>While RFC 1123 technically allows labels to start with digits, the current
Kubernetes implementation requires both RFC 1035 and RFC 1123 labels to start
with an alphabetic character. The exception is when the <code>RelaxedServiceNameValidation</code>
feature gate is enabled for Service objects, which allows Service names to start with digits.</div><h3 id="path-segment-names">Path Segment Names</h3><p>Some resource types require their names to be able to be safely encoded as a
path segment. In other words, the name may not be "." or ".." and the name may
not contain "/" or "%".</p><p>Here's an example manifest for a Pod named <code>nginx-demo</code>.</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>Pod<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">metadata</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>nginx-demo<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">spec</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">containers</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">image</span>:<span style="color:#bbb"> </span>nginx:1.14.2<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">ports</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span>- <span style="color:green;font-weight:700">containerPort</span>:<span style="color:#bbb"> </span><span style="color:#666">80</span><span style="color:#bbb">
</span></span></span></code></pre></div><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>Some resource types have additional restrictions on their names.</div><h2 id="uids">UIDs</h2><p>A Kubernetes systems-generated string to uniquely identify objects.</p><p>Every object created over the whole lifetime of a Kubernetes cluster has a distinct UID. It is intended to distinguish between historical occurrences of similar entities.</p><p>Kubernetes UIDs are universally unique identifiers (also known as UUIDs).
UUIDs are standardized as ISO/IEC 9834-8 and as ITU-T X.667.</p><h2 id="what-s-next">What's next</h2><ul><li>Read about <a href="/docs/concepts/overview/working-with-objects/labels/">labels</a> and <a href="/docs/concepts/overview/working-with-objects/annotations/">annotations</a> in Kubernetes.</li><li>See the <a href="https://git.k8s.io/design-proposals-archive/architecture/identifiers.md">Identifiers and Names in Kubernetes</a> design document.</li></ul></div>
<hr>
<div class="td-content"><h1 data-pagefind-weight="10">Namespaces</h1><p>In Kubernetes, <em>namespaces</em> provide a mechanism for isolating groups of resources within a single cluster. Names of resources need to be unique within a namespace, but not across namespaces. Namespace-based scoping is applicable only for namespaced <a class="glossary-tooltip" title="An entity in the Kubernetes system, representing part of the state of your cluster." data-toggle="tooltip" data-placement="top" href="/docs/concepts/overview/working-with-objects/#kubernetes-objects" target="_blank" aria-label="objects">objects</a> <em>(e.g. Deployments, Services, etc.)</em> and not for cluster-wide objects <em>(e.g. StorageClass, Nodes, PersistentVolumes, etc.)</em>.</p><h2 id="when-to-use-multiple-namespaces">When to Use Multiple Namespaces</h2><p>Namespaces are intended for use in environments with many users spread across multiple
teams, or projects. For clusters with a few to tens of users, you should not
need to create or think about namespaces at all. Start using namespaces when you
need the features they provide.</p><p>Namespaces provide a scope for names. Names of resources need to be unique within a namespace,
but not across namespaces. Namespaces cannot be nested inside one another and each Kubernetes
resource can only be in one namespace.</p><p>Namespaces are a way to divide cluster resources between multiple users (via <a href="/docs/concepts/policy/resource-quotas/">resource quota</a>).</p><p>It is not necessary to use multiple namespaces to separate slightly different
resources, such as different versions of the same software: use
<a class="glossary-tooltip" title="Tags objects with identifying attributes that are meaningful and relevant to users." data-toggle="tooltip" data-placement="top" href="/docs/concepts/overview/working-with-objects/labels" target="_blank" aria-label="labels">labels</a> to distinguish
resources within the same namespace.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>For a production cluster, consider <em>not</em> using the <code>default</code> namespace. Instead, make other namespaces and use those.</div><h2 id="initial-namespaces">Initial namespaces</h2><p>Kubernetes starts with four initial namespaces:</p><dl><dt><code>default</code></dt><dd>Kubernetes includes this namespace so that you can start using your new cluster without first creating a namespace.</dd><dt><code>kube-node-lease</code></dt><dd>This namespace holds <a href="/docs/concepts/architecture/leases/">Lease</a> objects associated with each node. Node leases allow the kubelet to send <a href="/docs/concepts/architecture/nodes/#node-heartbeats">heartbeats</a> so that the control plane can detect node failure.</dd><dt><code>kube-public</code></dt><dd>This namespace is readable by <em>all</em> clients (including those not authenticated). This namespace is mostly reserved for cluster usage, in case that some resources should be visible and readable publicly throughout the whole cluster. The public aspect of this namespace is only a convention, not a requirement.</dd><dt><code>kube-system</code></dt><dd>The namespace for objects created by the Kubernetes system.</dd></dl><h2 id="working-with-namespaces">Working with Namespaces</h2><p>Creation and deletion of namespaces are described in the
<a href="/docs/tasks/administer-cluster/namespaces/">Admin Guide documentation for namespaces</a>.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>Avoid creating namespaces with the prefix <code>kube-</code>, since it is reserved for Kubernetes system namespaces.</div><h3 id="viewing-namespaces">Viewing namespaces</h3><p>You can list the current namespaces in a cluster using:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl get namespace
</span></span></code></pre></div><pre tabindex="0"><code>NAME              STATUS   AGE
default           Active   1d
kube-node-lease   Active   1d
kube-public       Active   1d
kube-system       Active   1d
</code></pre><h3 id="setting-the-namespace-for-a-request">Setting the namespace for a request</h3><p>To set the namespace for a current request, use the <code>--namespace</code> flag.</p><p>For example:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl run nginx --image<span style="color:#666">=</span>nginx --namespace<span style="color:#666">=</span>&lt;insert-namespace-name-here&gt;
</span></span><span style="display:flex"><span>kubectl get pods --namespace<span style="color:#666">=</span>&lt;insert-namespace-name-here&gt;
</span></span></code></pre></div><h3 id="setting-the-namespace-preference">Setting the namespace preference</h3><p>You can permanently save the namespace for all subsequent kubectl commands in that
context.</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl config set-context --current --namespace<span style="color:#666">=</span>&lt;insert-namespace-name-here&gt;
</span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"># Validate it</span>
</span></span><span style="display:flex"><span>kubectl config view --minify | grep namespace:
</span></span></code></pre></div><h2 id="namespaces-and-dns">Namespaces and DNS</h2><p>When you create a <a href="/docs/concepts/services-networking/service/">Service</a>,
it creates a corresponding <a href="/docs/concepts/services-networking/dns-pod-service/">DNS entry</a>.
This entry is of the form <code>&lt;service-name&gt;.&lt;namespace-name&gt;.svc.cluster.local</code>, which means
that if a container only uses <code>&lt;service-name&gt;</code>, it will resolve to the service which
is local to a namespace. This is useful for using the same configuration across
multiple namespaces such as Development, Staging and Production. If you want to reach
across namespaces, you need to use the fully qualified domain name (FQDN).</p><p>As a result, all namespace names must be valid
<a href="/docs/concepts/overview/working-with-objects/names/#dns-label-names">RFC 1123 DNS labels</a>.</p><div class="alert alert-danger" role="alert"><h4 class="alert-heading">Warning:</h4><p>By creating namespaces with the same name as <a href="https://data.iana.org/TLD/tlds-alpha-by-domain.txt">public top-level
domains</a>, Services in these
namespaces can have short DNS names that overlap with public DNS records.
Workloads from any namespace performing a DNS lookup without a <a href="https://datatracker.ietf.org/doc/html/rfc1034#page-8">trailing dot</a> will
be redirected to those services, taking precedence over public DNS.</p><p>To mitigate this, limit privileges for creating namespaces to trusted users. If
required, you could additionally configure third-party security controls, such
as <a href="/docs/reference/access-authn-authz/extensible-admission-controllers/">admission
webhooks</a>,
to block creating any namespace with the name of <a href="https://data.iana.org/TLD/tlds-alpha-by-domain.txt">public
TLDs</a>.</p></div><h2 id="not-all-objects-are-in-a-namespace">Not all objects are in a namespace</h2><p>Most Kubernetes resources (e.g. pods, services, replication controllers, and others) are
in some namespaces. However namespace resources are not themselves in a namespace.
And low-level resources, such as
<a href="/docs/concepts/architecture/nodes/">nodes</a> and
<a href="/docs/concepts/storage/persistent-volumes/">persistentVolumes</a>, are not in any namespace.</p><p>To see which Kubernetes resources are and aren't in a namespace:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span><span style="color:#080;font-style:italic"># In a namespace</span>
</span></span><span style="display:flex"><span>kubectl api-resources --namespaced<span style="color:#666">=</span><span style="color:#a2f">true</span>
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"># Not in a namespace</span>
</span></span><span style="display:flex"><span>kubectl api-resources --namespaced<span style="color:#666">=</span><span style="color:#a2f">false</span>
</span></span></code></pre></div><h2 id="automatic-labelling">Automatic labelling</h2><div class="feature-state-notice feature-stable"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes 1.22 [stable]</code></div><p>The Kubernetes control plane sets an immutable <a class="glossary-tooltip" title="Tags objects with identifying attributes that are meaningful and relevant to users." data-toggle="tooltip" data-placement="top" href="/docs/concepts/overview/working-with-objects/labels" target="_blank" aria-label="label">label</a>
<code>kubernetes.io/metadata.name</code> on all namespaces.
The value of the label is the namespace name.</p><h2 id="what-s-next">What's next</h2><ul><li>Learn more about <a href="/docs/tasks/administer-cluster/namespaces/#creating-a-new-namespace">creating a new namespace</a>.</li><li>Learn more about <a href="/docs/tasks/administer-cluster/namespaces/#deleting-a-namespace">deleting a namespace</a>.</li></ul></div>