<hr>
<div class="td-content"><h1>Best practices</h1><div class="section-index"><hr class="panel-line"/><div class="entry"><h5><a href="/docs/setup/best-practices/cluster-large/">Considerations for large clusters</a></h5><p/></div><div class="entry"><h5><a href="/docs/setup/best-practices/multiple-zones/">Running in multiple zones</a></h5><p/></div><div class="entry"><h5><a href="/docs/setup/best-practices/node-conformance/">Validate node setup</a></h5><p/></div><div class="entry"><h5><a href="/docs/setup/best-practices/enforcing-pod-security-standards/">Enforcing Pod Security Standards</a></h5><p/></div><div class="entry"><h5><a href="/docs/setup/best-practices/certificates/">PKI certificates and requirements</a></h5><p/></div></div></div>
<hr>
<div class="td-content"><h1 data-pagefind-weight="10">Enforcing Pod Security Standards</h1><p>This page provides an overview of best practices when it comes to enforcing
<a href="/docs/concepts/security/pod-security-standards/">Pod Security Standards</a>.</p><h2 id="using-the-built-in-pod-security-admission-controller">Using the built-in Pod Security Admission Controller</h2><div class="feature-state-notice feature-stable"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.25 [stable]</code></div><p>The <a href="/docs/reference/access-authn-authz/admission-controllers/#podsecurity">Pod Security Admission Controller</a>
intends to replace the deprecated PodSecurityPolicies.</p><h3 id="configure-all-cluster-namespaces">Configure all cluster namespaces</h3><p>Namespaces that lack any configuration at all should be considered significant gaps in your cluster
security model. We recommend taking the time to analyze the types of workloads occurring in each
namespace, and by referencing the Pod Security Standards, decide on an appropriate level for
each of them. Unlabeled namespaces should only indicate that they've yet to be evaluated.</p><p>In the scenario that all workloads in all namespaces have the same security requirements,
we provide an <a href="/docs/tasks/configure-pod-container/enforce-standards-namespace-labels/#applying-to-all-namespaces">example</a>
that illustrates how the PodSecurity labels can be applied in bulk.</p><h3 id="embrace-the-principle-of-least-privilege">Embrace the principle of least privilege</h3><p>In an ideal world, every pod in every namespace would meet the requirements of the <code>restricted</code>
policy. However, this is not possible nor practical, as some workloads will require elevated
privileges for legitimate reasons.</p><ul><li>Namespaces allowing <code>privileged</code> workloads should establish and enforce appropriate access controls.</li><li>For workloads running in those permissive namespaces, maintain documentation about their unique
security requirements. If at all possible, consider how those requirements could be further
constrained.</li></ul><h3 id="adopt-a-multi-mode-strategy">Adopt a multi-mode strategy</h3><p>The <code>audit</code> and <code>warn</code> modes of the Pod Security Standards admission controller make it easy to
collect important security insights about your pods without breaking existing workloads.</p><p>It is good practice to enable these modes for all namespaces, setting them to the <em>desired</em> level
and version you would eventually like to <code>enforce</code>. The warnings and audit annotations generated in
this phase can guide you toward that state. If you expect workload authors to make changes to fit
within the desired level, enable the <code>warn</code> mode. If you expect to use audit logs to monitor/drive
changes to fit within the desired level, enable the <code>audit</code> mode.</p><p>When you have the <code>enforce</code> mode set to your desired value, these modes can still be useful in a
few different ways:</p><ul><li>By setting <code>warn</code> to the same level as <code>enforce</code>, clients will receive warnings when attempting
to create Pods (or resources that have Pod templates) that do not pass validation. This will help
them update those resources to become compliant.</li><li>In Namespaces that pin <code>enforce</code> to a specific non-latest version, setting the <code>audit</code> and <code>warn</code>
modes to the same level as <code>enforce</code>, but to the <code>latest</code> version, gives visibility into settings
that were allowed by previous versions but are not allowed per current best practices.</li></ul><h2 id="third-party-alternatives">Third-party alternatives</h2><div class="alert alert-secondary callout third-party-content" role="alert"><strong>Note:</strong> This section links to third party projects that provide functionality required by Kubernetes. The Kubernetes project authors aren't responsible for these projects, which are listed alphabetically. To add a project to this list, read the <a href="/docs/contribute/style/content-guide/#third-party-content">content guide</a> before submitting a change. <a href="#third-party-content-disclaimer">More information.</a></div><p>Other alternatives for enforcing security profiles are being developed in the Kubernetes
ecosystem:</p><ul><li><a href="https://github.com/kubewarden">Kubewarden</a>.</li><li><a href="https://kyverno.io/policies/">Kyverno</a>.</li><li><a href="https://github.com/open-policy-agent/gatekeeper">OPA Gatekeeper</a>.</li></ul><p>The decision to go with a <em>built-in</em> solution (e.g. PodSecurity admission controller) versus a
third-party tool is entirely dependent on your own situation. When evaluating any solution,
trust of your supply chain is crucial. Ultimately, using <em>any</em> of the aforementioned approaches
will be better than doing nothing.</p></div>
<hr>
<div class="td-content"><h1 data-pagefind-weight="10">Running in multiple zones</h1><p>This page describes running Kubernetes across multiple zones.</p><h2 id="background">Background</h2><p>Kubernetes is designed so that a single Kubernetes cluster can run
across multiple failure zones, typically where these zones fit within
a logical grouping called a <em>region</em>. Major cloud providers define a region
as a set of failure zones (also called <em>availability zones</em>) that provide
a consistent set of features: within a region, each zone offers the same
APIs and services.</p><p>Typical cloud architectures aim to minimize the chance that a failure in
one zone also impairs services in another zone.</p><h2 id="control-plane-behavior">Control plane behavior</h2><p>All <a href="/docs/concepts/architecture/#control-plane-components">control plane components</a>
support running as a pool of interchangeable resources, replicated per
component.</p><p>When you deploy a cluster control plane, place replicas of
control plane components across multiple failure zones. If availability is
an important concern, select at least three failure zones and replicate
each individual control plane component (API server, scheduler, etcd,
cluster controller manager) across at least three failure zones.
If you are running a cloud controller manager then you should
also replicate this across all the failure zones you selected.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>Kubernetes does not provide cross-zone resilience for the API server
endpoints. You can use various techniques to improve availability for
the cluster API server, including DNS round-robin, SRV records, or
a third-party load balancing solution with health checking.</div><h2 id="node-behavior">Node behavior</h2><p>Kubernetes automatically spreads the Pods for
workload resources (such as <a class="glossary-tooltip" title="Manages a replicated application on your cluster." data-toggle="tooltip" data-placement="top" href="/docs/concepts/workloads/controllers/deployment/" target="_blank" aria-label="Deployment">Deployment</a>
or <a class="glossary-tooltip" title="A StatefulSet manages deployment and scaling of a set of Pods, with durable storage and persistent identifiers for each Pod." data-toggle="tooltip" data-placement="top" href="/docs/concepts/workloads/controllers/statefulset/" target="_blank" aria-label="StatefulSet">StatefulSet</a>)
across different nodes in a cluster. This spreading helps
reduce the impact of failures.</p><p>When nodes start up, the kubelet on each node automatically adds
<a class="glossary-tooltip" title="Tags objects with identifying attributes that are meaningful and relevant to users." data-toggle="tooltip" data-placement="top" href="/docs/concepts/overview/working-with-objects/labels" target="_blank" aria-label="labels">labels</a> to the Node object
that represents that specific kubelet in the Kubernetes API.
These labels can include
<a href="/docs/reference/labels-annotations-taints/#topologykubernetesiozone">zone information</a>.</p><p>If your cluster spans multiple zones or regions, you can use node labels
in conjunction with
<a href="/docs/concepts/scheduling-eviction/topology-spread-constraints/">Pod topology spread constraints</a>
to control how Pods are spread across your cluster among fault domains:
regions, zones, and even specific nodes.
These hints enable the
<a class="glossary-tooltip" title="Control plane component that watches for newly created pods with no assigned node, and selects a node for them to run on." data-toggle="tooltip" data-placement="top" href="/docs/reference/command-line-tools-reference/kube-scheduler/" target="_blank" aria-label="scheduler">scheduler</a> to place
Pods for better expected availability, reducing the risk that a correlated
failure affects your whole workload.</p><p>For example, you can set a constraint to make sure that the
3 replicas of a StatefulSet are all running in different zones to each
other, whenever that is feasible. You can define this declaratively
without explicitly defining which availability zones are in use for
each workload.</p><h3 id="distributing-nodes-across-zones">Distributing nodes across zones</h3><p>Kubernetes' core does not create nodes for you; you need to do that yourself,
or use a tool such as the <a href="https://cluster-api.sigs.k8s.io/">Cluster API</a> to
manage nodes on your behalf.</p><p>Using tools such as the Cluster API you can define sets of machines to run as
worker nodes for your cluster across multiple failure domains, and rules to
automatically heal the cluster in case of whole-zone service disruption.</p><h2 id="manual-zone-assignment-for-pods">Manual zone assignment for Pods</h2><p>You can apply <a href="/docs/concepts/scheduling-eviction/assign-pod-node/#nodeselector">node selector constraints</a>
to Pods that you create, as well as to Pod templates in workload resources
such as Deployment, StatefulSet, or Job.</p><h2 id="storage-access-for-zones">Storage access for zones</h2><p>When persistent volumes are created, Kubernetes automatically adds zone labels
to any PersistentVolumes that are linked to a specific zone.
The <a class="glossary-tooltip" title="Control plane component that watches for newly created pods with no assigned node, and selects a node for them to run on." data-toggle="tooltip" data-placement="top" href="/docs/reference/command-line-tools-reference/kube-scheduler/" target="_blank" aria-label="scheduler">scheduler</a> then ensures,
through its <code>NoVolumeZoneConflict</code> predicate, that pods which claim a given PersistentVolume
are only placed into the same zone as that volume.</p><p>Please note that the method of adding zone labels can depend on your
cloud provider and the storage provisioner you’re using. Always refer to the specific
documentation for your environment to ensure correct configuration.</p><p>You can specify a <a class="glossary-tooltip" title="A StorageClass provides a way for administrators to describe different available storage types." data-toggle="tooltip" data-placement="top" href="/docs/concepts/storage/storage-classes" target="_blank" aria-label="StorageClass">StorageClass</a>
for PersistentVolumeClaims that specifies the failure domains (zones) that the
storage in that class may use.
To learn about configuring a StorageClass that is aware of failure domains or zones,
see <a href="/docs/concepts/storage/storage-classes/#allowed-topologies">Allowed topologies</a>.</p><h2 id="networking">Networking</h2><p>By itself, Kubernetes does not include zone-aware networking. You can use a
<a href="/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/">network plugin</a>
to configure cluster networking, and that network solution might have zone-specific
elements. For example, if your cloud provider supports Services with
<code>type=LoadBalancer</code>, the load balancer might only send traffic to Pods running in the
same zone as the load balancer element processing a given connection.
Check your cloud provider's documentation for details.</p><p>For custom or on-premises deployments, similar considerations apply.
<a class="glossary-tooltip" title="A way to expose an application running on a set of Pods as a network service." data-toggle="tooltip" data-placement="top" href="/docs/concepts/services-networking/service/" target="_blank" aria-label="Service">Service</a> and
<a class="glossary-tooltip" title="An API object that manages external access to the services in a cluster, typically HTTP." data-toggle="tooltip" data-placement="top" href="/docs/concepts/services-networking/ingress/" target="_blank" aria-label="Ingress">Ingress</a> behavior, including handling
of different failure zones, does vary depending on exactly how your cluster is set up.</p><h2 id="fault-recovery">Fault recovery</h2><p>When you set up your cluster, you might also need to consider whether and how
your setup can restore service if all the failure zones in a region go
off-line at the same time. For example, do you rely on there being at least
one node able to run Pods in a zone?<br/>Make sure that any cluster-critical repair work does not rely
on there being at least one healthy node in your cluster. For example: if all nodes
are unhealthy, you might need to run a repair Job with a special
<a class="glossary-tooltip" title="A core object consisting of three required properties: key, value, and effect. Tolerations enable the scheduling of pods on nodes or node groups that have a matching taint." data-toggle="tooltip" data-placement="top" href="/docs/concepts/scheduling-eviction/taint-and-toleration/" target="_blank" aria-label="toleration">toleration</a> so that the repair
can complete enough to bring at least one node into service.</p><p>Kubernetes doesn't come with an answer for this challenge; however, it's
something to consider.</p><h2 id="what-s-next">What's next</h2><p>To learn how the scheduler places Pods in a cluster, honoring the configured constraints,
visit <a href="/docs/concepts/scheduling-eviction/">Scheduling and Eviction</a>.</p></div>
<hr>
<div class="td-content"><h1 data-pagefind-weight="10">PKI certificates and requirements</h1><p>Kubernetes requires PKI certificates for authentication over TLS.
If you install Kubernetes with <a href="/docs/reference/setup-tools/kubeadm/">kubeadm</a>, the certificates
that your cluster requires are automatically generated.
You can also generate your own certificates -- for example, to keep your private keys more secure
by not storing them on the API server.
This page explains the certificates that your cluster requires.</p><h2 id="how-certificates-are-used-by-your-cluster">How certificates are used by your cluster</h2><p>Kubernetes requires PKI for the following operations:</p><h3 id="server-certificates">Server certificates</h3><ul><li>Server certificate for the API server endpoint</li><li>Server certificate for the etcd server</li><li><a href="/docs/reference/access-authn-authz/kubelet-tls-bootstrapping/#client-and-serving-certificates">Server certificates</a>
for each kubelet (every <a class="glossary-tooltip" title="A node is a worker machine in Kubernetes." data-toggle="tooltip" data-placement="top" href="/docs/concepts/architecture/nodes/" target="_blank" aria-label="node">node</a> runs a kubelet)</li><li>Optional server certificate for the <a href="/docs/tasks/extend-kubernetes/configure-aggregation-layer/">front-proxy</a></li></ul><h3 id="client-certificates">Client certificates</h3><ul><li>Client certificates for each kubelet, used to authenticate to the API server as a client of
the Kubernetes API</li><li>Client certificate for each API server, used to authenticate to etcd</li><li>Client certificate for the controller manager to securely communicate with the API server</li><li>Client certificate for the scheduler to securely communicate with the API server</li><li>Client certificates, one for each node, for kube-proxy to authenticate to the API server</li><li>Optional client certificates for administrators of the cluster to authenticate to the API server</li><li>Optional client certificate for the <a href="/docs/tasks/extend-kubernetes/configure-aggregation-layer/">front-proxy</a></li></ul><h3 id="kubelet-s-server-and-client-certificates">Kubelet's server and client certificates</h3><p>To establish a secure connection and authenticate itself to the kubelet, the API Server
requires a client certificate and key pair.</p><p>In this scenario, there are two approaches for certificate usage:</p><ul><li><p>Shared Certificates: The kube-apiserver can utilize the same certificate and key pair it uses
to authenticate its clients. This means that the existing certificates, such as <code>apiserver.crt</code>
and <code>apiserver.key</code>, can be used for communicating with the kubelet servers.</p></li><li><p>Separate Certificates: Alternatively, the kube-apiserver can generate a new client certificate
and key pair to authenticate its communication with the kubelet servers. In this case,
a distinct certificate named <code>kubelet-client.crt</code> and its corresponding private key,
<code>kubelet-client.key</code> are created.</p></li></ul><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4><code>front-proxy</code> certificates are required only if you run kube-proxy to support
<a href="/docs/tasks/extend-kubernetes/setup-extension-api-server/">an extension API server</a>.</div><p>etcd also implements mutual TLS to authenticate clients and peers.</p><h2 id="where-certificates-are-stored">Where certificates are stored</h2><p>If you install Kubernetes with kubeadm, most certificates are stored in <code>/etc/kubernetes/pki</code>.
All paths in this documentation are relative to that directory, with the exception of user account
certificates which kubeadm places in <code>/etc/kubernetes</code>.</p><h2 id="configure-certificates-manually">Configure certificates manually</h2><p>If you don't want kubeadm to generate the required certificates, you can create them using a
single root CA or by providing all certificates. See <a href="/docs/tasks/administer-cluster/certificates/">Certificates</a>
for details on creating your own certificate authority. See
<a href="/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/">Certificate Management with kubeadm</a>
for more on managing certificates.</p><h3 id="single-root-ca">Single root CA</h3><p>You can create a single root CA, controlled by an administrator. This root CA can then create
multiple intermediate CAs, and delegate all further creation to Kubernetes itself.</p><p>Required CAs:</p><table><thead><tr><th>Path</th><th>Default CN</th><th>Description</th></tr></thead><tbody><tr><td>ca.crt,key</td><td>kubernetes-ca</td><td>Kubernetes general CA</td></tr><tr><td>etcd/ca.crt,key</td><td>etcd-ca</td><td>For all etcd-related functions</td></tr><tr><td>front-proxy-ca.crt,key</td><td>kubernetes-front-proxy-ca</td><td>For the <a href="/docs/tasks/extend-kubernetes/configure-aggregation-layer/">front-end proxy</a></td></tr></tbody></table><p>On top of the above CAs, it is also necessary to get a public/private key pair for service account
management, <code>sa.key</code> and <code>sa.pub</code>.
The following example illustrates the CA key and certificate files shown in the previous table:</p><pre tabindex="0"><code>/etc/kubernetes/pki/ca.crt
/etc/kubernetes/pki/ca.key
/etc/kubernetes/pki/etcd/ca.crt
/etc/kubernetes/pki/etcd/ca.key
/etc/kubernetes/pki/front-proxy-ca.crt
/etc/kubernetes/pki/front-proxy-ca.key
</code></pre><h3 id="all-certificates">All certificates</h3><p>If you don't wish to copy the CA private keys to your cluster, you can generate all certificates yourself.</p><p>Required certificates:</p><table><thead><tr><th>Default CN</th><th>Parent CA</th><th>O (in Subject)</th><th>kind</th><th>hosts (SAN)</th></tr></thead><tbody><tr><td>kube-etcd</td><td>etcd-ca</td><td/><td>server, client</td><td><code>&lt;hostname&gt;</code>, <code>&lt;Host_IP&gt;</code>, <code>localhost</code>, <code>127.0.0.1</code></td></tr><tr><td>kube-etcd-peer</td><td>etcd-ca</td><td/><td>server, client</td><td><code>&lt;hostname&gt;</code>, <code>&lt;Host_IP&gt;</code>, <code>localhost</code>, <code>127.0.0.1</code></td></tr><tr><td>kube-etcd-healthcheck-client</td><td>etcd-ca</td><td/><td>client</td><td/></tr><tr><td>kube-apiserver-etcd-client</td><td>etcd-ca</td><td/><td>client</td><td/></tr><tr><td>kube-apiserver</td><td>kubernetes-ca</td><td/><td>server</td><td><code>&lt;hostname&gt;</code>, <code>&lt;Host_IP&gt;</code>, <code>&lt;advertise_IP&gt;</code><sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></td></tr><tr><td>kube-apiserver-kubelet-client</td><td>kubernetes-ca</td><td>system:masters</td><td>client</td><td/></tr><tr><td>front-proxy-client</td><td>kubernetes-front-proxy-ca</td><td/><td>client</td><td/></tr></tbody></table><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>Instead of using the super-user group <code>system:masters</code> for <code>kube-apiserver-kubelet-client</code>
a less privileged group can be used. kubeadm uses the <code>kubeadm:cluster-admins</code> group for
that purpose.</div><p>where <code>kind</code> maps to one or more of the x509 key usage, which is also documented in the
<code>.spec.usages</code> of a <a href="/docs/reference/kubernetes-api/authentication-resources/certificate-signing-request-v1/#CertificateSigningRequest">CertificateSigningRequest</a>
type:</p><table><thead><tr><th>kind</th><th>Key usage</th></tr></thead><tbody><tr><td>server</td><td>digital signature, key encipherment, server auth</td></tr><tr><td>client</td><td>digital signature, key encipherment, client auth</td></tr></tbody></table><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>Hosts/SAN listed above are the recommended ones for getting a working cluster; if required by a
specific setup, it is possible to add additional SANs on all the server certificates.</div><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4><p>For kubeadm users only:</p><ul><li>The scenario where you are copying to your cluster CA certificates without private keys is
referred as external CA in the kubeadm documentation.</li><li>If you are comparing the above list with a kubeadm generated PKI, please be aware that
<code>kube-etcd</code>, <code>kube-etcd-peer</code> and <code>kube-etcd-healthcheck-client</code> certificates are not generated
in case of external etcd.</li></ul></div><h3 id="certificate-paths">Certificate paths</h3><p>Certificates should be placed in a recommended path (as used by <a href="/docs/reference/setup-tools/kubeadm/">kubeadm</a>).
Paths should be specified using the given argument regardless of location.</p><table><thead><tr><th>DefaultCN</th><th>recommendedkeypath</th><th>recommendedcertpath</th><th>command</th><th>keyargument</th><th>certargument</th></tr></thead><tbody><tr><td>etcd-ca</td><td>etcd/ca.key</td><td>etcd/ca.crt</td><td>kube-apiserver</td><td/><td>--etcd-cafile</td></tr><tr><td>kube-apiserver-etcd-client</td><td>apiserver-etcd-client.key</td><td>apiserver-etcd-client.crt</td><td>kube-apiserver</td><td>--etcd-keyfile</td><td>--etcd-certfile</td></tr><tr><td>kubernetes-ca</td><td>ca.key</td><td>ca.crt</td><td>kube-apiserver</td><td/><td>--client-ca-file</td></tr><tr><td>kubernetes-ca</td><td>ca.key</td><td>ca.crt</td><td>kube-controller-manager</td><td>--cluster-signing-key-file</td><td>--client-ca-file,--root-ca-file,--cluster-signing-cert-file</td></tr><tr><td>kube-apiserver</td><td>apiserver.key</td><td>apiserver.crt</td><td>kube-apiserver</td><td>--tls-private-key-file</td><td>--tls-cert-file</td></tr><tr><td>kube-apiserver-kubelet-client</td><td>apiserver-kubelet-client.key</td><td>apiserver-kubelet-client.crt</td><td>kube-apiserver</td><td>--kubelet-client-key</td><td>--kubelet-client-certificate</td></tr><tr><td>front-proxy-ca</td><td>front-proxy-ca.key</td><td>front-proxy-ca.crt</td><td>kube-apiserver</td><td/><td>--requestheader-client-ca-file</td></tr><tr><td>front-proxy-ca</td><td>front-proxy-ca.key</td><td>front-proxy-ca.crt</td><td>kube-controller-manager</td><td/><td>--requestheader-client-ca-file</td></tr><tr><td>front-proxy-client</td><td>front-proxy-client.key</td><td>front-proxy-client.crt</td><td>kube-apiserver</td><td>--proxy-client-key-file</td><td>--proxy-client-cert-file</td></tr><tr><td>etcd-ca</td><td>etcd/ca.key</td><td>etcd/ca.crt</td><td>etcd</td><td/><td>--trusted-ca-file,--peer-trusted-ca-file</td></tr><tr><td>kube-etcd</td><td>etcd/server.key</td><td>etcd/server.crt</td><td>etcd</td><td>--key-file</td><td>--cert-file</td></tr><tr><td>kube-etcd-peer</td><td>etcd/peer.key</td><td>etcd/peer.crt</td><td>etcd</td><td>--peer-key-file</td><td>--peer-cert-file</td></tr><tr><td>etcd-ca</td><td/><td>etcd/ca.crt</td><td>etcdctl</td><td/><td>--cacert</td></tr><tr><td>kube-etcd-healthcheck-client</td><td>etcd/healthcheck-client.key</td><td>etcd/healthcheck-client.crt</td><td>etcdctl</td><td>--key</td><td>--cert</td></tr></tbody></table><p>Same considerations apply for the service account key pair:</p><table><thead><tr><th>private key path</th><th>public key path</th><th>command</th><th>argument</th></tr></thead><tbody><tr><td>sa.key</td><td/><td>kube-controller-manager</td><td>--service-account-private-key-file</td></tr><tr><td/><td>sa.pub</td><td>kube-apiserver</td><td>--service-account-key-file</td></tr></tbody></table><p>The following example illustrates the file paths <a href="#certificate-paths">from the previous tables</a>
you need to provide if you are generating all of your own keys and certificates:</p><pre tabindex="0"><code>/etc/kubernetes/pki/etcd/ca.key
/etc/kubernetes/pki/etcd/ca.crt
/etc/kubernetes/pki/apiserver-etcd-client.key
/etc/kubernetes/pki/apiserver-etcd-client.crt
/etc/kubernetes/pki/ca.key
/etc/kubernetes/pki/ca.crt
/etc/kubernetes/pki/apiserver.key
/etc/kubernetes/pki/apiserver.crt
/etc/kubernetes/pki/apiserver-kubelet-client.key
/etc/kubernetes/pki/apiserver-kubelet-client.crt
/etc/kubernetes/pki/front-proxy-ca.key
/etc/kubernetes/pki/front-proxy-ca.crt
/etc/kubernetes/pki/front-proxy-client.key
/etc/kubernetes/pki/front-proxy-client.crt
/etc/kubernetes/pki/etcd/server.key
/etc/kubernetes/pki/etcd/server.crt
/etc/kubernetes/pki/etcd/peer.key
/etc/kubernetes/pki/etcd/peer.crt
/etc/kubernetes/pki/etcd/healthcheck-client.key
/etc/kubernetes/pki/etcd/healthcheck-client.crt
/etc/kubernetes/pki/sa.key
/etc/kubernetes/pki/sa.pub
</code></pre><h2 id="configure-certificates-for-user-accounts">Configure certificates for user accounts</h2><p>You must manually configure these administrator accounts and service accounts:</p><table><thead><tr><th>Filename</th><th>Credential name</th><th>Default CN</th><th>O (in Subject)</th></tr></thead><tbody><tr><td>admin.conf</td><td>default-admin</td><td>kubernetes-admin</td><td><code>&lt;admin-group&gt;</code></td></tr><tr><td>super-admin.conf</td><td>default-super-admin</td><td>kubernetes-super-admin</td><td>system:masters</td></tr><tr><td>kubelet.conf</td><td>default-auth</td><td>system:node:<code>&lt;nodeName&gt;</code> (see note)</td><td>system:nodes</td></tr><tr><td>controller-manager.conf</td><td>default-controller-manager</td><td>system:kube-controller-manager</td><td/></tr><tr><td>scheduler.conf</td><td>default-scheduler</td><td>system:kube-scheduler</td><td/></tr></tbody></table><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>The value of <code>&lt;nodeName&gt;</code> for <code>kubelet.conf</code> <strong>must</strong> match precisely the value of the node name
provided by the kubelet as it registers with the apiserver. For further details, read the
<a href="/docs/reference/access-authn-authz/node/">Node Authorization</a>.</div><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4><p>In the above example <code>&lt;admin-group&gt;</code> is implementation specific. Some tools sign the
certificate in the default <code>admin.conf</code> to be part of the <code>system:masters</code> group.
<code>system:masters</code> is a break-glass, super user group can bypass the authorization
layer of Kubernetes, such as RBAC. Also some tools do not generate a separate
<code>super-admin.conf</code> with a certificate bound to this super user group.</p><p>kubeadm generates two separate administrator certificates in kubeconfig files.
One is in <code>admin.conf</code> and has <code>Subject: O = kubeadm:cluster-admins, CN = kubernetes-admin</code>.
<code>kubeadm:cluster-admins</code> is a custom group bound to the <code>cluster-admin</code> ClusterRole.
This file is generated on all kubeadm managed control plane machines.</p><p>Another is in <code>super-admin.conf</code> that has <code>Subject: O = system:masters, CN = kubernetes-super-admin</code>.
This file is generated only on the node where <code>kubeadm init</code> was called.</p></div><ol><li><p>For each configuration, generate an x509 certificate/key pair with the
given Common Name (CN) and Organization (O).</p></li><li><p>Run <code>kubectl</code> as follows for each configuration:</p><pre tabindex="0"><code>KUBECONFIG=&lt;filename&gt; kubectl config set-cluster default-cluster --server=https://&lt;host ip&gt;:6443 --certificate-authority &lt;path-to-kubernetes-ca&gt; --embed-certs
KUBECONFIG=&lt;filename&gt; kubectl config set-credentials &lt;credential-name&gt; --client-key &lt;path-to-key&gt;.pem --client-certificate &lt;path-to-cert&gt;.pem --embed-certs
KUBECONFIG=&lt;filename&gt; kubectl config set-context default-system --cluster default-cluster --user &lt;credential-name&gt;
KUBECONFIG=&lt;filename&gt; kubectl config use-context default-system
</code></pre></li></ol><p>These files are used as follows:</p><table><thead><tr><th>Filename</th><th>Command</th><th>Comment</th></tr></thead><tbody><tr><td>admin.conf</td><td>kubectl</td><td>Configures administrator user for the cluster</td></tr><tr><td>super-admin.conf</td><td>kubectl</td><td>Configures super administrator user for the cluster</td></tr><tr><td>kubelet.conf</td><td>kubelet</td><td>One required for each node in the cluster.</td></tr><tr><td>controller-manager.conf</td><td>kube-controller-manager</td><td>Must be added to manifest in <code>manifests/kube-controller-manager.yaml</code></td></tr><tr><td>scheduler.conf</td><td>kube-scheduler</td><td>Must be added to manifest in <code>manifests/kube-scheduler.yaml</code></td></tr></tbody></table><p>The following files illustrate full paths to the files listed in the previous table:</p><pre tabindex="0"><code>/etc/kubernetes/admin.conf
/etc/kubernetes/super-admin.conf
/etc/kubernetes/kubelet.conf
/etc/kubernetes/controller-manager.conf
/etc/kubernetes/scheduler.conf
</code></pre><div class="footnotes" role="doc-endnotes"><hr/><ol><li id="fn:1"><p>any other IP or DNS name you contact your cluster on (as used by <a href="/docs/reference/setup-tools/kubeadm/">kubeadm</a>
the load balancer stable IP and/or DNS name, <code>kubernetes</code>, <code>kubernetes.default</code>, <code>kubernetes.default.svc</code>,
<code>kubernetes.default.svc.cluster</code>, <code>kubernetes.default.svc.cluster.local</code>) <a href="#fnref:1" class="footnote-backref" role="doc-backlink">↩︎</a></p></li></ol></div></div>
<hr>
<div class="td-content"><h1 data-pagefind-weight="10">Validate node setup</h1><h2 id="node-conformance-test">Node Conformance Test</h2><p><em>Node conformance test</em> is a containerized test framework that provides a system
verification and functionality test for a node. The test validates whether the
node meets the minimum requirements for Kubernetes; a node that passes the test
is qualified to join a Kubernetes cluster.</p><h2 id="node-prerequisite">Node Prerequisite</h2><p>To run node conformance test, a node must satisfy the same prerequisites as a
standard Kubernetes node. At a minimum, the node should have the following
daemons installed:</p><ul><li>CRI-compatible container runtimes such as Docker, containerd and CRI-O</li><li>kubelet</li></ul><h2 id="running-node-conformance-test">Running Node Conformance Test</h2><p>To run the node conformance test, perform the following steps:</p><ol><li><p>Work out the value of the <code>--kubeconfig</code> option for the kubelet; for example:
<code>--kubeconfig=/var/lib/kubelet/config.yaml</code>.
Because the test framework starts a local control plane to test the kubelet,
use <code>http://localhost:8080</code> as the URL of the API server.
There are some other kubelet command line parameters you may want to use:</p><ul><li><code>--cloud-provider</code>: If you are using <code>--cloud-provider=gce</code>, you should
remove the flag to run the test.</li></ul></li><li><p>Run the node conformance test with command:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span><span style="color:#080;font-style:italic"># $CONFIG_DIR is the pod manifest path of your kubelet.</span>
</span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"># $LOG_DIR is the test output path.</span>
</span></span><span style="display:flex"><span>sudo docker run -it --rm --privileged --net<span style="color:#666">=</span>host <span style="color:#b62;font-weight:700">\
</span></span></span><span style="display:flex"><span><span style="color:#b62;font-weight:700"/>  -v /:/rootfs -v <span style="color:#b8860b">$CONFIG_DIR</span>:<span style="color:#b8860b">$CONFIG_DIR</span> -v <span style="color:#b8860b">$LOG_DIR</span>:/var/result <span style="color:#b62;font-weight:700">\
</span></span></span><span style="display:flex"><span><span style="color:#b62;font-weight:700"/>  registry.k8s.io/node-test:0.2
</span></span></code></pre></div></li></ol><h2 id="running-node-conformance-test-for-other-architectures">Running Node Conformance Test for Other Architectures</h2><p>Kubernetes also provides node conformance test docker images for other
architectures:</p><table><thead><tr><th>Arch</th><th style="text-align:center">Image</th></tr></thead><tbody><tr><td>amd64</td><td style="text-align:center">node-test-amd64</td></tr><tr><td>arm</td><td style="text-align:center">node-test-arm</td></tr><tr><td>arm64</td><td style="text-align:center">node-test-arm64</td></tr></tbody></table><h2 id="running-selected-test">Running Selected Test</h2><p>To run specific tests, overwrite the environment variable <code>FOCUS</code> with the
regular expression of tests you want to run.</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>sudo docker run -it --rm --privileged --net<span style="color:#666">=</span>host <span style="color:#b62;font-weight:700">\
</span></span></span><span style="display:flex"><span><span style="color:#b62;font-weight:700"/>  -v /:/rootfs:ro -v <span style="color:#b8860b">$CONFIG_DIR</span>:<span style="color:#b8860b">$CONFIG_DIR</span> -v <span style="color:#b8860b">$LOG_DIR</span>:/var/result <span style="color:#b62;font-weight:700">\
</span></span></span><span style="display:flex"><span><span style="color:#b62;font-weight:700"/>  -e <span style="color:#b8860b">FOCUS</span><span style="color:#666">=</span>MirrorPod <span style="color:#b62;font-weight:700">\ </span><span style="color:#080;font-style:italic"># Only run MirrorPod test</span>
</span></span><span style="display:flex"><span>  registry.k8s.io/node-test:0.2
</span></span></code></pre></div><p>To skip specific tests, overwrite the environment variable <code>SKIP</code> with the
regular expression of tests you want to skip.</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>sudo docker run -it --rm --privileged --net<span style="color:#666">=</span>host <span style="color:#b62;font-weight:700">\
</span></span></span><span style="display:flex"><span><span style="color:#b62;font-weight:700"/>  -v /:/rootfs:ro -v <span style="color:#b8860b">$CONFIG_DIR</span>:<span style="color:#b8860b">$CONFIG_DIR</span> -v <span style="color:#b8860b">$LOG_DIR</span>:/var/result <span style="color:#b62;font-weight:700">\
</span></span></span><span style="display:flex"><span><span style="color:#b62;font-weight:700"/>  -e <span style="color:#b8860b">SKIP</span><span style="color:#666">=</span>MirrorPod <span style="color:#b62;font-weight:700">\ </span><span style="color:#080;font-style:italic"># Run all conformance tests but skip MirrorPod test</span>
</span></span><span style="display:flex"><span>  registry.k8s.io/node-test:0.2
</span></span></code></pre></div><p>Node conformance test is a containerized version of
<a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/e2e-node-tests.md">node e2e test</a>.
By default, it runs all conformance tests.</p><p>Theoretically, you can run any node e2e test if you configure the container and
mount required volumes properly. But <strong>it is strongly recommended to only run conformance
test</strong>, because it requires much more complex configuration to run non-conformance test.</p><h2 id="caveats">Caveats</h2><ul><li>The test leaves some docker images on the node, including the node conformance
test image and images of containers used in the functionality
test.</li><li>The test leaves dead containers on the node. These containers are created
during the functionality test.</li></ul></div>
<hr>
<div class="td-content"><h1 data-pagefind-weight="10">Considerations for large clusters</h1><p>A cluster is a set of <a class="glossary-tooltip" title="A node is a worker machine in Kubernetes." data-toggle="tooltip" data-placement="top" href="/docs/concepts/architecture/nodes/" target="_blank" aria-label="nodes">nodes</a> (physical
or virtual machines) running Kubernetes agents, managed by the
<a class="glossary-tooltip" title="The container orchestration layer that exposes the API and interfaces to define, deploy, and manage the lifecycle of containers." data-toggle="tooltip" data-placement="top" href="/docs/reference/glossary/?all=true#term-control-plane" target="_blank" aria-label="control plane">control plane</a>.
Kubernetes v1.34 supports clusters with up to 5,000 nodes. More specifically,
Kubernetes is designed to accommodate configurations that meet <em>all</em> of the following criteria:</p><ul><li>No more than 110 pods per node</li><li>No more than 5,000 nodes</li><li>No more than 150,000 total pods</li><li>No more than 300,000 total containers</li></ul><p>You can scale your cluster by adding or removing nodes. The way you do this depends
on how your cluster is deployed.</p><h2 id="quota-issues">Cloud provider resource quotas</h2><p>To avoid running into cloud provider quota issues, when creating a cluster with many nodes,
consider:</p><ul><li>Requesting a quota increase for cloud resources such as:<ul><li>Computer instances</li><li>CPUs</li><li>Storage volumes</li><li>In-use IP addresses</li><li>Packet filtering rule sets</li><li>Number of load balancers</li><li>Network subnets</li><li>Log streams</li></ul></li><li>Gating the cluster scaling actions to bring up new nodes in batches, with a pause
between batches, because some cloud providers rate limit the creation of new instances.</li></ul><h2 id="control-plane-components">Control plane components</h2><p>For a large cluster, you need a control plane with sufficient compute and other
resources.</p><p>Typically you would run one or two control plane instances per failure zone,
scaling those instances vertically first and then scaling horizontally after reaching
the point of falling returns to (vertical) scale.</p><p>You should run at least one instance per failure zone to provide fault-tolerance. Kubernetes
nodes do not automatically steer traffic towards control-plane endpoints that are in the
same failure zone; however, your cloud provider might have its own mechanisms to do this.</p><p>For example, using a managed load balancer, you configure the load balancer to send traffic
that originates from the kubelet and Pods in failure zone <em>A</em>, and direct that traffic only
to the control plane hosts that are also in zone <em>A</em>. If a single control-plane host or
endpoint failure zone <em>A</em> goes offline, that means that all the control-plane traffic for
nodes in zone <em>A</em> is now being sent between zones. Running multiple control plane hosts in
each zone makes that outcome less likely.</p><h3 id="etcd-storage">etcd storage</h3><p>To improve performance of large clusters, you can store Event objects in a separate
dedicated etcd instance.</p><p>When creating a cluster, you can (using custom tooling):</p><ul><li>start and configure additional etcd instance</li><li>configure the <a class="glossary-tooltip" title="Control plane component that serves the Kubernetes API." data-toggle="tooltip" data-placement="top" href="/docs/concepts/architecture/#kube-apiserver" target="_blank" aria-label="API server">API server</a> to use it for storing events</li></ul><p>See <a href="/docs/tasks/administer-cluster/configure-upgrade-etcd/">Operating etcd clusters for Kubernetes</a> and
<a href="/docs/setup/production-environment/tools/kubeadm/setup-ha-etcd-with-kubeadm/">Set up a High Availability etcd cluster with kubeadm</a>
for details on configuring and managing etcd for a large cluster.</p><h2 id="addon-resources">Addon resources</h2><p>Kubernetes <a href="/docs/concepts/configuration/manage-resources-containers/">resource limits</a>
help to minimize the impact of memory leaks and other ways that pods and containers can
impact on other components. These resource limits apply to
<a class="glossary-tooltip" title="Resources that extend the functionality of Kubernetes." data-toggle="tooltip" data-placement="top" href="/docs/concepts/cluster-administration/addons/" target="_blank" aria-label="addon">addon</a> resources just as they apply to application workloads.</p><p>For example, you can set CPU and memory limits for a logging component:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:#bbb">  </span>...<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">containers</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>fluentd-cloud-logging<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">image</span>:<span style="color:#bbb"> </span>fluent/fluentd-kubernetes-daemonset:v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">resources</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">limits</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">cpu</span>:<span style="color:#bbb"> </span>100m<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">memory</span>:<span style="color:#bbb"> </span>200Mi<span style="color:#bbb">
</span></span></span></code></pre></div><p>Addons' default limits are typically based on data collected from experience running
each addon on small or medium Kubernetes clusters. When running on large
clusters, addons often consume more of some resources than their default limits.
If a large cluster is deployed without adjusting these values, the addon(s)
may continuously get killed because they keep hitting the memory limit.
Alternatively, the addon may run but with poor performance due to CPU time
slice restrictions.</p><p>To avoid running into cluster addon resource issues, when creating a cluster with
many nodes, consider the following:</p><ul><li>Some addons scale vertically - there is one replica of the addon for the cluster
or serving a whole failure zone. For these addons, increase requests and limits
as you scale out your cluster.</li><li>Many addons scale horizontally - you add capacity by running more pods - but with
a very large cluster you may also need to raise CPU or memory limits slightly.
The <a href="https://github.com/kubernetes/autoscaler/tree/master/vertical-pod-autoscaler#readme">Vertical Pod Autoscaler</a> can run in <em>recommender</em> mode to provide suggested
figures for requests and limits.</li><li>Some addons run as one copy per node, controlled by a <a class="glossary-tooltip" title="Ensures a copy of a Pod is running across a set of nodes in a cluster." data-toggle="tooltip" data-placement="top" href="/docs/concepts/workloads/controllers/daemonset" target="_blank" aria-label="DaemonSet">DaemonSet</a>: for example, a node-level log aggregator. Similar to
the case with horizontally-scaled addons, you may also need to raise CPU or memory
limits slightly.</li></ul><h2 id="what-s-next">What's next</h2><ul><li><p><code>VerticalPodAutoscaler</code> is a custom resource that you can deploy into your cluster
to help you manage resource requests and limits for pods.<br/>Learn more about <a href="https://github.com/kubernetes/autoscaler/tree/master/vertical-pod-autoscaler#readme">Vertical Pod Autoscaler</a>
and how you can use it to scale cluster
components, including cluster-critical addons.</p></li><li><p>Read about <a href="/docs/concepts/cluster-administration/node-autoscaling/">Node autoscaling</a></p></li><li><p>The <a href="https://github.com/kubernetes/autoscaler/tree/master/addon-resizer#readme">addon resizer</a>
helps you in resizing the addons automatically as your cluster's scale changes.</p></li></ul></div>