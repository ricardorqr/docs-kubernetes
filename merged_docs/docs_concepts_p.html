<hr>
<div class="td-content"><h1 data-pagefind-weight="10">Limit Ranges</h1><p>By default, containers run with unbounded
<a href="/docs/concepts/configuration/manage-resources-containers/">compute resources</a> on a Kubernetes cluster.
Using Kubernetes <a href="/docs/concepts/policy/resource-quotas/">resource quotas</a>,
administrators (also termed <em>cluster operators</em>) can restrict consumption and creation
of cluster resources (such as CPU time, memory, and persistent storage) within a specified
<a class="glossary-tooltip" title="An abstraction used by Kubernetes to support isolation of groups of resources within a single cluster." data-toggle="tooltip" data-placement="top" href="/docs/concepts/overview/working-with-objects/namespaces" target="_blank" aria-label="namespace">namespace</a>.
Within a namespace, a <a class="glossary-tooltip" title="A Pod represents a set of running containers in your cluster." data-toggle="tooltip" data-placement="top" href="/docs/concepts/workloads/pods/" target="_blank" aria-label="Pod">Pod</a> can consume as much CPU and memory as is allowed by the ResourceQuotas that apply to that namespace.
As a cluster operator, or as a namespace-level administrator, you might also be concerned
about making sure that a single object cannot monopolize all available resources within a namespace.</p><p>A LimitRange is a policy to constrain the resource allocations (limits and requests) that you can specify for
each applicable object kind (such as Pod or <a class="glossary-tooltip" title="Claims storage resources defined in a PersistentVolume so that it can be mounted as a volume in a container." data-toggle="tooltip" data-placement="top" href="/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims" target="_blank" aria-label="PersistentVolumeClaim">PersistentVolumeClaim</a>) in a namespace.</p><p>A <em>LimitRange</em> provides constraints that can:</p><ul><li>Enforce minimum and maximum compute resources usage per Pod or Container in a namespace.</li><li>Enforce minimum and maximum storage request per
<a class="glossary-tooltip" title="Claims storage resources defined in a PersistentVolume so that it can be mounted as a volume in a container." data-toggle="tooltip" data-placement="top" href="/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims" target="_blank" aria-label="PersistentVolumeClaim">PersistentVolumeClaim</a> in a namespace.</li><li>Enforce a ratio between request and limit for a resource in a namespace.</li><li>Set default request/limit for compute resources in a namespace and automatically
inject them to Containers at runtime.</li></ul><p>Kubernetes constrains resource allocations to Pods in a particular namespace
whenever there is at least one LimitRange object in that namespace.</p><p>The name of a LimitRange object must be a valid
<a href="/docs/concepts/overview/working-with-objects/names/#dns-subdomain-names">DNS subdomain name</a>.</p><h2 id="constraints-on-resource-limits-and-requests">Constraints on resource limits and requests</h2><ul><li>The administrator creates a LimitRange in a namespace.</li><li>Users create (or try to create) objects in that namespace, such as Pods or
PersistentVolumeClaims.</li><li>First, the LimitRange admission controller applies default request and limit values
for all Pods (and their containers) that do not set compute resource requirements.</li><li>Second, the LimitRange tracks usage to ensure it does not exceed resource minimum,
maximum and ratio defined in any LimitRange present in the namespace.</li><li>If you attempt to create or update an object (Pod or PersistentVolumeClaim) that violates
a LimitRange constraint, your request to the API server will fail with anHTTP status
code <code>403 Forbidden</code> and a message explaining the constraint that has been violated.</li><li>If you add a LimitRange in a namespace that applies to compute-related resources
such as <code>cpu</code> and <code>memory</code>, you must specify requests or limits for those values.
Otherwise, the system may reject Pod creation.</li><li>LimitRange validations occur only at Pod admission stage, not on running Pods.
If you add or modify a LimitRange, the Pods that already exist in that namespace
continue unchanged.</li><li>If two or more LimitRange objects exist in the namespace, it is not deterministic
which default value will be applied.</li></ul><h2 id="limitrange-and-admission-checks-for-pods">LimitRange and admission checks for Pods</h2><p>A LimitRange does <strong>not</strong> check the consistency of the default values it applies.
This means that a default value for the <em>limit</em> that is set by LimitRange may be
less than the <em>request</em> value specified for the container in the spec that a client
submits to the API server. If that happens, the final Pod will not be schedulable.</p><p>For example, you define a LimitRange with below manifest:<div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>The following examples operate within the default namespace of your cluster, as the namespace
parameter is undefined and the LimitRange scope is limited to the namespace level.
This implies that any references or operations within these examples will interact
with elements within the default namespace of your cluster. You can override the
operating namespace by configuring namespace in the <code>metadata.namespace</code> field.</div></p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/concepts/policy/limit-range/problematic-limit-range.yaml" download="concepts/policy/limit-range/problematic-limit-range.yaml"><code>concepts/policy/limit-range/problematic-limit-range.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" onclick="copyCode(&quot;concepts-policy-limit-range-problematic-limit-range-yaml&quot;)" title="Copy concepts/policy/limit-range/problematic-limit-range.yaml to clipboard"/></div><div class="includecode" id="concepts-policy-limit-range-problematic-limit-range-yaml"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>LimitRange<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">metadata</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>cpu-resource-constraint<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">spec</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">limits</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span>- <span style="color:green;font-weight:700">default</span>:<span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># this section defines default limits</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">cpu</span>:<span style="color:#bbb"> </span>500m<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">defaultRequest</span>:<span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># this section defines default requests</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">cpu</span>:<span style="color:#bbb"> </span>500m<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">max</span>:<span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># max and min define the limit range</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">cpu</span>:<span style="color:#bbb"> </span><span style="color:#b44">"1"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">min</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">cpu</span>:<span style="color:#bbb"> </span>100m<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">type</span>:<span style="color:#bbb"> </span>Container<span style="color:#bbb">
</span></span></span></code></pre></div></div></div><p>along with a Pod that declares a CPU resource request of <code>700m</code>, but not a limit:</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/concepts/policy/limit-range/example-conflict-with-limitrange-cpu.yaml" download="concepts/policy/limit-range/example-conflict-with-limitrange-cpu.yaml"><code>concepts/policy/limit-range/example-conflict-with-limitrange-cpu.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" onclick="copyCode(&quot;concepts-policy-limit-range-example-conflict-with-limitrange-cpu-yaml&quot;)" title="Copy concepts/policy/limit-range/example-conflict-with-limitrange-cpu.yaml to clipboard"/></div><div class="includecode" id="concepts-policy-limit-range-example-conflict-with-limitrange-cpu-yaml"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>Pod<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">metadata</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>example-conflict-with-limitrange-cpu<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">spec</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">containers</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>demo<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">image</span>:<span style="color:#bbb"> </span>registry.k8s.io/pause:3.8<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">resources</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">requests</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">cpu</span>:<span style="color:#bbb"> </span>700m<span style="color:#bbb">
</span></span></span></code></pre></div></div></div><p>then that Pod will not be scheduled, failing with an error similar to:</p><pre tabindex="0"><code>Pod "example-conflict-with-limitrange-cpu" is invalid: spec.containers[0].resources.requests: Invalid value: "700m": must be less than or equal to cpu limit
</code></pre><p>If you set both <code>request</code> and <code>limit</code>, then that new Pod will be scheduled successfully
even with the same LimitRange in place:</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/concepts/policy/limit-range/example-no-conflict-with-limitrange-cpu.yaml" download="concepts/policy/limit-range/example-no-conflict-with-limitrange-cpu.yaml"><code>concepts/policy/limit-range/example-no-conflict-with-limitrange-cpu.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" onclick="copyCode(&quot;concepts-policy-limit-range-example-no-conflict-with-limitrange-cpu-yaml&quot;)" title="Copy concepts/policy/limit-range/example-no-conflict-with-limitrange-cpu.yaml to clipboard"/></div><div class="includecode" id="concepts-policy-limit-range-example-no-conflict-with-limitrange-cpu-yaml"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>Pod<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">metadata</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>example-no-conflict-with-limitrange-cpu<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">spec</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">containers</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>demo<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">image</span>:<span style="color:#bbb"> </span>registry.k8s.io/pause:3.8<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">resources</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">requests</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">cpu</span>:<span style="color:#bbb"> </span>700m<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">limits</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">cpu</span>:<span style="color:#bbb"> </span>700m<span style="color:#bbb">
</span></span></span></code></pre></div></div></div><h2 id="example-resource-constraints">Example resource constraints</h2><p>Examples of policies that could be created using LimitRange are:</p><ul><li>In a 2 node cluster with a capacity of 8 GiB RAM and 16 cores, constrain Pods in a
namespace to request 100m of CPU with a max limit of 500m for CPU and request 200Mi
for Memory with a max limit of 600Mi for Memory.</li><li>Define default CPU limit and request to 150m and memory default request to 300Mi for
Containers started with no cpu and memory requests in their specs.</li></ul><p>In the case where the total limits of the namespace is less than the sum of the limits
of the Pods/Containers, there may be contention for resources. In this case, the
Containers or Pods will not be created.</p><p>Neither contention nor changes to a LimitRange will affect already created resources.</p><h2 id="what-s-next">What's next</h2><p>For examples on using limits, see:</p><ul><li><a href="/docs/tasks/administer-cluster/manage-resources/cpu-constraint-namespace/">how to configure minimum and maximum CPU constraints per namespace</a>.</li><li><a href="/docs/tasks/administer-cluster/manage-resources/memory-constraint-namespace/">how to configure minimum and maximum Memory constraints per namespace</a>.</li><li><a href="/docs/tasks/administer-cluster/manage-resources/cpu-default-namespace/">how to configure default CPU Requests and Limits per namespace</a>.</li><li><a href="/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/">how to configure default Memory Requests and Limits per namespace</a>.</li><li><a href="/docs/tasks/administer-cluster/limit-storage-consumption/#limitrange-to-limit-requests-for-storage">how to configure minimum and maximum Storage consumption per namespace</a>.</li><li>a <a href="/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/">detailed example on configuring quota per namespace</a>.</li></ul><p>Refer to the <a href="https://git.k8s.io/design-proposals-archive/resource-management/admission_control_limit_range.md">LimitRanger design document</a>
for context and historical information.</p></div>
<hr>
<div class="td-content"><h1 data-pagefind-weight="10">Process ID Limits And Reservations</h1><div class="feature-state-notice feature-stable"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.20 [stable]</code></div><p>Kubernetes allow you to limit the number of process IDs (PIDs) that a
<a class="glossary-tooltip" title="A Pod represents a set of running containers in your cluster." data-toggle="tooltip" data-placement="top" href="/docs/concepts/workloads/pods/" target="_blank" aria-label="Pod">Pod</a> can use.
You can also reserve a number of allocatable PIDs for each <a class="glossary-tooltip" title="A node is a worker machine in Kubernetes." data-toggle="tooltip" data-placement="top" href="/docs/concepts/architecture/nodes/" target="_blank" aria-label="node">node</a>
for use by the operating system and daemons (rather than by Pods).</p><p>Process IDs (PIDs) are a fundamental resource on nodes. It is trivial to hit the
task limit without hitting any other resource limits, which can then cause
instability to a host machine.</p><p>Cluster administrators require mechanisms to ensure that Pods running in the
cluster cannot induce PID exhaustion that prevents host daemons (such as the
<a class="glossary-tooltip" title="An agent that runs on each node in the cluster. It makes sure that containers are running in a pod." data-toggle="tooltip" data-placement="top" href="/docs/reference/command-line-tools-reference/kubelet" target="_blank" aria-label="kubelet">kubelet</a> or
<a class="glossary-tooltip" title="kube-proxy is a network proxy that runs on each node in the cluster." data-toggle="tooltip" data-placement="top" href="/docs/reference/command-line-tools-reference/kube-proxy/" target="_blank" aria-label="kube-proxy">kube-proxy</a>,
and potentially also the container runtime) from running.
In addition, it is important to ensure that PIDs are limited among Pods in order
to ensure they have limited impact on other workloads on the same node.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>On certain Linux installations, the operating system sets the PIDs limit to a low default,
such as <code>32768</code>. Consider raising the value of <code>/proc/sys/kernel/pid_max</code>.</div><p>You can configure a kubelet to limit the number of PIDs a given Pod can consume.
For example, if your node's host OS is set to use a maximum of <code>262144</code> PIDs and
expect to host less than <code>250</code> Pods, one can give each Pod a budget of <code>1000</code>
PIDs to prevent using up that node's overall number of available PIDs. If the
admin wants to overcommit PIDs similar to CPU or memory, they may do so as well
with some additional risks. Either way, a single Pod will not be able to bring
the whole machine down. This kind of resource limiting helps to prevent simple
fork bombs from affecting operation of an entire cluster.</p><p>Per-Pod PID limiting allows administrators to protect one Pod from another, but
does not ensure that all Pods scheduled onto that host are unable to impact the node overall.
Per-Pod limiting also does not protect the node agents themselves from PID exhaustion.</p><p>You can also reserve an amount of PIDs for node overhead, separate from the
allocation to Pods. This is similar to how you can reserve CPU, memory, or other
resources for use by the operating system and other facilities outside of Pods
and their containers.</p><p>PID limiting is an important sibling to <a href="/docs/concepts/configuration/manage-resources-containers/">compute
resource</a> requests
and limits. However, you specify it in a different way: rather than defining a
Pod's resource limit in the <code>.spec</code> for a Pod, you configure the limit as a
setting on the kubelet. Pod-defined PID limits are not currently supported.</p><div class="alert alert-caution" role="alert"><h4 class="alert-heading">Caution:</h4>This means that the limit that applies to a Pod may be different depending on
where the Pod is scheduled. To make things simple, it's easiest if all Nodes use
the same PID resource limits and reservations.</div><h2 id="node-pid-limits">Node PID limits</h2><p>Kubernetes allows you to reserve a number of process IDs for the system use. To
configure the reservation, use the parameter <code>pid=&lt;number&gt;</code> in the
<code>--system-reserved</code> and <code>--kube-reserved</code> command line options to the kubelet.
The value you specified declares that the specified number of process IDs will
be reserved for the system as a whole and for Kubernetes system daemons
respectively.</p><h2 id="pod-pid-limits">Pod PID limits</h2><p>Kubernetes allows you to limit the number of processes running in a Pod. You
specify this limit at the node level, rather than configuring it as a resource
limit for a particular Pod. Each Node can have a different PID limit.<br/>To configure the limit, you can specify the command line parameter <code>--pod-max-pids</code>
to the kubelet, or set <code>PodPidsLimit</code> in the kubelet
<a href="/docs/tasks/administer-cluster/kubelet-config-file/">configuration file</a>.</p><h2 id="pid-based-eviction">PID based eviction</h2><p>You can configure kubelet to start terminating a Pod when it is misbehaving and consuming abnormal amount of resources.
This feature is called eviction. You can
<a href="/docs/concepts/scheduling-eviction/node-pressure-eviction/">Configure Out of Resource Handling</a>
for various eviction signals.
Use <code>pid.available</code> eviction signal to configure the threshold for number of PIDs used by Pod.
You can set soft and hard eviction policies.
However, even with the hard eviction policy, if the number of PIDs growing very fast,
node can still get into unstable state by hitting the node PIDs limit.
Eviction signal value is calculated periodically and does NOT enforce the limit.</p><p>PID limiting - per Pod and per Node sets the hard limit.
Once the limit is hit, workload will start experiencing failures when trying to get a new PID.
It may or may not lead to rescheduling of a Pod,
depending on how workload reacts on these failures and how liveness and readiness
probes are configured for the Pod. However, if limits were set correctly,
you can guarantee that other Pods workload and system processes will not run out of PIDs
when one Pod is misbehaving.</p><h2 id="what-s-next">What's next</h2><ul><li>Refer to the <a href="https://github.com/kubernetes/enhancements/blob/097b4d8276bc9564e56adf72505d43ce9bc5e9e8/keps/sig-node/20190129-pid-limiting.md">PID Limiting enhancement document</a> for more information.</li><li>For historical context, read
<a href="/blog/2019/04/15/process-id-limiting-for-stability-improvements-in-kubernetes-1.14/">Process ID Limiting for Stability Improvements in Kubernetes 1.14</a>.</li><li>Read <a href="/docs/concepts/configuration/manage-resources-containers/">Managing Resources for Containers</a>.</li><li>Learn how to <a href="/docs/concepts/scheduling-eviction/node-pressure-eviction/">Configure Out of Resource Handling</a>.</li></ul></div>
<hr>
<div class="td-content"><h1 data-pagefind-weight="10">Node Resource Managers</h1><p>In order to support latency-critical and high-throughput workloads, Kubernetes offers a suite of
Resource Managers. The managers aim to co-ordinate and optimise the alignment of node's resources for pods
configured with a specific requirement for CPUs, devices, and memory (hugepages) resources.</p><h2 id="hardware-topology-alignment-policies">Hardware topology alignment policies</h2><p><em>Topology Manager</em> is a kubelet component that aims to coordinate the set of components that are
responsible for these optimizations. The overall resource management process is governed using
the policy you specify. To learn more, read
<a href="/docs/tasks/administer-cluster/topology-manager/">Control Topology Management Policies on a Node</a>.</p><h2 id="policies-for-assigning-cpus-to-pods">Policies for assigning CPUs to Pods</h2><div class="feature-state-notice feature-stable" title="Feature Gate: CPUManager"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.26 [stable]</code> (enabled by default: true)</div><p>Once a Pod is bound to a Node, the kubelet on that node may need to either multiplex the existing
hardware (for example, sharing CPUs across multiple Pods) or allocate hardware by dedicating some
resource (for example, assigning one of more CPUs for a Pod's exclusive use).</p><p>By default, the kubelet uses <a href="https://en.wikipedia.org/wiki/Completely_Fair_Scheduler">CFS quota</a>
to enforce pod CPU limits.  When the node runs many CPU-bound pods, the workload can move to
different CPU cores depending on whether the pod is throttled and which CPU cores are available
at scheduling time. Many workloads are not sensitive to this migration and thus
work fine without any intervention.</p><p>However, in workloads where CPU cache affinity and scheduling latency significantly affect
workload performance, the kubelet allows alternative CPU
management policies to determine some placement preferences on the node.
This is implemented using the <em>CPU Manager</em> and its policy.
There are two available policies:</p><ul><li><code>none</code>: the <code>none</code> policy explicitly enables the existing default CPU
affinity scheme, providing no affinity beyond what the OS scheduler does
automatically.  Limits on CPU usage for
<a href="/docs/concepts/workloads/pods/pod-qos/">Guaranteed pods</a> and
<a href="/docs/concepts/workloads/pods/pod-qos/">Burstable pods</a>
are enforced using CFS quota.</li><li><code>static</code>: the <code>static</code> policy allows containers in <code>Guaranteed</code> pods with integer CPU
<code>requests</code> access to exclusive CPUs on the node. This exclusivity is enforced
using the <a href="https://www.kernel.org/doc/Documentation/cgroup-v2.txt">cpuset cgroup controller</a>.</li></ul><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>System services such as the container runtime and the kubelet itself can continue to run on
these exclusive CPUs.  The exclusivity only extends to other pods.</div><p>CPU Manager doesn't support offlining and onlining of CPUs at runtime.</p><h3 id="static-policy">Static policy</h3><p>The static policy enables finer-grained CPU management and exclusive CPU assignment.
This policy manages a shared pool of CPUs that initially contains all CPUs in the
node. The amount of exclusively allocatable CPUs is equal to the total
number of CPUs in the node minus any CPU reservations set by the kubelet configuration.
CPUs reserved by these options are taken, in integer quantity, from the initial shared pool in ascending order by physical
core ID.  This shared pool is the set of CPUs on which any containers in
<code>BestEffort</code> and <code>Burstable</code> pods run. Containers in <code>Guaranteed</code> pods with fractional
CPU <code>requests</code> also run on CPUs in the shared pool. Only containers that are
part of a <code>Guaranteed</code> pod and have integer CPU <code>requests</code> are assigned
exclusive CPUs.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>The kubelet requires a CPU reservation greater than zero when the static policy is enabled.
This is because a zero CPU reservation would allow the shared pool to become empty.</div><p>As <code>Guaranteed</code> pods whose containers fit the requirements for being statically
assigned are scheduled to the node, CPUs are removed from the shared pool and
placed in the cpuset for the container. CFS quota is not used to bound
the CPU usage of these containers as their usage is bound by the scheduling domain
itself. In others words, the number of CPUs in the container cpuset is equal to the integer
CPU <code>limit</code> specified in the pod spec. This static assignment increases CPU
affinity and decreases context switches due to throttling for the CPU-bound
workload.</p><p>Consider the containers in the following pod specs:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">spec</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">containers</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">image</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span></span></span></code></pre></div><p>The pod above runs in the <code>BestEffort</code> QoS class because no resource <code>requests</code> or
<code>limits</code> are specified. It runs in the shared pool.</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">spec</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">containers</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">image</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">resources</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">limits</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">memory</span>:<span style="color:#bbb"> </span><span style="color:#b44">"200Mi"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">requests</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">memory</span>:<span style="color:#bbb"> </span><span style="color:#b44">"100Mi"</span><span style="color:#bbb">
</span></span></span></code></pre></div><p>The pod above runs in the <code>Burstable</code> QoS class because resource <code>requests</code> do not
equal <code>limits</code> and the <code>cpu</code> quantity is not specified. It runs in the shared
pool.</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">spec</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">containers</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">image</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">resources</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">limits</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">memory</span>:<span style="color:#bbb"> </span><span style="color:#b44">"200Mi"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">cpu</span>:<span style="color:#bbb"> </span><span style="color:#b44">"2"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">requests</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">memory</span>:<span style="color:#bbb"> </span><span style="color:#b44">"100Mi"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">cpu</span>:<span style="color:#bbb"> </span><span style="color:#b44">"1"</span><span style="color:#bbb">
</span></span></span></code></pre></div><p>The pod above runs in the <code>Burstable</code> QoS class because resource <code>requests</code> do not
equal <code>limits</code>. It runs in the shared pool.</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">spec</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">containers</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">image</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">resources</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">limits</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">memory</span>:<span style="color:#bbb"> </span><span style="color:#b44">"200Mi"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">cpu</span>:<span style="color:#bbb"> </span><span style="color:#b44">"2"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">requests</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">memory</span>:<span style="color:#bbb"> </span><span style="color:#b44">"200Mi"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">cpu</span>:<span style="color:#bbb"> </span><span style="color:#b44">"2"</span><span style="color:#bbb">
</span></span></span></code></pre></div><p>The pod above runs in the <code>Guaranteed</code> QoS class because <code>requests</code> are equal to <code>limits</code>.
And the container's resource limit for the CPU resource is an integer greater than
or equal to one. The <code>nginx</code> container is granted 2 exclusive CPUs.</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">spec</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">containers</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">image</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">resources</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">limits</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">memory</span>:<span style="color:#bbb"> </span><span style="color:#b44">"200Mi"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">cpu</span>:<span style="color:#bbb"> </span><span style="color:#b44">"1.5"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">requests</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">memory</span>:<span style="color:#bbb"> </span><span style="color:#b44">"200Mi"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">cpu</span>:<span style="color:#bbb"> </span><span style="color:#b44">"1.5"</span><span style="color:#bbb">
</span></span></span></code></pre></div><p>The pod above runs in the <code>Guaranteed</code> QoS class because <code>requests</code> are equal to <code>limits</code>.
But the container's resource limit for the CPU resource is a fraction. It runs in
the shared pool.</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">spec</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">containers</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">image</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">resources</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">limits</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">memory</span>:<span style="color:#bbb"> </span><span style="color:#b44">"200Mi"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">cpu</span>:<span style="color:#bbb"> </span><span style="color:#b44">"2"</span><span style="color:#bbb">
</span></span></span></code></pre></div><p>The pod above runs in the <code>Guaranteed</code> QoS class because only <code>limits</code> are specified
and <code>requests</code> are set equal to <code>limits</code> when not explicitly specified. And the
container's resource limit for the CPU resource is an integer greater than or
equal to one. The <code>nginx</code> container is granted 2 exclusive CPUs.</p><h4 id="cpu-policy-static--options">Static policy options</h4><p>Here are the available policy options for the static CPU management policy,
listed in alphabetical order:</p><dl><dt><code>align-by-socket</code> (alpha, hidden by default)</dt><dd>Align CPUs by physical package / socket boundary, rather than logical NUMA boundaries
(available since Kubernetes v1.25)</dd><dt><code>distribute-cpus-across-cores</code> (alpha, hidden by default)</dt><dd>Allocate virtual cores, sometimes called hardware threads, across different physical cores
(available since Kubernetes v1.31)</dd><dt><code>distribute-cpus-across-numa</code> (beta, visible by default)</dt><dd>Spread CPUs across different NUMA domains, aiming for an even balance between the selected domains
(available since Kubernetes v1.23)</dd><dt><code>full-pcpus-only</code> (GA, visible by default)</dt><dd>Always allocate full physical cores (available since Kubernetes v1.22, GA since Kubernetes v1.33)</dd><dt><code>strict-cpu-reservation</code> (beta, visible by default)</dt><dd>Prevent all the pods regardless of their Quality of Service class to run on reserved CPUs
(available since Kubernetes v1.32)</dd><dt><code>prefer-align-cpus-by-uncorecache</code> (beta, visible by default)</dt><dd>Align CPUs by uncore (Last-Level) cache boundary on a best-effort way
(available since Kubernetes v1.32)</dd></dl><p>You can toggle groups of options on and off based upon their maturity level
using the following feature gates:</p><ul><li><code>CPUManagerPolicyBetaOptions</code> (default enabled). Disable to hide beta-level options.</li><li><code>CPUManagerPolicyAlphaOptions</code> (default disabled). Enable to show alpha-level options.</li></ul><p>You will still have to enable each option using the <code>cpuManagerPolicyOptions</code> field in the
kubelet configuration file.</p><p>For more detail about the individual options you can configure, read on.</p><h5 id="full-pcpus-only"><code>full-pcpus-only</code></h5><p>If the <code>full-pcpus-only</code> policy option is specified, the static policy will always allocate full physical cores.
By default, without this option, the static policy allocates CPUs using a topology-aware best-fit allocation.
On SMT enabled systems, the policy can allocate individual virtual cores, which correspond to hardware threads.
This can lead to different containers sharing the same physical cores; this behaviour in turn contributes
to the <a href="https://en.wikipedia.org/wiki/Cloud_computing_issues#Performance_interference_and_noisy_neighbors">noisy neighbours problem</a>.
With the option enabled, the pod will be admitted by the kubelet only if the CPU request of all its containers
can be fulfilled by allocating full physical cores.
If the pod does not pass the admission, it will be put in Failed state with the message <code>SMTAlignmentError</code>.</p><h5 id="distribute-cpus-across-numa"><code>distribute-cpus-across-numa</code></h5><p>If the <code>distribute-cpus-across-numa</code>policy option is specified, the static
policy will evenly distribute CPUs across NUMA nodes in cases where more than
one NUMA node is required to satisfy the allocation.
By default, the <code>CPUManager</code> will pack CPUs onto one NUMA node until it is
filled, with any remaining CPUs simply spilling over to the next NUMA node.
This can cause undesired bottlenecks in parallel code relying on barriers (and
similar synchronization primitives), as this type of code tends to run only as
fast as its slowest worker (which is slowed down by the fact that fewer CPUs
are available on at least one NUMA node).
By distributing CPUs evenly across NUMA nodes, application developers can more
easily ensure that no single worker suffers from NUMA effects more than any
other, improving the overall performance of these types of applications.</p><h5 id="align-by-socket"><code>align-by-socket</code></h5><p>If the <code>align-by-socket</code> policy option is specified, CPUs will be considered
aligned at the socket boundary when deciding how to allocate CPUs to a
container. By default, the <code>CPUManager</code> aligns CPU allocations at the NUMA
boundary, which could result in performance degradation if CPUs need to be
pulled from more than one NUMA node to satisfy the allocation. Although it
tries to ensure that all CPUs are allocated from the <em>minimum</em> number of NUMA
nodes, there is no guarantee that those NUMA nodes will be on the same socket.
By directing the <code>CPUManager</code> to explicitly align CPUs at the socket boundary
rather than the NUMA boundary, we are able to avoid such issues. Note, this
policy option is not compatible with <code>TopologyManager</code> <code>single-numa-node</code>
policy and does not apply to hardware where the number of sockets is greater
than number of NUMA nodes.</p><h5 id="distribute-cpus-across-cores"><code>distribute-cpus-across-cores</code></h5><p>If the <code>distribute-cpus-across-cores</code> policy option is specified, the static policy
will attempt to allocate virtual cores (hardware threads) across different physical cores.
By default, the <code>CPUManager</code> tends to pack CPUs onto as few physical cores as possible,
which can lead to contention among CPUs on the same physical core and result
in performance bottlenecks. By enabling the <code>distribute-cpus-across-cores</code> policy,
the static policy ensures that CPUs are distributed across as many physical cores
as possible, reducing the contention on the same physical core and thereby
improving overall performance. However, it is important to note that this strategy
might be less effective when the system is heavily loaded. Under such conditions,
the benefit of reducing contention diminishes. Conversely, default behavior
can help in reducing inter-core communication overhead, potentially providing
better performance under high load conditions.</p><h5 id="strict-cpu-reservation"><code>strict-cpu-reservation</code></h5><p>The <code>reservedSystemCPUs</code> parameter in <a href="/docs/reference/config-api/kubelet-config.v1beta1/">KubeletConfiguration</a>,
or the deprecated kubelet command line option <code>--reserved-cpus</code>, defines an explicit CPU set for OS system daemons
and kubernetes system daemons. More details of this parameter can be found on the
<a href="/docs/tasks/administer-cluster/reserve-compute-resources/#explicitly-reserved-cpu-list">Explicitly Reserved CPU List</a> page.
By default, this isolation is implemented only for guaranteed pods with integer CPU requests not for burstable and best-effort pods
(and guaranteed pods with fractional CPU requests). Admission is only comparing the CPU requests against the allocatable CPUs.
Since the CPU limit is higher than the request, the default behaviour allows burstable and best-effort pods to use up the capacity
of <code>reservedSystemCPUs</code> and cause host OS services to starve in real life deployments.
If the <code>strict-cpu-reservation</code> policy option is enabled, the static policy will not allow
any workload to use the CPU cores specified in <code>reservedSystemCPUs</code>.</p><h5 id="prefer-align-cpus-by-uncorecache"><code>prefer-align-cpus-by-uncorecache</code></h5><p>If the <code>prefer-align-cpus-by-uncorecache</code> policy is specified, the static policy
will allocate CPU resources for individual containers such that all CPUs assigned
to a container share the same uncore cache block (also known as the Last-Level Cache
or LLC). By default, the <code>CPUManager</code> will tightly pack CPU assignments which can
result in containers being assigned CPUs from multiple uncore caches. This option
enables the <code>CPUManager</code> to allocate CPUs in a way that maximizes the efficient use
of the uncore cache. Allocation is performed on a best-effort basis, aiming to
affine as many CPUs as possible within the same uncore cache. If the container's
CPU requirement exceeds the CPU capacity of a single uncore cache, the <code>CPUManager</code>
minimizes the number of uncore caches used in order to maintain optimal uncore
cache alignment. Specific workloads can benefit in performance from the reduction
of inter-cache latency and noisy neighbors at the cache level. If the <code>CPUManager</code>
cannot align optimally while the node has sufficient resources, the container will
still be admitted using the default packed behavior.</p><h2 id="memory-management-policies">Memory Management Policies</h2><div class="feature-state-notice feature-stable" title="Feature Gate: MemoryManager"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.32 [stable]</code> (enabled by default: true)</div><p>The Kubernetes <em>Memory Manager</em> enables the feature of guaranteed memory (and hugepages)
allocation for pods in the <code>Guaranteed</code> <a class="glossary-tooltip" title="QoS Class (Quality of Service Class) provides a way for Kubernetes to classify pods within the cluster into several classes and make decisions about scheduling and eviction." data-toggle="tooltip" data-placement="top" href="/docs/concepts/workloads/pods/pod-qos/" target="_blank" aria-label="QoS class">QoS class</a>.</p><p>The Memory Manager employs hint generation protocol to yield the most suitable NUMA affinity for a pod.
The Memory Manager feeds the central manager (<em>Topology Manager</em>) with these affinity hints.
Based on both the hints and Topology Manager policy, the pod is rejected or admitted to the node.</p><p>Moreover, the Memory Manager ensures that the memory which a pod requests
is allocated from a minimum number of NUMA nodes.</p><h2 id="other-resource-managers">Other resource managers</h2><p>The configuration of individual managers is elaborated in dedicated documents:</p><ul><li><a href="/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/#device-plugin-integration-with-the-topology-manager">Device Manager</a></li></ul></div>
<hr>
<div class="td-content"><h1 data-pagefind-weight="10">Policies</h1><div class="lead">Manage security and best-practices with policies.</div><p>Kubernetes policies are configurations that manage other configurations or runtime behaviors. Kubernetes offers various forms of policies, described below:</p><h2 id="apply-policies-using-api-objects">Apply policies using API objects</h2><p>Some API objects act as policies. Here are some examples:</p><ul><li><a href="/docs/concepts/services-networking/network-policies/">NetworkPolicies</a> can be used to restrict ingress and egress traffic for a workload.</li><li><a href="/docs/concepts/policy/limit-range/">LimitRanges</a> manage resource allocation constraints across different object kinds.</li><li><a href="/docs/concepts/policy/resource-quotas/">ResourceQuotas</a> limit resource consumption for a <a class="glossary-tooltip" title="An abstraction used by Kubernetes to support isolation of groups of resources within a single cluster." data-toggle="tooltip" data-placement="top" href="/docs/concepts/overview/working-with-objects/namespaces" target="_blank" aria-label="namespace">namespace</a>.</li></ul><h2 id="apply-policies-using-admission-controllers">Apply policies using admission controllers</h2><p>An <a class="glossary-tooltip" title="A piece of code that intercepts requests to the Kubernetes API server prior to persistence of the object." data-toggle="tooltip" data-placement="top" href="/docs/reference/access-authn-authz/admission-controllers/" target="_blank" aria-label="admission controller">admission controller</a>
runs in the API server
and can validate or mutate API requests. Some admission controllers act to apply policies.
For example, the <a href="/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages">AlwaysPullImages</a> admission controller modifies a new Pod to set the image pull policy to <code>Always</code>.</p><p>Kubernetes has several built-in admission controllers that are configurable via the API server <code>--enable-admission-plugins</code> flag.</p><p>Details on admission controllers, with the complete list of available admission controllers, are documented in a dedicated section:</p><ul><li><a href="/docs/reference/access-authn-authz/admission-controllers/">Admission Controllers</a></li></ul><h2 id="apply-policies-using-validatingadmissionpolicy">Apply policies using ValidatingAdmissionPolicy</h2><p>Validating admission policies allow configurable validation checks to be executed in the API server using the Common Expression Language (CEL). For example, a <code>ValidatingAdmissionPolicy</code> can be used to disallow use of the <code>latest</code> image tag.</p><p>A <code>ValidatingAdmissionPolicy</code> operates on an API request and can be used to block, audit, and warn users about non-compliant configurations.</p><p>Details on the <code>ValidatingAdmissionPolicy</code> API, with examples, are documented in a dedicated section:</p><ul><li><a href="/docs/reference/access-authn-authz/validating-admission-policy/">Validating Admission Policy</a></li></ul><h2 id="apply-policies-using-dynamic-admission-control">Apply policies using dynamic admission control</h2><p>Dynamic admission controllers (or admission webhooks) run outside the API server as separate applications that register to receive webhooks requests to perform validation or mutation of API requests.</p><p>Dynamic admission controllers can be used to apply policies on API requests and trigger other policy-based workflows. A dynamic admission controller can perform complex checks including those that require retrieval of other cluster resources and external data. For example, an image verification check can lookup data from OCI registries to validate the container image signatures and attestations.</p><p>Details on dynamic admission control are documented in a dedicated section:</p><ul><li><a href="/docs/reference/access-authn-authz/extensible-admission-controllers/">Dynamic Admission Control</a></li></ul><h3 id="implementations-admission-control">Implementations</h3><div class="alert alert-secondary callout third-party-content" role="alert"><strong>Note:</strong> This section links to third party projects that provide functionality required by Kubernetes. The Kubernetes project authors aren't responsible for these projects, which are listed alphabetically. To add a project to this list, read the <a href="/docs/contribute/style/content-guide/#third-party-content">content guide</a> before submitting a change. <a href="#third-party-content-disclaimer">More information.</a></div><p>Dynamic Admission Controllers that act as flexible policy engines are being developed in the Kubernetes ecosystem, such as:</p><ul><li><a href="https://github.com/kubewarden">Kubewarden</a></li><li><a href="https://kyverno.io">Kyverno</a></li><li><a href="https://github.com/open-policy-agent/gatekeeper">OPA Gatekeeper</a></li><li><a href="https://polaris.docs.fairwinds.com/admission-controller/">Polaris</a></li></ul><h2 id="apply-policies-using-kubelet-configurations">Apply policies using Kubelet configurations</h2><p>Kubernetes allows configuring the Kubelet on each worker node. Some Kubelet configurations act as policies:</p><ul><li><a href="/docs/concepts/policy/pid-limiting/">Process ID limits and reservations</a> are used to limit and reserve allocatable PIDs.</li><li><a href="/docs/concepts/policy/node-resource-managers/">Node Resource Managers</a> can manage compute, memory, and device resources for latency-critical and high-throughput workloads.</li></ul><div class="section-index"/></div>
<hr>
<div class="td-content"><h1 data-pagefind-weight="10">Resource Quotas</h1><p>When several users or teams share a cluster with a fixed number of nodes,
there is a concern that one team could use more than its fair share of resources.</p><p><em>Resource quotas</em> are a tool for administrators to address this concern.</p><p>A resource quota, defined by a ResourceQuota object, provides constraints that limit
aggregate resource consumption per <a class="glossary-tooltip" title="An abstraction used by Kubernetes to support isolation of groups of resources within a single cluster." data-toggle="tooltip" data-placement="top" href="/docs/concepts/overview/working-with-objects/namespaces" target="_blank" aria-label="namespace">namespace</a>. A ResourceQuota can also
limit the <a href="#quota-on-object-count">quantity of objects that can be created in a namespace</a> by API kind, as well as the total
amount of <a class="glossary-tooltip" title="A defined amount of infrastructure available for consumption (CPU, memory, etc)." data-toggle="tooltip" data-placement="top" href="/docs/reference/glossary/?all=true#term-infrastructure-resource" target="_blank" aria-label="infrastructure resources">infrastructure resources</a> that may be consumed by
API objects found in that namespace.</p><div class="alert alert-caution" role="alert"><h4 class="alert-heading">Caution:</h4>Neither contention nor changes to quota will affect already created resources.</div><h2 id="how-kubernetes-resourcequotas-work">How Kubernetes ResourceQuotas work</h2><p>ResourceQuotas work like this:</p><ul><li><p>Different teams work in different namespaces. This separation can be enforced with
<a href="/docs/reference/access-authn-authz/rbac/">RBAC</a> or any other <a href="/docs/reference/access-authn-authz/authorization/">authorization</a>
mechanism.</p></li><li><p>A cluster administrator creates at least one ResourceQuota for each namespace.</p><ul><li>To make sure the enforcement stays enforced, the cluster administrator should also restrict access to delete or update
that ResourceQuota; for example, by defining a <a href="/docs/reference/access-authn-authz/validating-admission-policy/">ValidatingAdmissionPolicy</a>.</li></ul></li><li><p>Users create resources (pods, services, etc.) in the namespace, and the quota system
tracks usage to ensure it does not exceed hard resource limits defined in a ResourceQuota.</p><p>You can apply a <a href="#quota-scopes">scope</a> to a ResourceQuota to limit where it applies,</p></li><li><p>If creating or updating a resource violates a quota constraint, the control plane rejects that request with HTTP
status code <code>403 Forbidden</code>. The error includes a message explaining the constraint that would have been violated.</p></li><li><p>If quotas are enabled in a namespace for <a class="glossary-tooltip" title="A defined amount of infrastructure available for consumption (CPU, memory, etc)." data-toggle="tooltip" data-placement="top" href="/docs/reference/glossary/?all=true#term-infrastructure-resource" target="_blank" aria-label="resource">resource</a>
such as <code>cpu</code> and <code>memory</code>, users must specify requests or limits for those values when they define a Pod; otherwise,
the quota system may reject pod creation.</p><p>The resource quota <a href="/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/">walkthrough</a>
shows an example of how to avoid this problem.</p></li></ul><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4><ul><li>You can define a <a href="/docs/concepts/policy/limit-range/">LimitRange</a>
to force defaults on pods that make no compute resource requirements (so that users don't have to remember to do that).</li></ul></div><p>You often do not create Pods directly; for example, you more usually create a <a href="/docs/concepts/workloads/controllers/">workload management</a>
object such as a <a class="glossary-tooltip" title="Manages a replicated application on your cluster." data-toggle="tooltip" data-placement="top" href="/docs/concepts/workloads/controllers/deployment/" target="_blank" aria-label="Deployment">Deployment</a>. If you create a Deployment that tries to use more
resources than are available, the creation of the Deployment (or other workload management object) <strong>succeeds</strong>, but
the Deployment may not be able to get all of the Pods it manages to exist. In that case you can check the status of
the Deployment, for example with <code>kubectl describe</code>, to see what has happened.</p><ul><li>For <code>cpu</code> and <code>memory</code> resources, ResourceQuotas enforce that <strong>every</strong>
(new) pod in that namespace sets a limit for that resource.
If you enforce a resource quota in a namespace for either <code>cpu</code> or <code>memory</code>,
you and other clients, <strong>must</strong> specify either <code>requests</code> or <code>limits</code> for that resource,
for every new Pod you submit. If you don't, the control plane may reject admission
for that Pod.</li><li>For other resources: ResourceQuota works and will ignore pods in the namespace without
setting a limit or request for that resource. It means that you can create a new pod
without limit/request for ephemeral storage if the resource quota limits the ephemeral
storage of this namespace.</li></ul><p>You can use a <a href="/docs/concepts/policy/limit-range/">LimitRange</a> to automatically set
a default request for these resources.</p><p>The name of a ResourceQuota object must be a valid
<a href="/docs/concepts/overview/working-with-objects/names/#dns-subdomain-names">DNS subdomain name</a>.</p><p>Examples of policies that could be created using namespaces and quotas are:</p><ul><li>In a cluster with a capacity of 32 GiB RAM, and 16 cores, let team A use 20 GiB and 10 cores,
let B use 10GiB and 4 cores, and hold 2GiB and 2 cores in reserve for future allocation.</li><li>Limit the "testing" namespace to using 1 core and 1GiB RAM. Let the "production" namespace
use any amount.</li></ul><p>In the case where the total capacity of the cluster is less than the sum of the quotas of the namespaces,
there may be contention for resources. This is handled on a first-come-first-served basis.</p><h2 id="enabling-resource-quota">Enabling Resource Quota</h2><p>ResourceQuota support is enabled by default for many Kubernetes distributions. It is
enabled when the <a class="glossary-tooltip" title="Control plane component that serves the Kubernetes API." data-toggle="tooltip" data-placement="top" href="/docs/concepts/architecture/#kube-apiserver" target="_blank" aria-label="API server">API server</a>
<code>--enable-admission-plugins=</code> flag has <code>ResourceQuota</code> as
one of its arguments.</p><p>A resource quota is enforced in a particular namespace when there is a
ResourceQuota in that namespace.</p><h2 id="types-of-resource-quota">Types of resource quota</h2><p>The ResourceQuota mechanism lets you enforce different kinds of limits. This
section describes the types of limit that you can enforce.</p><h3 id="compute-resource-quota">Quota for infrastructure resources</h3><p>You can limit the total sum of
<a href="/docs/concepts/configuration/manage-resources-containers/">compute resources</a>
that can be requested in a given namespace.</p><p>The following resource types are supported:</p><table><thead><tr><th>Resource Name</th><th>Description</th></tr></thead><tbody><tr><td><code>limits.cpu</code></td><td>Across all pods in a non-terminal state, the sum of CPU limits cannot exceed this value.</td></tr><tr><td><code>limits.memory</code></td><td>Across all pods in a non-terminal state, the sum of memory limits cannot exceed this value.</td></tr><tr><td><code>requests.cpu</code></td><td>Across all pods in a non-terminal state, the sum of CPU requests cannot exceed this value.</td></tr><tr><td><code>requests.memory</code></td><td>Across all pods in a non-terminal state, the sum of memory requests cannot exceed this value.</td></tr><tr><td><code>hugepages-&lt;size&gt;</code></td><td>Across all pods in a non-terminal state, the number of huge page requests of the specified size cannot exceed this value.</td></tr><tr><td><code>cpu</code></td><td>Same as <code>requests.cpu</code></td></tr><tr><td><code>memory</code></td><td>Same as <code>requests.memory</code></td></tr></tbody></table><h3 id="quota-for-extended-resources">Quota for extended resources</h3><p>In addition to the resources mentioned above, in release 1.10, quota support for
<a href="/docs/concepts/configuration/manage-resources-containers/#extended-resources">extended resources</a> is added.</p><p>As overcommit is not allowed for extended resources, it makes no sense to specify both <code>requests</code>
and <code>limits</code> for the same extended resource in a quota. So for extended resources, only quota items
with prefix <code>requests.</code> are allowed.</p><p>Take the GPU resource as an example, if the resource name is <code>nvidia.com/gpu</code>, and you want to
limit the total number of GPUs requested in a namespace to 4, you can define a quota as follows:</p><ul><li><code>requests.nvidia.com/gpu: 4</code></li></ul><p>See <a href="#viewing-and-setting-quotas">Viewing and Setting Quotas</a> for more details.</p><h3 id="quota-for-storage">Quota for storage</h3><p>You can limit the total sum of <a href="/docs/concepts/storage/persistent-volumes/">storage</a> for volumes
that can be requested in a given namespace.</p><p>In addition, you can limit consumption of storage resources based on associated
<a href="/docs/concepts/storage/storage-classes/">StorageClass</a>.</p><table><thead><tr><th>Resource Name</th><th>Description</th></tr></thead><tbody><tr><td><code>requests.storage</code></td><td>Across all persistent volume claims, the sum of storage requests cannot exceed this value.</td></tr><tr><td><code>persistentvolumeclaims</code></td><td>The total number of <a href="/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims">PersistentVolumeClaims</a> that can exist in the namespace.</td></tr><tr><td><code>&lt;storage-class-name&gt;.storageclass.storage.k8s.io/requests.storage</code></td><td>Across all persistent volume claims associated with the <code>&lt;storage-class-name&gt;</code>, the sum of storage requests cannot exceed this value.</td></tr><tr><td><code>&lt;storage-class-name&gt;.storageclass.storage.k8s.io/persistentvolumeclaims</code></td><td>Across all persistent volume claims associated with the <code>&lt;storage-class-name&gt;</code>, the total number of <a href="/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims">persistent volume claims</a> that can exist in the namespace.</td></tr></tbody></table><p>For example, if you want to quota storage with <code>gold</code> StorageClass separate from
a <code>bronze</code> StorageClass, you can define a quota as follows:</p><ul><li><code>gold.storageclass.storage.k8s.io/requests.storage: 500Gi</code></li><li><code>bronze.storageclass.storage.k8s.io/requests.storage: 100Gi</code></li></ul><h4 id="quota-for-local-ephemeral-storage">Quota for local ephemeral storage</h4><div class="feature-state-notice feature-alpha"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.8 [alpha]</code></div><table><thead><tr><th>Resource Name</th><th>Description</th></tr></thead><tbody><tr><td><code>requests.ephemeral-storage</code></td><td>Across all pods in the namespace, the sum of local ephemeral storage requests cannot exceed this value.</td></tr><tr><td><code>limits.ephemeral-storage</code></td><td>Across all pods in the namespace, the sum of local ephemeral storage limits cannot exceed this value.</td></tr><tr><td><code>ephemeral-storage</code></td><td>Same as <code>requests.ephemeral-storage</code>.</td></tr></tbody></table><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4><p>When using a CRI container runtime, container logs will count against the ephemeral storage quota.
This can result in the unexpected eviction of pods that have exhausted their storage quotas.</p><p>Refer to <a href="/docs/concepts/cluster-administration/logging/">Logging Architecture</a> for details.</p></div><h3 id="quota-on-object-count">Quota on object count</h3><p>You can set quota for <em>the total number of one particular <a class="glossary-tooltip" title="A Kubernetes entity, representing an endpoint on the Kubernetes API server." data-toggle="tooltip" data-placement="top" href="/docs/reference/using-api/api-concepts/#standard-api-terminology" target="_blank" aria-label="resource">resource</a> kind</em> in the Kubernetes API,
using the following syntax:</p><ul><li><code>count/&lt;resource&gt;.&lt;group&gt;</code> for resources from non-core API groups</li><li><code>count/&lt;resource&gt;</code> for resources from the core API group</li></ul><p>For example, the PodTemplate API is in the core API group and so if you want to limit the number of
PodTemplate objects in a namespace, you use <code>count/podtemplates</code>.</p><p>These types of quotas are useful to protect against exhaustion of control plane storage. For example, you may
want to limit the number of Secrets in a server given their large size. Too many Secrets in a cluster can
actually prevent servers and controllers from starting. You can set a quota for Jobs to protect against
a poorly configured CronJob. CronJobs that create too many Jobs in a namespace can lead to a denial of service.</p><p>If you define a quota this way, it applies to Kubernetes' APIs that are part of the API server, and
to any custom resources backed by a CustomResourceDefinition.
For example, to create a quota on a <code>widgets</code> custom resource in the <code>example.com</code> API group,
use <code>count/widgets.example.com</code>.
If you use <a href="/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/">API aggregation</a> to
add additional, custom APIs that are not defined as CustomResourceDefinitions, the core Kubernetes
control plane does not enforce quota for the aggregated API. The extension API server is expected to
provide quota enforcement if that's appropriate for the custom API.</p><h5 id="resource-quota-object-count-generic">Generic syntax</h5><p>This is a list of common examples of object kinds that you may want to put under object count quota,
listed by the configuration string that you would use.</p><ul><li><code>count/pods</code></li><li><code>count/persistentvolumeclaims</code></li><li><code>count/services</code></li><li><code>count/secrets</code></li><li><code>count/configmaps</code></li><li><code>count/deployments.apps</code></li><li><code>count/replicasets.apps</code></li><li><code>count/statefulsets.apps</code></li><li><code>count/jobs.batch</code></li><li><code>count/cronjobs.batch</code></li></ul><h5 id="resource-quota-object-count-specialized">Specialized syntax</h5><p>There is another syntax only to set the same type of quota, that only works for certain API kinds.
The following types are supported:</p><table><thead><tr><th>Resource Name</th><th>Description</th></tr></thead><tbody><tr><td><code>configmaps</code></td><td>The total number of ConfigMaps that can exist in the namespace.</td></tr><tr><td><code>persistentvolumeclaims</code></td><td>The total number of <a href="/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims">PersistentVolumeClaims</a> that can exist in the namespace.</td></tr><tr><td><code>pods</code></td><td>The total number of Pods in a non-terminal state that can exist in the namespace. A pod is in a terminal state if <code>.status.phase in (Failed, Succeeded)</code> is true.</td></tr><tr><td><code>replicationcontrollers</code></td><td>The total number of ReplicationControllers that can exist in the namespace.</td></tr><tr><td><code>resourcequotas</code></td><td>The total number of ResourceQuotas that can exist in the namespace.</td></tr><tr><td><code>services</code></td><td>The total number of Services that can exist in the namespace.</td></tr><tr><td><code>services.loadbalancers</code></td><td>The total number of Services of type <code>LoadBalancer</code> that can exist in the namespace.</td></tr><tr><td><code>services.nodeports</code></td><td>The total number of <code>NodePorts</code> allocated to Services of type <code>NodePort</code> or <code>LoadBalancer</code> that can exist in the namespace.</td></tr><tr><td><code>secrets</code></td><td>The total number of Secrets that can exist in the namespace.</td></tr></tbody></table><p>For example, <code>pods</code> quota counts and enforces a maximum on the number of <code>pods</code>
created in a single namespace that are not terminal. You might want to set a <code>pods</code>
quota on a namespace to avoid the case where a user creates many small pods and
exhausts the cluster's supply of Pod IPs.</p><p>You can find more examples on <a href="#viewing-and-setting-quotas">Viewing and Setting Quotas</a>.</p><h2 id="viewing-and-setting-quotas">Viewing and Setting Quotas</h2><p>kubectl supports creating, updating, and viewing quotas:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl create namespace myspace
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>cat <span style="color:#b44">&lt;&lt;EOF &gt; compute-resources.yaml
</span></span></span><span style="display:flex"><span><span style="color:#b44">apiVersion: v1
</span></span></span><span style="display:flex"><span><span style="color:#b44">kind: ResourceQuota
</span></span></span><span style="display:flex"><span><span style="color:#b44">metadata:
</span></span></span><span style="display:flex"><span><span style="color:#b44">  name: compute-resources
</span></span></span><span style="display:flex"><span><span style="color:#b44">spec:
</span></span></span><span style="display:flex"><span><span style="color:#b44">  hard:
</span></span></span><span style="display:flex"><span><span style="color:#b44">    requests.cpu: "1"
</span></span></span><span style="display:flex"><span><span style="color:#b44">    requests.memory: "1Gi"
</span></span></span><span style="display:flex"><span><span style="color:#b44">    limits.cpu: "2"
</span></span></span><span style="display:flex"><span><span style="color:#b44">    limits.memory: "2Gi"
</span></span></span><span style="display:flex"><span><span style="color:#b44">    requests.nvidia.com/gpu: 4
</span></span></span><span style="display:flex"><span><span style="color:#b44">EOF</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl create -f ./compute-resources.yaml --namespace<span style="color:#666">=</span>myspace
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>cat <span style="color:#b44">&lt;&lt;EOF &gt; object-counts.yaml
</span></span></span><span style="display:flex"><span><span style="color:#b44">apiVersion: v1
</span></span></span><span style="display:flex"><span><span style="color:#b44">kind: ResourceQuota
</span></span></span><span style="display:flex"><span><span style="color:#b44">metadata:
</span></span></span><span style="display:flex"><span><span style="color:#b44">  name: object-counts
</span></span></span><span style="display:flex"><span><span style="color:#b44">spec:
</span></span></span><span style="display:flex"><span><span style="color:#b44">  hard:
</span></span></span><span style="display:flex"><span><span style="color:#b44">    configmaps: "10"
</span></span></span><span style="display:flex"><span><span style="color:#b44">    persistentvolumeclaims: "4"
</span></span></span><span style="display:flex"><span><span style="color:#b44">    pods: "4"
</span></span></span><span style="display:flex"><span><span style="color:#b44">    replicationcontrollers: "20"
</span></span></span><span style="display:flex"><span><span style="color:#b44">    secrets: "10"
</span></span></span><span style="display:flex"><span><span style="color:#b44">    services: "10"
</span></span></span><span style="display:flex"><span><span style="color:#b44">    services.loadbalancers: "2"
</span></span></span><span style="display:flex"><span><span style="color:#b44">EOF</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl create -f ./object-counts.yaml --namespace<span style="color:#666">=</span>myspace
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl get quota --namespace<span style="color:#666">=</span>myspace
</span></span></code></pre></div><pre tabindex="0"><code class="language-none" data-lang="none">NAME                    AGE
compute-resources       30s
object-counts           32s
</code></pre><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl describe quota compute-resources --namespace<span style="color:#666">=</span>myspace
</span></span></code></pre></div><pre tabindex="0"><code class="language-none" data-lang="none">Name:                    compute-resources
Namespace:               myspace
Resource                 Used  Hard
--------                 ----  ----
limits.cpu               0     2
limits.memory            0     2Gi
requests.cpu             0     1
requests.memory          0     1Gi
requests.nvidia.com/gpu  0     4
</code></pre><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl describe quota object-counts --namespace<span style="color:#666">=</span>myspace
</span></span></code></pre></div><pre tabindex="0"><code class="language-none" data-lang="none">Name:                   object-counts
Namespace:              myspace
Resource                Used    Hard
--------                ----    ----
configmaps              0       10
persistentvolumeclaims  0       4
pods                    0       4
replicationcontrollers  0       20
secrets                 1       10
services                0       10
services.loadbalancers  0       2
</code></pre><p>kubectl also supports object count quota for all standard namespaced resources
using the syntax <code>count/&lt;resource&gt;.&lt;group&gt;</code>:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl create namespace myspace
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl create quota <span style="color:#a2f">test</span> --hard<span style="color:#666">=</span>count/deployments.apps<span style="color:#666">=</span>2,count/replicasets.apps<span style="color:#666">=</span>4,count/pods<span style="color:#666">=</span>3,count/secrets<span style="color:#666">=</span><span style="color:#666">4</span> --namespace<span style="color:#666">=</span>myspace
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl create deployment nginx --image<span style="color:#666">=</span>nginx --namespace<span style="color:#666">=</span>myspace --replicas<span style="color:#666">=</span><span style="color:#666">2</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl describe quota --namespace<span style="color:#666">=</span>myspace
</span></span></code></pre></div><pre tabindex="0"><code>Name:                         test
Namespace:                    myspace
Resource                      Used  Hard
--------                      ----  ----
count/deployments.apps        1     2
count/pods                    2     3
count/replicasets.apps        1     4
count/secrets                 1     4
</code></pre><h2 id="quota-and-cluster-capacity">Quota and Cluster Capacity</h2><p>ResourceQuotas are independent of the cluster capacity. They are
expressed in absolute units. So, if you add nodes to your cluster, this does <em>not</em>
automatically give each namespace the ability to consume more resources.</p><p>Sometimes more complex policies may be desired, such as:</p><ul><li>Proportionally divide total cluster resources among several teams.</li><li>Allow each tenant to grow resource usage as needed, but have a generous
limit to prevent accidental resource exhaustion.</li><li>Detect demand from one namespace, add nodes, and increase quota.</li></ul><p>Such policies could be implemented using <code>ResourceQuotas</code> as building blocks, by
writing a "controller" that watches the quota usage and adjusts the quota
hard limits of each namespace according to other signals.</p><p>Note that resource quota divides up aggregate cluster resources, but it creates no
restrictions around nodes: pods from several namespaces may run on the same node.</p><h2 id="quota-scopes">Quota scopes</h2><p>Each quota can have an associated set of <code>scopes</code>. A quota will only measure usage for a resource if it matches
the intersection of enumerated scopes.</p><p>When a scope is added to the quota, it limits the number of resources it supports to those that pertain to the scope.
Resources specified on the quota outside of the allowed set results in a validation error.</p><p>Kubernetes 1.34 supports the following scopes:</p><table><thead><tr><th>Scope</th><th>Description</th></tr></thead><tbody><tr><td><a href="#quota-scope-best-effort"><code>BestEffort</code></a></td><td>Match pods that have best effort quality of service.</td></tr><tr><td><a href="#cross-namespace-pod-affinity-scope"><code>CrossNamespacePodAffinity</code></a></td><td>Match pods that have cross-namespace pod <a href="/docs/concepts/scheduling-eviction/assign-pod-node/">(anti)affinity terms</a>.</td></tr><tr><td><a href="#quota-scope-non-best-effort"><code>NotBestEffort</code></a></td><td>Match pods that do not have best effort quality of service.</td></tr><tr><td><a href="#quota-scope-non-terminating"><code>NotTerminating</code></a></td><td>Match pods where <code>.spec.activeDeadlineSeconds</code>]() is <code>nil</code>]()</td></tr><tr><td><a href="#resource-quota-per-priorityclass"><code>PriorityClass</code></a></td><td>Match pods that references the specified <a href="/docs/concepts/scheduling-eviction/pod-priority-preemption/">priority class</a>.</td></tr><tr><td><a href="#quota-scope-terminating"><code>Terminating</code></a></td><td>Match pods where <code>.spec.activeDeadlineSeconds</code>]() &gt;= <code>0</code>]()</td></tr><tr><td><a href="#quota-scope-volume-attributes-class"><code>VolumeAttributesClass</code></a></td><td>Match PersistentVolumeClaims that reference the specified <a href="/docs/concepts/storage/volume-attributes-classes/">volume attributes class</a>.</td></tr></tbody></table><p>ResourceQuotas with a scope set can also have a optional <code>scopeSelector</code> field. You define one or more <em>match expressions</em>
that specify an <code>operators</code> and, if relevant, a set of <code>values</code> to match. For example:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">scopeSelector</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">matchExpressions</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span>- <span style="color:green;font-weight:700">scopeName</span>:<span style="color:#bbb"> </span>BestEffort<span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># Match pods that have best effort quality of service</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">operator</span>:<span style="color:#bbb"> </span>Exists<span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># optional; "Exists" is implied for BestEffort scope</span><span style="color:#bbb">
</span></span></span></code></pre></div><p>The <code>scopeSelector</code> supports the following values in the <code>operator</code> field:</p><ul><li><code>In</code></li><li><code>NotIn</code></li><li><code>Exists</code></li><li><code>DoesNotExist</code></li></ul><p>If the <code>operator</code> is <code>In</code> or <code>NotIn</code>, the <code>values</code> field must have at least
one value. For example:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">scopeSelector</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">matchExpressions</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span>- <span style="color:green;font-weight:700">scopeName</span>:<span style="color:#bbb"> </span>PriorityClass<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">operator</span>:<span style="color:#bbb"> </span>In<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">values</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">          </span>- middle<span style="color:#bbb">
</span></span></span></code></pre></div><p>If the <code>operator</code> is <code>Exists</code> or <code>DoesNotExist</code>, the <code>values</code> field must <em>NOT</em> be
specified.</p><h3 id="quota-scope-best-effort">Best effort Pods scope</h3><p>This scope only tracks quota consumed by Pods.
It only matches pods that have the <a href="/docs/concepts/workloads/pods/pod-qos/#besteffort">best effort</a>
<a href="/docs/concepts/workloads/pods/pod-qos/">QoS class</a>.</p><p>The <code>operator</code> for a <code>scopeSelector</code> must be <code>Exists</code>.</p><h3 id="quota-scope-non-best-effort">Not-best-effort Pods scope</h3><p>This scope only tracks quota consumed by Pods.
It only matches pods that have the <a href="/docs/concepts/workloads/pods/pod-qos/#guaranteed">Guaranteed</a>
or <a href="/docs/concepts/workloads/pods/pod-qos/#burstable">Burstable</a>
<a href="/docs/concepts/workloads/pods/pod-qos/">QoS class</a>.</p><p>The <code>operator</code> for a <code>scopeSelector</code> must be <code>Exists</code>.</p><h3 id="quota-scope-non-terminating">Non-terminating Pods scope</h3><p>This scope only tracks quota consumed by Pods that are not terminating. The <code>operator</code> for a <code>scopeSelector</code>
must be <code>Exists</code>.</p><p>A Pod is not terminating if the <code>.spec.activeDeadlineSeconds</code> field is unset.</p><p>You can use a ResourceQuota with this scope to manage the following resources:</p><ul><li><code>count.pods</code></li><li><code>pods</code></li><li><code>cpu</code></li><li><code>memory</code></li><li><code>requests.cpu</code></li><li><code>requests.memory</code></li><li><code>limits.cpu</code></li><li><code>limits.memory</code></li></ul><h3 id="quota-scope-terminating">Terminating Pods scope</h3><p>This scope only tracks quota consumed by Pods that are terminating. The <code>operator</code> for a <code>scopeSelector</code>
must be <code>Exists</code>.</p><p>A Pod is considered as <em>terminating</em> if the <code>.spec.activeDeadlineSeconds</code> field is set to any number.</p><p>You can use a ResourceQuota with this scope to manage the following resources:</p><ul><li><code>count.pods</code></li><li><code>pods</code></li><li><code>cpu</code></li><li><code>memory</code></li><li><code>requests.cpu</code></li><li><code>requests.memory</code></li><li><code>limits.cpu</code></li><li><code>limits.memory</code></li></ul><h3 id="cross-namespace-pod-affinity-scope">Cross-namespace pod affinity scope</h3><div class="feature-state-notice feature-stable"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.24 [stable]</code></div><p>You can use <code>CrossNamespacePodAffinity</code> <a href="#quota-scopes">quota scope</a> to limit which namespaces are allowed to
have pods with affinity terms that cross namespaces. Specifically, it controls which pods are allowed
to set <code>namespaces</code> or <code>namespaceSelector</code> fields in pod <a href="/docs/concepts/scheduling-eviction/assign-pod-node/">(anti)affinity terms</a>.</p><p>Preventing users from using cross-namespace affinity terms might be desired since a pod
with anti-affinity constraints can block pods from all other namespaces
from getting scheduled in a failure domain.</p><p>Using this scope, you (as a cluster administrator) can prevent certain namespaces - such as <code>foo-ns</code> in the example below -
from having pods that use cross-namespace pod affinity. You configure this creating a ResourceQuota object in
that namespace with <code>CrossNamespacePodAffinity</code> scope and hard limit of 0:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>ResourceQuota<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">metadata</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>disable-cross-namespace-affinity<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">namespace</span>:<span style="color:#bbb"> </span>foo-ns<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">spec</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">hard</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">pods</span>:<span style="color:#bbb"> </span><span style="color:#b44">"0"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">scopeSelector</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">matchExpressions</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span>- <span style="color:green;font-weight:700">scopeName</span>:<span style="color:#bbb"> </span>CrossNamespacePodAffinity<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">operator</span>:<span style="color:#bbb"> </span>Exists<span style="color:#bbb">
</span></span></span></code></pre></div><p>If you want to disallow using <code>namespaces</code> and <code>namespaceSelector</code> by default, and
only allow it for specific namespaces, you could configure <code>CrossNamespacePodAffinity</code>
as a limited resource by setting the kube-apiserver flag <code>--admission-control-config-file</code>
to the path of the following configuration file:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>apiserver.config.k8s.io/v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>AdmissionConfiguration<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">plugins</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span><span style="color:#b44">"ResourceQuota"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">configuration</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>apiserver.config.k8s.io/v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>ResourceQuotaConfiguration<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">limitedResources</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span>- <span style="color:green;font-weight:700">resource</span>:<span style="color:#bbb"> </span>pods<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">matchScopes</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span>- <span style="color:green;font-weight:700">scopeName</span>:<span style="color:#bbb"> </span>CrossNamespacePodAffinity<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">operator</span>:<span style="color:#bbb"> </span>Exists<span style="color:#bbb">
</span></span></span></code></pre></div><p>With the above configuration, pods can use <code>namespaces</code> and <code>namespaceSelector</code> in pod affinity only
if the namespace where they are created have a resource quota object with
<code>CrossNamespacePodAffinity</code> scope and a hard limit greater than or equal to the number of pods using those fields.</p><h3 id="resource-quota-per-priorityclass">PriorityClass scope</h3><div class="feature-state-notice feature-stable"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.17 [stable]</code></div><p>A ResourceQuota with a PriorityClass scope only matches Pods that have a particular
<a href="/docs/concepts/scheduling-eviction/pod-priority-preemption/">priority class</a>, and only
if any <code>scopeSelector</code> in the quota spec selects a particular Pod.</p><p>Pods can be created at a specific <a href="/docs/concepts/scheduling-eviction/pod-priority-preemption/#pod-priority">priority</a>.
You can control a pod's consumption of system resources based on a pod's priority, by using the <code>scopeSelector</code>
field in the quota spec.</p><p>When quota is scoped for PriorityClass using the <code>scopeSelector</code> field, the ResourceQuota
can only track (and limit) the following resources:</p><ul><li><code>pods</code></li><li><code>cpu</code></li><li><code>memory</code></li><li><code>ephemeral-storage</code></li><li><code>limits.cpu</code></li><li><code>limits.memory</code></li><li><code>limits.ephemeral-storage</code></li><li><code>requests.cpu</code></li><li><code>requests.memory</code></li><li><code>requests.ephemeral-storage</code></li></ul><h4 id="quota-scope-priorityclass-example">Example</h4><p>This example creates a ResourceQuota matches it with pods at specific priorities. The example
works as follows:</p><ul><li>Pods in the cluster have one of the three <a href="/docs/concepts/scheduling-eviction/pod-priority-preemption/#priorityclass">PriorityClasses</a>, "low", "medium", "high".<ul><li>If you want to try this out, use a testing cluster and set up those three PriorityClasses before you continue.</li></ul></li><li>One quota object is created for each priority.</li></ul><p>Inspect this set of ResourceQuotas:</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/policy/quota.yaml" download="policy/quota.yaml"><code>policy/quota.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" onclick="copyCode(&quot;policy-quota-yaml&quot;)" title="Copy policy/quota.yaml to clipboard"/></div><div class="includecode" id="policy-quota-yaml"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>ResourceQuota<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">metadata</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>pods-high<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">spec</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">hard</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">cpu</span>:<span style="color:#bbb"> </span><span style="color:#b44">"1000"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">memory</span>:<span style="color:#bbb"> </span><span style="color:#b44">"200Gi"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">pods</span>:<span style="color:#bbb"> </span><span style="color:#b44">"10"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">scopeSelector</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">matchExpressions</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span>- <span style="color:green;font-weight:700">operator</span>:<span style="color:#bbb"> </span>In<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">scopeName</span>:<span style="color:#bbb"> </span>PriorityClass<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">values</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">"high"</span>]<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:#00f;font-weight:700">---</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>ResourceQuota<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">metadata</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>pods-medium<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">spec</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">hard</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">cpu</span>:<span style="color:#bbb"> </span><span style="color:#b44">"10"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">memory</span>:<span style="color:#bbb"> </span><span style="color:#b44">"20Gi"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">pods</span>:<span style="color:#bbb"> </span><span style="color:#b44">"10"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">scopeSelector</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">matchExpressions</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span>- <span style="color:green;font-weight:700">operator</span>:<span style="color:#bbb"> </span>In<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">scopeName</span>:<span style="color:#bbb"> </span>PriorityClass<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">values</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">"medium"</span>]<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:#00f;font-weight:700">---</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>ResourceQuota<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">metadata</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>pods-low<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">spec</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">hard</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">cpu</span>:<span style="color:#bbb"> </span><span style="color:#b44">"5"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">memory</span>:<span style="color:#bbb"> </span><span style="color:#b44">"10Gi"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">pods</span>:<span style="color:#bbb"> </span><span style="color:#b44">"10"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">scopeSelector</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">matchExpressions</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span>- <span style="color:green;font-weight:700">operator</span>:<span style="color:#bbb"> </span>In<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">scopeName</span>:<span style="color:#bbb"> </span>PriorityClass<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">values</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">"low"</span>]<span style="color:#bbb">
</span></span></span></code></pre></div></div></div><p>Apply the YAML using <code>kubectl create</code>.</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl create -f https://k8s.io/examples/policy/quota.yaml
</span></span></code></pre></div><pre tabindex="0"><code>resourcequota/pods-high created
resourcequota/pods-medium created
resourcequota/pods-low created
</code></pre><p>Verify that <code>Used</code> quota is <code>0</code> using <code>kubectl describe quota</code>.</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl describe quota
</span></span></code></pre></div><pre tabindex="0"><code>Name:       pods-high
Namespace:  default
Resource    Used  Hard
--------    ----  ----
cpu         0     1k
memory      0     200Gi
pods        0     10


Name:       pods-low
Namespace:  default
Resource    Used  Hard
--------    ----  ----
cpu         0     5
memory      0     10Gi
pods        0     10


Name:       pods-medium
Namespace:  default
Resource    Used  Hard
--------    ----  ----
cpu         0     10
memory      0     20Gi
pods        0     10
</code></pre><p>Create a pod with priority "high".</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/policy/high-priority-pod.yaml" download="policy/high-priority-pod.yaml"><code>policy/high-priority-pod.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" onclick="copyCode(&quot;policy-high-priority-pod-yaml&quot;)" title="Copy policy/high-priority-pod.yaml to clipboard"/></div><div class="includecode" id="policy-high-priority-pod-yaml"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>Pod<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">metadata</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>high-priority<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">spec</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">containers</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>high-priority<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">image</span>:<span style="color:#bbb"> </span>ubuntu<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">command</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">"/bin/sh"</span>]<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">args</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">"-c"</span>,<span style="color:#bbb"> </span><span style="color:#b44">"while true; do echo hello; sleep 10;done"</span>]<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">resources</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">requests</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">memory</span>:<span style="color:#bbb"> </span><span style="color:#b44">"10Gi"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">cpu</span>:<span style="color:#bbb"> </span><span style="color:#b44">"500m"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">limits</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">memory</span>:<span style="color:#bbb"> </span><span style="color:#b44">"10Gi"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">cpu</span>:<span style="color:#bbb"> </span><span style="color:#b44">"500m"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">priorityClassName</span>:<span style="color:#bbb"> </span>high<span style="color:#bbb">
</span></span></span></code></pre></div></div></div><p>To create the Pod:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl create -f https://k8s.io/examples/policy/high-priority-pod.yaml
</span></span></code></pre></div><p>Verify that "Used" stats for "high" priority quota, <code>pods-high</code>, has changed and that
the other two quotas are unchanged.</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl describe quota
</span></span></code></pre></div><pre tabindex="0"><code>Name:       pods-high
Namespace:  default
Resource    Used  Hard
--------    ----  ----
cpu         500m  1k
memory      10Gi  200Gi
pods        1     10


Name:       pods-low
Namespace:  default
Resource    Used  Hard
--------    ----  ----
cpu         0     5
memory      0     10Gi
pods        0     10


Name:       pods-medium
Namespace:  default
Resource    Used  Hard
--------    ----  ----
cpu         0     10
memory      0     20Gi
pods        0     10
</code></pre><h4 id="limiting-priorityclass-consumption-by-default">Limiting PriorityClass consumption by default</h4><p>It may be desired that pods at a particular priority, such as "cluster-services",
should be allowed in a namespace, if and only if, a matching quota object exists.</p><p>With this mechanism, operators are able to restrict usage of certain high
priority classes to a limited number of namespaces and not every namespace
will be able to consume these priority classes by default.</p><p>To enforce this, <code>kube-apiserver</code> flag <code>--admission-control-config-file</code> should be
used to pass path to the following configuration file:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>apiserver.config.k8s.io/v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>AdmissionConfiguration<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">plugins</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span><span style="color:#b44">"ResourceQuota"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">configuration</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>apiserver.config.k8s.io/v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>ResourceQuotaConfiguration<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">limitedResources</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span>- <span style="color:green;font-weight:700">resource</span>:<span style="color:#bbb"> </span>pods<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">matchScopes</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span>- <span style="color:green;font-weight:700">scopeName</span>:<span style="color:#bbb"> </span>PriorityClass<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">operator</span>:<span style="color:#bbb"> </span>In<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">values</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">"cluster-services"</span>]<span style="color:#bbb">
</span></span></span></code></pre></div><p>Then, create a resource quota object in the <code>kube-system</code> namespace:</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/policy/priority-class-resourcequota.yaml" download="policy/priority-class-resourcequota.yaml"><code>policy/priority-class-resourcequota.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" onclick="copyCode(&quot;policy-priority-class-resourcequota-yaml&quot;)" title="Copy policy/priority-class-resourcequota.yaml to clipboard"/></div><div class="includecode" id="policy-priority-class-resourcequota-yaml"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>ResourceQuota<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">metadata</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>pods-cluster-services<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">spec</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">scopeSelector</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">matchExpressions</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span>- <span style="color:green;font-weight:700">operator </span>:<span style="color:#bbb"> </span>In<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">scopeName</span>:<span style="color:#bbb"> </span>PriorityClass<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">values</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">"cluster-services"</span>]</span></span></code></pre></div></div></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl apply -f https://k8s.io/examples/policy/priority-class-resourcequota.yaml -n kube-system
</span></span></code></pre></div><pre tabindex="0"><code class="language-none" data-lang="none">resourcequota/pods-cluster-services created
</code></pre><p>In this case, a pod creation will be allowed if:</p><ol><li>the Pod's <code>priorityClassName</code> is not specified.</li><li>the Pod's <code>priorityClassName</code> is specified to a value other than <code>cluster-services</code>.</li><li>the Pod's <code>priorityClassName</code> is set to <code>cluster-services</code>, it is to be created
in the <code>kube-system</code> namespace, and it has passed the resource quota check.</li></ol><p>A Pod creation request is rejected if its <code>priorityClassName</code> is set to <code>cluster-services</code>
and it is to be created in a namespace other than <code>kube-system</code>.</p><h3 id="quota-scope-volume-attributes-class">VolumeAttributesClass scope</h3><div class="feature-state-notice feature-stable" title="Feature Gate: VolumeAttributesClass"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.34 [stable]</code> (enabled by default: true)</div><p>This scope only tracks quota consumed by PersistentVolumeClaims.</p><p>PersistentVolumeClaims can be created with a specific
<a href="/docs/concepts/storage/volume-attributes-classes/">VolumeAttributesClass</a>, and might be modified after creation.
You can control a PVC's consumption of storage resources based on the associated
VolumeAttributesClasses, by using the <code>scopeSelector</code> field in the quota spec.</p><p>The PVC references the associated VolumeAttributesClass by the following fields:</p><ul><li><code>spec.volumeAttributesClassName</code></li><li><code>status.currentVolumeAttributesClassName</code></li><li><code>status.modifyVolumeStatus.targetVolumeAttributesClassName</code></li></ul><p>A relevant ResourceQuota is matched and consumed only if the ResourceQuota has a <code>scopeSelector</code> that selects the PVC.</p><p>When the quota is scoped for the volume attributes class using the <code>scopeSelector</code> field, the quota object is restricted to track only the following resources:</p><ul><li><code>persistentvolumeclaims</code></li><li><code>requests.storage</code></li></ul><p>Read <a href="/docs/tasks/administer-cluster/limit-storage-consumption/">Limit Storage Consumption</a> to learn more about this.</p><h2 id="what-s-next">What's next</h2><ul><li>See a <a href="/docs/tasks/administer-cluster/quota-api-object/">detailed example for how to use resource quota</a>.</li><li>Read the ResourceQuota <a href="/docs/reference/kubernetes-api/policy-resources/resource-quota-v1/">API reference</a></li><li>Learn about <a href="/docs/concepts/policy/limit-range/">LimitRanges</a></li><li>You can read the historical <a href="https://git.k8s.io/design-proposals-archive/resource-management/admission_control_resource_quota.md">ResourceQuota design document</a>
for more information.</li><li>You can also read the <a href="https://git.k8s.io/design-proposals-archive/scheduling/pod-priority-resourcequota.md">Quota support for priority class design document</a>.</li></ul></div>