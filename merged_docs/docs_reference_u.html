<hr>
<div class="td-content"><h1 data-pagefind-weight="10">Declarative API Validation</h1><div class="feature-state-notice feature-beta"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.33 [beta]</code></div><p>Kubernetes 1.34 includes optional <em>declarative validation</em> for APIs. When enabled, the Kubernetes API server can use this mechanism rather than the legacy approach that relies on hand-written Go
code (<code>validation.go</code> files) to ensure that requests against the API are valid.
Kubernetes developers, and people <a href="/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/">extending the Kubernetes API</a>,
can define validation rules directly alongside the API type definitions (<code>types.go</code> files). Code authors define
special comment tags (e.g., <code>+k8s:minimum=0</code>). A code generator (<code>validation-gen</code>) then uses these tags to produce
optimized Go code for API validation.</p><p>While primarily a feature impacting Kubernetes contributors and potentially developers of <a href="/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/">extension API servers</a>, cluster administrators should understand its behavior, especially during its rollout phases.</p><p>Declarative validation is being rolled out gradually.
In Kubernetes 1.34, the APIs that use declarative validation include:</p><ul><li><a href="/docs/concepts/workloads/controllers/replicationcontroller/">ReplicationController</a></li></ul><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>For the beta of this feature, Kubernetes is intentionally using a superseded API as a test bed for the change.
Future Kubernetes releases may roll this out to more APIs.</div><ul><li><code>DeclarativeValidation</code>: (Beta, Default: <code>true</code>) When enabled, the API server runs <em>both</em> the new declarative validation and the old hand-written validation for migrated types/fields. The results are compared internally.</li><li><code>DeclarativeValidationTakeover</code>: (Beta, Default: <code>false</code>) This gate determines which validation result is <em>authoritative</em> (i.e., returned to the user and used for admission decisions).</li></ul><p><strong>Default Behavior (Kubernetes 1.34):</strong></p><ul><li>With <code>DeclarativeValidation=true</code> and <code>DeclarativeValidationTakeover=false</code> (the default values for the gates), both validation systems run.</li><li><strong>The results of the <em>hand-written</em> validation are used.</strong> The declarative validation runs in a mismatch mode for comparison.</li><li>Mismatches between the two validation systems are logged by the API server and increment the <code>declarative_validation_mismatch_total</code> metric. This helps developers identify and fix discrepancies during the Beta phase.</li><li><strong>Cluster upgrades should be safe</strong> regarding this feature, as the authoritative validation logic doesn't change by default.</li></ul><p>Administrators can choose to explicitly enable <code>DeclarativeValidationTakeover=true</code> to make the <em>declarative</em> validation authoritative for migrated fields, typically after verifying stability in their environment (e.g., by monitoring the mismatch metric).</p><h2 id="opt-out">Disabling declarative validation</h2><p>As a cluster administrator, you might consider disabling declarative validation whilst it is still beta, under specific circumstances:</p><ul><li><strong>Unexpected Validation Behavior:</strong> If enabling <code>DeclarativeValidationTakeover</code> leads to unexpected validation errors or allows objects that were previously invalid.</li><li><strong>Performance Regressions:</strong> If monitoring indicates significant latency increases (e.g., in <code>apiserver_request_duration_seconds</code>) correlated with the feature's enablement.</li><li><strong>High Mismatch Rate:</strong> If the <code>declarative_validation_mismatch_total</code> metric shows frequent mismatches, suggesting potential bugs in the declarative rules affecting the cluster's workloads, even if <code>DeclarativeValidationTakeover</code> is false.</li></ul><p>To revert to only using hand-written validation (as used before Kubernetes v1.33), disable the <code>DeclarativeValidation</code> feature gate, for example
via command-line arguments: (<code>--feature-gates=DeclarativeValidation=false</code>). This also implicitly disables the effect of <code>DeclarativeValidationTakeover</code>.</p><h2 id="considerations-for-downgrade-and-rollback">Considerations for downgrade and rollback</h2><p>Disabling the feature acts as a safety mechanism. However, be aware of a potential edge case (considered unlikely due to extensive testing): If a bug in declarative validation (when <code>DeclarativeValidationTakeover=true</code>) <em>incorrectly allowed</em> an invalid object to be persisted, disabling the feature gates might then cause subsequent updates to that specific object to be blocked by the now-authoritative (and correct) hand-written validation. Resolving this might require manual correction of the stored object, potentially via direct etcd modification in rare cases.</p><p>For details on managing feature gates, see <a href="/docs/reference/command-line-tools-reference/feature-gates/">Feature Gates</a>.</p><h2 id="declarative-validation-tag-reference">Declarative validation tag reference</h2><p>This document provides a comprehensive reference for all available declarative validation tags.</p><h3 id="catalog">Tag catalog</h3><table><thead><tr><th>Tag</th><th>Description</th></tr></thead><tbody><tr><td><a href="#tag-eachKey"><code>+k8s:eachKey</code></a></td><td>Declares a validation for each key in a map.</td></tr><tr><td><a href="#tag-eachVal"><code>+k8s:eachVal</code></a></td><td>Declares a validation for each value in a map or list.</td></tr><tr><td><a href="#tag-enum"><code>+k8s:enum</code></a></td><td>Indicates that a string type is an enum.</td></tr><tr><td><a href="#tag-forbidden"><code>+k8s:forbidden</code></a></td><td>Indicates that a field may not be specified.</td></tr><tr><td><a href="#tag-format"><code>+k8s:format</code></a></td><td>Indicates that a string field has a particular format.</td></tr><tr><td><a href="#tag-ifDisabled"><code>+k8s:ifDisabled</code></a></td><td>Declares a validation that only applies when an option is disabled.</td></tr><tr><td><a href="#tag-ifEnabled"><code>+k8s:ifEnabled</code></a></td><td>Declares a validation that only applies when an option is enabled.</td></tr><tr><td><a href="#tag-isSubresource"><code>+k8s:isSubresource</code></a></td><td>Specifies that validations in a package only apply to a specific subresource.</td></tr><tr><td><a href="#tag-item"><code>+k8s:item</code></a></td><td>Declares a validation for an item of a slice declared as a <code>+k8s:listType=map</code>.</td></tr><tr><td><a href="#tag-listMapKey"><code>+k8s:listMapKey</code></a></td><td>Declares a named sub-field of a list's value-type to be part of the list-map key.</td></tr><tr><td><a href="#tag-listType"><code>+k8s:listType</code></a></td><td>Declares a list field's semantic type.</td></tr><tr><td><a href="#tag-maxItems"><code>+k8s:maxItems</code></a></td><td>Indicates that a list field has a limit on its size.</td></tr><tr><td><a href="#tag-maxLength"><code>+k8s:maxLength</code></a></td><td>Indicates that a string field has a limit on its length.</td></tr><tr><td><a href="#tag-minimum"><code>+k8s:minimum</code></a></td><td>Indicates that a numeric field has a minimum value.</td></tr><tr><td><a href="#tag-neq"><code>+k8s:neq</code></a></td><td>Verifies the field's value is not equal to a specific disallowed value.</td></tr><tr><td><a href="#tag-opaqueType"><code>+k8s:opaqueType</code></a></td><td>Indicates that any validations declared on the referenced type will be ignored.</td></tr><tr><td><a href="#tag-optional"><code>+k8s:optional</code></a></td><td>Indicates that a field is optional to clients.</td></tr><tr><td><a href="#tag-required"><code>+k8s:required</code></a></td><td>Indicates that a field must be specified by clients.</td></tr><tr><td><a href="#tag-subfield"><code>+k8s:subfield</code></a></td><td>Declares a validation for a subfield of a struct.</td></tr><tr><td><a href="#tag-supportsSubresource"><code>+k8s:supportsSubresource</code></a></td><td>Declares a supported subresource for the types within a package.</td></tr><tr><td><a href="#tag-unionDiscriminator"><code>+k8s:unionDiscriminator</code></a></td><td>Indicates that this field is the discriminator for a union.</td></tr><tr><td><a href="#tag-unionMember"><code>+k8s:unionMember</code></a></td><td>Indicates that this field is a member of a union group.</td></tr><tr><td><a href="#tag-zeroOrOneOfMember"><code>+k8s:zeroOrOneOfMember</code></a></td><td>Indicates that this field is a member of a zero-or-one-of group.</td></tr></tbody></table><hr/><h2 id="tag-reference">Tag Reference</h2><h3 id="tag-eachKey"><code>+k8s:eachKey</code></h3><p><strong>Description:</strong></p><p>Declares a validation for each key in a map.</p><p><strong>Payload:</strong></p><ul><li><code>&lt;validation-tag&gt;</code>: The tag to evaluate for each key.</li></ul><p><strong>Usage Example:</strong></p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="display:flex"><span><span style="color:#a2f;font-weight:700">type</span> MyStruct <span style="color:#a2f;font-weight:700">struct</span> {
</span></span><span style="display:flex"><span>    <span style="color:#080;font-style:italic">// +k8s:eachKey=+k8s:minimum=1
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>    MyMap <span style="color:#a2f;font-weight:700">map</span>[<span style="color:#0b0;font-weight:700">int</span>]<span style="color:#0b0;font-weight:700">string</span> <span style="color:#b44">`json:"myMap"`</span>
</span></span><span style="display:flex"><span>}
</span></span></code></pre></div><p>In this example, <code>eachKey</code> is used to specify that the <code>+k8s:minimum</code> tag should be applied to each <code>int</code> key in <code>MyMap</code>. This means that all keys in the map must be &gt;= 1.</p><h3 id="tag-eachVal"><code>+k8s:eachVal</code></h3><p><strong>Description:</strong></p><p>Declares a validation for each value in a map or list.</p><p><strong>Payload:</strong></p><ul><li><code>&lt;validation-tag&gt;</code>: The tag to evaluate for each value.</li></ul><p><strong>Usage Example:</strong></p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="display:flex"><span><span style="color:#a2f;font-weight:700">type</span> MyStruct <span style="color:#a2f;font-weight:700">struct</span> {
</span></span><span style="display:flex"><span>    <span style="color:#080;font-style:italic">// +k8s:eachVal=+k8s:minimum=1
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>    MyMap <span style="color:#a2f;font-weight:700">map</span>[<span style="color:#0b0;font-weight:700">string</span>]<span style="color:#0b0;font-weight:700">int</span> <span style="color:#b44">`json:"myMap"`</span>
</span></span><span style="display:flex"><span>}
</span></span></code></pre></div><p>In this example, <code>eachVal</code> is used to specify that the <code>+k8s:minimum</code> tag should be applied to each element in <code>MyList</code>. This means that all fields in <code>MyStruct</code> must be &gt;= 1.</p><h3 id="tag-enum"><code>+k8s:enum</code></h3><p><strong>Description:</strong></p><p>Indicates that a string type is an enum. All const values of this type are considered values in the enum.</p><p><strong>Usage Example:</strong></p><p>First, define a new string type and some constants of that type:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="display:flex"><span><span style="color:#080;font-style:italic">// +k8s:enum
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/><span style="color:#a2f;font-weight:700">type</span> MyEnum <span style="color:#0b0;font-weight:700">string</span>
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span><span style="color:#a2f;font-weight:700">const</span> (
</span></span><span style="display:flex"><span>    MyEnumA MyEnum = <span style="color:#b44">"A"</span>
</span></span><span style="display:flex"><span>    MyEnumB MyEnum = <span style="color:#b44">"B"</span>
</span></span><span style="display:flex"><span>)
</span></span></code></pre></div><p>Then, use this type in another struct:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="display:flex"><span><span style="color:#a2f;font-weight:700">type</span> MyStruct <span style="color:#a2f;font-weight:700">struct</span> {
</span></span><span style="display:flex"><span>    MyField MyEnum <span style="color:#b44">`json:"myField"`</span>
</span></span><span style="display:flex"><span>}
</span></span></code></pre></div><p>The validation logic will ensure that <code>MyField</code> is one of the defined enum values (<code>"A"</code> or <code>"B"</code>).</p><h3 id="tag-forbidden"><code>+k8s:forbidden</code></h3><p><strong>Description:</strong></p><p>Indicates that a field may not be specified.</p><p><strong>Usage Example:</strong></p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="display:flex"><span><span style="color:#a2f;font-weight:700">type</span> MyStruct <span style="color:#a2f;font-weight:700">struct</span> {
</span></span><span style="display:flex"><span>    <span style="color:#080;font-style:italic">// +k8s:forbidden
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>    MyField <span style="color:#0b0;font-weight:700">string</span> <span style="color:#b44">`json:"myField"`</span>
</span></span><span style="display:flex"><span>}
</span></span></code></pre></div><p>In this example, <code>MyField</code> cannot be provided (it is forbidden) when creating or updating <code>MyStruct</code>.</p><h3 id="tag-format"><code>+k8s:format</code></h3><p><strong>Description:</strong></p><p>Indicates that a string field has a particular format.</p><p><strong>Payloads:</strong></p><ul><li><code>k8s-ip</code>: This field holds an IPv4 or IPv6 address value. IPv4 octets may have leading zeros.</li><li><code>k8s-long-name</code>: This field holds a Kubernetes "long name", aka a "DNS subdomain" value.</li><li><code>k8s-short-name</code>: This field holds a Kubernetes "short name", aka a "DNS label" value.</li></ul><p><strong>Usage Example:</strong></p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="display:flex"><span><span style="color:#a2f;font-weight:700">type</span> MyStruct <span style="color:#a2f;font-weight:700">struct</span> {
</span></span><span style="display:flex"><span>    <span style="color:#080;font-style:italic">// +k8s:format=k8s-ip
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>    IPAddress <span style="color:#0b0;font-weight:700">string</span> <span style="color:#b44">`json:"ipAddress"`</span>
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span>    <span style="color:#080;font-style:italic">// +k8s:format=k8s-long-name
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>    Subdomain <span style="color:#0b0;font-weight:700">string</span> <span style="color:#b44">`json:"subdomain"`</span>
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span>    <span style="color:#080;font-style:italic">// +k8s:format=k8s-short-name
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>    Label <span style="color:#0b0;font-weight:700">string</span> <span style="color:#b44">`json:"label"`</span>
</span></span><span style="display:flex"><span>}
</span></span></code></pre></div><p>In this example:</p><ul><li><code>IPAddress</code> must be a valid IP address.</li><li><code>Subdomain</code> must be a valid DNS subdomain.</li><li><code>Label</code> must be a valid DNS label.</li></ul><h3 id="tag-ifDisabled"><code>+k8s:ifDisabled</code></h3><p><strong>Description:</strong></p><p>Declares a validation that only applies when an option is disabled.</p><p><strong>Arguments:</strong></p><ul><li><code>&lt;option&gt;</code> (string, required): The name of the option.</li></ul><p><strong>Payload:</strong></p><ul><li><code>&lt;validation-tag&gt;</code>: This validation tag will be evaluated only if the validation option is disabled.</li></ul><p><strong>Usage Example:</strong></p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="display:flex"><span><span style="color:#a2f;font-weight:700">type</span> MyStruct <span style="color:#a2f;font-weight:700">struct</span> {
</span></span><span style="display:flex"><span>    <span style="color:#080;font-style:italic">// +k8s:ifDisabled("my-feature")=+k8s:required
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>    MyField <span style="color:#0b0;font-weight:700">string</span> <span style="color:#b44">`json:"myField"`</span>
</span></span><span style="display:flex"><span>}
</span></span></code></pre></div><p>In this example, <code>MyField</code> is required only if the "my-feature" option is disabled.</p><h3 id="tag-ifEnabled"><code>+k8s:ifEnabled</code></h3><p><strong>Description:</strong></p><p>Declares a validation that only applies when an option is enabled.</p><p><strong>Arguments:</strong></p><ul><li><code>&lt;option&gt;</code> (string, required): The name of the option.</li></ul><p><strong>Payload:</strong></p><ul><li><code>&lt;validation-tag&gt;</code>: This validation tag will be evaluated only if the validation option is enabled.</li></ul><p><strong>Usage Example:</strong></p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="display:flex"><span><span style="color:#a2f;font-weight:700">type</span> MyStruct <span style="color:#a2f;font-weight:700">struct</span> {
</span></span><span style="display:flex"><span>    <span style="color:#080;font-style:italic">// +k8s:ifEnabled("my-feature")=+k8s:required
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>    MyField <span style="color:#0b0;font-weight:700">string</span> <span style="color:#b44">`json:"myField"`</span>
</span></span><span style="display:flex"><span>}
</span></span></code></pre></div><p>In this example, <code>MyField</code> is required only if the "my-feature" option is enabled.</p><h3 id="tag-isSubresource"><code>+k8s:isSubresource</code></h3><p><strong>Description:</strong></p><p>The <code>+k8s:isSubresource</code> tag is a package-level comment that <strong>scopes the validation rules within that package to a specific subresource</strong>. It essentially tells the code generator, "The validation logic defined here is the specific implementation for this subresource and should not be applied to the root object or any other subresource."</p><p><strong>CRITICAL DEPENDENCY:</strong></p><p>This tag is <strong>dependent</strong> on a corresponding <code>+k8s:supportsSubresource</code> tag being present in the package where the main API type is defined.</p><ul><li><code>+k8s:supportsSubresource</code> opens the door by telling the dispatcher that a subresource is valid.</li><li><code>+k8s:isSubresource</code> provides the specialized validation logic that runs when a request comes through that door.</li></ul><p>If you use <code>+k8s:isSubresource</code> without the corresponding <code>+k8s:supportsSubresource</code> declaration on the main type, the specialized validation code will be generated but will be <strong>unreachable</strong>. The main dispatcher will not recognize the subresource path and will reject the request before it can be routed to your specific validation logic.</p><p>This dependency allows for powerful organization, such as placing your main API types in one package and defining their subresource-specific validations in separate, dedicated packages.</p><p><strong>Scope:</strong> Package</p><p><strong>Payload:</strong></p><ul><li><code>&lt;subresource-path&gt;</code>: The path of the subresource to which the validations in this package should apply (e.g., <code>"/status"</code>, <code>"/scale"</code>).</li></ul><p><strong>Usage Example:</strong></p><p>This two-part example demonstrates the intended use case of separating concerns.</p><p><strong>1. Declare Support in the Main API Package:</strong>
First, declare that the <code>Deployment</code> type supports <code>/scale</code> validation in its primary package.</p><p><em>File: <code>staging/src/k8s.io/api/apps/v1/doc.go</code></em></p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="display:flex"><span><span style="color:#080;font-style:italic">// This enables the validation dispatcher to handle requests for "/scale".
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic">// +k8s:supportsSubresource="/scale"
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/><span style="color:#a2f;font-weight:700">package</span> v1
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span><span style="color:#080;font-style:italic">// ... includes the definition for the Deployment type
</span></span></span></code></pre></div><p><strong>2. Scope Validation Logic in a Separate Package:</strong>
Next, create a separate package for the validation rules that are specific <em>only</em> to the <code>/scale</code> subresource.</p><p><em>File: <code>staging/src/k8s.io/api/apps/v1/validations/scale/doc.go</code></em></p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="display:flex"><span><span style="color:#080;font-style:italic">// This ensures the rules in this package ONLY run for the "/scale" subresource.
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic">// +k8s:isSubresource="/scale"
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/><span style="color:#a2f;font-weight:700">package</span> scale
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span><span style="color:#a2f;font-weight:700">import</span> <span style="color:#b44">"k8s.io/api/apps/v1"</span>
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span><span style="color:#080;font-style:italic">// Validation code in this package would reference types from package v1 (e.g., v1.Scale).
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic">// The generated validation function will only be invoked for requests to the "/scale"
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic">// subresource of a type defined in a package that supports it.
</span></span></span></code></pre></div><h3 id="tag-item"><code>+k8s:item</code></h3><p><strong>Description:</strong></p><p>Declares a validation for an item of a slice declared as a <code>+k8s:listType=map</code>. The item to match is declared by providing field-value pair arguments where the field is a <code>listMapKey</code>. All <code>listMapKey</code> key fields must be specified.</p><p><strong>Usage:</strong></p><p><code>+k8s:item(&lt;listMapKey-JSON-field-name&gt;: &lt;value&gt;,...)=&lt;validation-tag&gt;</code></p><p><code>+k8s:item(stringKey: "value", intKey: 42, boolKey: true)=&lt;validation-tag&gt;</code></p><p>Arguments must be named with the JSON names of the list-map key fields. Values can be strings, integers, or booleans.</p><p><strong>Payload:</strong></p><ul><li><code>&lt;validation-tag&gt;</code>: The tag to evaluate for the matching list item.</li></ul><p><strong>Usage Example:</strong></p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="display:flex"><span><span style="color:#a2f;font-weight:700">type</span> MyStruct <span style="color:#a2f;font-weight:700">struct</span> {
</span></span><span style="display:flex"><span>	<span style="color:#080;font-style:italic">// +k8s:listType=map
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>	<span style="color:#080;font-style:italic">// +k8s:listMapKey=type
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>	<span style="color:#080;font-style:italic">// +k8s:item(type: "Approved")=+k8s:zeroOrOneOfMember
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>	<span style="color:#080;font-style:italic">// +k8s:item(type: "Denied")=+k8s:zeroOrOneOfMember
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>	MyConditions []MyCondition <span style="color:#b44">`json:"conditions"`</span>
</span></span><span style="display:flex"><span>}
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span><span style="color:#a2f;font-weight:700">type</span> MyCondition <span style="color:#a2f;font-weight:700">struct</span> {
</span></span><span style="display:flex"><span>    Type <span style="color:#0b0;font-weight:700">string</span> <span style="color:#b44">`json:"type"`</span>
</span></span><span style="display:flex"><span>    Status <span style="color:#0b0;font-weight:700">string</span> <span style="color:#b44">`json:"status"`</span>
</span></span><span style="display:flex"><span>}
</span></span></code></pre></div><p>In this example:</p><ul><li>The condition with <code>type</code> "Approved" is part of a zero-or-one-of group.</li><li>The condition with <code>type</code> "Denied" is part of a zero-or-one-of group.</li></ul><h3 id="tag-listMapKey"><code>+k8s:listMapKey</code></h3><p><strong>Description:</strong></p><p>Declares a named sub-field of a list's value-type to be part of the list-map key. This tag is required when <code>+k8s:listType=map</code> is used. Multiple <code>+k8s:listMapKey</code> tags can be used on a list-map to specify that it is keyed off of multiple fields.</p><p><strong>Payload:</strong></p><ul><li><code>&lt;field-json-name&gt;</code>: The JSON name of the field to be used as the key.</li></ul><p><strong>Usage Example:</strong></p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="display:flex"><span><span style="color:#080;font-style:italic">// +k8s:listType=map
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic">// +k8s:listMapKey=keyFieldOne
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic">// +k8s:listMapKey=keyFieldTwo
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/><span style="color:#a2f;font-weight:700">type</span> MyList []MyStruct
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span><span style="color:#a2f;font-weight:700">type</span> MyStruct <span style="color:#a2f;font-weight:700">struct</span> {
</span></span><span style="display:flex"><span>    keyFieldOne <span style="color:#0b0;font-weight:700">string</span> <span style="color:#b44">`json:"keyFieldOne"`</span>
</span></span><span style="display:flex"><span>    keyFieldTwo <span style="color:#0b0;font-weight:700">string</span> <span style="color:#b44">`json:"keyFieldTwo"`</span>
</span></span><span style="display:flex"><span>    valueField <span style="color:#0b0;font-weight:700">string</span> <span style="color:#b44">`json:"valueField"`</span>
</span></span><span style="display:flex"><span>}
</span></span></code></pre></div><p>In this example, <code>listMapKey</code> is used to specify that the <code>keyField</code> of <code>MyStruct</code> should be used as the key for the list-map.</p><h3 id="tag-listType"><code>+k8s:listType</code></h3><p><strong>Description:</strong></p><p>Declares a list field's semantic type. This tag is used to specify how a list should be treated, for example, as a map or a set.</p><p><strong>Payload:</strong></p><ul><li><code>atomic</code>: The list is treated as a single atomic value.</li><li><code>map</code>: The list is treated as a map, where each element has a unique key. Requires the use of <code>+k8s:listMapKey</code>.</li><li><code>set</code>: The list is treated as a set, where each element is unique.</li></ul><p><strong>Usage Example:</strong></p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="display:flex"><span><span style="color:#080;font-style:italic">// +k8s:listType=map
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic">// +k8s:listMapKey=keyField
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/><span style="color:#a2f;font-weight:700">type</span> MyList []MyStruct
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span><span style="color:#a2f;font-weight:700">type</span> MyStruct <span style="color:#a2f;font-weight:700">struct</span> {
</span></span><span style="display:flex"><span>    keyField <span style="color:#0b0;font-weight:700">string</span> <span style="color:#b44">`json:"keyField"`</span>
</span></span><span style="display:flex"><span>    valueField <span style="color:#0b0;font-weight:700">string</span> <span style="color:#b44">`json:"valueField"`</span>
</span></span><span style="display:flex"><span>}
</span></span></code></pre></div><p>In this example, <code>MyList</code> is declared as a list of type <code>map</code>, with <code>keyField</code> as the key. This means that the validation logic will ensure that each element in the list has a unique <code>keyField</code>.</p><h3 id="tag-maxItems"><code>+k8s:maxItems</code></h3><p><strong>Description:</strong></p><p>Indicates that a list field has a limit on its size.</p><p><strong>Payload:</strong></p><ul><li><code>&lt;non-negative integer&gt;</code>: This field must be no more than X items long.</li></ul><p><strong>Usage Example:</strong></p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="display:flex"><span><span style="color:#a2f;font-weight:700">type</span> MyStruct <span style="color:#a2f;font-weight:700">struct</span> {
</span></span><span style="display:flex"><span>    <span style="color:#080;font-style:italic">// +k8s:maxItems=5
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>    MyList []<span style="color:#0b0;font-weight:700">string</span> <span style="color:#b44">`json:"myList"`</span>
</span></span><span style="display:flex"><span>}
</span></span></code></pre></div><p>In this example, <code>MyList</code> cannot contain more than 5 items.</p><h3 id="tag-maxLength"><code>+k8s:maxLength</code></h3><p><strong>Description:</strong></p><p>Indicates that a string field has a limit on its length.</p><p><strong>Payload:</strong></p><ul><li><code>&lt;non-negative integer&gt;</code>: This field must be no more than X characters long.</li></ul><p><strong>Usage Example:</strong></p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="display:flex"><span><span style="color:#a2f;font-weight:700">type</span> MyStruct <span style="color:#a2f;font-weight:700">struct</span> {
</span></span><span style="display:flex"><span>    <span style="color:#080;font-style:italic">// +k8s:maxLength=10
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>    MyString <span style="color:#0b0;font-weight:700">string</span> <span style="color:#b44">`json:"myString"`</span>
</span></span><span style="display:flex"><span>}
</span></span></code></pre></div><p>In this example, <code>MyString</code> cannot be longer than 10 characters.</p><h3 id="tag-minimum"><code>+k8s:minimum</code></h3><p><strong>Description:</strong></p><p>Indicates that a numeric field has a minimum value.</p><p><strong>Payload:</strong></p><ul><li><code>&lt;integer&gt;</code>: This field must be greater than or equal to x.</li></ul><p><strong>Usage Example:</strong></p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="display:flex"><span><span style="color:#a2f;font-weight:700">type</span> MyStruct <span style="color:#a2f;font-weight:700">struct</span> {
</span></span><span style="display:flex"><span>    <span style="color:#080;font-style:italic">// +k8s:minimum=0
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>    MyInt <span style="color:#0b0;font-weight:700">int</span> <span style="color:#b44">`json:"myInt"`</span>
</span></span><span style="display:flex"><span>}
</span></span></code></pre></div><p>In this example, <code>MyInt</code> must be greater than or equal to 0.</p><h3 id="tag-neq"><code>+k8s:neq</code></h3><p><strong>Description:</strong></p><p>Verifies the field's value is not equal to a specific disallowed value. Supports string, integer, and boolean types.</p><p><strong>Payload:</strong></p><ul><li><code>&lt;value&gt;</code>: The disallowed value. The parser will infer the type (string, int, bool).</li></ul><p><strong>Usage Example:</strong></p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="display:flex"><span><span style="color:#a2f;font-weight:700">type</span> MyStruct <span style="color:#a2f;font-weight:700">struct</span> {
</span></span><span style="display:flex"><span>    <span style="color:#080;font-style:italic">// +k8s:neq="disallowed"
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>    MyString <span style="color:#0b0;font-weight:700">string</span> <span style="color:#b44">`json:"myString"`</span>
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span>    <span style="color:#080;font-style:italic">// +k8s:neq=0
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>    MyInt <span style="color:#0b0;font-weight:700">int</span> <span style="color:#b44">`json:"myInt"`</span>
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span>    <span style="color:#080;font-style:italic">// +k8s:neq=true
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>    MyBool <span style="color:#0b0;font-weight:700">bool</span> <span style="color:#b44">`json:"myBool"`</span>
</span></span><span style="display:flex"><span>}
</span></span></code></pre></div><p>In this example:</p><ul><li><code>MyString</code> cannot be equal to <code>"disallowed"</code>.</li><li><code>MyInt</code> cannot be equal to <code>0</code>.</li><li><code>MyBool</code> cannot be equal to <code>true</code>.</li></ul><h3 id="tag-opaqueType"><code>+k8s:opaqueType</code></h3><p><strong>Description:</strong></p><p>Indicates that any validations declared on the referenced type will be ignored. If a referenced type's package is not included in the generator's current flags, this tag must be set, or code generation will fail (preventing silent mistakes). If the validations should not be ignored, add the type's package to the generator using the <code>--readonly-pkg</code> flag.</p><p><strong>Usage Example:</strong></p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="display:flex"><span><span style="color:#a2f;font-weight:700">import</span> <span style="color:#b44">"some/external/package"</span>
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span><span style="color:#a2f;font-weight:700">type</span> MyStruct <span style="color:#a2f;font-weight:700">struct</span> {
</span></span><span style="display:flex"><span>    <span style="color:#080;font-style:italic">// +k8s:opaqueType
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>    ExternalField <span style="color:#a2f;font-weight:700">package</span>.ExternalType <span style="color:#b44">`json:"externalField"`</span>
</span></span><span style="display:flex"><span>}
</span></span></code></pre></div><p>In this example, any validation tags on <code>package.ExternalType</code> will be ignored.</p><h3 id="tag-optional"><code>+k8s:optional</code></h3><p><strong>Description:</strong></p><p>Indicates that a field is optional to clients.</p><p><strong>Usage Example:</strong></p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="display:flex"><span><span style="color:#a2f;font-weight:700">type</span> MyStruct <span style="color:#a2f;font-weight:700">struct</span> {
</span></span><span style="display:flex"><span>    <span style="color:#080;font-style:italic">// +k8s:optional
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>    MyField <span style="color:#0b0;font-weight:700">string</span> <span style="color:#b44">`json:"myField"`</span>
</span></span><span style="display:flex"><span>}
</span></span></code></pre></div><p>In this example, <code>MyField</code> is not required to be provided when creating or updating <code>MyStruct</code>.</p><h3 id="tag-required"><code>+k8s:required</code></h3><p><strong>Description:</strong></p><p>Indicates that a field must be specified by clients.</p><p><strong>Usage Example:</strong></p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="display:flex"><span><span style="color:#a2f;font-weight:700">type</span> MyStruct <span style="color:#a2f;font-weight:700">struct</span> {
</span></span><span style="display:flex"><span>    <span style="color:#080;font-style:italic">// +k8s:required
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>    MyField <span style="color:#0b0;font-weight:700">string</span> <span style="color:#b44">`json:"myField"`</span>
</span></span><span style="display:flex"><span>}
</span></span></code></pre></div><p>In this example, <code>MyField</code> must be provided when creating or updating <code>MyStruct</code>.</p><h3 id="tag-subfield"><code>+k8s:subfield</code></h3><p><strong>Description:</strong></p><p>Declares a validation for a subfield of a struct.</p><p><strong>Arguments:</strong></p><ul><li><code>&lt;field-json-name&gt;</code> (string, required): The JSON name of the subfield.</li></ul><p><strong>Payload:</strong></p><ul><li><code>&lt;validation-tag&gt;</code>: The tag to evaluate for the subfield.</li></ul><p><strong>Usage Example:</strong></p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="display:flex"><span><span style="color:#a2f;font-weight:700">type</span> MyStruct <span style="color:#a2f;font-weight:700">struct</span> {
</span></span><span style="display:flex"><span>    <span style="color:#080;font-style:italic">// +k8s:subfield("mySubfield")=+k8s:required
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>    MyStruct MyStruct <span style="color:#b44">`json:"MyStruct"`</span>
</span></span><span style="display:flex"><span>}
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span><span style="color:#a2f;font-weight:700">type</span> MyStruct <span style="color:#a2f;font-weight:700">struct</span> {
</span></span><span style="display:flex"><span>    MySubfield <span style="color:#0b0;font-weight:700">string</span> <span style="color:#b44">`json:"mySubfield"`</span>
</span></span><span style="display:flex"><span>}
</span></span></code></pre></div><p>In this example, <code>MySubfield</code> within <code>MyStruct</code> is required.</p><h3 id="tag-supportsSubresource"><code>+k8s:supportsSubresource</code></h3><p><strong>Description:</strong></p><p>The <code>+k8s:supportsSubresource</code> tag is a package-level comment tag that <strong>declares which subresources are valid targets for validation</strong> for the types within that package. Think of this tag as registering an endpoint; it tells the validation framework that a specific subresource path is recognized and should not be immediately rejected.</p><p>When the validation code is generated, this tag adds the specified subresource path to the main dispatch function for a type. This allows incoming requests for that subresource to be routed to a validation implementation.</p><p>Multiple tags can be used to declare support for several subresources. If no <code>+k8s:supportsSubresource</code> tags are present in a package, validation is only enabled for the root resource (e.g., <code>.../myresources/myobject</code>), and any requests to subresources will fail with a "no validation found" error.</p><p><strong>Standalone Usage:</strong></p><p>If you use <code>+k8s:supportsSubresource</code> without a corresponding <code>+k8s:isSubresource</code> tag for a specific validation, the validation rules for the root object will be applied to the subresource by default.</p><p><strong>Scope:</strong> Package</p><p><strong>Payload:</strong></p><ul><li><code>&lt;subresource-path&gt;</code>: The path of the subresource to support (e.g., <code>"/status"</code>, <code>"/scale"</code>).</li></ul><p><strong>Usage Example:</strong></p><p>By adding these tags, you are enabling the validation system to handle requests for the <code>/status</code> and <code>/scale</code> subresources for the types defined in package <code>v1</code>.</p><p><em>File: <code>staging/src/k8s.io/api/core/v1/doc.go</code></em></p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="display:flex"><span><span style="color:#080;font-style:italic">// +k8s:supportsSubresource="/status"
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic">// +k8s:supportsSubresource="/scale"
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/><span style="color:#a2f;font-weight:700">package</span> v1
</span></span></code></pre></div><h3 id="tag-unionDiscriminator"><code>+k8s:unionDiscriminator</code></h3><p><strong>Description:</strong></p><p>Indicates that this field is the discriminator for a union.</p><p><strong>Arguments:</strong></p><ul><li><code>union</code> (string, optional): The name of the union, if more than one exists.</li></ul><p><strong>Usage Example:</strong></p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="display:flex"><span><span style="color:#a2f;font-weight:700">type</span> MyStruct <span style="color:#a2f;font-weight:700">struct</span> {
</span></span><span style="display:flex"><span>	TypeMeta <span style="color:#0b0;font-weight:700">int</span>
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span>	<span style="color:#080;font-style:italic">// +k8s:unionDiscriminator
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>	D D <span style="color:#b44">`json:"d"`</span>
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span>	<span style="color:#080;font-style:italic">// +k8s:unionMember
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>	<span style="color:#080;font-style:italic">// +k8s:optional
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>	M1 <span style="color:#666">*</span>M1 <span style="color:#b44">`json:"m1"`</span>
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span>	<span style="color:#080;font-style:italic">// +k8s:unionMember
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>	<span style="color:#080;font-style:italic">// +k8s:optional
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>	M2 <span style="color:#666">*</span>M2 <span style="color:#b44">`json:"m2"`</span>
</span></span><span style="display:flex"><span>}
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span><span style="color:#a2f;font-weight:700">type</span> D <span style="color:#0b0;font-weight:700">string</span>
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span><span style="color:#a2f;font-weight:700">const</span> (
</span></span><span style="display:flex"><span>	DM1 D = <span style="color:#b44">"M1"</span>
</span></span><span style="display:flex"><span>	DM2 D = <span style="color:#b44">"M2"</span>
</span></span><span style="display:flex"><span>)
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span><span style="color:#a2f;font-weight:700">type</span> M1 <span style="color:#a2f;font-weight:700">struct</span>{}
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span><span style="color:#a2f;font-weight:700">type</span> M2 <span style="color:#a2f;font-weight:700">struct</span>{}
</span></span></code></pre></div><p>In this example, the <code>Type</code> field is the discriminator for the union. The value of <code>Type</code> will determine which of the union members (<code>M1</code> or <code>M2</code>) is expected to be present.</p><h3 id="tag-unionMember"><code>+k8s:unionMember</code></h3><p><strong>Description:</strong></p><p>Indicates that this field is a member of a union.</p><p><strong>Arguments:</strong></p><ul><li><code>union</code> (string, optional): The name of the union, if more than one exists.</li><li><code>memberName</code> (string, optional): The discriminator value for this member. Defaults to the field's name.</li></ul><p><strong>Usage Example:</strong></p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="display:flex"><span><span style="color:#a2f;font-weight:700">type</span> MyStruct <span style="color:#a2f;font-weight:700">struct</span> {
</span></span><span style="display:flex"><span>	<span style="color:#080;font-style:italic">// +k8s:unionMember(union: "union1")
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>	<span style="color:#080;font-style:italic">// +k8s:optional
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>	M1 <span style="color:#666">*</span>M1 <span style="color:#b44">`json:"u1m1"`</span>
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span>	<span style="color:#080;font-style:italic">// +k8s:unionMember(union: "union1")
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>	<span style="color:#080;font-style:italic">// +k8s:optional
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>	M2 <span style="color:#666">*</span>M2 <span style="color:#b44">`json:"u1m2"`</span>
</span></span><span style="display:flex"><span>}
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span><span style="color:#a2f;font-weight:700">type</span> M1 <span style="color:#a2f;font-weight:700">struct</span>{}
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span><span style="color:#a2f;font-weight:700">type</span> M2 <span style="color:#a2f;font-weight:700">struct</span>{}
</span></span></code></pre></div><p>In this example, <code>M1</code> and <code>M2</code> are members of the named union <code>union1</code>.</p><h3 id="tag-zeroOrOneOfMember"><code>+k8s:zeroOrOneOfMember</code></h3><p><strong>Description:</strong></p><p>Indicates that this field is a member of a zero-or-one-of union. A zero-or-one-of union allows at most one member to be set. Unlike regular unions, having no members set is valid.</p><p><strong>Arguments:</strong></p><ul><li><code>union</code> (string, optional): The name of the union, if more than one exists.</li><li><code>memberName</code> (string, optional): The custom member name for this member. Defaults to the field's name.</li></ul><p><strong>Usage Example:</strong></p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="display:flex"><span><span style="color:#a2f;font-weight:700">type</span> MyStruct <span style="color:#a2f;font-weight:700">struct</span> {
</span></span><span style="display:flex"><span>	<span style="color:#080;font-style:italic">// +k8s:zeroOrOneOfMember
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>	<span style="color:#080;font-style:italic">// +k8s:optional
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>	M1 <span style="color:#666">*</span>M1 <span style="color:#b44">`json:"m1"`</span>
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span>	<span style="color:#080;font-style:italic">// +k8s:zeroOrOneOfMember
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>	<span style="color:#080;font-style:italic">// +k8s:optional
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>	M2 <span style="color:#666">*</span>M2 <span style="color:#b44">`json:"m2"`</span>
</span></span><span style="display:flex"><span>}
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span><span style="color:#a2f;font-weight:700">type</span> M1 <span style="color:#a2f;font-weight:700">struct</span>{}
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span><span style="color:#a2f;font-weight:700">type</span> M2 <span style="color:#a2f;font-weight:700">struct</span>{}
</span></span></code></pre></div><p>In this example, at most one of <code>A</code> or <code>B</code> can be set. It is also valid for neither to be set.</p></div>
<hr>
<div class="td-content"><h1 data-pagefind-weight="10">Deprecated API Migration Guide</h1><p>As the Kubernetes API evolves, APIs are periodically reorganized or upgraded.
When APIs evolve, the old API is deprecated and eventually removed.
This page contains information you need to know when migrating from
deprecated API versions to newer and more stable API versions.</p><h2 id="removed-apis-by-release">Removed APIs by release</h2><h3 id="v1-32">v1.32</h3><p>The <strong>v1.32</strong> release stopped serving the following deprecated API versions:</p><h4 id="flowcontrol-resources-v132">Flow control resources</h4><p>The <strong>flowcontrol.apiserver.k8s.io/v1beta3</strong> API version of FlowSchema and PriorityLevelConfiguration is no longer served as of v1.32.</p><ul><li>Migrate manifests and API clients to use the <strong>flowcontrol.apiserver.k8s.io/v1</strong> API version, available since v1.29.</li><li>All existing persisted objects are accessible via the new API</li><li>Notable changes in <strong>flowcontrol.apiserver.k8s.io/v1</strong>:<ul><li>The PriorityLevelConfiguration <code>spec.limited.nominalConcurrencyShares</code> field only defaults to 30 when unspecified, and an explicit value of 0 is not changed to 30.</li></ul></li></ul><h3 id="v1-29">v1.29</h3><p>The <strong>v1.29</strong> release stopped serving the following deprecated API versions:</p><h4 id="flowcontrol-resources-v129">Flow control resources</h4><p>The <strong>flowcontrol.apiserver.k8s.io/v1beta2</strong> API version of FlowSchema and PriorityLevelConfiguration is no longer served as of v1.29.</p><ul><li>Migrate manifests and API clients to use the <strong>flowcontrol.apiserver.k8s.io/v1</strong> API version, available since v1.29, or the <strong>flowcontrol.apiserver.k8s.io/v1beta3</strong> API version, available since v1.26.</li><li>All existing persisted objects are accessible via the new API</li><li>Notable changes in <strong>flowcontrol.apiserver.k8s.io/v1</strong>:<ul><li>The PriorityLevelConfiguration <code>spec.limited.assuredConcurrencyShares</code> field is renamed to <code>spec.limited.nominalConcurrencyShares</code> and only defaults to 30 when unspecified, and an explicit value of 0 is not changed to 30.</li></ul></li><li>Notable changes in <strong>flowcontrol.apiserver.k8s.io/v1beta3</strong>:<ul><li>The PriorityLevelConfiguration <code>spec.limited.assuredConcurrencyShares</code> field is renamed to <code>spec.limited.nominalConcurrencyShares</code></li></ul></li></ul><h3 id="v1-27">v1.27</h3><p>The <strong>v1.27</strong> release stopped serving the following deprecated API versions:</p><h4 id="csistoragecapacity-v127">CSIStorageCapacity</h4><p>The <strong>storage.k8s.io/v1beta1</strong> API version of CSIStorageCapacity is no longer served as of v1.27.</p><ul><li>Migrate manifests and API clients to use the <strong>storage.k8s.io/v1</strong> API version, available since v1.24.</li><li>All existing persisted objects are accessible via the new API</li><li>No notable changes</li></ul><h3 id="v1-26">v1.26</h3><p>The <strong>v1.26</strong> release stopped serving the following deprecated API versions:</p><h4 id="flowcontrol-resources-v126">Flow control resources</h4><p>The <strong>flowcontrol.apiserver.k8s.io/v1beta1</strong> API version of FlowSchema and PriorityLevelConfiguration is no longer served as of v1.26.</p><ul><li>Migrate manifests and API clients to use the <strong>flowcontrol.apiserver.k8s.io/v1beta2</strong> API version.</li><li>All existing persisted objects are accessible via the new API</li><li>No notable changes</li></ul><h4 id="horizontalpodautoscaler-v126">HorizontalPodAutoscaler</h4><p>The <strong>autoscaling/v2beta2</strong> API version of HorizontalPodAutoscaler is no longer served as of v1.26.</p><ul><li>Migrate manifests and API clients to use the <strong>autoscaling/v2</strong> API version, available since v1.23.</li><li>All existing persisted objects are accessible via the new API</li><li>Notable changes:<ul><li><code>targetAverageUtilization</code> is replaced with <code>target.averageUtilization</code> and <code>target.type: Utilization</code>. See <a href="/docs/tasks/run-application/horizontal-pod-autoscale-walkthrough/#autoscaling-on-multiple-metrics-and-custom-metrics">Autoscaling on multiple metrics and custom metrics</a>.</li></ul></li></ul><h3 id="v1-25">v1.25</h3><p>The <strong>v1.25</strong> release stopped serving the following deprecated API versions:</p><h4 id="cronjob-v125">CronJob</h4><p>The <strong>batch/v1beta1</strong> API version of CronJob is no longer served as of v1.25.</p><ul><li>Migrate manifests and API clients to use the <strong>batch/v1</strong> API version, available since v1.21.</li><li>All existing persisted objects are accessible via the new API</li><li>No notable changes</li></ul><h4 id="endpointslice-v125">EndpointSlice</h4><p>The <strong>discovery.k8s.io/v1beta1</strong> API version of EndpointSlice is no longer served as of v1.25.</p><ul><li>Migrate manifests and API clients to use the <strong>discovery.k8s.io/v1</strong> API version, available since v1.21.</li><li>All existing persisted objects are accessible via the new API</li><li>Notable changes in <strong>discovery.k8s.io/v1</strong>:<ul><li>use per Endpoint <code>nodeName</code> field instead of deprecated <code>topology["kubernetes.io/hostname"]</code> field</li><li>use per Endpoint <code>zone</code> field instead of deprecated <code>topology["topology.kubernetes.io/zone"]</code> field</li><li><code>topology</code> is replaced with the <code>deprecatedTopology</code> field which is not writable in v1</li></ul></li></ul><h4 id="event-v125">Event</h4><p>The <strong>events.k8s.io/v1beta1</strong> API version of Event is no longer served as of v1.25.</p><ul><li>Migrate manifests and API clients to use the <strong>events.k8s.io/v1</strong> API version, available since v1.19.</li><li>All existing persisted objects are accessible via the new API</li><li>Notable changes in <strong>events.k8s.io/v1</strong>:<ul><li><code>type</code> is limited to <code>Normal</code> and <code>Warning</code></li><li><code>involvedObject</code> is renamed to <code>regarding</code></li><li><code>action</code>, <code>reason</code>, <code>reportingController</code>, and <code>reportingInstance</code> are required
when creating new <strong>events.k8s.io/v1</strong> Events</li><li>use <code>eventTime</code> instead of the deprecated <code>firstTimestamp</code> field (which is renamed
to <code>deprecatedFirstTimestamp</code> and not permitted in new <strong>events.k8s.io/v1</strong> Events)</li><li>use <code>series.lastObservedTime</code> instead of the deprecated <code>lastTimestamp</code> field
(which is renamed to <code>deprecatedLastTimestamp</code> and not permitted in new <strong>events.k8s.io/v1</strong> Events)</li><li>use <code>series.count</code> instead of the deprecated <code>count</code> field
(which is renamed to <code>deprecatedCount</code> and not permitted in new <strong>events.k8s.io/v1</strong> Events)</li><li>use <code>reportingController</code> instead of the deprecated <code>source.component</code> field
(which is renamed to <code>deprecatedSource.component</code> and not permitted in new <strong>events.k8s.io/v1</strong> Events)</li><li>use <code>reportingInstance</code> instead of the deprecated <code>source.host</code> field
(which is renamed to <code>deprecatedSource.host</code> and not permitted in new <strong>events.k8s.io/v1</strong> Events)</li></ul></li></ul><h4 id="horizontalpodautoscaler-v125">HorizontalPodAutoscaler</h4><p>The <strong>autoscaling/v2beta1</strong> API version of HorizontalPodAutoscaler is no longer served as of v1.25.</p><ul><li>Migrate manifests and API clients to use the <strong>autoscaling/v2</strong> API version, available since v1.23.</li><li>All existing persisted objects are accessible via the new API</li><li>Notable changes:<ul><li><code>targetAverageUtilization</code> is replaced with <code>target.averageUtilization</code> and <code>target.type: Utilization</code>. See <a href="/docs/tasks/run-application/horizontal-pod-autoscale-walkthrough/#autoscaling-on-multiple-metrics-and-custom-metrics">Autoscaling on multiple metrics and custom metrics</a>.</li></ul></li></ul><h4 id="poddisruptionbudget-v125">PodDisruptionBudget</h4><p>The <strong>policy/v1beta1</strong> API version of PodDisruptionBudget is no longer served as of v1.25.</p><ul><li>Migrate manifests and API clients to use the <strong>policy/v1</strong> API version, available since v1.21.</li><li>All existing persisted objects are accessible via the new API</li><li>Notable changes in <strong>policy/v1</strong>:<ul><li>an empty <code>spec.selector</code> (<code>{}</code>) written to a <code>policy/v1</code> PodDisruptionBudget selects all
pods in the namespace (in <code>policy/v1beta1</code> an empty <code>spec.selector</code> selected no pods).
An unset <code>spec.selector</code> selects no pods in either API version.</li></ul></li></ul><h4 id="psp-v125">PodSecurityPolicy</h4><p>PodSecurityPolicy in the <strong>policy/v1beta1</strong> API version is no longer served as of v1.25,
and the PodSecurityPolicy admission controller will be removed.</p><p>Migrate to <a href="/docs/concepts/security/pod-security-admission/">Pod Security Admission</a>
or a <a href="/docs/reference/access-authn-authz/extensible-admission-controllers/">3rd party admission webhook</a>.
For a migration guide, see <a href="/docs/tasks/configure-pod-container/migrate-from-psp/">Migrate from PodSecurityPolicy to the Built-In PodSecurity Admission Controller</a>.
For more information on the deprecation, see <a href="/blog/2021/04/06/podsecuritypolicy-deprecation-past-present-and-future/">PodSecurityPolicy Deprecation: Past, Present, and Future</a>.</p><h4 id="runtimeclass-v125">RuntimeClass</h4><p>RuntimeClass in the <strong>node.k8s.io/v1beta1</strong> API version is no longer served as of v1.25.</p><ul><li>Migrate manifests and API clients to use the <strong>node.k8s.io/v1</strong> API version, available since v1.20.</li><li>All existing persisted objects are accessible via the new API</li><li>No notable changes</li></ul><h3 id="v1-22">v1.22</h3><p>The <strong>v1.22</strong> release stopped serving the following deprecated API versions:</p><h4 id="webhook-resources-v122">Webhook resources</h4><p>The <strong>admissionregistration.k8s.io/v1beta1</strong> API version of MutatingWebhookConfiguration
and ValidatingWebhookConfiguration is no longer served as of v1.22.</p><ul><li>Migrate manifests and API clients to use the <strong>admissionregistration.k8s.io/v1</strong> API version, available since v1.16.</li><li>All existing persisted objects are accessible via the new APIs</li><li>Notable changes:<ul><li><code>webhooks[*].failurePolicy</code> default changed from <code>Ignore</code> to <code>Fail</code> for v1</li><li><code>webhooks[*].matchPolicy</code> default changed from <code>Exact</code> to <code>Equivalent</code> for v1</li><li><code>webhooks[*].timeoutSeconds</code> default changed from <code>30s</code> to <code>10s</code> for v1</li><li><code>webhooks[*].sideEffects</code> default value is removed, and the field made required,
and only <code>None</code> and <code>NoneOnDryRun</code> are permitted for v1</li><li><code>webhooks[*].admissionReviewVersions</code> default value is removed and the field made
required for v1 (supported versions for AdmissionReview are <code>v1</code> and <code>v1beta1</code>)</li><li><code>webhooks[*].name</code> must be unique in the list for objects created via <code>admissionregistration.k8s.io/v1</code></li></ul></li></ul><h4 id="customresourcedefinition-v122">CustomResourceDefinition</h4><p>The <strong>apiextensions.k8s.io/v1beta1</strong> API version of CustomResourceDefinition is no longer served as of v1.22.</p><ul><li>Migrate manifests and API clients to use the <strong>apiextensions.k8s.io/v1</strong> API version, available since v1.16.</li><li>All existing persisted objects are accessible via the new API</li><li>Notable changes:<ul><li><code>spec.scope</code> is no longer defaulted to <code>Namespaced</code> and must be explicitly specified</li><li><code>spec.version</code> is removed in v1; use <code>spec.versions</code> instead</li><li><code>spec.validation</code> is removed in v1; use <code>spec.versions[*].schema</code> instead</li><li><code>spec.subresources</code> is removed in v1; use <code>spec.versions[*].subresources</code> instead</li><li><code>spec.additionalPrinterColumns</code> is removed in v1; use <code>spec.versions[*].additionalPrinterColumns</code> instead</li><li><code>spec.conversion.webhookClientConfig</code> is moved to <code>spec.conversion.webhook.clientConfig</code> in v1</li><li><code>spec.conversion.conversionReviewVersions</code> is moved to <code>spec.conversion.webhook.conversionReviewVersions</code> in v1</li><li><code>spec.versions[*].schema.openAPIV3Schema</code> is now required when creating v1 CustomResourceDefinition objects,
and must be a <a href="/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#specifying-a-structural-schema">structural schema</a></li><li><code>spec.preserveUnknownFields: true</code> is disallowed when creating v1 CustomResourceDefinition objects;
it must be specified within schema definitions as <code>x-kubernetes-preserve-unknown-fields: true</code></li><li>In <code>additionalPrinterColumns</code> items, the <code>JSONPath</code> field was renamed to <code>jsonPath</code> in v1
(fixes <a href="https://github.com/kubernetes/kubernetes/issues/66531">#66531</a>)</li></ul></li></ul><h4 id="apiservice-v122">APIService</h4><p>The <strong>apiregistration.k8s.io/v1beta1</strong> API version of APIService is no longer served as of v1.22.</p><ul><li>Migrate manifests and API clients to use the <strong>apiregistration.k8s.io/v1</strong> API version, available since v1.10.</li><li>All existing persisted objects are accessible via the new API</li><li>No notable changes</li></ul><h4 id="tokenreview-v122">TokenReview</h4><p>The <strong>authentication.k8s.io/v1beta1</strong> API version of TokenReview is no longer served as of v1.22.</p><ul><li>Migrate manifests and API clients to use the <strong>authentication.k8s.io/v1</strong> API version, available since v1.6.</li><li>No notable changes</li></ul><h4 id="subjectaccessreview-resources-v122">SubjectAccessReview resources</h4><p>The <strong>authorization.k8s.io/v1beta1</strong> API version of LocalSubjectAccessReview,
SelfSubjectAccessReview, SubjectAccessReview, and SelfSubjectRulesReview is no longer served as of v1.22.</p><ul><li>Migrate manifests and API clients to use the <strong>authorization.k8s.io/v1</strong> API version, available since v1.6.</li><li>Notable changes:<ul><li><code>spec.group</code> was renamed to <code>spec.groups</code> in v1 (fixes <a href="https://github.com/kubernetes/kubernetes/issues/32709">#32709</a>)</li></ul></li></ul><h4 id="certificatesigningrequest-v122">CertificateSigningRequest</h4><p>The <strong>certificates.k8s.io/v1beta1</strong> API version of CertificateSigningRequest is no longer served as of v1.22.</p><ul><li>Migrate manifests and API clients to use the <strong>certificates.k8s.io/v1</strong> API version, available since v1.19.</li><li>All existing persisted objects are accessible via the new API</li><li>Notable changes in <code>certificates.k8s.io/v1</code>:<ul><li>For API clients requesting certificates:<ul><li><code>spec.signerName</code> is now required
(see <a href="/docs/reference/access-authn-authz/certificate-signing-requests/#kubernetes-signers">known Kubernetes signers</a>),
and requests for <code>kubernetes.io/legacy-unknown</code> are not allowed to be created via the <code>certificates.k8s.io/v1</code> API</li><li><code>spec.usages</code> is now required, may not contain duplicate values, and must only contain known usages</li></ul></li><li>For API clients approving or signing certificates:<ul><li><code>status.conditions</code> may not contain duplicate types</li><li><code>status.conditions[*].status</code> is now required</li><li><code>status.certificate</code> must be PEM-encoded, and contain only <code>CERTIFICATE</code> blocks</li></ul></li></ul></li></ul><h4 id="lease-v122">Lease</h4><p>The <strong>coordination.k8s.io/v1beta1</strong> API version of Lease is no longer served as of v1.22.</p><ul><li>Migrate manifests and API clients to use the <strong>coordination.k8s.io/v1</strong> API version, available since v1.14.</li><li>All existing persisted objects are accessible via the new API</li><li>No notable changes</li></ul><h4 id="ingress-v122">Ingress</h4><p>The <strong>extensions/v1beta1</strong> and <strong>networking.k8s.io/v1beta1</strong> API versions of Ingress is no longer served as of v1.22.</p><ul><li>Migrate manifests and API clients to use the <strong>networking.k8s.io/v1</strong> API version, available since v1.19.</li><li>All existing persisted objects are accessible via the new API</li><li>Notable changes:<ul><li><code>spec.backend</code> is renamed to <code>spec.defaultBackend</code></li><li>The backend <code>serviceName</code> field is renamed to <code>service.name</code></li><li>Numeric backend <code>servicePort</code> fields are renamed to <code>service.port.number</code></li><li>String backend <code>servicePort</code> fields are renamed to <code>service.port.name</code></li><li><code>pathType</code> is now required for each specified path. Options are <code>Prefix</code>,
<code>Exact</code>, and <code>ImplementationSpecific</code>. To match the undefined <code>v1beta1</code> behavior, use <code>ImplementationSpecific</code>.</li></ul></li></ul><h4 id="ingressclass-v122">IngressClass</h4><p>The <strong>networking.k8s.io/v1beta1</strong> API version of IngressClass is no longer served as of v1.22.</p><ul><li>Migrate manifests and API clients to use the <strong>networking.k8s.io/v1</strong> API version, available since v1.19.</li><li>All existing persisted objects are accessible via the new API</li><li>No notable changes</li></ul><h4 id="rbac-resources-v122">RBAC resources</h4><p>The <strong>rbac.authorization.k8s.io/v1beta1</strong> API version of ClusterRole, ClusterRoleBinding,
Role, and RoleBinding is no longer served as of v1.22.</p><ul><li>Migrate manifests and API clients to use the <strong>rbac.authorization.k8s.io/v1</strong> API version, available since v1.8.</li><li>All existing persisted objects are accessible via the new APIs</li><li>No notable changes</li></ul><h4 id="priorityclass-v122">PriorityClass</h4><p>The <strong>scheduling.k8s.io/v1beta1</strong> API version of PriorityClass is no longer served as of v1.22.</p><ul><li>Migrate manifests and API clients to use the <strong>scheduling.k8s.io/v1</strong> API version, available since v1.14.</li><li>All existing persisted objects are accessible via the new API</li><li>No notable changes</li></ul><h4 id="storage-resources-v122">Storage resources</h4><p>The <strong>storage.k8s.io/v1beta1</strong> API version of CSIDriver, CSINode, StorageClass, and VolumeAttachment is no longer served as of v1.22.</p><ul><li>Migrate manifests and API clients to use the <strong>storage.k8s.io/v1</strong> API version<ul><li>CSIDriver is available in <strong>storage.k8s.io/v1</strong> since v1.19.</li><li>CSINode is available in <strong>storage.k8s.io/v1</strong> since v1.17</li><li>StorageClass is available in <strong>storage.k8s.io/v1</strong> since v1.6</li><li>VolumeAttachment is available in <strong>storage.k8s.io/v1</strong> v1.13</li></ul></li><li>All existing persisted objects are accessible via the new APIs</li><li>No notable changes</li></ul><h3 id="v1-16">v1.16</h3><p>The <strong>v1.16</strong> release stopped serving the following deprecated API versions:</p><h4 id="networkpolicy-v116">NetworkPolicy</h4><p>The <strong>extensions/v1beta1</strong> API version of NetworkPolicy is no longer served as of v1.16.</p><ul><li>Migrate manifests and API clients to use the <strong>networking.k8s.io/v1</strong> API version, available since v1.8.</li><li>All existing persisted objects are accessible via the new API</li></ul><h4 id="daemonset-v116">DaemonSet</h4><p>The <strong>extensions/v1beta1</strong> and <strong>apps/v1beta2</strong> API versions of DaemonSet are no longer served as of v1.16.</p><ul><li>Migrate manifests and API clients to use the <strong>apps/v1</strong> API version, available since v1.9.</li><li>All existing persisted objects are accessible via the new API</li><li>Notable changes:<ul><li><code>spec.templateGeneration</code> is removed</li><li><code>spec.selector</code> is now required and immutable after creation; use the existing
template labels as the selector for seamless upgrades</li><li><code>spec.updateStrategy.type</code> now defaults to <code>RollingUpdate</code>
(the default in <code>extensions/v1beta1</code> was <code>OnDelete</code>)</li></ul></li></ul><h4 id="deployment-v116">Deployment</h4><p>The <strong>extensions/v1beta1</strong>, <strong>apps/v1beta1</strong>, and <strong>apps/v1beta2</strong> API versions of Deployment are no longer served as of v1.16.</p><ul><li>Migrate manifests and API clients to use the <strong>apps/v1</strong> API version, available since v1.9.</li><li>All existing persisted objects are accessible via the new API</li><li>Notable changes:<ul><li><code>spec.rollbackTo</code> is removed</li><li><code>spec.selector</code> is now required and immutable after creation; use the existing
template labels as the selector for seamless upgrades</li><li><code>spec.progressDeadlineSeconds</code> now defaults to <code>600</code> seconds
(the default in <code>extensions/v1beta1</code> was no deadline)</li><li><code>spec.revisionHistoryLimit</code> now defaults to <code>10</code>
(the default in <code>apps/v1beta1</code> was <code>2</code>, the default in <code>extensions/v1beta1</code> was to retain all)</li><li><code>maxSurge</code> and <code>maxUnavailable</code> now default to <code>25%</code>
(the default in <code>extensions/v1beta1</code> was <code>1</code>)</li></ul></li></ul><h4 id="statefulset-v116">StatefulSet</h4><p>The <strong>apps/v1beta1</strong> and <strong>apps/v1beta2</strong> API versions of StatefulSet are no longer served as of v1.16.</p><ul><li>Migrate manifests and API clients to use the <strong>apps/v1</strong> API version, available since v1.9.</li><li>All existing persisted objects are accessible via the new API</li><li>Notable changes:<ul><li><code>spec.selector</code> is now required and immutable after creation;
use the existing template labels as the selector for seamless upgrades</li><li><code>spec.updateStrategy.type</code> now defaults to <code>RollingUpdate</code>
(the default in <code>apps/v1beta1</code> was <code>OnDelete</code>)</li></ul></li></ul><h4 id="replicaset-v116">ReplicaSet</h4><p>The <strong>extensions/v1beta1</strong>, <strong>apps/v1beta1</strong>, and <strong>apps/v1beta2</strong> API versions of ReplicaSet are no longer served as of v1.16.</p><ul><li>Migrate manifests and API clients to use the <strong>apps/v1</strong> API version, available since v1.9.</li><li>All existing persisted objects are accessible via the new API</li><li>Notable changes:<ul><li><code>spec.selector</code> is now required and immutable after creation; use the existing template labels as the selector for seamless upgrades</li></ul></li></ul><h4 id="psp-v116">PodSecurityPolicy</h4><p>The <strong>extensions/v1beta1</strong> API version of PodSecurityPolicy is no longer served as of v1.16.</p><ul><li>Migrate manifests and API client to use the <strong>policy/v1beta1</strong> API version, available since v1.10.</li><li>Note that the <strong>policy/v1beta1</strong> API version of PodSecurityPolicy will be removed in v1.25.</li></ul><h2 id="what-to-do">What to do</h2><h3 id="test-with-deprecated-apis-disabled">Test with deprecated APIs disabled</h3><p>You can test your clusters by starting an API server with specific API versions disabled
to simulate upcoming removals. Add the following flag to the API server startup arguments:</p><p><code>--runtime-config=&lt;group&gt;/&lt;version&gt;=false</code></p><p>For example:</p><p><code>--runtime-config=admissionregistration.k8s.io/v1beta1=false,apiextensions.k8s.io/v1beta1,...</code></p><h3 id="locate-use-of-deprecated-apis">Locate use of deprecated APIs</h3><p>Use <a href="/blog/2020/09/03/warnings/#deprecation-warnings">client warnings, metrics, and audit information available in 1.19+</a>
to locate use of deprecated APIs.</p><h3 id="migrate-to-non-deprecated-apis">Migrate to non-deprecated APIs</h3><ul><li><p>Update custom integrations and controllers to call the non-deprecated APIs</p></li><li><p>Change YAML files to reference the non-deprecated APIs</p><p>You can use the <code>kubectl convert</code> command to automatically convert an existing object:</p><p><code>kubectl convert -f &lt;file&gt; --output-version &lt;group&gt;/&lt;version&gt;</code>.</p><p>For example, to convert an older Deployment to <code>apps/v1</code>, you can run:</p><p><code>kubectl convert -f ./my-deployment.yaml --output-version apps/v1</code></p><p>This conversion may use non-ideal default values. To learn more about a specific
resource, check the Kubernetes <a href="/docs/reference/kubernetes-api/">API reference</a>.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4><p>The <code>kubectl convert</code> tool is not installed by default, although
in fact it once was part of <code>kubectl</code> itself. For more details, you can read the
<a href="https://github.com/kubernetes/kubectl/issues/725">deprecation and removal issue</a>
for the built-in subcommand.</p><p>To learn how to set up <code>kubectl convert</code> on your computer, visit the page that is right for your
operating system:
<a href="/docs/tasks/tools/install-kubectl-linux/#install-kubectl-convert-plugin">Linux</a>,
<a href="/docs/tasks/tools/install-kubectl-macos/#install-kubectl-convert-plugin">macOS</a>, or
<a href="/docs/tasks/tools/install-kubectl-windows/#install-kubectl-convert-plugin">Windows</a>.</p></div></li></ul></div>
<hr>
<div class="td-content"><h1 data-pagefind-weight="10">Common Expression Language in Kubernetes</h1><p>The <a href="https://github.com/google/cel-go">Common Expression Language (CEL)</a> is used
in the Kubernetes API to declare validation rules, policy rules, and other
constraints or conditions.</p><p>CEL expressions are evaluated directly in the
<a class="glossary-tooltip" title="Control plane component that serves the Kubernetes API." data-toggle="tooltip" data-placement="top" href="/docs/concepts/architecture/#kube-apiserver" target="_blank" aria-label="API server">API server</a>, making CEL a
convenient alternative to out-of-process mechanisms, such as webhooks, for many
extensibility use cases. Your CEL expressions continue to execute so long as the
control plane's API server component remains available.</p><h2 id="language-overview">Language overview</h2><p>The <a href="https://github.com/google/cel-spec/blob/master/doc/langdef.md">CEL language</a>
has a straightforward syntax that is similar to the expressions in C, C++, Java,
JavaScript and Go.</p><p>CEL was designed to be embedded into applications. Each CEL "program" is a
single expression that evaluates to a single value. CEL expressions are
typically short "one-liners" that inline well into the string fields of Kubernetes
API resources.</p><p>Inputs to a CEL program are "variables". Each Kubernetes API field that contains
CEL declares in the API documentation which variables are available to use for
that field. For example, in the <code>x-kubernetes-validations[i].rules</code> field of
CustomResourceDefinitions, the <code>self</code> and <code>oldSelf</code> variables are available and
refer to the previous and current state of the custom resource data to be
validated by the CEL expression. Other Kubernetes API fields may declare
different variables. See the API documentation of the API fields to learn which
variables are available for that field.</p><p>Example CEL expressions:</p><table><caption>Examples of CEL expressions and the purpose of each</caption><thead><tr><th>Rule</th><th>Purpose</th></tr></thead><tbody><tr><td><tt>self.minReplicas &lt;= self.replicas &amp;&amp; self.replicas &lt;= self.maxReplicas</tt></td><td>Validate that the three fields defining replicas are ordered appropriately</td></tr><tr><td><tt>'Available' in self.stateCounts</tt></td><td>Validate that an entry with the 'Available' key exists in a map</td></tr><tr><td><tt>(self.list1.size() == 0) != (self.list2.size() == 0)</tt></td><td>Validate that one of two lists is non-empty, but not both</td></tr><tr><td><tt>self.envars.filter(e, e.name = 'MY_ENV').all(e, e.value.matches('^[a-zA-Z]*$'))</tt></td><td>Validate the 'value' field of a listMap entry where key field 'name' is 'MY_ENV'</td></tr><tr><td><tt>has(self.expired) &amp;&amp; self.created + self.ttl &lt; self.expired</tt></td><td>Validate that 'expired' date is after a 'create' date plus a 'ttl' duration</td></tr><tr><td><tt>self.health.startsWith('ok')</tt></td><td>Validate a 'health' string field has the prefix 'ok'</td></tr><tr><td><tt>self.widgets.exists(w, w.key == 'x' &amp;&amp; w.foo &lt; 10)</tt></td><td>Validate that the 'foo' property of a listMap item with a key 'x' is less than 10</td></tr><tr><td><tt>type(self) == string ? self == '99%' : self == 42</tt></td><td>Validate an int-or-string field for both the int and string cases</td></tr><tr><td><tt>self.metadata.name == 'singleton'</tt></td><td>Validate that an object's name matches a specific value (making it a singleton)</td></tr><tr><td><tt>self.set1.all(e, !(e in self.set2))</tt></td><td>Validate that two listSets are disjoint</td></tr><tr><td><tt>self.names.size() == self.details.size() &amp;&amp; self.names.all(n, n in self.details)</tt></td><td>Validate the 'details' map is keyed by the items in the 'names' listSet</td></tr><tr><td><tt>self.details.all(key, key.matches('^[a-zA-Z]*$'))</tt></td><td>Validate the keys of the 'details' map</td></tr><tr><td><tt>self.details.all(key, self.details[key].matches('^[a-zA-Z]*$'))</tt></td><td>Validate the values of the 'details' map</td></tr></tbody></table><h2 id="cel-options-language-features-and-libraries">CEL options, language features, and libraries</h2><p>CEL is configured with the following options, libraries and language features,
introduced at the specified Kubernetes versions:</p><table><thead><tr><th>CEL option, library or language feature</th><th>Included</th><th>Availability</th></tr></thead><tbody><tr><td><a href="https://github.com/google/cel-spec/blob/v0.7.0/doc/langdef.md#macros">Standard macros</a></td><td><code>has</code>, <code>all</code>, <code>exists</code>, <code>exists_one</code>, <code>map</code>, <code>filter</code></td><td>All Kubernetes versions</td></tr><tr><td><a href="https://github.com/google/cel-spec/blob/master/doc/langdef.md#list-of-standard-definitions">Standard functions</a></td><td>See
<a href="https://github.com/google/cel-spec/blob/master/doc/langdef.md#list-of-standard-definitions">official list of standard definitions</a></td><td>All Kubernetes versions</td></tr><tr><td><a href="https://pkg.go.dev/github.com/google/cel-go@v0.17.4/cel#HomogeneousAggregateLiterals">Homogeneous Aggregate Literals</a></td><td>-</td><td>All Kubernetes versions</td></tr><tr><td><a href="https://pkg.go.dev/github.com/google/cel-go@v0.17.4/cel#DefaultUTCTimeZone">Default UTC Time Zone</a></td><td>-</td><td>All Kubernetes versions</td></tr><tr><td><a href="https://pkg.go.dev/github.com/google/cel-go@v0.17.4/cel#EagerlyValidateDeclarations">Eagerly Validate Declarations</a></td><td>-</td><td>All Kubernetes versions</td></tr><tr><td><a href="https://pkg.go.dev/github.com/google/cel-go/ext#Strings">Extended strings library</a>, Version 1</td><td><code>charAt</code>, <code>indexOf</code>, <code>lastIndexOf</code>, <code>lowerAscii</code>,
<code>upperAscii</code>, <code>replace</code>, <code>split</code>, <code>join</code>, <code>substring</code>,
<code>trim</code></td><td>Kubernetes versions between 1.25 and 1.30</td></tr><tr><td><a href="https://pkg.go.dev/github.com/google/cel-go/ext#Strings">Extended strings library</a>, Version 2</td><td><code>charAt</code>, <code>indexOf</code>, <code>lastIndexOf</code>, <code>lowerAscii</code>,
<code>upperAscii</code>, <code>replace</code>, <code>split</code>, <code>join</code>, <code>substring</code>,
<code>trim</code></td><td>Kubernetes versions 1.30+</td></tr><tr><td>Kubernetes list library</td><td>See
<a href="#kubernetes-list-library">Kubernetes list library</a></td><td>All Kubernetes versions</td></tr><tr><td>Kubernetes regex library</td><td>See
<a href="#kubernetes-regex-library">Kubernetes regex library</a></td><td>All Kubernetes versions</td></tr><tr><td>Kubernetes URL library</td><td>See
<a href="#kubernetes-url-library">Kubernetes URL library</a></td><td>All Kubernetes versions</td></tr><tr><td>Kubernetes IP address library</td><td>See
<a href="#kubernetes-ip-address-library">Kubernetes IP address library</a></td><td>Kubernetes versions 1.31+</td></tr><tr><td>Kubernetes CIDR library</td><td>See
<a href="#kubernetes-cidr-library">Kubernetes CIDR library</a></td><td>Kubernetes versions 1.31+</td></tr><tr><tr><td>Kubernetes authorizer library</td><td>See
<a href="#kubernetes-authorizer-library">Kubernetes authorizer library</a></td><td>All Kubernetes versions</td></tr><tr><td>Kubernetes quantity library</td><td>See
<a href="#kubernetes-quantity-library">Kubernetes quantity library</a></td><td>Kubernetes versions 1.29+</td></tr><tr><td>Kubernetes semver library</td><td>See
<a href="#kubernetes-semver-library">Kubernetes semver library</a></td><td>Kubernetes versions 1.34+</td></tr><tr><td>Kubernetes format library</td><td>See
<a href="#kubernetes-format-library">Kubernetes format library</a></td><td>Kubernetes versions 1.32+</td></tr><tr><td>CEL optional types</td><td>See
<a href="https://pkg.go.dev/github.com/google/cel-go@v0.17.4/cel#OptionalTypes">CEL optional types</a></td><td>Kubernetes versions 1.29+</td></tr><tr><td>CEL CrossTypeNumericComparisons</td><td>See
<a href="https://pkg.go.dev/github.com/google/cel-go@v0.17.4/cel#CrossTypeNumericComparisons">CEL CrossTypeNumericComparisons</a></td><td>Kubernetes versions 1.29+</td><tr><td>CEL TwoVarComprehensions</td><td>See
<a href="https://pkg.go.dev/github.com/google/cel-go@v0.25.0/ext#readme-twovarcomprehensions">CEL TwoVarComprehensions</a></td><td>Kubernetes versions 1.33+</td></tr></tr></tr></tbody></table><p>CEL functions, features and language settings support Kubernetes control plane
rollbacks. For example, <em>CEL Optional Values</em> was introduced at Kubernetes 1.29
and so only API servers at that version or newer will accept write requests to
CEL expressions that use <em>CEL Optional Values</em>. However, when a cluster is
rolled back to Kubernetes 1.28 CEL expressions using "CEL Optional Values" that
are already stored in API resources will continue to evaluate correctly.</p><h2 id="kubernetes-cel-libraries">Kubernetes CEL libraries</h2><p>In additional to the CEL community libraries, Kubernetes includes CEL libraries
that are available everywhere CEL is used in Kubernetes.</p><h3 id="kubernetes-list-library">Kubernetes list library</h3><p>The list library includes <code>indexOf</code> and <code>lastIndexOf</code>, which work similar to the
strings functions of the same names. These functions either the first or last
positional index of the provided element in the list.</p><p>The list library also includes <code>min</code>, <code>max</code> and <code>sum</code>. Sum is supported on all
number types as well as the duration type. Min and max are supported on all
comparable types.</p><p><code>isSorted</code> is also provided as a convenience function and is supported on all
comparable types.</p><p>Examples:</p><table><caption>Examples of CEL expressions using list library functions</caption><thead><tr><td>CEL Expression</td><td>Purpose</td></tr></thead><tbody><tr><td><tt>names.isSorted()</tt></td><td>Verify that a list of names is kept in alphabetical order</td></tr><tr><td><tt>items.map(x, x.weight).sum() == 1.0</tt></td><td>Verify that the "weights" of a list of objects sum to 1.0</td></tr><tr><td><tt>lowPriorities.map(x, x.priority).max() &lt; highPriorities.map(x, x.priority).min()</tt></td><td>Verify that two sets of priorities do not overlap</td></tr><tr><td><tt>names.indexOf('should-be-first') == 1</tt></td><td>Require that the first name in a list if a specific value</td></tr></tbody></table><p>See the <a href="https://pkg.go.dev/k8s.io/apiextensions-apiserver/pkg/apiserver/schema/cel/library#Lists">Kubernetes List Library</a>
godoc for more information.</p><h3 id="kubernetes-regex-library">Kubernetes regex library</h3><p>In addition to the <code>matches</code> function provided by the CEL standard library, the
regex library provides <code>find</code> and <code>findAll</code>, enabling a much wider range of
regex operations.</p><p>Examples:</p><table><caption>Examples of CEL expressions using regex library functions</caption><thead><tr><td>CEL Expression</td><td>Purpose</td></tr></thead><tbody><tr><td><tt>"abc 123".find('[0-9]+')</tt></td><td>Find the first number in a string</td></tr><tr><td><tt>"1, 2, 3, 4".findAll('[0-9]+').map(x, int(x)).sum() &lt; 100</tt></td><td>Verify that the numbers in a string sum to less than 100</td></tr></tbody></table><p>See the <a href="https://pkg.go.dev/k8s.io/apiextensions-apiserver/pkg/apiserver/schema/cel/library#Regex">Kubernetes regex library</a>
godoc for more information.</p><h3 id="kubernetes-url-library">Kubernetes URL library</h3><p>To make it easier and safer to process URLs, the following functions have been added:</p><ul><li><code>isURL(string)</code> checks if a string is a valid URL according to the
<a href="https://pkg.go.dev/net/url#URL">Go's net/url</a> package. The string must be an
absolute URL.</li><li><code>url(string) URL</code> converts a string to a URL or results in an error if the
string is not a valid URL.</li></ul><p>Once parsed via the <code>url</code> function, the resulting URL object has <code>getScheme</code>,
<code>getHost</code>, <code>getHostname</code>, <code>getPort</code>, <code>getEscapedPath</code> and <code>getQuery</code> accessors.</p><p>Examples:</p><table><caption>Examples of CEL expressions using URL library functions</caption><thead><tr><td>CEL Expression</td><td>Purpose</td></tr></thead><tbody><tr><td><tt>url('https://example.com:80/').getHost()</tt></td><td>Gets the 'example.com:80' host part of the URL</td></tr><tr><td><tt>url('https://example.com/path with spaces/').getEscapedPath()</tt></td><td>Returns '/path%20with%20spaces/'</td></tr></tbody></table><p>See the <a href="https://pkg.go.dev/k8s.io/apiextensions-apiserver/pkg/apiserver/schema/cel/library#URLs">Kubernetes URL library</a>
godoc for more information.</p><h3 id="kubernetes-ip-address-library">Kubernetes IP address library</h3><p>To make it easier and safer to process IP addresses, the following functions have been added:</p><ul><li><code>isIP(string)</code> checks if a string is a valid IP address.</li><li><code>ip(string) IP</code> converts a string to an IP address object or results in an error if the string is not a valid IP address.</li></ul><p>For both functions, the IP address must be an IPv4 or IPv6 address.
IPv4-mapped IPv6 addresses (e.g. <code>::ffff:1.2.3.4</code>) are not allowed.
IP addresses with zones (e.g. <code>fe80::1%eth0</code>) are not allowed.
Leading zeros in IPv4 address octets are not allowed.</p><p>Once parsed via the <code>ip</code> function, the resulting IP object has the
following library of member functions:</p><table><caption>Available member functions of an IP address object</caption><thead><tr><th>Member Function</th><th>CEL Return Value</th><th>Description</th></tr></thead><tbody><tr><td><tt>isCanonical()</tt></td><td>bool</td><td>Returns true if the IP address is in its canonical form.
There is exactly one canonical form for every IP address, so fields containing
IPs in canonical form can just be treated as strings when checking for equality or uniqueness.</td></tr><tr><td><tt>family()</tt></td><td>int</td><td>Returns the IP address family, <tt>4</tt> for IPv4 and <tt>6</tt> for IPv6.</td></tr><tr><td><tt>isUnspecified()</tt></td><td>bool</td><td>Returns true if the IP address is the unspecified address.
Either the IPv4 address "0.0.0.0" or the IPv6 address "::".</td></tr><tr><td><tt>isLoopback()</tt></td><td>bool</td><td>Returns true if the IP address is the loopback address.
Either an IPv4 address with a value of 127.x.x.x or an IPv6 address with a value of ::1.</td></tr><tr><td><tt>isLinkLocalMulticast()</tt></td><td>bool</td><td>Returns true if the IP address is a link-local multicast address.
Either an IPv4 address with a value of 224.0.0.x or an IPv6 address in the network ff00::/8.</td></tr><tr><td><tt>isLinkLocalUnicast()</tt></td><td>bool</td><td>Returns true if the IP address is a link-local unicast address.
Either an IPv4 address with a value of 169.254.x.x or an IPv6 address in the network fe80::/10.</td></tr><tr><td><tt>isGlobalUnicast()</tt></td><td>bool</td><td>Returns true if the IP address is a global unicast address.
Either an IPv4 address that is not zero or 255.255.255.255 or an IPv6 address that is not a link-local unicast, loopback or multicast address.</td></tr></tbody></table><p>Examples:</p><table><caption>Examples of CEL expressions using IP address library functions</caption><thead><tr><th>CEL Expression</th><th>Purpose</th></tr></thead><tbody><tr><td><tt>isIP('127.0.0.1')</tt></td><td>Returns true for a valid IP.</td></tr><tr><td><tt>ip('2001:db8::abcd').isCanonical()</tt></td><td>Returns true for a canonical IPv6.</td></tr><tr><td><tt>ip('2001:DB8::ABCD').isCanonical()</tt></td><td>Returns false because the canonical form is lowercase.</td></tr><tr><td><tt>ip('127.0.0.1').family() == 4</tt></td><td>Check the address family of an IP.</td></tr><tr><td><tt>ip('::1').isLoopback()</tt></td><td>Check if an IP is a loopback address.</td></tr><tr><td><tt>ip('192.168.0.1').isGlobalUnicast()</tt></td><td>Check if an IP is a global unicast address.</td></tr></tbody></table><p>See the <a href="https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#IP">Kubernetes IP address library</a> godoc for more information.</p><h3 id="kubernetes-cidr-library">Kubernetes CIDR library</h3><p>CIDR provides a CEL function library extension of <a class="glossary-tooltip" title="CIDR is a notation for describing blocks of IP addresses and is used heavily in various networking configurations." data-toggle="tooltip" data-placement="top" href="/docs/reference/glossary/?all=true#term-CIDR" target="_blank" aria-label="CIDR">CIDR</a> notation parsing functions.</p><h4 id="cidr"><code>cidr</code></h4><p>Converts a string in CIDR notation to a network address representation or results in an error if the string is not a valid CIDR notation.
The CIDR must be an IPv4 or IPv6 subnet address with a mask.
Leading zeros in IPv4 address octets are not allowed.
IPv4-mapped IPv6 addresses (e.g. <code>::ffff:1.2.3.4/24</code>) are not allowed.</p><p><tt>cidr(&lt;string&gt;) &lt;CIDR&gt;</tt></p><p>Examples:</p><p><tt>cidr('192.168.0.0/16')</tt> // returns an IPv4 address with a CIDR mask
<tt>cidr('::1/128')</tt> // returns an IPv6 address with a CIDR mask
<tt>cidr('192.168.0.0/33')</tt> // error
<tt>cidr('::1/129')</tt> // error
<tt>cidr('192.168.0.1/16')</tt> // error, because there are non-0 bits after the prefix</p><h4 id="iscidr"><code>isCIDR</code></h4><p>Returns true if a string is a valid CIDR notation representation of a subnet with mask.
The CIDR must be an IPv4 or IPv6 subnet address with a mask.
Leading zeros in IPv4 address octets are not allowed.
IPv4-mapped IPv6 addresses (e.g. <code>::ffff:1.2.3.4/24</code>) are not allowed.</p><p><tt>isCIDR(&lt;string&gt;) &lt;bool&gt;</tt></p><p>Examples:</p><p><tt>isCIDR('192.168.0.0/16')</tt> // returns true
<tt>isCIDR('::1/128')</tt> // returns true
<tt>isCIDR('192.168.0.0/33')</tt> // returns false
<tt>isCIDR('::1/129')</tt> // returns false</p><h4 id="containsip-containscidr-ip-masked-prefixlength"><code>containsIP</code> / <code>containsCIDR</code> / <code>ip</code> / <code>masked</code> / <code>prefixLength</code></h4><ul><li><p><code>containsIP</code>: Returns true if a the CIDR contains the given IP address.
The IP address must be an IPv4 or IPv6 address.
May take either a string or IP address as an argument.</p></li><li><p><code>containsCIDR</code>: Returns true if a the CIDR contains the given CIDR.
The CIDR must be an IPv4 or IPv6 subnet address with a mask.
May take either a string or CIDR as an argument.</p></li><li><p><code>ip</code>: Returns the IP address representation of the CIDR.</p></li><li><p><code>masked</code>: Returns the CIDR representation of the network address with a masked prefix.
This can be used to return the canonical form of the CIDR network.</p></li><li><p><code>prefixLength</code>: Returns the prefix length of the CIDR in bits.
This is the number of bits in the mask.</p></li></ul><p>Examples:</p><table><caption>Examples of CEL expressions using CIDR library functions</caption><thead><tr><th>CEL Expression</th><th>Purpose</th></tr></thead><tbody><tr><td><tt>cidr('192.168.0.0/24').containsIP(ip('192.168.0.1'))</tt></td><td>Checks if a CIDR contains a given IP address (IP object).</td></tr><tr><td><tt>cidr('192.168.0.0/24').containsIP(ip('192.168.1.1'))</tt></td><td>Checks if a CIDR contains a given IP address (IP object).</td></tr><tr><td><tt>cidr('192.168.0.0/24').containsIP('192.168.0.1')</tt></td><td>Checks if a CIDR contains a given IP address (string).</td></tr><tr><td><tt>cidr('192.168.0.0/24').containsIP('192.168.1.1')</tt></td><td>Checks if a CIDR contains a given IP address (string).</td></tr><tr><td><tt>cidr('192.168.0.0/16').containsCIDR(cidr('192.168.10.0/24'))</tt></td><td>Checks if a CIDR contains another given CIDR (CIDR object).</td></tr><tr><td><tt>cidr('192.168.1.0/24').containsCIDR(cidr('192.168.2.0/24'))</tt></td><td>Checks if a CIDR contains another given CIDR (CIDR object).</td></tr><tr><td><tt>cidr('192.168.0.0/16').containsCIDR('192.168.10.0/24')</tt></td><td>Checks if a CIDR contains another given CIDR (string).</td></tr><tr><td><tt>cidr('192.168.1.0/24').containsCIDR('192.168.2.0/24')</tt></td><td>Checks if a CIDR contains another given CIDR (string).</td></tr><tr><td><tt>cidr('192.168.0.1/24').ip()</tt></td><td>Returns the IP address part of a CIDR.</td></tr><tr><td><tt>cidr('192.168.0.1/24').ip().family()</tt></td><td>Returns the family of the IP address part of a CIDR.</td></tr><tr><td><tt>cidr('::1/128').ip()</tt></td><td>Returns the IP address part of an IPv6 CIDR.</td></tr><tr><td><tt>cidr('::1/128').ip().family()</tt></td><td>Returns the family of the IP address part of an IPv6 CIDR.</td></tr><tr><td><tt>cidr('192.168.0.0/24').masked()</tt></td><td>Returns the canonical form of a CIDR network.</td></tr><tr><td><tt>cidr('192.168.0.1/24').masked()</tt></td><td>Returns the canonical form of a CIDR network, masking non-prefix bits.</td></tr><tr><td><tt>cidr('192.168.0.0/24') == cidr('192.168.0.0/24').masked()</tt></td><td>Compares a CIDR to its canonical form (already canonical).</td></tr><tr><td><tt>cidr('192.168.0.1/24') == cidr('192.168.0.1/24').masked()</tt></td><td>Compares a CIDR to its canonical form (not canonical).</td></tr><tr><td><tt>cidr('192.168.0.0/16').prefixLength()</tt></td><td>Returns the prefix length of an IPv4 CIDR.</td></tr><tr><td><tt>cidr('::1/128').prefixLength()</tt></td><td>Returns the prefix length of an IPv6 CIDR.</td></tr></tbody></table><p>See the <a href="https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#CIDR">Kubernetes CIDR library</a> godoc for more information.</p><h3 id="kubernetes-authorizer-library">Kubernetes authorizer library</h3><p>For CEL expressions in the API where a variable of type <code>Authorizer</code> is available,
the authorizer may be used to perform authorization checks for the principal
(authenticated user) of the request.</p><p>API resource checks are performed as follows:</p><ol><li>Specify the group and resource to check: <code>Authorizer.group(string).resource(string) ResourceCheck</code></li><li>Optionally call any combination of the following builder functions to further narrow the authorization check.
Note that these functions return the receiver type and can be chained:<ul><li><code>ResourceCheck.subresource(string) ResourceCheck</code></li><li><code>ResourceCheck.namespace(string) ResourceCheck</code></li><li><code>ResourceCheck.name(string) ResourceCheck</code></li></ul></li><li>Call <code>ResourceCheck.check(verb string) Decision</code> to perform the authorization check.</li><li>Call <code>allowed() bool</code> or <code>reason() string</code> to inspect the result of the authorization check.</li></ol><p>Non-resource authorization performed are used as follows:</p><ol><li>Specify only a path: <code>Authorizer.path(string) PathCheck</code></li><li>Call <code>PathCheck.check(httpVerb string) Decision</code> to perform the authorization check.</li><li>Call <code>allowed() bool</code> or <code>reason() string</code> to inspect the result of the authorization check.</li></ol><p>To perform an authorization check for a service account:</p><ul><li><code>Authorizer.serviceAccount(namespace string, name string) Authorizer</code></li></ul><table><caption>Examples of CEL expressions using URL library functions</caption><thead><tr><th>CEL Expression</th><th>Purpose</th></tr></thead><tbody><tr><td><tt>authorizer.group('').resource('pods').namespace('default').check('create').allowed()</tt></td><td>Returns true if the principal (user or service account) is allowed create pods in the 'default' namespace.</td></tr><tr><td><tt>authorizer.path('/healthz').check('get').allowed()</tt></td><td>Checks if the principal (user or service account) is authorized to make HTTP GET requests to the /healthz API path.</td></tr><tr><td><tt>authorizer.serviceAccount('default', 'myserviceaccount').resource('deployments').check('delete').allowed()<tt/></tt></td><td>Checks if the service account is authorized to delete deployments.</td></tr></tbody></table><div class="feature-state-notice feature-stable" title="Feature Gate: AuthorizeWithSelectors"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.34 [stable]</code> (enabled by default: true)</div><p>For CEL expressions in the API where a variable of type <code>Authorizer</code> is available,
field and label selectors can be included in authorization checks.</p><table><caption>Examples of CEL expressions using selector authorization functions</caption><thead><tr><th>CEL Expression</th><th>Purpose</th></tr></thead><tbody><tr><td><tt>authorizer.group('').resource('pods').fieldSelector('spec.nodeName=mynode').check('list').allowed()</tt></td><td>Returns true if the principal (user or service account) is allowed
to list pods with the field selector <tt>spec.nodeName=mynode</tt>.</td></tr><tr><td><tt>authorizer.group('').resource('pods').labelSelector('example.com/mylabel=myvalue').check('list').allowed()</tt></td><td>Returns true if the principal (user or service account) is allowed
to list pods with the label selector <tt>example.com/mylabel=myvalue</tt>.</td></tr></tbody></table><p>See the <a href="https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz">Kubernetes Authz library</a>
and <a href="https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#AuthzSelectors">Kubernetes AuthzSelectors library</a>
godoc for more information.</p><h3 id="kubernetes-format-library">Kubernetes format library</h3><p>The <code>format</code> library provides functions for validating common Kubernetes string formats.
This can be useful in the <code>messageExpression</code> of validation rules to provide more specific error messages.</p><p>The library provides <code>format()</code> functions for each named format, and a generic <code>format.named()</code> function.</p><ul><li><code>format.named(string)</code>  <code>?Format</code>: Returns the <code>Format</code> object for the given format name, if it exists. Otherwise, returns <code>optional.none</code>.</li><li><code>format.&lt;formatName&gt;() -&gt; Format</code>: Convenience functions for all the named formats are also available. For example, <code>format.dns1123Label()</code> returns the <code>Format</code> object for DNS-1123 labels.</li><li><code>&lt;Format&gt;.validate(string) -&gt; list&lt;string&gt;?</code>: Validates the given string against the format. Returns <code>optional.none</code> if the string is valid, otherwise an optional containing a list of validation error strings.</li></ul><p><strong>Available Formats:</strong></p><p>The following format names are supported:</p><table><caption>Available formats for the format library</caption><thead><tr><th>Format Name</th><th>Description</th></tr></thead><tbody><tr><td><tt>dns1123Label</tt></td><td>Validates if the string is a valid DNS-1123 label.</td></tr><tr><td><tt>dns1123Subdomain</tt></td><td>Validates if the string is a valid DNS-1123 subdomain.</td></tr><tr><td><tt>dns1035Label</tt></td><td>Validates if the string is a valid DNS-1035 label.</td></tr><tr><td><tt>qualifiedName</tt></td><td>Validates if the string is a valid qualified name.</td></tr><tr><td><tt>dns1123LabelPrefix</tt></td><td>Validates if the string is a valid DNS-1123 label prefix.</td></tr><tr><td><tt>dns1123SubdomainPrefix</tt></td><td>Validates if the string is a valid DNS-1123 subdomain prefix.</td></tr><tr><td><tt>dns1035LabelPrefix</tt></td><td>Validates if the string is a valid DNS-1035 label prefix.</td></tr><tr><td><tt>labelValue</tt></td><td>Validates if the string is a valid label value.</td></tr><tr><td><tt>uri</tt></td><td>Validates if the string is a valid URI. Uses the same pattern as `isURL`, but returns an error list.</td></tr><tr><td><tt>uuid</tt></td><td>Validates if the string is a valid UUID.</td></tr><tr><td><tt>byte</tt></td><td>Validates if the string is a valid base64 encoded string.</td></tr><tr><td><tt>date</tt></td><td>Validates if the string is a valid date in `YYYY-MM-DD` format.</td></tr><tr><td><tt>datetime</tt></td><td>Validates if the string is a valid datetime in RFC3339 format.</td></tr></tbody></table><p><strong>Examples:</strong></p><table><caption>Examples of CEL expressions using format library functions</caption><thead><tr><th>CEL Expression</th><th>Purpose</th></tr></thead><tbody><tr><td><tt>!format.dns1123Label().validate(self.metadata.name).hasValue()</tt></td><td>A validation rule that checks if an object's name is a valid DNS-1123 label.</td></tr><tr><td><tt>format.dns1123Label().validate(self.metadata.name).orValue([]).join("\\n")</tt></td><td>A `messageExpression` that returns specific validation errors for a field. If the field is valid, `validate` returns `optional.none`, and `orValue` provides an empty list, resulting in an empty string.</td></tr></tbody></table><p>See the <a href="https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Format">Kubernetes Format library</a> godoc for more information.</p><h3 id="kubernetes-quantity-library">Kubernetes quantity library</h3><p>Kubernetes 1.28 adds support for manipulating quantity strings (ex 1.5G, 512k, 20Mi)</p><ul><li><code>isQuantity(string)</code> checks if a string is a valid Quantity according to
<a href="https://pkg.go.dev/k8s.io/apimachinery/pkg/api/resource#Quantity">Kubernetes' resource.Quantity</a>.</li><li><code>quantity(string) Quantity</code> converts a string to a Quantity or results in an error if the
string is not a valid quantity.</li></ul><p>Once parsed via the <code>quantity</code> function, the resulting Quantity object has the
following library of member functions:</p><table><caption>Available member functions of a Quantity</caption><thead><tr><th>Member Function</th><th>CEL Return Value</th><th>Description</th></tr></thead><tbody><tr><td><tt>isInteger()</tt></td><td>bool</td><td>Returns true if and only if asInteger is safe to call without an error</td></tr><tr><td><tt>asInteger()</tt></td><td>int</td><td>Returns a representation of the current value as an <tt>int64</tt> if possible
or results in an error if conversion would result in overflowor loss of precision.</td></tr><tr><td><tt>asApproximateFloat()</tt></td><td>float</td><td>Returns a <tt>float64</tt> representation of the quantity which may lose precision.
If the value of the quantity is outside the range of a <tt>float64</tt>,
<tt>+Inf/-Inf</tt> will be returned.</td></tr><tr><td><tt>sign()</tt></td><td>int</td><td>Returns <tt>1</tt> if the quantity is positive, <tt>-1</tt> if it is negative.
<tt>0</tt> if it is zero.</td></tr><tr><td><tt>add(&lt;Quantity&gt;)</tt></td><td>Quantity</td><td>Returns sum of two quantities</td></tr><tr><td><tt>add(&lt;int&gt;)</tt></td><td>Quantity</td><td>Returns sum of quantity and an integer</td><td><tr><td><tt>sub(&lt;Quantity&gt;)</tt></td><td>Quantity</td><td>Returns difference between two quantities</td></tr><tr><td><tt>sub(&lt;int&gt;)</tt></td><td>Quantity</td><td>Returns difference between a quantity and an integer</td></tr><tr><td><tt>isLessThan(&lt;Quantity&gt;)</tt></td><td>bool</td><td>Returns true if and only if the receiver is less than the operand</td></tr><tr><td><tt>isGreaterThan(&lt;Quantity&gt;)</tt></td><td>bool</td><td>Returns true if and only if the receiver is greater than the operand</td></tr><tr><td><tt>compareTo(&lt;Quantity&gt;)</tt></td><td>int</td><td>Compares receiver to operand and returns 0 if they are equal,
1 if the receiver is greater, or -1 if the receiver is less than the operand</td></tr></td></tr></tbody></table><p>Examples:</p><table><caption>Examples of CEL expressions using URL library functions</caption><thead><tr><th>CEL Expression</th><th>Purpose</th></tr></thead><tbody><tr><td><tt>quantity("500000G").isInteger()</tt></td><td>Test if conversion to integer would throw an error</td></tr><tr><td><tt>quantity("50k").asInteger()</tt></td><td>Precise conversion to integer</td></tr><tr><td><tt>quantity("9999999999999999999999999999999999999G").asApproximateFloat()</tt></td><td>Lossy conversion to float</td></tr><tr><td><tt>quantity("50k").add(quantity("20k"))</tt></td><td>Add two quantities</td></tr><tr><td><tt>quantity("50k").sub(20000)</tt></td><td>Subtract an integer from a quantity</td></tr><tr><td><tt>quantity("50k").add(20).sub(quantity("100k")).sub(-50000)</tt></td><td>Chain adding and subtracting integers and quantities</td></tr><tr><td><tt>quantity("200M").compareTo(quantity("0.2G"))</tt></td><td>Compare two quantities</td></tr><tr><td><tt>quantity("150Mi").isGreaterThan(quantity("100Mi"))</tt></td><td>Test if a quantity is greater than the receiver</td></tr><tr><td><tt>quantity("50M").isLessThan(quantity("100M"))</tt></td><td>Test if a quantity is less than the receiver</td></tr></tbody></table><h3 id="kubernetes-semver-library">Kubernetes semver library</h3><p>Kubernetes v1.34 adds support for parsing and comparing strings that follow the Semantic Versioning 2.0.0 specification.
Refer to the <a href="https://semver.org/">semver.org</a> documentation for information on accepted patterns.</p><ul><li><code>isSemver(string)</code> checks if a string is a valid semantic version.</li><li><code>semver(string)</code> converts a string to a Semver object or results in an error.</li></ul><p>An optional boolean <code>normalize</code> argument can be passed to <code>isSemver</code> and <code>semver</code>. If <code>true</code>, normalization removes any "v" prefix, adds a 0 minor and patch numbers to versions with only major or major.minor components specified, and removes any leading 0s.</p><p>Once parsed via the <code>semver</code> function, the resulting Semver object has the
following library of member functions:</p><table><caption>Available member functions of a Semver object</caption><thead><tr><th>Member Function</th><th>CEL Return Value</th><th>Description</th></tr></thead><tbody><tr><td><tt>major()</tt></td><td>int</td><td>Returns the major version number.</td></tr><tr><td><tt>minor()</tt></td><td>int</td><td>Returns the minor version number.</td></tr><tr><td><tt>patch()</tt></td><td>int</td><td>Returns the patch version number.</td></tr><tr><td><tt>isLessThan(&lt;Semver&gt;)</tt></td><td>bool</td><td>Returns true if and only if the receiver is less than the operand.</td></tr><tr><td><tt>isGreaterThan(&lt;Semver&gt;)</tt></td><td>bool</td><td>Returns true if and only if the receiver is greater than the operand.</td></tr><tr><td><tt>compareTo(&lt;Semver&gt;)</tt></td><td>int</td><td>Compares receiver to operand and returns 0 if they are equal,
1 if the receiver is greater, or -1 if the receiver is less than the operand.</td></tr></tbody></table><p>Examples:</p><table><caption>Examples of CEL expressions using semver library functions</caption><thead><tr><th>CEL Expression</th><th>Purpose</th></tr></thead><tbody><tr><td><tt>isSemver('1.0.0')</tt></td><td>Returns true for a valid Semver string.</td></tr><tr><td><tt>isSemver('v1.0', true)</tt></td><td>Returns true for a normalizable Semver string.</td></tr><tr><td><tt>semver('1.2.3').major()</tt></td><td>Returns the major version of a Semver.</td></tr><tr><td><tt>semver('1.2.3').compareTo(semver('2.0.0')) &lt; 0</tt></td><td>Compare two Semver strings.</td></tr></tbody></table><p>See the <a href="https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#SemverLib">Kubernetes Semver library</a> godoc for more information.</p><h2 id="type-checking">Type checking</h2><p>CEL is a <a href="https://github.com/google/cel-spec/blob/master/doc/langdef.md#gradual-type-checking">gradually typed language</a>.</p><p>Some Kubernetes API fields contain fully type checked CEL expressions. For example,
<a href="/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#validation-rules">CustomResourceDefinitions Validation Rules</a>
are fully type checked.</p><p>Some Kubernetes API fields contain partially type checked CEL expressions. A
partially type checked expression is an expressions where some of the variables
are statically typed but others are dynamically typed. For example, in the CEL
expressions of
<a href="/docs/reference/access-authn-authz/validating-admission-policy/">ValidatingAdmissionPolicies</a>
the <code>request</code> variable is typed, but the <code>object</code> variable is dynamically typed.
As a result, an expression containing <code>request.namex</code> would fail type checking
because the <code>namex</code> field is not defined. However, <code>object.namex</code> would pass
type checking even when the <code>namex</code> field is not defined for the resource kinds
that <code>object</code> refers to, because <code>object</code> is dynamically typed.</p><p>The <code>has()</code> macro in CEL may be used in CEL expressions to check if a field of a
dynamically typed variable is accessible before attempting to access the field's
value. For example:</p><pre tabindex="0"><code class="language-cel" data-lang="cel">has(object.namex) ? object.namex == 'special' : request.name == 'special'
</code></pre><h2 id="type-system-integration">Type system integration</h2><table><caption>Table showing the relationship between OpenAPIv3 types and CEL types</caption><thead><tr><th>OpenAPIv3 type</th><th>CEL type</th></tr></thead><tbody><tr><td>'object' with Properties</td><td>object / "message type"
(<tt>type(&lt;object&gt;)</tt> evaluates to
<tt>selfType&lt;uniqueNumber&gt;.path.to.object.from.self</tt>)</td></tr><tr><td>'object' with <tt>additionalProperties</tt></td><td>map</td></tr><tr><td>'object' with <tt>x-kubernetes-embedded-type</tt></td><td>object / "message type", 'apiVersion', 'kind', 'metadata.name'
and 'metadata.generateName' are implicitly included in schema</td></tr><tr><td>'object' with x-kubernetes-preserve-unknown-fields</td><td>object / "message type", unknown fields are NOT accessible in CEL expression</td></tr><tr><td><tt>x-kubernetes-int-or-string</tt></td><td>Union of <tt>int</tt> or <tt>string</tt>,
<tt>self.intOrString &lt; 100 | self.intOrString == '50%'</tt>
evaluates to true for both <tt>50</tt> and <tt>"50%"</tt></td></tr><tr><td>'array'</td><td>list</td></tr><tr><td>'array' with <tt>x-kubernetes-list-type=map</tt></td><td>list with map based Equality &amp; unique key guarantees</td></tr><tr><td>'array' with <tt>x-kubernetes-list-type=set</tt></td><td>list with set based Equality &amp; unique entry guarantees</td></tr><tr><td>'boolean'</td><td>boolean</td></tr><tr><td>'number' (all formats)</td><td>double</td></tr><tr><td>'integer' (all formats)</td><td>int (64)</td></tr><tr><td><i>no equivalent</i></td><td>uint (64)</td></tr><tr><td>'null'</td><td>null_type</td></tr><tr><td>'string'</td><td>string</td></tr><tr><td>'string' with format=byte (base64 encoded)</td><td>bytes</td></tr><tr><td>'string' with format=date</td><td>timestamp (<tt>google.protobuf.Timestamp</tt>)</td></tr><tr><td>'string' with format=datetime</td><td>timestamp (<tt>google.protobuf.Timestamp</tt>)</td></tr><tr><td>'string' with format=duration</td><td>duration (<tt>google.protobuf.Duration</tt>)</td></tr></tbody></table><p>Also see: <a href="https://github.com/google/cel-spec/blob/v0.6.0/doc/langdef.md#values">CEL types</a>,
<a href="https://swagger.io/specification/#data-types">OpenAPI types</a>,
<a href="/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#specifying-a-structural-schema">Kubernetes Structural Schemas</a>.</p><p>Equality comparison for arrays with <code>x-kubernetes-list-type</code> of <code>set</code> or <code>map</code> ignores element
order. For example <code>[1, 2] == [2, 1]</code> if the arrays represent Kubernetes <code>set</code> values.</p><p>Concatenation on arrays with <code>x-kubernetes-list-type</code> use the semantics of the
list type:</p><dl><dt><code>set</code></dt><dd><code>X + Y</code> performs a union where the array positions of all elements in
<code>X</code> are preserved and non-intersecting elements in <code>Y</code> are appended, retaining
their partial order.</dd><dt><code>map</code></dt><dd><code>X + Y</code> performs a merge where the array positions of all keys in <code>X</code>
are preserved but the values are overwritten by values in <code>Y</code> when the key
sets of <code>X</code> and <code>Y</code> intersect. Elements in <code>Y</code> with non-intersecting keys are
appended, retaining their partial order.</dd></dl><h2 id="escaping">Escaping</h2><p>Only Kubernetes resource property names of the form
<code>[a-zA-Z_.-/][a-zA-Z0-9_.-/]*</code> are accessible from CEL. Accessible property
names are escaped according to the following rules when accessed in the
expression:</p><table><caption>Table of CEL identifier escaping rules</caption><thead><tr><th>escape sequence</th><th>property name equivalent</th></tr></thead><tbody><tr><td><tt>__underscores__</tt></td><td><tt>__</tt></td></tr><tr><td><tt>__dot__</tt></td><td><tt>.</tt></td></tr><tr><td><tt>__dash__</tt></td><td><tt>-</tt></td></tr><tr><td><tt>__slash__</tt></td><td><tt>/</tt></td></tr><tr><td><tt>__{keyword}__</tt></td><td><a href="https://github.com/google/cel-spec/blob/v0.6.0/doc/langdef.md#syntax">CEL <b>RESERVED</b> keyword</a></td></tr></tbody></table><p>When you escape any of CEL's <strong>RESERVED</strong> keywords you need to match the exact property name
use the underscore escaping
(for example, <code>int</code> in the word <code>sprint</code> would not be escaped and nor would it need to be).</p><p>Examples on escaping:</p><table><caption>Examples escaped CEL identifiers</caption><thead><tr><th>property name</th><th>rule with escaped property name</th></tr></thead><tbody><tr><td><tt>namespace</tt></td><td><tt>self.__namespace__ &gt; 0</tt></td></tr><tr><td><tt>x-prop</tt></td><td><tt>self.x__dash__prop &gt; 0</tt></td></tr><tr><td><tt>redact_d</tt></td><td><tt>self.redact__underscores__d &gt; 0</tt></td></tr><tr><td><tt>string</tt></td><td><tt>self.startsWith('kube')</tt></td></tr></tbody></table><h2 id="resource-constraints">Resource constraints</h2><p>CEL is non-Turing complete and offers a variety of production safety controls to
limit execution time. CEL's <em>resource constraint</em> features provide feedback to
developers about expression complexity and help protect the API server from
excessive resource consumption during evaluation. CEL's resource constraint
features are used to prevent CEL evaluation from consuming excessive API server
resources.</p><p>A key element of the resource constraint features is a <em>cost unit</em> that CEL
defines as a way of tracking CPU utilization. Cost units are independent of
system load and hardware. Cost units are also deterministic; for any given CEL
expression and input data, evaluation of the expression by the CEL interpreter
will always result in the same cost.</p><p>Many of CEL's core operations have fixed costs. The simplest operations, such as
comparisons (e.g. <code>&lt;</code>) have a cost of 1. Some have a higher fixed cost, for
example list literal declarations have a fixed base cost of 40 cost units.</p><p>Calls to functions implemented in native code approximate cost based on the time
complexity of the operation. For example: operations that use regular
expressions, such as <code>match</code> and <code>find</code>, are estimated using an approximated
cost of <code>length(regexString)*length(inputString)</code>. The approximated cost
reflects the worst case time complexity of Go's RE2 implementation.</p><h3 id="runtime-cost-budget">Runtime cost budget</h3><p>All CEL expressions evaluated by Kubernetes are constrained by a runtime cost
budget. The runtime cost budget is an estimate of actual CPU utilization
computed by incrementing a cost unit counter while interpreting a CEL
expression. If the CEL interpreter executes too many instructions, the runtime
cost budget will be exceeded, execution of the expressions will be halted, and
an error will result.</p><p>Some Kubernetes resources define an additional runtime cost budget that bounds
the execution of multiple expressions. If the sum total of the cost of
expressions exceed the budget, execution of the expressions will be halted, and
an error will result. For example the validation of a custom resource has a
<em>per-validation</em> runtime cost budget for all
<a href="/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#validation-rules">Validation Rules</a>
evaluated to validate the custom resource.</p><h3 id="estimated-cost-limits">Estimated cost limits</h3><p>For some Kubernetes resources, the API server may also check if worst case
estimated running time of CEL expressions would be prohibitively expensive to
execute. If so, the API server prevent the CEL expression from being written to
API resources by rejecting create or update operations containing the CEL
expression to the API resources. This feature offers a stronger assurance that
CEL expressions written to the API resource will be evaluated at runtime without
exceeding the runtime cost budget.</p></div>
<hr>
<div class="td-content"><h1 data-pagefind-weight="10">Kubernetes Deprecation Policy</h1><p>This document details the deprecation policy for various facets of the system.</p><p>Kubernetes is a large system with many components and many contributors. As
with any such software, the feature set naturally evolves over time, and
sometimes a feature may need to be removed. This could include an API, a flag,
or even an entire feature. To avoid breaking existing users, Kubernetes follows
a deprecation policy for aspects of the system that are slated to be removed.</p><h2 id="deprecating-parts-of-the-api">Deprecating parts of the API</h2><p>Since Kubernetes is an API-driven system, the API has evolved over time to
reflect the evolving understanding of the problem space. The Kubernetes API is
actually a set of APIs, called "API groups", and each API group is
independently versioned. <a href="/docs/reference/using-api/#api-versioning">API versions</a> fall
into 3 main tracks, each of which has different policies for deprecation:</p><table><thead><tr><th>Example</th><th>Track</th></tr></thead><tbody><tr><td>v1</td><td>GA (generally available, stable)</td></tr><tr><td>v1beta1</td><td>Beta (pre-release)</td></tr><tr><td>v1alpha1</td><td>Alpha (experimental)</td></tr></tbody></table><p>A given release of Kubernetes can support any number of API groups and any
number of versions of each.</p><p>The following rules govern the deprecation of elements of the API. This
includes:</p><ul><li>REST resources (aka API objects)</li><li>Fields of REST resources</li><li>Annotations on REST resources, including "beta" annotations but not
including "alpha" annotations.</li><li>Enumerated or constant values</li><li>Component config structures</li></ul><p>These rules are enforced between official releases, not between
arbitrary commits to master or release branches.</p><p><strong>Rule #1: API elements may only be removed by incrementing the version of the
API group.</strong></p><p>Once an API element has been added to an API group at a particular version, it
can not be removed from that version or have its behavior significantly
changed, regardless of track.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>For historical reasons, there are 2 "monolithic" API groups - "core" (no
group name) and "extensions". Resources will incrementally be moved from these
legacy API groups into more domain-specific API groups.</div><p><strong>Rule #2: API objects must be able to round-trip between API versions in a given
release without information loss, with the exception of whole REST resources
that do not exist in some versions.</strong></p><p>For example, an object can be written as v1 and then read back as v2 and
converted to v1, and the resulting v1 resource will be identical to the
original. The representation in v2 might be different from v1, but the system
knows how to convert between them in both directions. Additionally, any new
field added in v2 must be able to round-trip to v1 and back, which means v1
might have to add an equivalent field or represent it as an annotation.</p><p><strong>Rule #3: An API version in a given track may not be deprecated in favor of a less stable API version.</strong></p><ul><li>GA API versions can replace beta and alpha API versions.</li><li>Beta API versions can replace earlier beta and alpha API versions, but <em>may not</em> replace GA API versions.</li><li>Alpha API versions can replace earlier alpha API versions, but <em>may not</em> replace GA or beta API versions.</li></ul><p><strong>Rule #4a: API lifetime is determined by the API stability level</strong></p><ul><li>GA API versions may be marked as deprecated, but must not be removed within a major version of Kubernetes</li><li>Beta API versions are deprecated no more than 9 months or 3 minor releases after introduction (whichever is longer),
and are no longer served 9 months or 3 minor releases after deprecation (whichever is longer)</li><li>Alpha API versions may be removed in any release without prior deprecation notice</li></ul><p>This ensures beta API support covers the <a href="/releases/version-skew-policy/">maximum supported version skew of 2 releases</a>,
and that APIs don't stagnate on unstable beta versions, accumulating production usage that will be
disrupted when support for the beta API ends.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>There are no current plans for a major version revision of Kubernetes that removes GA APIs.</div><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>Until <a href="https://github.com/kubernetes/kubernetes/issues/52185">#52185</a> is
resolved, no API versions that have been persisted to storage may be removed.
Serving REST endpoints for those versions may be disabled (subject to the
deprecation timelines in this document), but the API server must remain capable
of decoding/converting previously persisted data from storage.</div><p><strong>Rule #4b: The "preferred" API version and the "storage version" for a given
group may not advance until after a release has been made that supports both the
new version and the previous version</strong></p><p>Users must be able to upgrade to a new release of Kubernetes and then roll back
to a previous release, without converting anything to the new API version or
suffering breakages (unless they explicitly used features only available in the
newer version). This is particularly evident in the stored representation of
objects.</p><p>All of this is best illustrated by examples. Imagine a Kubernetes release,
version X, which introduces a new API group. A new Kubernetes release is made
every approximately 4 months (3 per year). The following table describes which
API versions are supported in a series of subsequent releases.</p><table><thead><tr><th>Release</th><th>API Versions</th><th>Preferred/Storage Version</th><th>Notes</th></tr></thead><tbody><tr><td>X</td><td>v1alpha1</td><td>v1alpha1</td><td/></tr><tr><td>X+1</td><td>v1alpha2</td><td>v1alpha2</td><td><ul><li>v1alpha1 is removed. See release notes for required actions.</li></ul></td></tr><tr><td>X+2</td><td>v1beta1</td><td>v1beta1</td><td><ul><li>v1alpha2 is removed. See release notes for required actions.</li></ul></td></tr><tr><td>X+3</td><td>v1beta2, v1beta1 (deprecated)</td><td>v1beta1</td><td><ul><li>v1beta1 is deprecated. See release notes for required actions.</li></ul></td></tr><tr><td>X+4</td><td>v1beta2, v1beta1 (deprecated)</td><td>v1beta2</td><td/></tr><tr><td>X+5</td><td>v1, v1beta1 (deprecated), v1beta2 (deprecated)</td><td>v1beta2</td><td><ul><li>v1beta2 is deprecated. See release notes for required actions.</li></ul></td></tr><tr><td>X+6</td><td>v1, v1beta2 (deprecated)</td><td>v1</td><td><ul><li>v1beta1 is removed. See release notes for required actions.</li></ul></td></tr><tr><td>X+7</td><td>v1, v1beta2 (deprecated)</td><td>v1</td><td/></tr><tr><td>X+8</td><td>v2alpha1, v1</td><td>v1</td><td><ul><li>v1beta2 is removed. See release notes for required actions.</li></ul></td></tr><tr><td>X+9</td><td>v2alpha2, v1</td><td>v1</td><td><ul><li>v2alpha1 is removed. See release notes for required actions.</li></ul></td></tr><tr><td>X+10</td><td>v2beta1, v1</td><td>v1</td><td><ul><li>v2alpha2 is removed. See release notes for required actions.</li></ul></td></tr><tr><td>X+11</td><td>v2beta2, v2beta1 (deprecated), v1</td><td>v1</td><td><ul><li>v2beta1 is deprecated. See release notes for required actions.</li></ul></td></tr><tr><td>X+12</td><td>v2, v2beta2 (deprecated), v2beta1 (deprecated), v1 (deprecated)</td><td>v1</td><td><ul><li>v2beta2 is deprecated. See release notes for required actions.</li><li>v1 is deprecated in favor of v2, but will not be removed</li></ul></td></tr><tr><td>X+13</td><td>v2, v2beta1 (deprecated), v2beta2 (deprecated), v1 (deprecated)</td><td>v2</td><td/></tr><tr><td>X+14</td><td>v2, v2beta2 (deprecated), v1 (deprecated)</td><td>v2</td><td><ul><li>v2beta1 is removed. See release notes for required actions.</li></ul></td></tr><tr><td>X+15</td><td>v2, v1 (deprecated)</td><td>v2</td><td><ul><li>v2beta2 is removed. See release notes for required actions.</li></ul></td></tr></tbody></table><h3 id="rest-resources-aka-api-objects">REST resources (aka API objects)</h3><p>Consider a hypothetical REST resource named Widget, which was present in API v1
in the above timeline, and which needs to be deprecated. We document and
<a href="https://groups.google.com/forum/#!forum/kubernetes-announce">announce</a> the
deprecation in sync with release X+1. The Widget resource still exists in API
version v1 (deprecated) but not in v2alpha1. The Widget resource continues to
exist and function in releases up to and including X+8. Only in release X+9,
when API v1 has aged out, does the Widget resource cease to exist, and the
behavior get removed.</p><p>Starting in Kubernetes v1.19, making an API request to a deprecated REST API endpoint:</p><ol><li><p>Returns a <code>Warning</code> header
(as defined in <a href="https://tools.ietf.org/html/rfc7234#section-5.5">RFC7234, Section 5.5</a>) in the API response.</p></li><li><p>Adds a <code>"k8s.io/deprecated":"true"</code> annotation to the
<a href="/docs/tasks/debug/debug-cluster/audit/">audit event</a> recorded for the request.</p></li><li><p>Sets an <code>apiserver_requested_deprecated_apis</code> gauge metric to <code>1</code> in the <code>kube-apiserver</code>
process. The metric has labels for <code>group</code>, <code>version</code>, <code>resource</code>, <code>subresource</code> that can be joined
to the <code>apiserver_request_total</code> metric, and a <code>removed_release</code> label that indicates the
Kubernetes release in which the API will no longer be served. The following Prometheus query
returns information about requests made to deprecated APIs which will be removed in v1.22:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-promql" data-lang="promql"><span style="display:flex"><span><span style="color:#b8860b">apiserver_requested_deprecated_apis</span>{<span style="color:#a0a000">removed_release</span><span style="color:#666">=</span>"<span style="color:#b44">1.22</span>"}<span style="color:#bbb"> </span><span style="color:#666">*</span><span style="color:#bbb"> </span><span style="color:#a2f;font-weight:700">on</span><span style="color:#666">(</span><span style="color:#a2f;font-weight:700">group</span>,<span style="color:#b8860b">version</span>,<span style="color:#b8860b">resource</span>,<span style="color:#b8860b">subresource</span><span style="color:#666">)</span><span style="color:#bbb"> </span><span style="color:#a2f;font-weight:700">group_right</span><span style="color:#666">()</span><span style="color:#bbb"> </span><span style="color:#b8860b">apiserver_request_total</span><span style="color:#bbb">
</span></span></span></code></pre></div></li></ol><h3 id="fields-of-rest-resources">Fields of REST resources</h3><p>As with whole REST resources, an individual field which was present in API v1
must exist and function until API v1 is removed. Unlike whole resources, the
v2 APIs may choose a different representation for the field, as long as it can
be round-tripped. For example a v1 field named "magnitude" which was
deprecated might be named "deprecatedMagnitude" in API v2. When v1 is
eventually removed, the deprecated field can be removed from v2.</p><h3 id="enumerated-or-constant-values">Enumerated or constant values</h3><p>As with whole REST resources and fields thereof, a constant value which was
supported in API v1 must exist and function until API v1 is removed.</p><h3 id="component-config-structures">Component config structures</h3><p>Component configs are versioned and managed similar to REST resources.</p><h3 id="future-work">Future work</h3><p>Over time, Kubernetes will introduce more fine-grained API versions, at which
point these rules will be adjusted as needed.</p><h2 id="deprecating-a-flag-or-cli">Deprecating a flag or CLI</h2><p>The Kubernetes system is comprised of several different programs cooperating.
Sometimes, a Kubernetes release might remove flags or CLI commands
(collectively "CLI elements") in these programs. The individual programs
naturally sort into two main groups - user-facing and admin-facing programs,
which vary slightly in their deprecation policies. Unless a flag is explicitly
prefixed or documented as "alpha" or "beta", it is considered GA.</p><p>CLI elements are effectively part of the API to the system, but since they are
not versioned in the same way as the REST API, the rules for deprecation are as
follows:</p><p><strong>Rule #5a: CLI elements of user-facing components (e.g. kubectl) must function
after their announced deprecation for no less than:</strong></p><ul><li><strong>GA: 12 months or 2 releases (whichever is longer)</strong></li><li><strong>Beta: 3 months or 1 release (whichever is longer)</strong></li><li><strong>Alpha: 0 releases</strong></li></ul><p><strong>Rule #5b: CLI elements of admin-facing components (e.g. kubelet) must function
after their announced deprecation for no less than:</strong></p><ul><li><strong>GA: 6 months or 1 release (whichever is longer)</strong></li><li><strong>Beta: 3 months or 1 release (whichever is longer)</strong></li><li><strong>Alpha: 0 releases</strong></li></ul><p><strong>Rule #5c: Command line interface (CLI) elements cannot be deprecated in favor of
less stable CLI elements</strong></p><p>Similar to the Rule #3 for APIs, if an element of a command line interface is being replaced with an
alternative implementation, such as by renaming an existing element, or by switching to
use configuration sourced from a file
instead of a command line argument, that recommended alternative must be of
the same or higher stability level.</p><p><strong>Rule #6: Deprecated CLI elements must emit warnings (optionally disable)
when used.</strong></p><h2 id="deprecating-a-feature-or-behavior">Deprecating a feature or behavior</h2><p>Occasionally a Kubernetes release needs to deprecate some feature or behavior
of the system that is not controlled by the API or CLI. In this case, the
rules for deprecation are as follows:</p><p><strong>Rule #7: Deprecated behaviors must function for no less than 1 year after their
announced deprecation.</strong></p><p>If the feature or behavior is being replaced with an alternative implementation
that requires work to adopt the change, there should be an effort to simplify
the transition whenever possible. If an alternative implementation is under
Kubernetes organization control, the following rules apply:</p><p><strong>Rule #8: The feature of behavior must not be deprecated in favor of an alternative
implementation that is less stable</strong></p><p>For example, a generally available feature cannot be deprecated in favor of a Beta replacement.
The Kubernetes project does, however, encourage users to adopt and transitions to alternative
implementations even before they reach the same maturity level. This is particularly important
for exploring new use cases of a feature or getting an early feedback on the replacement.</p><p>Alternative implementations may sometimes be external tools or products,
for example a feature may move from the kubelet to container runtime
that is not under Kubernetes project control. In such cases, the rule cannot be
applied, but there must be an effort to ensure that there is a transition path
that does not compromise on components' maturity levels. In the example with
container runtimes, the effort may involve trying to ensure that popular container runtimes
have versions that offer the same level of stability while implementing that replacement behavior.</p><p>Deprecation rules for features and behaviors do not imply that all changes
to the system are governed by this policy.
These rules apply only to significant, user-visible behaviors which impact the
correctness of applications running on Kubernetes or that impact the
administration of Kubernetes clusters, and which are being removed entirely.</p><p>An exception to the above rule is <em>feature gates</em>. Feature gates are key=value
pairs that allow for users to enable/disable experimental features.</p><p>Feature gates are intended to cover the development life cycle of a feature - they
are not intended to be long-term APIs. As such, they are expected to be deprecated
and removed after a feature becomes GA or is dropped.</p><p>As a feature moves through the stages, the associated feature gate evolves.
The feature life cycle matched to its corresponding feature gate is:</p><ul><li>Alpha: the feature gate is disabled by default and can be enabled by the user.</li><li>Beta: the feature gate is enabled by default and can be disabled by the user.</li><li>GA: the feature gate is deprecated (see <a href="#deprecation">"Deprecation"</a>) and becomes
non-operational.</li><li>GA, deprecation window complete: the feature gate is removed and calls to it are
no longer accepted.</li></ul><h3 id="deprecation">Deprecation</h3><p>Features can be removed at any point in the life cycle prior to GA. When features are
removed prior to GA, their associated feature gates are also deprecated.</p><p>When an invocation tries to disable a non-operational feature gate, the call fails in order
to avoid unsupported scenarios that might otherwise run silently.</p><p>In some cases, removing pre-GA features requires considerable time. Feature gates can remain
operational until their associated feature is fully removed, at which point the feature gate
itself can be deprecated.</p><p>When removing a feature gate for a GA feature also requires considerable time, calls to
feature gates may remain operational if the feature gate has no effect on the feature,
and if the feature gate causes no errors.</p><p>Features intended to be disabled by users should include a mechanism for disabling the
feature in the associated feature gate.</p><p>Versioning for feature gates is different from the previously discussed components,
therefore the rules for deprecation are as follows:</p><p><strong>Rule #9: Feature gates must be deprecated when the corresponding feature they control
transitions a lifecycle stage as follows. Feature gates must function for no less than:</strong></p><ul><li><strong>Beta feature to GA: 6 months or 2 releases (whichever is longer)</strong></li><li><strong>Beta feature to EOL: 3 months or 1 release (whichever is longer)</strong></li><li><strong>Alpha feature to EOL: 0 releases</strong></li></ul><p><strong>Rule #10: Deprecated feature gates must respond with a warning when used. When a feature gate
is deprecated it must be documented in both in the release notes and the corresponding CLI help.
Both warnings and documentation must indicate whether a feature gate is non-operational.</strong></p><h2 id="deprecating-a-metric">Deprecating a metric</h2><p>Each component of the Kubernetes control-plane exposes metrics (usually the
<code>/metrics</code> endpoint), which are typically ingested by cluster administrators.
Not all metrics are the same: some metrics are commonly used as SLIs or used
to determine SLOs, these tend to have greater import. Other metrics are more
experimental in nature or are used primarily in the Kubernetes development
process.</p><p>Accordingly, metrics fall under three stability classes (<code>ALPHA</code>, <code>BETA</code> <code>STABLE</code>);
this impacts removal of a metric during a Kubernetes release. These classes
are determined by the perceived importance of the metric. The rules for
deprecating and removing a metric are as follows:</p><p><strong>Rule #11a: Metrics, for the corresponding stability class, must function for no less than:</strong></p><ul><li><strong>STABLE: 4 releases or 12 months (whichever is longer)</strong></li><li><strong>BETA: 2 releases or 8 months (whichever is longer)</strong></li><li><strong>ALPHA: 0 releases</strong></li></ul><p><strong>Rule #11b: Metrics, after their <em>announced deprecation</em>, must function for no less than:</strong></p><ul><li><strong>STABLE: 3 releases or 9 months (whichever is longer)</strong></li><li><strong>BETA: 1 releases or 4 months (whichever is longer)</strong></li><li><strong>ALPHA: 0 releases</strong></li></ul><p>Deprecated metrics will have their description text prefixed with a deprecation notice
string '(Deprecated from x.y)' and a warning log will be emitted during metric
registration. Like their stable undeprecated counterparts, deprecated metrics will
be automatically registered to the metrics endpoint and therefore visible.</p><p>On a subsequent release (when the metric's <code>deprecatedVersion</code> is equal to
<em>current_kubernetes_version - 3</em>), a deprecated metric will become a <em>hidden</em> metric.
<strong><em>Unlike</em></strong> their deprecated counterparts, hidden metrics will <em>no longer</em> be
automatically registered to the metrics endpoint (hence hidden). However, they
can be explicitly enabled through a command line flag on the binary
(<code>--show-hidden-metrics-for-version=</code>). This provides cluster admins an
escape hatch to properly migrate off of a deprecated metric, if they were not
able to react to the earlier deprecation warnings. Hidden metrics should be
deleted after one release.</p><h2 id="exceptions">Exceptions</h2><p>No policy can cover every possible situation. This policy is a living
document, and will evolve over time. In practice, there will be situations
that do not fit neatly into this policy, or for which this policy becomes a
serious impediment. Such situations should be discussed with SIGs and project
leaders to find the best solutions for those specific cases, always bearing in
mind that Kubernetes is committed to being a stable system that, as much as
possible, never breaks users. Exceptions will always be announced in all
relevant release notes.</p></div>
<hr>
<div class="td-content"><h1 data-pagefind-weight="10">API Overview</h1><p>This section provides reference information for the Kubernetes API.</p><p>The REST API is the fundamental fabric of Kubernetes. All operations and
communications between components, and external user commands are REST API
calls that the API Server handles. Consequently, everything in the Kubernetes
platform is treated as an API object and has a corresponding entry in the
<a href="/docs/reference/generated/kubernetes-api/v1.34/">API</a>.</p><p>The <a href="/docs/reference/generated/kubernetes-api/v1.34/">Kubernetes API reference</a>
lists the API for Kubernetes version v1.34.</p><p>For general background information, read
<a href="/docs/concepts/overview/kubernetes-api/">The Kubernetes API</a>.
<a href="/docs/concepts/security/controlling-access/">Controlling Access to the Kubernetes API</a>
describes how clients can authenticate to the Kubernetes API server, and how their
requests are authorized.</p><h2 id="api-versioning">API versioning</h2><p>The JSON and Protobuf serialization schemas follow the same guidelines for
schema changes. The following descriptions cover both formats.</p><p>The API versioning and software versioning are indirectly related.
The <a href="https://git.k8s.io/sig-release/release-engineering/versioning.md">API and release versioning proposal</a>
describes the relationship between API versioning and software versioning.</p><p>Different API versions indicate different levels of stability and support. You
can find more information about the criteria for each level in the
<a href="https://git.k8s.io/community/contributors/devel/sig-architecture/api_changes.md#alpha-beta-and-stable-versions">API Changes documentation</a>.</p><p>Here's a summary of each level:</p><ul><li><p>Alpha:</p><ul><li>The version names contain <code>alpha</code> (for example, <code>v1alpha1</code>).</li><li>Built-in alpha API versions are disabled by default and must be explicitly enabled in the <code>kube-apiserver</code> configuration to be used.</li><li>The software may contain bugs. Enabling a feature may expose bugs.</li><li>Support for an alpha API may be dropped at any time without notice.</li><li>The API may change in incompatible ways in a later software release without notice.</li><li>The software is recommended for use only in short-lived testing clusters,
due to increased risk of bugs and lack of long-term support.</li></ul></li><li><p>Beta:</p><ul><li><p>The version names contain <code>beta</code> (for example, <code>v2beta3</code>).</p></li><li><p>Built-in beta API versions are disabled by default and must be explicitly enabled in the <code>kube-apiserver</code> configuration to be used
(<strong>except</strong> for beta versions of APIs introduced prior to Kubernetes 1.22, which were enabled by default).</p></li><li><p>Built-in beta API versions have a maximum lifetime of 9 months or 3 minor releases (whichever is longer) from introduction
to deprecation, and 9 months or 3 minor releases (whichever is longer) from deprecation to removal.</p></li><li><p>The software is well tested. Enabling a feature is considered safe.</p></li><li><p>The support for a feature will not be dropped, though the details may change.</p></li><li><p>The schema and/or semantics of objects may change in incompatible ways in
a subsequent beta or stable API version. When this happens, migration
instructions are provided. Adapting to a subsequent beta or stable API version
may require editing or re-creating API objects, and may not be straightforward.
The migration may require downtime for applications that rely on the feature.</p></li><li><p>The software is not recommended for production uses. Subsequent releases
may introduce incompatible changes. Use of beta API versions is
required to transition to subsequent beta or stable API versions
once the beta API version is deprecated and no longer served.</p></li></ul><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>Please try beta features and provide feedback. After the features exit beta, it
may not be practical to make more changes.</div></li><li><p>Stable:</p><ul><li>The version name is <code>vX</code> where <code>X</code> is an integer.</li><li>Stable API versions remain available for all future releases within a Kubernetes major version,
and there are no current plans for a major version revision of Kubernetes that removes stable APIs.</li></ul></li></ul><h2 id="api-groups">API groups</h2><p><a href="https://git.k8s.io/design-proposals-archive/api-machinery/api-group.md">API groups</a>
make it easier to extend the Kubernetes API.
The API group is specified in a REST path and in the <code>apiVersion</code> field of a
serialized object.</p><p>There are several API groups in Kubernetes:</p><ul><li>The <em>core</em> (also called <em>legacy</em>) group is found at REST path <code>/api/v1</code>.
The core group is not specified as part of the <code>apiVersion</code> field, for
example, <code>apiVersion: v1</code>.</li><li>The named groups are at REST path <code>/apis/$GROUP_NAME/$VERSION</code> and use
<code>apiVersion: $GROUP_NAME/$VERSION</code> (for example, <code>apiVersion: batch/v1</code>).
You can find the full list of supported API groups in
<a href="/docs/reference/generated/kubernetes-api/v1.34/#-strong-api-groups-strong-">Kubernetes API reference</a>.</li></ul><h2 id="enabling-or-disabling">Enabling or disabling API groups</h2><p>Certain resources and API groups are enabled by default. You can enable or
disable them by setting <code>--runtime-config</code> on the API server. The
<code>--runtime-config</code> flag accepts comma separated <code>&lt;key&gt;[=&lt;value&gt;]</code> pairs
describing the runtime configuration of the API server. If the <code>=&lt;value&gt;</code>
part is omitted, it is treated as if <code>=true</code> is specified. For example:</p><ul><li>to disable <code>batch/v1</code>, set <code>--runtime-config=batch/v1=false</code></li><li>to enable <code>batch/v2alpha1</code>, set <code>--runtime-config=batch/v2alpha1</code></li><li>to enable a specific version of an API, such as <code>storage.k8s.io/v1beta1/csistoragecapacities</code>, set <code>--runtime-config=storage.k8s.io/v1beta1/csistoragecapacities</code></li></ul><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>When you enable or disable groups or resources, you need to restart the API
server and controller manager to pick up the <code>--runtime-config</code> changes.</div><h2 id="persistence">Persistence</h2><p>Kubernetes stores its serialized state in terms of the API resources by writing them into
<a class="glossary-tooltip" title="Consistent and highly-available key value store used as backing store of Kubernetes for all cluster data." data-toggle="tooltip" data-placement="top" href="/docs/tasks/administer-cluster/configure-upgrade-etcd/" target="_blank" aria-label="etcd">etcd</a>.</p><h2 id="what-s-next">What's next</h2><ul><li>Learn more about <a href="https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#api-conventions">API conventions</a></li><li>Read the design documentation for
<a href="https://git.k8s.io/design-proposals-archive/api-machinery/aggregated-api-servers.md">aggregator</a></li><li>Learn about <a href="/docs/reference/using-api/declarative-validation/">Declarative API Validation</a>.</li></ul><div class="section-index"/></div>
<hr>
<div class="td-content"><h1 data-pagefind-weight="10">Server-Side Apply</h1><div class="feature-state-notice feature-stable" title="Feature Gate: ServerSideApply"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.22 [stable]</code> (enabled by default: true)</div><p>Kubernetes supports multiple appliers collaborating to manage the fields
of a single <a href="/docs/concepts/overview/working-with-objects/">object</a>.</p><p>Server-Side Apply provides an optional mechanism for your cluster's control plane to track
changes to an object's fields. At the level of a specific resource, Server-Side
Apply records and tracks information about control over the fields of that object.</p><p>Server-Side Apply helps users and <a class="glossary-tooltip" title="A control loop that watches the shared state of the cluster through the apiserver and makes changes attempting to move the current state towards the desired state." data-toggle="tooltip" data-placement="top" href="/docs/concepts/architecture/controller/" target="_blank" aria-label="controllers">controllers</a>
manage their resources through declarative configuration. Clients can create and modify
<a class="glossary-tooltip" title="An entity in the Kubernetes system, representing part of the state of your cluster." data-toggle="tooltip" data-placement="top" href="/docs/concepts/overview/working-with-objects/#kubernetes-objects" target="_blank" aria-label="objects">objects</a>
declaratively by submitting their <em>fully specified intent</em>.</p><p>A fully specified intent is a partial object that only includes the fields and
values for which the user has an opinion. That intent either creates a new
object (using default values for unspecified fields), or is
<a href="#merge-strategy">combined</a>, by the API server, with the existing object.</p><p><a href="#comparison-with-client-side-apply">Comparison with Client-Side Apply</a> explains
how Server-Side Apply differs from the original, client-side <code>kubectl apply</code>
implementation.</p><h2 id="field-management">Field management</h2><p>The Kubernetes API server tracks <em>managed fields</em> for all newly created objects.</p><p>When trying to apply an object, fields that have a different value and are owned by
another <a href="#managers">manager</a> will result in a <a href="#conflicts">conflict</a>. This is done
in order to signal that the operation might undo another collaborator's changes.
Writes to objects with managed fields can be forced, in which case the value of any
conflicted field will be overridden, and the ownership will be transferred.</p><p>Whenever a field's value does change, ownership moves from its current manager to the
manager making the change.</p><p>Apply checks if there are any other field managers that also own the
field. If the field is not owned by any other field managers, that field is
set to its default value (if there is one), or otherwise is deleted from the
object.
The same rule applies to fields that are lists, associative lists, or maps.</p><p>For a user to manage a field, in the Server-Side Apply sense, means that the
user relies on and expects the value of the field not to change. The user who
last made an assertion about the value of a field will be recorded as the
current field manager. This can be done by changing the field manager
details explicitly using HTTP <code>POST</code> (<strong>create</strong>), <code>PUT</code> (<strong>update</strong>), or non-apply
<code>PATCH</code> (<strong>patch</strong>). You can also declare and record a field manager
by including a value for that field in a Server-Side Apply operation.</p><p>A Server-Side Apply <strong>patch</strong> request requires the client to provide its identity
as a <a href="#managers">field manager</a>. When using Server-Side Apply, trying to change a
field that is controlled by a different manager results in a rejected
request unless the client forces an override.
For details of overrides, see <a href="#conflicts">Conflicts</a>.</p><p>When two or more appliers set a field to the same value, they share ownership of
that field. Any subsequent attempt to change the value of the shared field, by any of
the appliers, results in a conflict. Shared field owners may give up ownership
of a field by making a Server-Side Apply <strong>patch</strong> request that doesn't include
that field.</p><p>Field management details are stored in a <code>managedFields</code> field that is part of an
object's <a href="/docs/reference/kubernetes-api/common-definitions/object-meta/"><code>metadata</code></a>.</p><p>If you remove a field from a manifest and apply that manifest, Server-Side
Apply checks if there are any other field managers that also own the field.
If the field is not owned by any other field managers, it is either deleted
from the live object or reset to its default value, if it has one.
The same rule applies to associative list or map items.</p><p>Compared to the (legacy)
<a href="/docs/reference/labels-annotations-taints/#kubectl-kubernetes-io-last-applied-configuration"><code>kubectl.kubernetes.io/last-applied-configuration</code></a>
annotation managed by <code>kubectl</code>, Server-Side Apply uses a more declarative
approach, that tracks a user's (or client's) field management, rather than
a user's last applied state. As a side effect of using Server-Side Apply,
information about which field manager manages each field in an object also
becomes available.</p><h3 id="ssa-example-configmap">Example</h3><p>A simple example of an object created using Server-Side Apply could look like this:</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4><code>kubectl get</code> omits managed fields by default.
Add <code>--show-managed-fields</code> to show <code>managedFields</code> when the output format is either <code>json</code> or <code>yaml</code>.</div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:#00f;font-weight:700">---</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>ConfigMap<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">metadata</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>test-cm<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">namespace</span>:<span style="color:#bbb"> </span>default<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">labels</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">test-label</span>:<span style="color:#bbb"> </span>test<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">managedFields</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span>- <span style="color:green;font-weight:700">manager</span>:<span style="color:#bbb"> </span>kubectl<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">operation: Apply # note capitalization</span>:<span style="color:#bbb"> </span><span style="color:#b44">"Apply"</span><span style="color:#bbb"> </span>(or "Update")<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">time</span>:<span style="color:#bbb"> </span><span style="color:#b44">"2010-10-10T0:00:00Z"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">fieldsType</span>:<span style="color:#bbb"> </span>FieldsV1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">fieldsV1</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">f:metadata</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">f:labels</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">          </span><span style="color:green;font-weight:700">f:test-label</span>:<span style="color:#bbb"> </span>{}<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">f:data</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">f:key</span>:<span style="color:#bbb"> </span>{}<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">data</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">key</span>:<span style="color:#bbb"> </span>some value<span style="color:#bbb">
</span></span></span></code></pre></div><p>That example ConfigMap object contains a single field management record in
<code>.metadata.managedFields</code>. The field management record consists of basic information
about the managing entity itself, plus details about the fields being managed and
the relevant operation (<code>Apply</code> or <code>Update</code>). If the request that last changed that
field was a Server-Side Apply <strong>patch</strong> then the value of <code>operation</code> is <code>Apply</code>;
otherwise, it is <code>Update</code>.</p><p>There is another possible outcome. A client could submit an invalid request
body. If the fully specified intent does not produce a valid object, the
request fails.</p><p>It is however possible to change <code>.metadata.managedFields</code> through an
<strong>update</strong>, or through a <strong>patch</strong> operation that does not use Server-Side Apply.
Doing so is highly discouraged, but might be a reasonable option to try if,
for example, the <code>.metadata.managedFields</code> get into an inconsistent state
(which should not happen in normal operations).</p><p>The format of <code>managedFields</code> is <a href="/docs/reference/kubernetes-api/common-definitions/object-meta/#System">described</a>
in the Kubernetes API reference.</p><div class="alert alert-caution" role="alert"><h4 class="alert-heading">Caution:</h4>The <code>.metadata.managedFields</code> field is managed by the API server.
You should avoid updating it manually.</div><h3 id="conflicts">Conflicts</h3><p>A <em>conflict</em> is a special status error that occurs when an <code>Apply</code> operation tries
to change a field that another manager also claims to manage. This prevents an
applier from unintentionally overwriting the value set by another user. When
this occurs, the applier has 3 options to resolve the conflicts:</p><ul><li><p><strong>Overwrite value, become sole manager:</strong> If overwriting the value was
intentional (or if the applier is an automated process like a controller) the
applier should set the <code>force</code> query parameter to true (for <code>kubectl apply</code>,
you use the <code>--force-conflicts</code> command line parameter), and make the request
again. This forces the operation to succeed, changes the value of the field,
and removes the field from all other managers' entries in <code>managedFields</code>.</p></li><li><p><strong>Don't overwrite value, give up management claim:</strong> If the applier doesn't
care about the value of the field any more, the applier can remove it from their
local model of the resource, and make a new request with that particular field
omitted. This leaves the value unchanged, and causes the field to be removed
from the applier's entry in <code>managedFields</code>.</p></li><li><p><strong>Don't overwrite value, become shared manager:</strong> If the applier still cares
about the value of a field, but doesn't want to overwrite it, they can
change the value of that field in their local model of the resource so as to
match the value of the object on the server, and then make a new request that
takes into account that local update. Doing so leaves the value unchanged,
and causes that field's management to be shared by the applier along with all
other field managers that already claimed to manage it.</p></li></ul><h3 id="managers">Field managers</h3><p>Managers identify distinct workflows that are modifying the object (especially
useful on conflicts!), and can be specified through the
<a href="/docs/reference/kubernetes-api/common-parameters/common-parameters/#fieldManager"><code>fieldManager</code></a>
query parameter as part of a modifying request. When you Apply to a resource,
the <code>fieldManager</code> parameter is required.
For other updates, the API server infers a field manager identity from the
"User-Agent:" HTTP header (if present).</p><p>When you use the <code>kubectl</code> tool to perform a Server-Side Apply operation, <code>kubectl</code>
sets the manager identity to <code>"kubectl"</code> by default.</p><h2 id="serialization">Serialization</h2><p>At the protocol level, Kubernetes represents Server-Side Apply message bodies
as <a href="https://yaml.org/">YAML</a>, with the media type <code>application/apply-patch+yaml</code>.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4><p>Whether you are submitting JSON data or YAML data, use
<code>application/apply-patch+yaml</code> as the <code>Content-Type</code> header value.</p><p>All JSON documents are valid YAML. However, Kubernetes has a bug where it uses a YAML
parser that does not fully implement the YAML specification. Some JSON escapes may
not be recognized.</p></div><p>The serialization is the same as for Kubernetes objects, with the exception that
clients are not required to send a complete object.</p><p>Here's an example of a Server-Side Apply message body (fully specified intent):</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span>{<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">"apiVersion": </span><span style="color:#b44">"v1"</span>,<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">"kind": </span><span style="color:#b44">"ConfigMap"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/>}<span style="color:#bbb">
</span></span></span></code></pre></div><p>(this would make a no-change update, provided that it was sent as the body
of a <strong>patch</strong> request to a valid <code>v1/configmaps</code> resource, and with the
appropriate request <code>Content-Type</code>).</p><h2 id="apply-and-update">Operations in scope for field management</h2><p>The Kubernetes API operations where field management is considered are:</p><ol><li>Server-Side Apply (HTTP <code>PATCH</code>, with content type <code>application/apply-patch+yaml</code>)</li><li>Replacing an existing object (<strong>update</strong> to Kubernetes; <code>PUT</code> at the HTTP level)</li></ol><p>Both operations update <code>.metadata.managedFields</code>, but behave a little differently.</p><p>Unless you specify a forced override, an apply operation that encounters field-level
conflicts always fails; by contrast, if you make a change using <strong>update</strong> that would
affect a managed field, a conflict never provokes failure of the operation.</p><p>All Server-Side Apply <strong>patch</strong> requests are required to identify themselves by providing a
<code>fieldManager</code> query parameter, while the query parameter is optional for <strong>update</strong>
operations. Finally, when using the <code>Apply</code> operation you cannot define <code>managedFields</code> in
the body of the request that you submit.</p><p>An example object with multiple managers could look like this:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:#00f;font-weight:700">---</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>ConfigMap<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">metadata</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>test-cm<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">namespace</span>:<span style="color:#bbb"> </span>default<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">labels</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">test-label</span>:<span style="color:#bbb"> </span>test<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">managedFields</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span>- <span style="color:green;font-weight:700">manager</span>:<span style="color:#bbb"> </span>kubectl<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">operation</span>:<span style="color:#bbb"> </span>Apply<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">time</span>:<span style="color:#bbb"> </span><span style="color:#b44">'2019-03-30T15:00:00.000Z'</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">fieldsType</span>:<span style="color:#bbb"> </span>FieldsV1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">fieldsV1</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">f:metadata</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">f:labels</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">          </span><span style="color:green;font-weight:700">f:test-label</span>:<span style="color:#bbb"> </span>{}<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span>- <span style="color:green;font-weight:700">manager</span>:<span style="color:#bbb"> </span>kube-controller-manager<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">operation</span>:<span style="color:#bbb"> </span>Update<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">time</span>:<span style="color:#bbb"> </span><span style="color:#b44">'2019-03-30T16:00:00.000Z'</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">fieldsType</span>:<span style="color:#bbb"> </span>FieldsV1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">fieldsV1</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">f:data</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">f:key</span>:<span style="color:#bbb"> </span>{}<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">data</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">key</span>:<span style="color:#bbb"> </span>new value<span style="color:#bbb">
</span></span></span></code></pre></div><p>In this example, a second operation was run as an <strong>update</strong> by the manager called
<code>kube-controller-manager</code>. The update request succeeded and changed a value in the data
field, which caused that field's management to change to the <code>kube-controller-manager</code>.</p><p>If this update has instead been attempted using Server-Side Apply, the request
would have failed due to conflicting ownership.</p><h2 id="merge-strategy">Merge strategy</h2><p>The merging strategy, implemented with Server-Side Apply, provides a generally
more stable object lifecycle. Server-Side Apply tries to merge fields based on
the actor who manages them instead of overruling based on values. This way
multiple actors can update the same object without causing unexpected interference.</p><p>When a user sends a <em>fully-specified intent</em> object to the Server-Side Apply
endpoint, the server merges it with the live object favoring the value from the
request body if it is specified in both places. If the set of items present in
the applied config is not a superset of the items applied by the same user last
time, each missing item not managed by any other appliers is removed. For
more information about how an object's schema is used to make decisions when
merging, see
<a href="https://sigs.k8s.io/structured-merge-diff">sigs.k8s.io/structured-merge-diff</a>.</p><p>The Kubernetes API (and the Go code that implements that API for Kubernetes) allows
defining <em>merge strategy markers</em>. These markers describe the merge strategy supported
for fields within Kubernetes objects.
For a <a class="glossary-tooltip" title="Custom code that defines a resource to add to your Kubernetes API server without building a complete custom server." data-toggle="tooltip" data-placement="top" href="/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/" target="_blank" aria-label="CustomResourceDefinition">CustomResourceDefinition</a>,
you can set these markers when you define the custom resource.</p><table><thead><tr><th>Golang marker</th><th>OpenAPI extension</th><th>Possible values</th><th>Description</th></tr></thead><tbody><tr><td><code>//+listType</code></td><td><code>x-kubernetes-list-type</code></td><td><code>atomic</code>/<code>set</code>/<code>map</code></td><td>Applicable to lists. <code>set</code> applies to lists that include only scalar elements. These elements must be unique. <code>map</code> applies to lists of nested types only. The key values (see <code>listMapKey</code>) must be unique in the list. <code>atomic</code> can apply to any list. If configured as <code>atomic</code>, the entire list is replaced during merge. At any point in time, a single manager owns the list. If <code>set</code> or <code>map</code>, different managers can manage entries separately.</td></tr><tr><td><code>//+listMapKey</code></td><td><code>x-kubernetes-list-map-keys</code></td><td>List of field names, e.g. <code>["port", "protocol"]</code></td><td>Only applicable when <code>+listType=map</code>. A list of field names whose values uniquely identify entries in the list. While there can be multiple keys, <code>listMapKey</code> is singular because keys need to be specified individually in the Go type. The key fields must be scalars.</td></tr><tr><td><code>//+mapType</code></td><td><code>x-kubernetes-map-type</code></td><td><code>atomic</code>/<code>granular</code></td><td>Applicable to maps. <code>atomic</code> means that the map can only be entirely replaced by a single manager. <code>granular</code> means that the map supports separate managers updating individual fields.</td></tr><tr><td><code>//+structType</code></td><td><code>x-kubernetes-map-type</code></td><td><code>atomic</code>/<code>granular</code></td><td>Applicable to structs; otherwise same usage and OpenAPI annotation as <code>//+mapType</code>.</td></tr></tbody></table><p>If <code>listType</code> is missing, the API server interprets a
<code>patchStrategy=merge</code> marker as a <code>listType=map</code> and the
corresponding <code>patchMergeKey</code> marker as a <code>listMapKey</code>.</p><p>The <code>atomic</code> list type is recursive.</p><p>(In the <a href="https://go.dev/">Go</a> code for Kubernetes, these markers are specified as
comments and code authors need not repeat them as field tags).</p><h2 id="custom-resources-and-server-side-apply">Custom resources and Server-Side Apply</h2><p>By default, Server-Side Apply treats custom resources as unstructured data. All
keys are treated the same as struct fields, and all lists are considered atomic.</p><p>If the CustomResourceDefinition defines a
<a href="/docs/reference/generated/kubernetes-api/v1.34#jsonschemaprops-v1-apiextensions-k8s-io">schema</a>
that contains annotations as defined in the previous <a href="#merge-strategy">Merge Strategy</a>
section, these annotations will be used when merging objects of this
type.</p><h3 id="compatibility-across-topology-changes">Compatibility across topology changes</h3><p>On rare occurrences, the author for a CustomResourceDefinition (CRD) or built-in
may want to change the specific topology of a field in their resource,
without incrementing its API version. Changing the topology of types,
by upgrading the cluster or updating the CRD, has different consequences when
updating existing objects. There are two categories of changes: when a field goes from
<code>map</code>/<code>set</code>/<code>granular</code> to <code>atomic</code>, and the other way around.</p><p>When the <code>listType</code>, <code>mapType</code>, or <code>structType</code> changes from
<code>map</code>/<code>set</code>/<code>granular</code> to <code>atomic</code>, the whole list, map, or struct of
existing objects will end-up being owned by actors who owned an element
of these types. This means that any further change to these objects
would cause a conflict.</p><p>When a <code>listType</code>, <code>mapType</code>, or <code>structType</code> changes from <code>atomic</code> to
<code>map</code>/<code>set</code>/<code>granular</code>, the API server is unable to infer the new
ownership of these fields. Because of that, no conflict will be produced
when objects have these fields updated. For that reason, it is not
recommended to change a type from <code>atomic</code> to <code>map</code>/<code>set</code>/<code>granular</code>.</p><p>Take for example, the custom resource:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:#00f;font-weight:700">---</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>example.com/v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>Foo<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">metadata</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>foo-sample<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">managedFields</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span>- <span style="color:green;font-weight:700">manager</span>:<span style="color:#bbb"> </span><span style="color:#b44">"manager-one"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">operation</span>:<span style="color:#bbb"> </span>Apply<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>example.com/v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">fieldsType</span>:<span style="color:#bbb"> </span>FieldsV1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">fieldsV1</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">f:spec</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">f:data</span>:<span style="color:#bbb"> </span>{}<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">spec</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">data</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">key1</span>:<span style="color:#bbb"> </span>val1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">key2</span>:<span style="color:#bbb"> </span>val2<span style="color:#bbb">
</span></span></span></code></pre></div><p>Before <code>spec.data</code> gets changed from <code>atomic</code> to <code>granular</code>,
<code>manager-one</code> owns the field <code>spec.data</code>, and all the fields within it
(<code>key1</code> and <code>key2</code>). When the CRD gets changed to make <code>spec.data</code>
<code>granular</code>, <code>manager-one</code> continues to own the top-level field
<code>spec.data</code> (meaning no other managers can delete the map called <code>data</code>
without a conflict), but it no longer owns <code>key1</code> and <code>key2</code>, so another
manager can then modify or delete those fields without conflict.</p><h2 id="using-server-side-apply-in-a-controller">Using Server-Side Apply in a controller</h2><p>As a developer of a controller, you can use Server-Side Apply as a way to
simplify the update logic of your controller. The main differences with a
read-modify-write and/or patch are the following:</p><ul><li>the applied object must contain all the fields that the controller cares about.</li><li>there is no way to remove fields that haven't been applied by the controller
before (controller can still send a <strong>patch</strong> or <strong>update</strong> for these use-cases).</li><li>the object doesn't have to be read beforehand; <code>resourceVersion</code> doesn't have
to be specified.</li></ul><p>It is strongly recommended for controllers to always force conflicts on objects that
they own and manage, since they might not be able to resolve or act on these conflicts.</p><h2 id="transferring-ownership">Transferring ownership</h2><p>In addition to the concurrency controls provided by <a href="#conflicts">conflict resolution</a>,
Server-Side Apply provides ways to perform coordinated
field ownership transfers from users to controllers.</p><p>This is best explained by example. Let's look at how to safely transfer
ownership of the <code>replicas</code> field from a user to a controller while enabling
automatic horizontal scaling for a Deployment, using the HorizontalPodAutoscaler
resource and its accompanying controller.</p><p>Say a user has defined Deployment with <code>replicas</code> set to the desired value:</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/application/ssa/nginx-deployment.yaml" download="application/ssa/nginx-deployment.yaml"><code>application/ssa/nginx-deployment.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" onclick="copyCode(&quot;application-ssa-nginx-deployment-yaml&quot;)" title="Copy application/ssa/nginx-deployment.yaml to clipboard"/></div><div class="includecode" id="application-ssa-nginx-deployment-yaml"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>apps/v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>Deployment<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">metadata</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>nginx-deployment<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">labels</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">app</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">spec</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">replicas</span>:<span style="color:#bbb"> </span><span style="color:#666">3</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">selector</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">matchLabels</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">app</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">template</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">metadata</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">labels</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">app</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">spec</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">containers</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">image</span>:<span style="color:#bbb"> </span>nginx:1.14.2<span style="color:#bbb">
</span></span></span></code></pre></div></div></div><p>And the user has created the Deployment using Server-Side Apply, like so:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl apply -f https://k8s.io/examples/application/ssa/nginx-deployment.yaml --server-side
</span></span></code></pre></div><p>Then later, automatic scaling is enabled for the Deployment; for example:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl autoscale deployment nginx-deployment --cpu-percent<span style="color:#666">=</span><span style="color:#666">50</span> --min<span style="color:#666">=</span><span style="color:#666">1</span> --max<span style="color:#666">=</span><span style="color:#666">10</span>
</span></span></code></pre></div><p>Now, the user would like to remove <code>replicas</code> from their configuration, so they
don't accidentally fight with the HorizontalPodAutoscaler (HPA) and its controller.
However, there is a race: it might take some time before the HPA feels the need
to adjust <code>.spec.replicas</code>; if the user removes <code>.spec.replicas</code> before the HPA writes
to the field and becomes its owner, then the API server would set <code>.spec.replicas</code> to
1 (the default replica count for Deployment).
This is not what the user wants to happen, even temporarily - it might well degrade
a running workload.</p><p>There are two solutions:</p><ul><li><p>(basic) Leave <code>replicas</code> in the configuration; when the HPA eventually writes to that
field, the system gives the user a conflict over it. At that point, it is safe
to remove from the configuration.</p></li><li><p>(more advanced) If, however, the user doesn't want to wait, for example
because they want to keep the cluster legible to their colleagues, then they
can take the following steps to make it safe to remove <code>replicas</code> from their
configuration:</p></li></ul><p>First, the user defines a new manifest containing only the <code>replicas</code> field:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:#080;font-style:italic"># Save this file as 'nginx-deployment-replicas-only.yaml'.</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>apps/v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>Deployment<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">metadata</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>nginx-deployment<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">spec</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">replicas</span>:<span style="color:#bbb"> </span><span style="color:#666">3</span><span style="color:#bbb">
</span></span></span></code></pre></div><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>The YAML file for SSA in this case only contains the fields you want to change.
You are not supposed to provide a fully compliant Deployment manifest if you only
want to modify the <code>spec.replicas</code> field using SSA.</div><p>The user applies that manifest using a private field manager name. In this example,
the user picked <code>handover-to-hpa</code>:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl apply -f nginx-deployment-replicas-only.yaml <span style="color:#b62;font-weight:700">\
</span></span></span><span style="display:flex"><span><span style="color:#b62;font-weight:700"/>  --server-side --field-manager<span style="color:#666">=</span>handover-to-hpa <span style="color:#b62;font-weight:700">\
</span></span></span><span style="display:flex"><span><span style="color:#b62;font-weight:700"/>  --validate<span style="color:#666">=</span><span style="color:#a2f">false</span>
</span></span></code></pre></div><p>If the apply results in a conflict with the HPA controller, then do nothing. The
conflict indicates the controller has claimed the field earlier in the
process than it sometimes does.</p><p>At this point the user may remove the <code>replicas</code> field from their manifest:</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/application/ssa/nginx-deployment-no-replicas.yaml" download="application/ssa/nginx-deployment-no-replicas.yaml"><code>application/ssa/nginx-deployment-no-replicas.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" onclick="copyCode(&quot;application-ssa-nginx-deployment-no-replicas-yaml&quot;)" title="Copy application/ssa/nginx-deployment-no-replicas.yaml to clipboard"/></div><div class="includecode" id="application-ssa-nginx-deployment-no-replicas-yaml"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>apps/v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>Deployment<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">metadata</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>nginx-deployment<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">labels</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">app</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">spec</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">selector</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">matchLabels</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">app</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">template</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">metadata</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">labels</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">app</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">spec</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">containers</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">image</span>:<span style="color:#bbb"> </span>nginx:1.14.2<span style="color:#bbb">
</span></span></span></code></pre></div></div></div><p>Note that whenever the HPA controller sets the <code>replicas</code> field to a new value,
the temporary field manager will no longer own any fields and will be
automatically deleted. No further clean up is required.</p><h3 id="transferring-ownership-between-managers">Transferring ownership between managers</h3><p>Field managers can transfer ownership of a field between each other by setting the field
to the same value in both of their applied configurations, causing them to share
ownership of the field. Once the managers share ownership of the field, one of them
can remove the field from their applied configuration to give up ownership and
complete the transfer to the other field manager.</p><h2 id="comparison-with-client-side-apply">Comparison with Client-Side Apply</h2><p>Server-Side Apply is meant both as a replacement for the original client-side
implementation of the <code>kubectl apply</code> subcommand, and as simple and effective
mechanism for <a class="glossary-tooltip" title="A control loop that watches the shared state of the cluster through the apiserver and makes changes attempting to move the current state towards the desired state." data-toggle="tooltip" data-placement="top" href="/docs/concepts/architecture/controller/" target="_blank" aria-label="controllers">controllers</a>
to enact their changes.</p><p>Compared to the <code>last-applied</code> annotation managed by <code>kubectl</code>, Server-Side
Apply uses a more declarative approach, which tracks an object's field management,
rather than a user's last applied state. This means that as a side effect of
using Server-Side Apply, information about which field manager manages each
field in an object also becomes available.</p><p>A consequence of the conflict detection and resolution implemented by Server-Side
Apply is that an applier always has up to date field values in their local
state. If they don't, they get a conflict the next time they apply. Any of the
three options to resolve conflicts results in the applied configuration being an
up to date subset of the object on the server's fields.</p><p>This is different from Client-Side Apply, where outdated values which have been
overwritten by other users are left in an applier's local config. These values
only become accurate when the user updates that specific field, if ever, and an
applier has no way of knowing whether their next apply will overwrite other
users' changes.</p><p>Another difference is that an applier using Client-Side Apply is unable to
change the API version they are using, but Server-Side Apply supports this use
case.</p><h2 id="migration-between-client-side-and-server-side-apply">Migration between client-side and server-side apply</h2><h3 id="upgrading-from-client-side-apply-to-server-side-apply">Upgrading from client-side apply to server-side apply</h3><p>Client-side apply users who manage a resource with <code>kubectl apply</code> can start
using server-side apply with the following flag.</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl apply --server-side <span style="color:#666">[</span>--dry-run<span style="color:#666">=</span>server<span style="color:#666">]</span>
</span></span></code></pre></div><p>By default, field management of the object transfers from client-side apply to
kubectl server-side apply, without encountering conflicts.</p><div class="alert alert-caution" role="alert"><h4 class="alert-heading">Caution:</h4><p>Keep the <code>last-applied-configuration</code> annotation up to date.
The annotation infers client-side applies managed fields.
Any fields not managed by client-side apply raise conflicts.</p><p>For example, if you used <code>kubectl scale</code> to update the replicas field after
client-side apply, then this field is not owned by client-side apply and
creates conflicts on <code>kubectl apply --server-side</code>.</p></div><p>This behavior applies to server-side apply with the <code>kubectl</code> field manager.
As an exception, you can opt-out of this behavior by specifying a different,
non-default field manager, as seen in the following example. The default field
manager for kubectl server-side apply is <code>kubectl</code>.</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl apply --server-side --field-manager<span style="color:#666">=</span>my-manager <span style="color:#666">[</span>--dry-run<span style="color:#666">=</span>server<span style="color:#666">]</span>
</span></span></code></pre></div><h3 id="downgrading-from-server-side-apply-to-client-side-apply">Downgrading from server-side apply to client-side apply</h3><p>If you manage a resource with <code>kubectl apply --server-side</code>,
you can downgrade to client-side apply directly with <code>kubectl apply</code>.</p><p>Downgrading works because kubectl Server-Side Apply keeps the
<code>last-applied-configuration</code> annotation up-to-date if you use
<code>kubectl apply</code>.</p><p>This behavior applies to Server-Side Apply with the <code>kubectl</code> field manager.
As an exception, you can opt-out of this behavior by specifying a different,
non-default field manager, as seen in the following example. The default field
manager for kubectl server-side apply is <code>kubectl</code>.</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl apply --server-side --field-manager<span style="color:#666">=</span>my-manager <span style="color:#666">[</span>--dry-run<span style="color:#666">=</span>server<span style="color:#666">]</span>
</span></span></code></pre></div><h2 id="api-implementation">API implementation</h2><p>The <code>PATCH</code> verb (for an object that supports Server-Side Apply) accepts the
unofficial <code>application/apply-patch+yaml</code> content type. Users of Server-Side
Apply can send partially specified objects as YAML as the body of a <code>PATCH</code> request
to the URI of a resource. When applying a configuration, you should always include all the
fields that are important to the outcome (such as a desired state) that you want to define.</p><p>All JSON messages are valid YAML. Therefore, in addition to using YAML request bodies for Server-Side Apply requests, you can also use JSON request bodies, as they are also valid YAML.
In either case, use the media type <code>application/apply-patch+yaml</code> for the HTTP request.</p><h3 id="rbac-and-permissions">Access control and permissions</h3><p>Since Server-Side Apply is a type of <code>PATCH</code>, a principal (such as a Role for Kubernetes
<a class="glossary-tooltip" title="Manages authorization decisions, allowing admins to dynamically configure access policies through the Kubernetes API." data-toggle="tooltip" data-placement="top" href="/docs/reference/access-authn-authz/rbac/" target="_blank" aria-label="RBAC">RBAC</a>) requires the <strong>patch</strong> permission to
edit existing resources, and also needs the <strong>create</strong> verb permission in order to create
new resources with Server-Side Apply.</p><h2 id="clearing-managedfields">Clearing <code>managedFields</code></h2><p>It is possible to strip all <code>managedFields</code> from an object by overwriting them
using a <strong>patch</strong> (JSON Merge Patch, Strategic Merge Patch, JSON Patch), or
through an <strong>update</strong> (HTTP <code>PUT</code>); in other words, through every write operation
other than <strong>apply</strong>. This can be done by overwriting the <code>managedFields</code> field
with an empty entry. Two examples are:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-console" data-lang="console"><span style="display:flex"><span><span style="color:#888">PATCH /api/v1/namespaces/default/configmaps/example-cm
</span></span></span><span style="display:flex"><span><span style="color:#888">Accept: application/json
</span></span></span><span style="display:flex"><span><span style="color:#888">Content-Type: application/merge-patch+json
</span></span></span><span style="display:flex"><span><span style="color:#888"/><span>
</span></span></span><span style="display:flex"><span><span/><span style="color:#888">{
</span></span></span><span style="display:flex"><span><span style="color:#888">  "metadata": {
</span></span></span><span style="display:flex"><span><span style="color:#888">    "managedFields": [
</span></span></span><span style="display:flex"><span><span style="color:#888">      {}
</span></span></span><span style="display:flex"><span><span style="color:#888">    ]
</span></span></span><span style="display:flex"><span><span style="color:#888">  }
</span></span></span><span style="display:flex"><span><span style="color:#888">}
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-console" data-lang="console"><span style="display:flex"><span><span style="color:#888">PATCH /api/v1/namespaces/default/configmaps/example-cm
</span></span></span><span style="display:flex"><span><span style="color:#888">Accept: application/json
</span></span></span><span style="display:flex"><span><span style="color:#888">Content-Type: application/json-patch+json
</span></span></span><span style="display:flex"><span><span style="color:#888">If-Match: 1234567890123456789
</span></span></span><span style="display:flex"><span><span style="color:#888"/><span>
</span></span></span><span style="display:flex"><span><span/><span style="color:#888">[{"op": "replace", "path": "/metadata/managedFields", "value": [{}]}]
</span></span></span></code></pre></div><p>This will overwrite the <code>managedFields</code> with a list containing a single empty
entry that then results in the <code>managedFields</code> being stripped entirely from the
object. Note that setting the <code>managedFields</code> to an empty list will not
reset the field. This is on purpose, so <code>managedFields</code> never get stripped by
clients not aware of the field.</p><p>In cases where the reset operation is combined with changes to other fields
than the <code>managedFields</code>, this will result in the <code>managedFields</code> being reset
first and the other changes being processed afterwards. As a result the
applier takes ownership of any fields updated in the same request.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>Server-Side Apply does not correctly track ownership on
sub-resources that don't receive the resource object type. If you are
using Server-Side Apply with such a sub-resource, the changed fields
may not be tracked.</div><h2 id="what-s-next">What's next</h2><p>You can read about <code>managedFields</code> within the Kubernetes API reference for the
<a href="/docs/reference/kubernetes-api/common-definitions/object-meta/"><code>metadata</code></a>
top level field.</p></div>
<hr>
<div class="td-content"><h1 data-pagefind-weight="10">Client Libraries</h1><p>This page contains an overview of the client libraries for using the Kubernetes
API from various programming languages.</p><p>To write applications using the <a href="/docs/reference/using-api/">Kubernetes REST API</a>,
you do not need to implement the API calls and request/response types yourself.
You can use a client library for the programming language you are using.</p><p>Client libraries often handle common tasks such as authentication for you.
Most client libraries can discover and use the Kubernetes Service Account to
authenticate if the API client is running inside the Kubernetes cluster, or can
understand the <a href="/docs/tasks/access-application-cluster/configure-access-multiple-clusters/">kubeconfig file</a>
format to read the credentials and the API Server address.</p><h2 id="officially-supported-kubernetes-client-libraries">Officially-supported Kubernetes client libraries</h2><p>The following client libraries are officially maintained by
<a href="https://github.com/kubernetes/community/tree/master/sig-api-machinery">Kubernetes SIG API Machinery</a>.</p><table><thead><tr><th>Language</th><th>Client Library</th><th>Sample Programs</th></tr></thead><tbody><tr><td>C</td><td><a href="https://github.com/kubernetes-client/c/">github.com/kubernetes-client/c</a></td><td><a href="https://github.com/kubernetes-client/c/tree/master/examples">browse</a></td></tr><tr><td>dotnet</td><td><a href="https://github.com/kubernetes-client/csharp">github.com/kubernetes-client/csharp</a></td><td><a href="https://github.com/kubernetes-client/csharp/tree/master/examples">browse</a></td></tr><tr><td>Go</td><td><a href="https://github.com/kubernetes/client-go/">github.com/kubernetes/client-go/</a></td><td><a href="https://github.com/kubernetes/client-go/tree/master/examples">browse</a></td></tr><tr><td>Haskell</td><td><a href="https://github.com/kubernetes-client/haskell">github.com/kubernetes-client/haskell</a></td><td><a href="https://github.com/kubernetes-client/haskell/tree/master/kubernetes-client/example">browse</a></td></tr><tr><td>Java</td><td><a href="https://github.com/kubernetes-client/java/">github.com/kubernetes-client/java</a></td><td><a href="https://github.com/kubernetes-client/java/tree/master/examples">browse</a></td></tr><tr><td>JavaScript</td><td><a href="https://github.com/kubernetes-client/javascript">github.com/kubernetes-client/javascript</a></td><td><a href="https://github.com/kubernetes-client/javascript/tree/master/examples">browse</a></td></tr><tr><td>Perl</td><td><a href="https://github.com/kubernetes-client/perl/">github.com/kubernetes-client/perl/</a></td><td><a href="https://github.com/kubernetes-client/perl/tree/master/examples">browse</a></td></tr><tr><td>Python</td><td><a href="https://github.com/kubernetes-client/python/">github.com/kubernetes-client/python/</a></td><td><a href="https://github.com/kubernetes-client/python/tree/master/examples">browse</a></td></tr><tr><td>Ruby</td><td><a href="https://github.com/kubernetes-client/ruby/">github.com/kubernetes-client/ruby/</a></td><td><a href="https://github.com/kubernetes-client/ruby/tree/master/examples">browse</a></td></tr></tbody></table><h2 id="community-maintained-client-libraries">Community-maintained client libraries</h2><div class="alert alert-secondary callout third-party-content" role="alert"><strong>Note:</strong>This section links to third party projects that provide functionality required by Kubernetes. The Kubernetes project authors aren't responsible for these projects, which are listed alphabetically. To add a project to this list, read the <a href="/docs/contribute/style/content-guide/#third-party-content">content guide</a> before submitting a change. <a href="#third-party-content-disclaimer">More information.</a></div><p>The following Kubernetes API client libraries are provided and maintained by
their authors, not the Kubernetes team.</p><table><thead><tr><th>Language</th><th>Client Library</th></tr></thead><tbody><tr><td>Clojure</td><td><a href="https://github.com/yanatan16/clj-kubernetes-api">github.com/yanatan16/clj-kubernetes-api</a></td></tr><tr><td>DotNet</td><td><a href="https://github.com/tonnyeremin/kubernetes_gen">github.com/tonnyeremin/kubernetes_gen</a></td></tr><tr><td>DotNet (RestSharp)</td><td><a href="https://github.com/masroorhasan/Kubernetes.DotNet">github.com/masroorhasan/Kubernetes.DotNet</a></td></tr><tr><td>Elixir</td><td><a href="https://github.com/obmarg/kazan/">github.com/obmarg/kazan</a></td></tr><tr><td>Elixir</td><td><a href="https://github.com/coryodaniel/k8s">github.com/coryodaniel/k8s</a></td></tr><tr><td>Java (OSGi)</td><td><a href="https://bitbucket.org/amdatulabs/amdatu-kubernetes">bitbucket.org/amdatulabs/amdatu-kubernetes</a></td></tr><tr><td>Java (Fabric8, OSGi)</td><td><a href="https://github.com/fabric8io/kubernetes-client">github.com/fabric8io/kubernetes-client</a></td></tr><tr><td>Java</td><td><a href="https://github.com/manusa/yakc">github.com/manusa/yakc</a></td></tr><tr><td>Lisp</td><td><a href="https://github.com/brendandburns/cl-k8s">github.com/brendandburns/cl-k8s</a></td></tr><tr><td>Lisp</td><td><a href="https://github.com/xh4/cube">github.com/xh4/cube</a></td></tr><tr><td>Node.js (TypeScript)</td><td><a href="https://github.com/Goyoo/node-k8s-client">github.com/Goyoo/node-k8s-client</a></td></tr><tr><td>Node.js</td><td><a href="https://github.com/ajpauwels/easy-k8s">github.com/ajpauwels/easy-k8s</a></td></tr><tr><td>Node.js</td><td><a href="https://github.com/godaddy/kubernetes-client">github.com/godaddy/kubernetes-client</a></td></tr><tr><td>Node.js</td><td><a href="https://github.com/tenxcloud/node-kubernetes-client">github.com/tenxcloud/node-kubernetes-client</a></td></tr><tr><td>Perl</td><td><a href="https://metacpan.org/pod/Net::Kubernetes">metacpan.org/pod/Net::Kubernetes</a></td></tr><tr><td>PHP</td><td><a href="https://github.com/allansun/kubernetes-php-client">github.com/allansun/kubernetes-php-client</a></td></tr><tr><td>PHP</td><td><a href="https://github.com/maclof/kubernetes-client">github.com/maclof/kubernetes-client</a></td></tr><tr><td>PHP</td><td><a href="https://github.com/travisghansen/kubernetes-client-php">github.com/travisghansen/kubernetes-client-php</a></td></tr><tr><td>PHP</td><td><a href="https://github.com/renoki-co/php-k8s">github.com/renoki-co/php-k8s</a></td></tr><tr><td>Python</td><td><a href="https://github.com/cloudcoil/cloudcoil">github.com/cloudcoil/cloudcoil</a></td></tr><tr><td>Python</td><td><a href="https://github.com/fiaas/k8s">github.com/fiaas/k8s</a></td></tr><tr><td>Python</td><td><a href="https://github.com/gtsystem/lightkube">github.com/gtsystem/lightkube</a></td></tr><tr><td>Python</td><td><a href="https://github.com/kr8s-org/kr8s">github.com/kr8s-org/kr8s</a></td></tr><tr><td>Python</td><td><a href="https://github.com/mnubo/kubernetes-py">github.com/mnubo/kubernetes-py</a></td></tr><tr><td>Python</td><td><a href="https://github.com/tomplus/kubernetes_asyncio">github.com/tomplus/kubernetes_asyncio</a></td></tr><tr><td>Python</td><td><a href="https://github.com/Frankkkkk/pykorm">github.com/Frankkkkk/pykorm</a></td></tr><tr><td>Ruby</td><td><a href="https://github.com/abonas/kubeclient">github.com/abonas/kubeclient</a></td></tr><tr><td>Ruby</td><td><a href="https://github.com/k8s-ruby/k8s-ruby">github.com/k8s-ruby/k8s-ruby</a></td></tr><tr><td>Ruby</td><td><a href="https://github.com/kontena/k8s-client">github.com/kontena/k8s-client</a></td></tr><tr><td>Rust</td><td><a href="https://github.com/kube-rs/kube">github.com/kube-rs/kube</a></td></tr><tr><td>Rust</td><td><a href="https://github.com/ynqa/kubernetes-rust">github.com/ynqa/kubernetes-rust</a></td></tr><tr><td>Scala</td><td><a href="https://github.com/hagay3/skuber">github.com/hagay3/skuber</a></td></tr><tr><td>Scala</td><td><a href="https://github.com/hnaderi/scala-k8s">github.com/hnaderi/scala-k8s</a></td></tr><tr><td>Scala</td><td><a href="https://github.com/joan38/kubernetes-client">github.com/joan38/kubernetes-client</a></td></tr><tr><td>Swift</td><td><a href="https://github.com/swiftkube/client">github.com/swiftkube/client</a></td></tr></tbody></table></div>
<hr>
<div class="td-content"><h1 data-pagefind-weight="10">Kubernetes API health endpoints</h1><p>The Kubernetes <a class="glossary-tooltip" title="Control plane component that serves the Kubernetes API." data-toggle="tooltip" data-placement="top" href="/docs/concepts/architecture/#kube-apiserver" target="_blank" aria-label="API server">API server</a> provides API endpoints to indicate the current status of the API server.
This page describes these API endpoints and explains how you can use them.</p><h2 id="api-endpoints-for-health">API endpoints for health</h2><p>The Kubernetes API server provides 3 API endpoints (<code>healthz</code>, <code>livez</code> and <code>readyz</code>) to indicate the current status of the API server.
The <code>healthz</code> endpoint is deprecated (since Kubernetes v1.16), and you should use the more specific <code>livez</code> and <code>readyz</code> endpoints instead.
The <code>livez</code> endpoint can be used with the <code>--livez-grace-period</code> <a href="/docs/reference/command-line-tools-reference/kube-apiserver/">flag</a> to specify the startup duration.
For a graceful shutdown you can specify the <code>--shutdown-delay-duration</code> <a href="/docs/reference/command-line-tools-reference/kube-apiserver/">flag</a> with the <code>/readyz</code> endpoint.
Machines that check the <code>healthz</code>/<code>livez</code>/<code>readyz</code> of the API server should rely on the HTTP status code.
A status code <code>200</code> indicates the API server is <code>healthy</code>/<code>live</code>/<code>ready</code>, depending on the called endpoint.
The more verbose options shown below are intended to be used by human operators to debug their cluster or understand the state of the API server.</p><p>The following examples will show how you can interact with the health API endpoints.</p><p>For all endpoints, you can use the <code>verbose</code> parameter to print out the checks and their status.
This can be useful for a human operator to debug the current status of the API server, it is not intended to be consumed by a machine:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>curl -k https://localhost:6443/livez?verbose
</span></span></code></pre></div><p>or from a remote host with authentication:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl get --raw<span style="color:#666">=</span><span style="color:#b44">'/readyz?verbose'</span>
</span></span></code></pre></div><p>The output will look like this:</p><pre><code>[+]ping ok
[+]log ok
[+]etcd ok
[+]poststarthook/start-kube-apiserver-admission-initializer ok
[+]poststarthook/generic-apiserver-start-informers ok
[+]poststarthook/start-apiextensions-informers ok
[+]poststarthook/start-apiextensions-controllers ok
[+]poststarthook/crd-informer-synced ok
[+]poststarthook/bootstrap-controller ok
[+]poststarthook/rbac/bootstrap-roles ok
[+]poststarthook/scheduling/bootstrap-system-priority-classes ok
[+]poststarthook/start-cluster-authentication-info-controller ok
[+]poststarthook/start-kube-aggregator-informers ok
[+]poststarthook/apiservice-registration-controller ok
[+]poststarthook/apiservice-status-available-controller ok
[+]poststarthook/kube-apiserver-autoregistration ok
[+]autoregister-completion ok
[+]poststarthook/apiservice-openapi-controller ok
healthz check passed
</code></pre><p>The Kubernetes API server also supports to exclude specific checks.
The query parameters can also be combined like in this example:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>curl -k <span style="color:#b44">'https://localhost:6443/readyz?verbose&amp;exclude=etcd'</span>
</span></span></code></pre></div><p>The output show that the <code>etcd</code> check is excluded:</p><pre><code>[+]ping ok
[+]log ok
[+]etcd excluded: ok
[+]poststarthook/start-kube-apiserver-admission-initializer ok
[+]poststarthook/generic-apiserver-start-informers ok
[+]poststarthook/start-apiextensions-informers ok
[+]poststarthook/start-apiextensions-controllers ok
[+]poststarthook/crd-informer-synced ok
[+]poststarthook/bootstrap-controller ok
[+]poststarthook/rbac/bootstrap-roles ok
[+]poststarthook/scheduling/bootstrap-system-priority-classes ok
[+]poststarthook/start-cluster-authentication-info-controller ok
[+]poststarthook/start-kube-aggregator-informers ok
[+]poststarthook/apiservice-registration-controller ok
[+]poststarthook/apiservice-status-available-controller ok
[+]poststarthook/kube-apiserver-autoregistration ok
[+]autoregister-completion ok
[+]poststarthook/apiservice-openapi-controller ok
[+]shutdown ok
healthz check passed
</code></pre><h2 id="individual-health-checks">Individual health checks</h2><div class="feature-state-notice feature-alpha"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.34 [alpha]</code></div><p>Each individual health check exposes an HTTP endpoint and can be checked individually.
The schema for the individual health checks is <code>/livez/&lt;healthcheck-name&gt;</code> or <code>/readyz/&lt;healthcheck-name&gt;</code>, where <code>livez</code> and <code>readyz</code> can be used to indicate if you want to check the liveness or the readiness of the API server, respectively.
The <code>&lt;healthcheck-name&gt;</code> path can be discovered using the <code>verbose</code> flag from above and take the path between <code>[+]</code> and <code>ok</code>.
These individual health checks should not be consumed by machines but can be helpful for a human operator to debug a system:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>curl -k https://localhost:6443/livez/etcd
</span></span></code></pre></div></div>
<hr>
<div class="td-content"><h1 data-pagefind-weight="10">Kubernetes API Concepts</h1><p>The Kubernetes API is a resource-based (RESTful) programmatic interface
provided via HTTP. It supports retrieving, creating, updating, and deleting
primary resources via the standard HTTP verbs (POST, PUT, PATCH, DELETE,
GET).</p><p>For some resources, the API includes additional subresources that allow
fine-grained authorization (such as separate views for Pod details and
log retrievals), and can accept and serve those resources in different
representations for convenience or efficiency.</p><p>Kubernetes supports efficient change notifications on resources via
<em>watches</em>:<p>in the Kubernetes API, watch is a verb that is used to track changes to an object in Kubernetes as a stream.
It is used for the efficient detection of changes.</p>Kubernetes also provides consistent list operations so that API clients can
effectively cache, track, and synchronize the state of resources.</p><p>You can view the <a href="/docs/reference/kubernetes-api/">API reference</a> online,
or read on to learn about the API in general.</p><h2 id="standard-api-terminology">Kubernetes API terminology</h2><p>Kubernetes generally leverages common RESTful terminology to describe the
API concepts:</p><ul><li>A <em>resource type</em> is the name used in the URL (<code>pods</code>, <code>namespaces</code>, <code>services</code>)</li><li>All resource types have a concrete representation (their object schema) which is called a <em>kind</em></li><li>A list of instances of a resource type is known as a <em>collection</em></li><li>A single instance of a resource type is called a <em>resource</em>, and also usually represents an <em>object</em></li><li>For some resource types, the API includes one or more <em>sub-resources</em>, which are represented as URI paths below the resource</li></ul><p>Most Kubernetes API resource types are
<a class="glossary-tooltip" title="An entity in the Kubernetes system, representing part of the state of your cluster." data-toggle="tooltip" data-placement="top" href="/docs/concepts/overview/working-with-objects/#kubernetes-objects" target="_blank" aria-label="objects">objects</a> 
they represent a concrete instance of a concept on the cluster, like a
pod or namespace. A smaller number of API resource types are <em>virtual</em> in
that they often represent operations on objects, rather than objects, such
as a permission check
(use a POST with a JSON-encoded body of <code>SubjectAccessReview</code> to the
<code>subjectaccessreviews</code> resource), or the <code>eviction</code> sub-resource of a Pod
(used to trigger
<a href="/docs/concepts/scheduling-eviction/api-eviction/">API-initiated eviction</a>).</p><h3 id="object-names">Object names</h3><p>All objects you can create via the API have a unique object
<a class="glossary-tooltip" title="A client-provided string that refers to an object in a resource URL, such as /api/v1/pods/some-name." data-toggle="tooltip" data-placement="top" href="/docs/concepts/overview/working-with-objects/names" target="_blank" aria-label="name">name</a> to allow idempotent creation and
retrieval, except that virtual resource types may not have unique names if they are
not retrievable, or do not rely on idempotency.
Within a <a class="glossary-tooltip" title="An abstraction used by Kubernetes to support isolation of groups of resources within a single cluster." data-toggle="tooltip" data-placement="top" href="/docs/concepts/overview/working-with-objects/namespaces" target="_blank" aria-label="namespace">namespace</a>, only one object
of a given kind can have a given name at a time. However, if you delete the object,
you can make a new object with the same name. Some objects are not namespaced (for
example: Nodes), and so their names must be unique across the whole cluster.</p><h3 id="api-verbs">API verbs</h3><p>Almost all object resource types support the standard HTTP verbs - GET, POST, PUT, PATCH,
and DELETE. Kubernetes also uses its own verbs, which are often written in lowercase to distinguish
them from HTTP verbs.</p><p>Kubernetes uses the term <strong>list</strong> to describe the action of returning a <a href="#collections">collection</a> of
resources, to distinguish it from retrieving a single resource which is usually called
a <strong>get</strong>. If you sent an HTTP GET request with the <code>?watch</code> query parameter,
Kubernetes calls this a <strong>watch</strong> and not a <strong>get</strong>
(see <a href="#efficient-detection-of-changes">Efficient detection of changes</a> for more details).</p><p>For PUT requests, Kubernetes internally classifies these as either <strong>create</strong> or <strong>update</strong>
based on the state of the existing object. An <strong>update</strong> is different from a <strong>patch</strong>; the
HTTP verb for a <strong>patch</strong> is PATCH.</p><h2 id="resource-uris">Resource URIs</h2><p>All resource types are either scoped by the cluster (<code>/apis/GROUP/VERSION/*</code>) or to a
namespace (<code>/apis/GROUP/VERSION/namespaces/NAMESPACE/*</code>). A namespace-scoped resource
type will be deleted when its namespace is deleted and access to that resource type
is controlled by authorization checks on the namespace scope.</p><p>Note: core resources use <code>/api</code> instead of <code>/apis</code> and omit the GROUP path segment.</p><p>Examples:</p><ul><li><code>/api/v1/namespaces</code></li><li><code>/api/v1/pods</code></li><li><code>/api/v1/namespaces/my-namespace/pods</code></li><li><code>/apis/apps/v1/deployments</code></li><li><code>/apis/apps/v1/namespaces/my-namespace/deployments</code></li><li><code>/apis/apps/v1/namespaces/my-namespace/deployments/my-deployment</code></li></ul><p>You can also access collections of resources (for example: listing all Nodes).
The following paths are used to retrieve collections and resources:</p><ul><li><p>Cluster-scoped resources:</p><ul><li><code>GET /apis/GROUP/VERSION/RESOURCETYPE</code> - return the collection of resources of the resource type</li><li><code>GET /apis/GROUP/VERSION/RESOURCETYPE/NAME</code> - return the resource with NAME under the resource type</li></ul></li><li><p>Namespace-scoped resources:</p><ul><li><code>GET /apis/GROUP/VERSION/RESOURCETYPE</code> - return the collection of all
instances of the resource type across all namespaces</li><li><code>GET /apis/GROUP/VERSION/namespaces/NAMESPACE/RESOURCETYPE</code> - return
collection of all instances of the resource type in NAMESPACE</li><li><code>GET /apis/GROUP/VERSION/namespaces/NAMESPACE/RESOURCETYPE/NAME</code> -
return the instance of the resource type with NAME in NAMESPACE</li></ul></li></ul><p>Since a namespace is a cluster-scoped resource type, you can retrieve the list
(collection) of all namespaces with <code>GET /api/v1/namespaces</code> and details about
a particular namespace with <code>GET /api/v1/namespaces/NAME</code>.</p><ul><li>Cluster-scoped subresource: <code>GET /apis/GROUP/VERSION/RESOURCETYPE/NAME/SUBRESOURCE</code></li><li>Namespace-scoped subresource: <code>GET /apis/GROUP/VERSION/namespaces/NAMESPACE/RESOURCETYPE/NAME/SUBRESOURCE</code></li></ul><p>The verbs supported for each subresource will differ depending on the object -
see the <a href="/docs/reference/kubernetes-api/">API reference</a> for more information. It
is not possible to access sub-resources across multiple resources - generally a new
virtual resource type would be used if that becomes necessary.</p><h2 id="alternate-representations-of-resources">HTTP media types</h2><p>Over HTTP, Kubernetes supports JSON, YAML, CBOR and Protobuf wire encodings.</p><p>By default, Kubernetes returns objects in <a href="#json-encoding">JSON serialization</a>, using the
<code>application/json</code> media type. Although JSON is the default, clients may request a response in
YAML, or use the more efficient binary <a href="#protobuf-encoding">Protobuf representation</a> for better performance at scale.</p><p>The Kubernetes API implements standard HTTP content type negotiation: passing an
<code>Accept</code> header with a <code>GET</code> call will request that the server tries to return
a response in your preferred media type. If you want to send an object in Protobuf to
the server for a <code>PUT</code> or <code>POST</code> request, you must set the <code>Content-Type</code> request header
appropriately.</p><p>If you request an available media type, the API server returns a response with a suitable
<code>Content-Type</code>; if none of the media types you request are supported, the API server returns
a <code>406 Not acceptable</code> error message.
All built-in resource types support the <code>application/json</code> media type.</p><h4 id="chunked-encoding-of-collections">Chunked encoding of collections</h4><p>For JSON and Protobuf encoding, Kubernetes implements custom encoders that write item, by item.
The feature doesn't change the output, but allows API server to avoid loading whole LIST response into memory.
Using other types of encoding (including pretty representation of JSON)
should be avoided for large collections of resources (&gt;100MB) as it can have negative performance impact.</p><h3 id="json-encoding">JSON resource encoding</h3><p>The Kubernetes API defaults to using <a href="https://www.json.org/json-en.html">JSON</a> for encoding
HTTP message bodies.</p><p>For example:</p><ol><li><p>List all of the pods on a cluster, without specifying a preferred format</p><pre tabindex="0"><code>GET /api/v1/pods
</code></pre><pre tabindex="0"><code>200 OK
Content-Type: application/json

 JSON encoded collection of Pods (PodList object)
</code></pre></li><li><p>Create a pod by sending JSON to the server, requesting a JSON response.</p><pre tabindex="0"><code>POST /api/v1/namespaces/test/pods
Content-Type: application/json
Accept: application/json
 JSON encoded Pod object
</code></pre><pre tabindex="0"><code>200 OK
Content-Type: application/json

{
  "kind": "Pod",
  "apiVersion": "v1",
  
}
</code></pre></li></ol><p>You can also request <a href="#table-fetches">table</a> and <a href="#metadata-only-fetches">metadata-only</a>
representations of this encoding.</p><h3 id="yaml-encoding">YAML resource encoding</h3><p>Kubernetes also supports the <a href="https://www.rfc-editor.org/rfc/rfc9512.html"><code>application/yaml</code></a>
media type for both requests and responses. <a href="https://yaml.org/"><code>YAML</code></a>
can be used for defining Kubernetes manifests and API interactions.</p><p>For example:</p><ol><li><p>List all of the pods on a cluster in YAML format</p><pre tabindex="0"><code>GET /api/v1/pods
Accept: application/yaml
</code></pre><pre tabindex="0"><code>200 OK
Content-Type: application/yaml

 YAML encoded collection of Pods (PodList object)
</code></pre></li><li><p>Create a pod by sending YAML-encoded data to the server, requesting a YAML response:</p><pre tabindex="0"><code>POST /api/v1/namespaces/test/pods
Content-Type: application/yaml
Accept: application/yaml
 YAML encoded Pod object
</code></pre><pre tabindex="0"><code>200 OK
Content-Type: application/yaml

apiVersion: v1
kind: Pod
metadata:
  name: my-pod
  
</code></pre></li></ol><p>You can also request <a href="#table-fetches">table</a> and <a href="#metadata-only-fetches">metadata-only</a>
representations of this encoding.</p><h3 id="protobuf-encoding">Kubernetes Protobuf encoding</h3><p>Kubernetes uses an envelope wrapper to encode <a href="https://protobuf.dev/">Protobuf</a> responses.
That wrapper starts with a 4 byte magic number to help identify content in disk or in etcd as Protobuf
(as opposed to JSON). The 4 byte magic number data is followed by a Protobuf encoded wrapper message, which
describes the encoding and type of the underlying object. Within the Protobuf wrapper message,
the inner object data is recorded using the <code>raw</code> field of Unknown (see the <a href="#protobuf-encoding-idl">IDL</a>
for more detail).</p><p>For example:</p><ol><li><p>List all of the pods on a cluster in Protobuf format.</p><pre tabindex="0"><code>GET /api/v1/pods
Accept: application/vnd.kubernetes.protobuf
</code></pre><pre tabindex="0"><code>200 OK
Content-Type: application/vnd.kubernetes.protobuf

 binary encoded collection of Pods (PodList object)
</code></pre></li><li><p>Create a pod by sending Protobuf encoded data to the server, but request a response
in JSON.</p><pre tabindex="0"><code>POST /api/v1/namespaces/test/pods
Content-Type: application/vnd.kubernetes.protobuf
Accept: application/json
 binary encoded Pod object
</code></pre><pre tabindex="0"><code>200 OK
Content-Type: application/json

{
  "kind": "Pod",
  "apiVersion": "v1",
  ...
}
</code></pre></li></ol><p>You can use both techniques together and use Kubernetes' Protobuf encoding to interact with any API that
supports it, for both reads and writes. Only some API resource types are <a href="#protobuf-encoding-compatibility">compatible</a>
with Protobuf.</p><a id="protobuf-encoding-idl"><p>The wrapper format is:</p><pre tabindex="0"><code>A four byte magic number prefix:
  Bytes 0-3: "k8s\x00" [0x6b, 0x38, 0x73, 0x00]

An encoded Protobuf message with the following IDL:
  message Unknown {
    // typeMeta should have the string values for "kind" and "apiVersion" as set on the JSON object
    optional TypeMeta typeMeta = 1;

    // raw will hold the complete serialized object in protobuf. See the protobuf definitions in the client libraries for a given kind.
    optional bytes raw = 2;

    // contentEncoding is encoding used for the raw data. Unspecified means no encoding.
    optional string contentEncoding = 3;

    // contentType is the serialization method used to serialize 'raw'. Unspecified means application/vnd.kubernetes.protobuf and is usually
    // omitted.
    optional string contentType = 4;
  }

  message TypeMeta {
    // apiVersion is the group/version for this type
    optional string apiVersion = 1;
    // kind is the name of the object schema. A protobuf definition should exist for this object.
    optional string kind = 2;
  }
</code></pre><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>Clients that receive a response in <code>application/vnd.kubernetes.protobuf</code> that does
not match the expected prefix should reject the response, as future versions may need
to alter the serialization format in an incompatible way and will do so by changing
the prefix.</div><p>You can also request <a href="#table-fetches">table</a> and <a href="#metadata-only-fetches">metadata-only</a>
representations of this encoding.</p><h4 id="protobuf-encoding-compatibility">Compatibility with Kubernetes Protobuf</h4><p>Not all API resource types support Kubernetes' Protobuf encoding; specifically, Protobuf isn't
available for resources that are defined as
<a class="glossary-tooltip" title="Custom code that defines a resource to add to your Kubernetes API server without building a complete custom server." data-toggle="tooltip" data-placement="top" href="/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/" target="_blank" aria-label="CustomResourceDefinitions">CustomResourceDefinitions</a>
or are served via the
<a class="glossary-tooltip" title="The aggregation layer lets you install additional Kubernetes-style APIs in your cluster." data-toggle="tooltip" data-placement="top" href="/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/" target="_blank" aria-label="aggregation layer">aggregation layer</a>.</p><p>As a client, if you might need to work with extension types you should specify multiple
content types in the request <code>Accept</code> header to support fallback to JSON.
For example:</p><pre tabindex="0"><code>Accept: application/vnd.kubernetes.protobuf, application/json
</code></pre><h3 id="cbor-encoding">CBOR resource encoding</h3><div class="feature-state-notice feature-alpha" title="Feature Gate: CBORServingAndStorage"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.32 [alpha]</code> (enabled by default: false)</div><p>With the <code>CBORServingAndStorage</code> <a href="/docs/reference/command-line-tools-reference/feature-gates/">feature gate</a>
enabled, request and response bodies for all built-in resource types and all resources defined by a
<a class="glossary-tooltip" title="Custom code that defines a resource to add to your Kubernetes API server without building a complete custom server." data-toggle="tooltip" data-placement="top" href="/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/" target="_blank" aria-label="CustomResourceDefinition">CustomResourceDefinition</a> may be encoded to the
<a href="https://www.rfc-editor.org/rfc/rfc8949">CBOR</a> binary data format. CBOR is also supported at the
<a class="glossary-tooltip" title="The aggregation layer lets you install additional Kubernetes-style APIs in your cluster." data-toggle="tooltip" data-placement="top" href="/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/" target="_blank" aria-label="aggregation layer">aggregation layer</a> if it is enabled in
individual aggregated API servers.</p><p>Clients should indicate the IANA media type <code>application/cbor</code> in the <code>Content-Type</code> HTTP request
header when the request body contains a single CBOR
<a href="https://www.rfc-editor.org/rfc/rfc8949.html#section-1.2-4.2">encoded data item</a>, and in the <code>Accept</code> HTTP request
header when prepared to accept a CBOR encoded data item in the response. API servers will use
<code>application/cbor</code> in the <code>Content-Type</code> HTTP response header when the response body contains a
CBOR-encoded object.</p><p>If an API server encodes its response to a <a href="#efficient-detection-of-changes">watch request</a> using
CBOR, the response body will be a <a href="https://www.rfc-editor.org/rfc/rfc8742">CBOR Sequence</a> and the
<code>Content-Type</code> HTTP response header will use the IANA media type <code>application/cbor-seq</code>. Each entry
of the sequence (if any) is a single CBOR-encoded watch event.</p><p>In addition to the existing <code>application/apply-patch+yaml</code> media type for YAML-encoded
<a href="#patch-and-apply">server-side apply configurations</a>, API servers that enable CBOR will accept the
<code>application/apply-patch+cbor</code> media type for CBOR-encoded server-side apply configurations. There
is no supported CBOR equivalent for <code>application/json-patch+json</code> or <code>application/merge-patch+json</code>,
or <code>application/strategic-merge-patch+json</code>.</p><p>You can also request <a href="#table-fetches">table</a> and <a href="#metadata-only-fetches">metadata-only</a>
representations of this encoding.</p><h2 id="efficient-detection-of-changes">Efficient detection of changes</h2><p>The Kubernetes API allows clients to make an initial request for an object or a
collection, and then to track changes since that initial request: a <strong>watch</strong>. Clients
can send a <strong>list</strong> or a <strong>get</strong> and then make a follow-up <strong>watch</strong> request.</p><p>To make this change tracking possible, every Kubernetes object has a <code>resourceVersion</code>
field representing the version of that resource as stored in the underlying persistence
layer. When retrieving a collection of resources (either namespace or cluster scoped),
the response from the API server contains a <code>resourceVersion</code> value. The client can
use that <code>resourceVersion</code> to initiate a <strong>watch</strong> against the API server.</p><p>When you send a <strong>watch</strong> request, the API server responds with a stream of
changes. These changes itemize the outcome of operations (such as <strong>create</strong>, <strong>delete</strong>,
and <strong>update</strong>) that occurred after the <code>resourceVersion</code> you specified as a parameter
to the <strong>watch</strong> request. The overall <strong>watch</strong> mechanism allows a client to fetch
the current state and then subscribe to subsequent changes, without missing any events.</p><p>If a client <strong>watch</strong> is disconnected then that client can start a new <strong>watch</strong> from
the last returned <code>resourceVersion</code>; the client could also perform a fresh <strong>get</strong> /
<strong>list</strong> request and begin again. See <a href="#resource-versions">Resource Version Semantics</a>
for more detail.</p><p>For example:</p><ol><li><p>List all of the pods in a given namespace.</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-http" data-lang="http"><span style="display:flex"><span><span>GET /api/v1/namespaces/test/pods
</span></span></span><span style="display:flex"><span><span>---
</span></span></span><span style="display:flex"><span><span>200 OK
</span></span></span><span style="display:flex"><span><span>Content-Type: application/json
</span></span></span><span style="display:flex"><span><span>
</span></span></span><span style="display:flex"><span><span>{
</span></span></span><span style="display:flex"><span><span>  "kind": "PodList",
</span></span></span><span style="display:flex"><span><span>  "apiVersion": "v1",
</span></span></span><span style="display:flex"><span><span>  "metadata": {"resourceVersion":"10245"},
</span></span></span><span style="display:flex"><span><span>  "items": [...]
</span></span></span><span style="display:flex"><span><span>}
</span></span></span></code></pre></div></li><li><p>Starting from resource version 10245, receive notifications of any API operations
(such as <strong>create</strong>, <strong>delete</strong>, <strong>patch</strong> or <strong>update</strong>) that affect Pods in the
<em>test</em> namespace. Each change notification is a JSON document. The HTTP response body
(served as <code>application/json</code>) consists a series of JSON documents.</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-http" data-lang="http"><span style="display:flex"><span><span>GET /api/v1/namespaces/test/pods?watch=1&amp;resourceVersion=10245
</span></span></span><span style="display:flex"><span><span>---
</span></span></span><span style="display:flex"><span><span>200 OK
</span></span></span><span style="display:flex"><span><span>Transfer-Encoding: chunked
</span></span></span><span style="display:flex"><span><span>Content-Type: application/json
</span></span></span><span style="display:flex"><span><span>
</span></span></span><span style="display:flex"><span><span>{
</span></span></span><span style="display:flex"><span><span>  "type": "ADDED",
</span></span></span><span style="display:flex"><span><span>  "object": {"kind": "Pod", "apiVersion": "v1", "metadata": {"resourceVersion": "10596", ...}, ...}
</span></span></span><span style="display:flex"><span><span>}
</span></span></span><span style="display:flex"><span><span>{
</span></span></span><span style="display:flex"><span><span>  "type": "MODIFIED",
</span></span></span><span style="display:flex"><span><span>  "object": {"kind": "Pod", "apiVersion": "v1", "metadata": {"resourceVersion": "11020", ...}, ...}
</span></span></span><span style="display:flex"><span><span>}
</span></span></span><span style="display:flex"><span><span>...
</span></span></span></code></pre></div></li></ol><p>A given Kubernetes server will only preserve a historical record of changes for a
limited time. Clusters using etcd 3 preserve changes in the last 5 minutes by default.
When the requested <strong>watch</strong> operations fail because the historical version of that
resource is not available, clients must handle the case by recognizing the status code
<code>410 Gone</code>, clearing their local cache, performing a new <strong>get</strong> or <strong>list</strong> operation,
and starting the <strong>watch</strong> from the <code>resourceVersion</code> that was returned.</p><p>For subscribing to collections, Kubernetes client libraries typically offer some form
of standard tool for this <strong>list</strong>-then-<strong>watch</strong> logic. (In the Go client library,
this is called a <code>Reflector</code> and is located in the <code>k8s.io/client-go/tools/cache</code> package.)</p><h3 id="watch-bookmarks">Watch bookmarks</h3><p>To mitigate the impact of short history window, the Kubernetes API provides a watch
event named <code>BOOKMARK</code>. It is a special kind of event to mark that all changes up
to a given <code>resourceVersion</code> the client is requesting have already been sent. The
document representing the <code>BOOKMARK</code> event is of the type requested by the request,
but only includes a <code>.metadata.resourceVersion</code> field. For example:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-http" data-lang="http"><span style="display:flex"><span><span>GET /api/v1/namespaces/test/pods?watch=1&amp;resourceVersion=10245&amp;allowWatchBookmarks=true
</span></span></span><span style="display:flex"><span><span>---
</span></span></span><span style="display:flex"><span><span>200 OK
</span></span></span><span style="display:flex"><span><span>Transfer-Encoding: chunked
</span></span></span><span style="display:flex"><span><span>Content-Type: application/json
</span></span></span><span style="display:flex"><span><span>
</span></span></span><span style="display:flex"><span><span>{
</span></span></span><span style="display:flex"><span><span>  "type": "ADDED",
</span></span></span><span style="display:flex"><span><span>  "object": {"kind": "Pod", "apiVersion": "v1", "metadata": {"resourceVersion": "10596", ...}, ...}
</span></span></span><span style="display:flex"><span><span>}
</span></span></span><span style="display:flex"><span><span>...
</span></span></span><span style="display:flex"><span><span>{
</span></span></span><span style="display:flex"><span><span>  "type": "BOOKMARK",
</span></span></span><span style="display:flex"><span><span>  "object": {"kind": "Pod", "apiVersion": "v1", "metadata": {"resourceVersion": "12746"} }
</span></span></span><span style="display:flex"><span><span>}
</span></span></span></code></pre></div><p>As a client, you can request <code>BOOKMARK</code> events by setting the
<code>allowWatchBookmarks=true</code> query parameter to a <strong>watch</strong> request, but you shouldn't
assume bookmarks are returned at any specific interval, nor can clients assume that
the API server will send any <code>BOOKMARK</code> event even when requested.</p><h2 id="streaming-lists">Streaming lists</h2><div class="feature-state-notice feature-beta" title="Feature Gate: WatchList"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.34 [beta]</code> (enabled by default: true)</div><p>On large clusters, retrieving the collection of some resource types may result in
a significant increase of resource usage (primarily RAM) on the control plane.
To alleviate the impact and simplify the user experience of the <strong>list</strong> + <strong>watch</strong>
pattern, Kubernetes v1.32 promotes to beta the feature that allows requesting the initial state
(previously requested via the <strong>list</strong> request) as part of the <strong>watch</strong> request.</p><p>On the client-side the initial state can be requested by specifying <code>sendInitialEvents=true</code> as query string parameter
in a <strong>watch</strong> request. If set, the API server starts the watch stream with synthetic init
events (of type <code>ADDED</code>) to build the whole state of all existing objects followed by a
<a href="/docs/reference/using-api/api-concepts/#watch-bookmarks"><code>BOOKMARK</code> event</a>
(if requested via <code>allowWatchBookmarks=true</code> option). The bookmark event includes the resource version
to which is synced. After sending the bookmark event, the API server continues as for any other <strong>watch</strong>
request.</p><p>When you set <code>sendInitialEvents=true</code> in the query string, Kubernetes also requires that you set
<code>resourceVersionMatch</code> to <code>NotOlderThan</code> value.
If you provided <code>resourceVersion</code> in the query string without providing a value or don't provide
it at all, this is interpreted as a request for <em>consistent read</em>;
the bookmark event is sent when the state is synced at least to the moment of a consistent read
from when the request started to be processed. If you specify <code>resourceVersion</code> (in the query string),
the bookmark event is sent when the state is synced at least to the provided resource version.</p><h3 id="example-streaming-lists">Example</h3><p>An example: you want to watch a collection of Pods. For that collection, the current resource version
is 10245 and there are two pods: <code>foo</code> and <code>bar</code>. Then sending the following request (explicitly requesting
<em>consistent read</em> by setting empty resource version using <code>resourceVersion=</code>) could result
in the following sequence of events:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-http" data-lang="http"><span style="display:flex"><span><span>GET /api/v1/namespaces/test/pods?watch=1&amp;sendInitialEvents=true&amp;allowWatchBookmarks=true&amp;resourceVersion=&amp;resourceVersionMatch=NotOlderThan
</span></span></span><span style="display:flex"><span><span>---
</span></span></span><span style="display:flex"><span><span>200 OK
</span></span></span><span style="display:flex"><span><span>Transfer-Encoding: chunked
</span></span></span><span style="display:flex"><span><span>Content-Type: application/json
</span></span></span><span style="display:flex"><span><span>
</span></span></span><span style="display:flex"><span><span>{
</span></span></span><span style="display:flex"><span><span>  "type": "ADDED",
</span></span></span><span style="display:flex"><span><span>  "object": {"kind": "Pod", "apiVersion": "v1", "metadata": {"resourceVersion": "8467", "name": "foo"}, ...}
</span></span></span><span style="display:flex"><span><span>}
</span></span></span><span style="display:flex"><span><span>{
</span></span></span><span style="display:flex"><span><span>  "type": "ADDED",
</span></span></span><span style="display:flex"><span><span>  "object": {"kind": "Pod", "apiVersion": "v1", "metadata": {"resourceVersion": "5726", "name": "bar"}, ...}
</span></span></span><span style="display:flex"><span><span>}
</span></span></span><span style="display:flex"><span><span>{
</span></span></span><span style="display:flex"><span><span>  "type": "BOOKMARK",
</span></span></span><span style="display:flex"><span><span>  "object": {"kind": "Pod", "apiVersion": "v1", "metadata": {"resourceVersion": "10245"} }
</span></span></span><span style="display:flex"><span><span>}
</span></span></span><span style="display:flex"><span><span>...
</span></span></span><span style="display:flex"><span><span>&lt;followed by regular watch stream starting from resourceVersion="10245"&gt;
</span></span></span></code></pre></div><h2 id="response-compression">Response compression</h2><div class="feature-state-notice feature-beta" title="Feature Gate: APIResponseCompression"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.16 [beta]</code> (enabled by default: true)</div><p><code>APIResponseCompression</code> is an option that allows the API server to compress the responses for <strong>get</strong>
and <strong>list</strong> requests, reducing the network bandwidth and improving the performance of large-scale clusters.
It is enabled by default since Kubernetes 1.16 and it can be disabled by including
<code>APIResponseCompression=false</code> in the <code>--feature-gates</code> flag on the API server.</p><p>API response compression can significantly reduce the size of the response, especially for large resources or
<a href="/docs/reference/using-api/api-concepts/#collections">collections</a>.
For example, a <strong>list</strong> request for pods can return hundreds of kilobytes or even megabytes of data,
depending on the number of pods and their attributes. By compressing the response, the network bandwidth
can be saved and the latency can be reduced.</p><p>To verify if <code>APIResponseCompression</code> is working, you can send a <strong>get</strong> or <strong>list</strong> request to the
API server with an <code>Accept-Encoding</code> header, and check the response size and headers. For example:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-http" data-lang="http"><span style="display:flex"><span><span>GET /api/v1/pods
</span></span></span><span style="display:flex"><span><span>Accept-Encoding: gzip
</span></span></span><span style="display:flex"><span><span>---
</span></span></span><span style="display:flex"><span><span>200 OK
</span></span></span><span style="display:flex"><span><span>Content-Type: application/json
</span></span></span><span style="display:flex"><span><span>content-encoding: gzip
</span></span></span><span style="display:flex"><span><span>...
</span></span></span></code></pre></div><p>The <code>content-encoding</code> header indicates that the response is compressed with <code>gzip</code>.</p><h2 id="retrieving-large-results-sets-in-chunks">Retrieving large results sets in chunks</h2><div class="feature-state-notice feature-stable" title="Feature Gate: APIListChunking"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.29 [stable]</code> (enabled by default: true)</div><p>On large clusters, retrieving the collection of some resource types may result in
very large responses that can impact the server and client. For instance, a cluster
may have tens of thousands of Pods, each of which is equivalent to roughly 2 KiB of
encoded JSON. Retrieving all pods across all namespaces may result in a very large
response (10-20MB) and consume a large amount of server resources.</p><p>The Kubernetes API server supports the ability to break a single large collection request
into many smaller chunks while preserving the consistency of the total request. Each
chunk can be returned sequentially which reduces both the total size of the request and
allows user-oriented clients to display results incrementally to improve responsiveness.</p><p>You can request that the API server handles a <strong>list</strong> by serving single collection
using pages (which Kubernetes calls <em>chunks</em>). To retrieve a single collection in
chunks, two query parameters <code>limit</code> and <code>continue</code> are supported on requests against
collections, and a response field <code>continue</code> is returned from all <strong>list</strong> operations
in the collection's <code>metadata</code> field. A client should specify the maximum results they
wish to receive in each chunk with <code>limit</code> and the server will return up to <code>limit</code>
resources in the result and include a <code>continue</code> value if there are more resources
in the collection.</p><p>As an API client, you can then pass this <code>continue</code> value to the API server on the
next request, to instruct the server to return the next page (<em>chunk</em>) of results. By
continuing until the server returns an empty <code>continue</code> value, you can retrieve the
entire collection.</p><p>Like a <strong>watch</strong> operation, a <code>continue</code> token will expire after a short amount
of time (by default 5 minutes) and return a <code>410 Gone</code> if more results cannot be
returned. In this case, the client will need to start from the beginning or omit the
<code>limit</code> parameter.</p><p>For example, if there are 1,253 pods on the cluster and you want to receive chunks
of 500 pods at a time, request those chunks as follows:</p><ol><li><p>List all of the pods on a cluster, retrieving up to 500 pods each time.</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-http" data-lang="http"><span style="display:flex"><span><span>GET /api/v1/pods?limit=500
</span></span></span><span style="display:flex"><span><span>---
</span></span></span><span style="display:flex"><span><span>200 OK
</span></span></span><span style="display:flex"><span><span>Content-Type: application/json
</span></span></span><span style="display:flex"><span><span>
</span></span></span><span style="display:flex"><span><span>{
</span></span></span><span style="display:flex"><span><span>  "kind": "PodList",
</span></span></span><span style="display:flex"><span><span>  "apiVersion": "v1",
</span></span></span><span style="display:flex"><span><span>  "metadata": {
</span></span></span><span style="display:flex"><span><span>    "resourceVersion":"10245",
</span></span></span><span style="display:flex"><span><span>    "continue": "ENCODED_CONTINUE_TOKEN",
</span></span></span><span style="display:flex"><span><span>    "remainingItemCount": 753,
</span></span></span><span style="display:flex"><span><span>    ...
</span></span></span><span style="display:flex"><span><span>  },
</span></span></span><span style="display:flex"><span><span>  "items": [...] // returns pods 1-500
</span></span></span><span style="display:flex"><span><span>}
</span></span></span></code></pre></div></li><li><p>Continue the previous call, retrieving the next set of 500 pods.</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-http" data-lang="http"><span style="display:flex"><span><span>GET /api/v1/pods?limit=500&amp;continue=ENCODED_CONTINUE_TOKEN
</span></span></span><span style="display:flex"><span><span>---
</span></span></span><span style="display:flex"><span><span>200 OK
</span></span></span><span style="display:flex"><span><span>Content-Type: application/json
</span></span></span><span style="display:flex"><span><span>
</span></span></span><span style="display:flex"><span><span>{
</span></span></span><span style="display:flex"><span><span>  "kind": "PodList",
</span></span></span><span style="display:flex"><span><span>  "apiVersion": "v1",
</span></span></span><span style="display:flex"><span><span>  "metadata": {
</span></span></span><span style="display:flex"><span><span>    "resourceVersion":"10245",
</span></span></span><span style="display:flex"><span><span>    "continue": "ENCODED_CONTINUE_TOKEN_2",
</span></span></span><span style="display:flex"><span><span>    "remainingItemCount": 253,
</span></span></span><span style="display:flex"><span><span>    ...
</span></span></span><span style="display:flex"><span><span>  },
</span></span></span><span style="display:flex"><span><span>  "items": [...] // returns pods 501-1000
</span></span></span><span style="display:flex"><span><span>}
</span></span></span></code></pre></div></li><li><p>Continue the previous call, retrieving the last 253 pods.</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-http" data-lang="http"><span style="display:flex"><span><span>GET /api/v1/pods?limit=500&amp;continue=ENCODED_CONTINUE_TOKEN_2
</span></span></span><span style="display:flex"><span><span>---
</span></span></span><span style="display:flex"><span><span>200 OK
</span></span></span><span style="display:flex"><span><span>Content-Type: application/json
</span></span></span><span style="display:flex"><span><span>
</span></span></span><span style="display:flex"><span><span>{
</span></span></span><span style="display:flex"><span><span>  "kind": "PodList",
</span></span></span><span style="display:flex"><span><span>  "apiVersion": "v1",
</span></span></span><span style="display:flex"><span><span>  "metadata": {
</span></span></span><span style="display:flex"><span><span>    "resourceVersion":"10245",
</span></span></span><span style="display:flex"><span><span>    "continue": "", // continue token is empty because we have reached the end of the list
</span></span></span><span style="display:flex"><span><span>    ...
</span></span></span><span style="display:flex"><span><span>  },
</span></span></span><span style="display:flex"><span><span>  "items": [...] // returns pods 1001-1253
</span></span></span><span style="display:flex"><span><span>}
</span></span></span></code></pre></div></li></ol><p>Notice that the <code>resourceVersion</code> of the collection remains constant across each request,
indicating the server is showing you a consistent snapshot of the pods. Pods that
are created, updated, or deleted after version <code>10245</code> would not be shown unless
you make a separate <strong>list</strong> request without the <code>continue</code> token. This allows you
to break large requests into smaller chunks and then perform a <strong>watch</strong> operation
on the full set without missing any updates.</p><p><code>remainingItemCount</code> is the number of subsequent items in the collection that are not
included in this response. If the <strong>list</strong> request contained label or field
<a class="glossary-tooltip" title="Allows users to filter a list of resources based on labels." data-toggle="tooltip" data-placement="top" href="/docs/concepts/overview/working-with-objects/labels/" target="_blank" aria-label="selectors">selectors</a> then the number of
remaining items is unknown and the API server does not include a <code>remainingItemCount</code>
field in its response.
If the <strong>list</strong> is complete (either because it is not chunking, or because this is the
last chunk), then there are no more remaining items and the API server does not include a
<code>remainingItemCount</code> field in its response. The intended use of the <code>remainingItemCount</code>
is estimating the size of a collection.</p><h2 id="collections">Collections</h2><p>In Kubernetes terminology, the response you get from a <strong>list</strong> is
a <em>collection</em>. However, Kubernetes defines concrete kinds for
collections of different types of resource. Collections have a kind
named for the resource kind, with <code>List</code> appended.</p><p>When you query the API for a particular type, all items returned by that query are
of that type. For example, when you <strong>list</strong> Services, the collection response
has <code>kind</code> set to
<a href="/docs/reference/kubernetes-api/service-resources/service-v1/#ServiceList"><code>ServiceList</code></a>;
each item in that collection represents a single Service. For example:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-http" data-lang="http"><span style="display:flex"><span><span>GET /api/v1/services
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span>{<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">"kind": </span><span style="color:#b44">"ServiceList"</span>,<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">"apiVersion": </span><span style="color:#b44">"v1"</span>,<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">"metadata": </span>{<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">"resourceVersion": </span><span style="color:#b44">"2947301"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span>},<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">"items": </span>[<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span>{<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">"metadata": </span>{<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">"name": </span><span style="color:#b44">"kubernetes"</span>,<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">"namespace": </span><span style="color:#b44">"default"</span>,<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:#00f;font-weight:700">...</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">"metadata": </span>{<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">"name": </span><span style="color:#b44">"kube-dns"</span>,<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">"namespace": </span><span style="color:#b44">"kube-system"</span>,<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:#00f;font-weight:700">...</span><span style="color:#bbb">
</span></span></span></code></pre></div><p>There are dozens of collection types (such as <code>PodList</code>, <code>ServiceList</code>,
and <code>NodeList</code>) defined in the Kubernetes API.
You can get more information about each collection type from the
<a href="/docs/reference/kubernetes-api/">Kubernetes API</a> documentation.</p><p>Some tools, such as <code>kubectl</code>, represent the Kubernetes collection
mechanism slightly differently from the Kubernetes API itself.
Because the output of <code>kubectl</code> might include the response from
multiple <strong>list</strong> operations at the API level, <code>kubectl</code> represents
a list of items using <code>kind: List</code>. For example:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl get services -A -o yaml
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>List<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">metadata</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">resourceVersion</span>:<span style="color:#bbb"> </span><span style="color:#b44">""</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">selfLink</span>:<span style="color:#bbb"> </span><span style="color:#b44">""</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">items</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/>- <span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>Service<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">metadata</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">creationTimestamp</span>:<span style="color:#bbb"> </span><span style="color:#b44">"2021-06-03T14:54:12Z"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">labels</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">component</span>:<span style="color:#bbb"> </span>apiserver<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">provider</span>:<span style="color:#bbb"> </span>kubernetes<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>kubernetes<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">namespace</span>:<span style="color:#bbb"> </span>default<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:#00f;font-weight:700">...</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/>- <span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>Service<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">metadata</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">annotations</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">prometheus.io/port</span>:<span style="color:#bbb"> </span><span style="color:#b44">"9153"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">prometheus.io/scrape</span>:<span style="color:#bbb"> </span><span style="color:#b44">"true"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">creationTimestamp</span>:<span style="color:#bbb"> </span><span style="color:#b44">"2021-06-03T14:54:14Z"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">labels</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">k8s-app</span>:<span style="color:#bbb"> </span>kube-dns<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">kubernetes.io/cluster-service</span>:<span style="color:#bbb"> </span><span style="color:#b44">"true"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">kubernetes.io/name</span>:<span style="color:#bbb"> </span>CoreDNS<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>kube-dns<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">namespace</span>:<span style="color:#bbb"> </span>kube-system<span style="color:#bbb">
</span></span></span></code></pre></div><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4><p>Keep in mind that the Kubernetes API does not have a <code>kind</code> named <code>List</code>.</p><p><code>kind: List</code> is a client-side, internal implementation detail for processing
collections that might be of different kinds of object. Avoid depending on
<code>kind: List</code> in automation or other code.</p></div><h2 id="table-fetches">Table fetches</h2><p>When you run <code>kubectl get</code>, the default output format is a simple tabular
representation of one or more instances of a particular resource type. In the past,
clients were required to reproduce the tabular and describe output implemented in
<code>kubectl</code> to perform simple lists of objects.
A few limitations of that approach include non-trivial logic when dealing with
certain objects. Additionally, types provided by API aggregation or third party
resources are not known at compile time. This means that generic implementations
had to be in place for types unrecognized by a client.</p><p>In order to avoid potential limitations as described above, clients may request
the Table representation of objects, delegating specific details of printing to the
server. The Kubernetes API implements standard HTTP content type negotiation: passing
an <code>Accept</code> header containing a value of <code>application/json;as=Table;g=meta.k8s.io;v=v1</code>
with a <code>GET</code> call will request that the server return objects in the Table content
type.</p><p>For example, list all of the pods on a cluster in the Table format.</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-http" data-lang="http"><span style="display:flex"><span><span>GET /api/v1/pods
</span></span></span><span style="display:flex"><span><span>Accept: application/json;as=Table;g=meta.k8s.io;v=v1
</span></span></span><span style="display:flex"><span><span>---
</span></span></span><span style="display:flex"><span><span>200 OK
</span></span></span><span style="display:flex"><span><span>Content-Type: application/json
</span></span></span><span style="display:flex"><span><span>
</span></span></span><span style="display:flex"><span><span>{
</span></span></span><span style="display:flex"><span><span>    "kind": "Table",
</span></span></span><span style="display:flex"><span><span>    "apiVersion": "meta.k8s.io/v1",
</span></span></span><span style="display:flex"><span><span>    ...
</span></span></span><span style="display:flex"><span><span>    "columnDefinitions": [
</span></span></span><span style="display:flex"><span><span>        ...
</span></span></span><span style="display:flex"><span><span>    ]
</span></span></span><span style="display:flex"><span><span>}
</span></span></span></code></pre></div><p>For API resource types that do not have a custom Table definition known to the control
plane, the API server returns a default Table response that consists of the resource's
<code>name</code> and <code>creationTimestamp</code> fields.</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-http" data-lang="http"><span style="display:flex"><span><span>GET /apis/crd.example.com/v1alpha1/namespaces/default/resources
</span></span></span><span style="display:flex"><span><span>---
</span></span></span><span style="display:flex"><span><span>200 OK
</span></span></span><span style="display:flex"><span><span>Content-Type: application/json
</span></span></span><span style="display:flex"><span><span>...
</span></span></span><span style="display:flex"><span><span>
</span></span></span><span style="display:flex"><span><span>{
</span></span></span><span style="display:flex"><span><span>    "kind": "Table",
</span></span></span><span style="display:flex"><span><span>    "apiVersion": "meta.k8s.io/v1",
</span></span></span><span style="display:flex"><span><span>    ...
</span></span></span><span style="display:flex"><span><span>    "columnDefinitions": [
</span></span></span><span style="display:flex"><span><span>        {
</span></span></span><span style="display:flex"><span><span>            "name": "Name",
</span></span></span><span style="display:flex"><span><span>            "type": "string",
</span></span></span><span style="display:flex"><span><span>            ...
</span></span></span><span style="display:flex"><span><span>        },
</span></span></span><span style="display:flex"><span><span>        {
</span></span></span><span style="display:flex"><span><span>            "name": "Created At",
</span></span></span><span style="display:flex"><span><span>            "type": "date",
</span></span></span><span style="display:flex"><span><span>            ...
</span></span></span><span style="display:flex"><span><span>        }
</span></span></span><span style="display:flex"><span><span>    ]
</span></span></span><span style="display:flex"><span><span>}
</span></span></span></code></pre></div><p>Not all API resource types support a Table response; for example, a
<a class="glossary-tooltip" title="Custom code that defines a resource to add to your Kubernetes API server without building a complete custom server." data-toggle="tooltip" data-placement="top" href="/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/" target="_blank" aria-label="CustomResourceDefinitions">CustomResourceDefinitions</a>
might not define field-to-table mappings, and an APIService that
<a href="/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/">extends the core Kubernetes API</a>
might not serve Table responses at all. If you are implementing a client that
uses the Table information and must work against all resource types, including
extensions, you should make requests that specify multiple content types in the
<code>Accept</code> header. For example:</p><pre tabindex="0"><code>Accept: application/json;as=Table;g=meta.k8s.io;v=v1, application/json
</code></pre><p>If the client indicates it only accepts <code>...;as=Table;g=meta.k8s.io;v=v1</code>, servers
that don't support table responses will return a 406 error code.</p><p>If falling back to full objects in that case is desired, clients can add <code>,application/json</code>
(or any other supported encoding) to their Accept header, and handle either
table or full objects in the response:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-http" data-lang="http"><span style="display:flex"><span><span>Accept: application/json;as=Table;g=meta.k8s.io;v=v1,application/json`
</span></span></span></code></pre></div><p>For more information on content type negotiation, see the
<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Content_negotiation">MDN Content Negotiation</a>.</p><h2 id="metadata-only-fetches">Metadata-only fetches</h2><p>To request partial object metadata, you can request metadata only responses in the <code>Accept</code>
header. The Kubernetes API implements a variation on HTTP content type negotiation.
As a client, you can provide an <code>Accept</code> header with the desired media type,
along with parameters that indicate you want only metadata.
For example: <code>Accept: application/json;as=PartialObjectMetadata;g=meta.k8s.io;v=v1</code>
for JSON.</p><p>For example, to list all of the pods in a cluster, across all namespaces, but returning only the metadata for each pod:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-http" data-lang="http"><span style="display:flex"><span><span>GET /api/v1/pods
</span></span></span><span style="display:flex"><span><span>Accept: application/json;as=PartialObjectMetadata;g=meta.k8s.io;v=v1
</span></span></span><span style="display:flex"><span><span>---
</span></span></span><span style="display:flex"><span><span>200 OK
</span></span></span><span style="display:flex"><span><span>Content-Type: application/json
</span></span></span><span style="display:flex"><span><span>
</span></span></span><span style="display:flex"><span><span>{
</span></span></span><span style="display:flex"><span><span>    "kind": "PartialObjectMetadataList",
</span></span></span><span style="display:flex"><span><span>    "apiVersion": "meta.k8s.io/v1",
</span></span></span><span style="display:flex"><span><span>    "metadata": {
</span></span></span><span style="display:flex"><span><span>        "resourceVersion": "...",
</span></span></span><span style="display:flex"><span><span>    },
</span></span></span><span style="display:flex"><span><span>    "items": [
</span></span></span><span style="display:flex"><span><span>        {
</span></span></span><span style="display:flex"><span><span>            "apiVersion": "meta.k8s.io/v1",
</span></span></span><span style="display:flex"><span><span>            "kind": "PartialObjectMetadata",
</span></span></span><span style="display:flex"><span><span>            "metadata": {
</span></span></span><span style="display:flex"><span><span>                "name": "pod-1",
</span></span></span><span style="display:flex"><span><span>                ...
</span></span></span><span style="display:flex"><span><span>            }
</span></span></span><span style="display:flex"><span><span>        },
</span></span></span><span style="display:flex"><span><span>        {
</span></span></span><span style="display:flex"><span><span>            "apiVersion": "meta.k8s.io/v1",
</span></span></span><span style="display:flex"><span><span>            "kind": "PartialObjectMetadata",
</span></span></span><span style="display:flex"><span><span>            "metadata": {
</span></span></span><span style="display:flex"><span><span>                "name": "pod-2",
</span></span></span><span style="display:flex"><span><span>                ...
</span></span></span><span style="display:flex"><span><span>            }
</span></span></span><span style="display:flex"><span><span>        }
</span></span></span><span style="display:flex"><span><span>    ]
</span></span></span><span style="display:flex"><span><span>}
</span></span></span></code></pre></div><p>For a request for a collection, the API server returns a PartialObjectMetadataList.
For a request for a single object, the API server returns a PartialObjectMetadata
representation of the
object. In both cases, the returned objects only contain the <code>metadata</code> field.
The <code>spec</code> and <code>status</code> fields are omitted.</p><p>This feature is useful for clients that only need to check for the existence of
an object, or that only need to read its metadata. It can significantly reduce
the size of the response from the API server.</p><p>You can request a metadata-only fetch for all available media types (JSON, YAML, CBOR and Kubernetes Protobuf).
For Protobuf, the
<code>Accept</code> header would be
<code>application/vnd.kubernetes.protobuf;as=PartialObjectMetadata;g=meta.k8s.io;v=v1</code>.</p><p>The Kubernetes API server supports partial fetching for nearly all of its built-in APIs.
However, you can use Kubernetes to access other API servers via the
<a class="glossary-tooltip" title="The aggregation layer lets you install additional Kubernetes-style APIs in your cluster." data-toggle="tooltip" data-placement="top" href="/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/" target="_blank" aria-label="aggregation layer">aggregation layer</a>, and those
APIs may not support partial fetches.</p><p>If a client uses the <code>Accept</code> header to <strong>only</strong> request a response <code>...;as=PartialObjectMetadata;g=meta.k8s.io;v=v1</code>,
and accesses an API that doesn't support partial responses, Kubernetes responds
with a 406 HTTP error.</p><p>If falling back to full objects in that case is desired, clients can add <code>,application/json</code>
(or any other supported encoding) to their Accept header, and handle either
PartialObjectMetadata or full objects in the response. It's a good idea to specify
that a partial response is preferred, using the <code>q</code> (<em>quality</em>) parameter. For example:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-http" data-lang="http"><span style="display:flex"><span><span>Accept: application/json;as=PartialObjectMetadata;g=meta.k8s.io;v=v1, application/json;q=0.9
</span></span></span></code></pre></div><p>For more information on content type negotiation, see the
<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Content_negotiation">MDN Content Negotiation</a>.</p><h2 id="resource-deletion">Resource deletion</h2><p>When you <strong>delete</strong> a resource this takes place in two phases.</p><ol><li><em>finalization</em></li><li>removal</li></ol><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span>{<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">"kind": </span><span style="color:#b44">"ConfigMap"</span>,<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">"apiVersion": </span><span style="color:#b44">"v1"</span>,<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">"metadata": </span>{<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">"finalizers": </span>[<span style="color:#b44">"url.io/neat-finalization"</span>,<span style="color:#bbb"> </span><span style="color:#b44">"other-url.io/my-finalizer"</span>],<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">"deletionTimestamp": </span>nil,<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span>}<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/>}<span style="color:#bbb">
</span></span></span></code></pre></div><p>When a client first sends a <strong>delete</strong> to request the removal of a resource,
the <code>.metadata.deletionTimestamp</code> is set to the current time.
Once the <code>.metadata.deletionTimestamp</code> is set, external controllers that act on finalizers
may start performing their cleanup work at any time, in any order.</p><p>Order is <strong>not</strong> enforced between finalizers because it would introduce significant
risk of stuck <code>.metadata.finalizers</code>.</p><p>The <code>.metadata.finalizers</code> field is shared: any actor with permission can reorder it.
If the finalizer list were processed in order, then this might lead to a situation
in which the component responsible for the first finalizer in the list is
waiting for some signal (field value, external system, or other) produced by a
component responsible for a finalizer later in the list, resulting in a deadlock.</p><p>Without enforced ordering, finalizers are free to order amongst themselves and are
not vulnerable to ordering changes in the list.</p><p>Once the last finalizer is removed, the resource is actually removed from etcd.</p><h3 id="force-deletion">Force deletion</h3><div class="feature-state-notice feature-alpha" title="Feature Gate: AllowUnsafeMalformedObjectDeletion"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.32 [alpha]</code> (enabled by default: false)</div><div class="alert alert-caution" role="alert"><h4 class="alert-heading">Caution:</h4>This may break the workload associated with the resource being force deleted, if it
relies on the normal deletion flow, so cluster breaking consequences may apply.</div><p>By enabling the delete option <code>ignoreStoreReadErrorWithClusterBreakingPotential</code>, the
user can perform an unsafe force <strong>delete</strong> operation of an undecryptable/corrupt
resource. This option is behind an ALPHA feature gate, and it is disabled by
default. In order to use this option, the cluster operator must enable the feature by
setting the command line option <code>--feature-gates=AllowUnsafeMalformedObjectDeletion=true</code>.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>The user performing the force <strong>delete</strong> operation must have the privileges to do both
the <strong>delete</strong> and <strong>unsafe-delete-ignore-read-errors</strong> verbs on the given resource.</div><p>A resource is considered corrupt if it can not be successfully retrieved from the
storage due to:</p><ul><li>transformation error (for example: decryption failure), or</li><li>the object failed to decode.</li></ul><p>The API server first attempts a normal deletion, and if it fails with
a <em>corrupt resource</em> error then it triggers the force delete. A force <strong>delete</strong> operation
is unsafe because it ignores finalizer constraints, and skips precondition checks.</p><p>The default value for this option is <code>false</code>, this maintains backward compatibility.
For a <strong>delete</strong> request with <code>ignoreStoreReadErrorWithClusterBreakingPotential</code>
set to <code>true</code>, the fields <code>dryRun</code>, <code>gracePeriodSeconds</code>, <code>orphanDependents</code>,
<code>preconditions</code>, and <code>propagationPolicy</code> must be left unset.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>If the user issues a <strong>delete</strong> request with <code>ignoreStoreReadErrorWithClusterBreakingPotential</code>
set to <code>true</code> on an otherwise readable resource, the API server aborts the request with an error.</div><h2 id="single-resource-api">Single resource API</h2><p>The Kubernetes API verbs <strong>get</strong>, <strong>create</strong>, <strong>update</strong>, <strong>patch</strong>,
<strong>delete</strong> and <strong>proxy</strong> support single resources only.
These verbs with single resource support have no support for submitting multiple
resources together in an ordered or unordered list or transaction.</p><p>When clients (including kubectl) act on a set of resources, the client makes a series
of single-resource API requests, then aggregates the responses if needed.</p><p>By contrast, the Kubernetes API verbs <strong>list</strong> and <strong>watch</strong> allow getting multiple
resources, and <strong>deletecollection</strong> allows deleting multiple resources.</p><h2 id="field-validation">Field validation</h2><p>Kubernetes always validates the type of fields. For example, if a field in the
API is defined as a number, you cannot set the field to a text value. If a field
is defined as an array of strings, you can only provide an array. Some fields
allow you to omit them, other fields are required. Omitting a required field
from an API request is an error.</p><p>If you make a request with an extra field, one that the cluster's control plane
does not recognize, then the behavior of the API server is more complicated.</p><p>By default, the API server drops fields that it does not recognize
from an input that it receives (for example, the JSON body of a <code>PUT</code> request).</p><p>There are two situations where the API server drops fields that you supplied in
an HTTP request.</p><p>These situations are:</p><ol><li>The field is unrecognized because it is not in the resource's OpenAPI schema. (One
exception to this is for <a class="glossary-tooltip" title="Custom code that defines a resource to add to your Kubernetes API server without building a complete custom server." data-toggle="tooltip" data-placement="top" href="/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/" target="_blank" aria-label="CRDs">CRDs</a>
that explicitly choose not to prune unknown fields via <code>x-kubernetes-preserve-unknown-fields</code>).</li><li>The field is duplicated in the object.</li></ol><h3 id="setting-the-field-validation-level">Validation for unrecognized or duplicate fields</h3><div class="feature-state-notice feature-stable" title="Feature Gate: ServerSideFieldValidation"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.27 [stable]</code> (enabled by default: true)</div><p>From 1.25 onward, unrecognized or duplicate fields in an object are detected via
validation on the server when you use HTTP verbs that can submit data (<code>POST</code>, <code>PUT</code>, and <code>PATCH</code>).
Possible levels of validation are <code>Ignore</code>, <code>Warn</code> (default), and <code>Strict</code>.</p><dl><dt><code>Ignore</code></dt><dd>The API server succeeds in handling the request as it would without the erroneous fields
being set, dropping all unknown and duplicate fields and giving no indication it
has done so.</dd><dt><code>Warn</code></dt><dd>(Default) The API server succeeds in handling the request, and reports a
warning to the client. The warning is sent using the <code>Warning:</code> response header,
adding one warning item for each unknown or duplicate field. For more
information about warnings and the Kubernetes API, see the blog article
<a href="/blog/2020/09/03/warnings/">Warning: Helpful Warnings Ahead</a>.</dd><dt><code>Strict</code></dt><dd>The API server rejects the request with a 400 Bad Request error when it
detects any unknown or duplicate fields. The response message from the API
server specifies all the unknown or duplicate fields that the API server has
detected.</dd></dl><p>The field validation level is set by the <code>fieldValidation</code> query parameter.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4><p>If you submit a request that specifies an unrecognized field, and that is also invalid for
a different reason (for example, the request provides a string value where the API expects
an integer for a known field), then the API server responds with a 400 Bad Request error, but will
not provide any information on unknown or duplicate fields (only which fatal
error it encountered first).</p><p>You always receive an error response in this case, no matter what field validation level you requested.</p></div><p>Tools that submit requests to the server (such as <code>kubectl</code>), might set their own
defaults that are different from the <code>Warn</code> validation level that the API server uses
by default.</p><p>The <code>kubectl</code> tool uses the <code>--validate</code> flag to set the level of field
validation. It accepts the values <code>ignore</code>, <code>warn</code>, and <code>strict</code> while
also accepting the values <code>true</code> (equivalent to <code>strict</code>) and <code>false</code>
(equivalent to <code>ignore</code>). The default validation setting for kubectl is
<code>--validate=true</code>, which means strict server-side field validation.</p><p>When kubectl cannot connect to an API server with field validation (API servers
prior to Kubernetes 1.27), it will fall back to using client-side validation.
Client-side validation will be removed entirely in a future version of kubectl.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>Prior to Kubernetes 1.25, <code>kubectl --validate</code> was used to toggle client-side validation on or off as
a boolean flag.</div><p>Starting from v1.33, Kubernetes (including v1.34) offers a way to define field validations using <em>declarative tags</em>.
This is useful for people contributing to Kubernetes itself, and it's also relevant if you're
writing your own API using Kubernetes libraries.
To learn more, see <a href="/docs/reference/using-api/declarative-validation/">Declarative API Validation</a>.</p><h2 id="dry-run">Dry-run</h2><div class="feature-state-notice feature-stable" title="Feature Gate: DryRun"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.19 [stable]</code> (enabled by default: true)</div><p>When you use HTTP verbs that can modify resources (<code>POST</code>, <code>PUT</code>, <code>PATCH</code>, and
<code>DELETE</code>), you can submit your request in a <em>dry run</em> mode. Dry run mode helps to
evaluate a request through the typical request stages (admission chain, validation,
merge conflicts) up until persisting objects to storage. The response body for the
request is as close as possible to a non-dry-run response. Kubernetes guarantees that
dry-run requests will not be persisted in storage or have any other side effects.</p><h3 id="make-a-dry-run-request">Make a dry-run request</h3><p>Dry-run is triggered by setting the <code>dryRun</code> query parameter. This parameter is a
string, working as an enum, and the only accepted values are:</p><dl><dt>[no value set]</dt><dd>Allow side effects. You request this with a query string such as <code>?dryRun</code>
or <code>?dryRun&amp;pretty=true</code>. The response is the final object that would have been
persisted, or an error if the request could not be fulfilled.</dd><dt><code>All</code></dt><dd>Every stage runs as normal, except for the final storage stage where side effects
are prevented.</dd></dl><p>When you set <code>?dryRun=All</code>, any relevant
<a class="glossary-tooltip" title="A piece of code that intercepts requests to the Kubernetes API server prior to persistence of the object." data-toggle="tooltip" data-placement="top" href="/docs/reference/access-authn-authz/admission-controllers/" target="_blank" aria-label="admission controllers">admission controllers</a>
are run, validating admission controllers check the request post-mutation, merge is
performed on <code>PATCH</code>, fields are defaulted, and schema validation occurs. The changes
are not persisted to the underlying storage, but the final object which would have
been persisted is still returned to the user, along with the normal status code.</p><p>If the non-dry-run version of a request would trigger an admission controller that has
side effects, the request will be failed rather than risk an unwanted side effect. All
built in admission control plugins support dry-run. Additionally, admission webhooks can
declare in their
<a href="/docs/reference/generated/kubernetes-api/v1.34/#validatingwebhook-v1-admissionregistration-k8s-io">configuration object</a>
that they do not have side effects, by setting their <code>sideEffects</code> field to <code>None</code>.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>If a webhook actually does have side effects, then the <code>sideEffects</code> field should be
set to "NoneOnDryRun". That change is appropriate provided that the webhook is also
be modified to understand the <code>DryRun</code> field in AdmissionReview, and to prevent side
effects on any request marked as dry runs.</div><p>Here is an example dry-run request that uses <code>?dryRun=All</code>:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-http" data-lang="http"><span style="display:flex"><span><span>POST /api/v1/namespaces/test/pods?dryRun=All
</span></span></span><span style="display:flex"><span><span>Content-Type: application/json
</span></span></span><span style="display:flex"><span><span>Accept: application/json
</span></span></span></code></pre></div><p>The response would look the same as for non-dry-run request, but the values of some
generated fields may differ.</p><h3 id="generated-values">Generated values</h3><p>Some values of an object are typically generated before the object is persisted. It
is important not to rely upon the values of these fields set by a dry-run request,
since these values will likely be different in dry-run mode from when the real
request is made. Some of these fields are:</p><ul><li><code>name</code>: if <code>generateName</code> is set, <code>name</code> will have a unique random name</li><li><code>creationTimestamp</code> / <code>deletionTimestamp</code>: records the time of creation/deletion</li><li><code>UID</code>: <a href="/docs/concepts/overview/working-with-objects/names/#uids">uniquely identifies</a>
the object and is randomly generated (non-deterministic)</li><li><code>resourceVersion</code>: tracks the persisted version of the object</li><li>Any field set by a mutating admission controller</li><li>For the <code>Service</code> resource: Ports or IP addresses that the kube-apiserver assigns to Service objects</li></ul><h3 id="dry-run-authorization">Dry-run authorization</h3><p>Authorization for dry-run and non-dry-run requests is identical. Thus, to make
a dry-run request, you must be authorized to make the non-dry-run request.</p><p>For example, to run a dry-run <strong>patch</strong> for a Deployment, you must be authorized
to perform that <strong>patch</strong>. Here is an example of a rule for Kubernetes
<a class="glossary-tooltip" title="Manages authorization decisions, allowing admins to dynamically configure access policies through the Kubernetes API." data-toggle="tooltip" data-placement="top" href="/docs/reference/access-authn-authz/rbac/" target="_blank" aria-label="RBAC">RBAC</a> that allows patching
Deployments:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">rules</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/>- <span style="color:green;font-weight:700">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">"apps"</span>]<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">"deployments"</span>]<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">verbs</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">"patch"</span>]<span style="color:#bbb">
</span></span></span></code></pre></div><p>See <a href="/docs/reference/access-authn-authz/authorization/">Authorization Overview</a>.</p><h2 id="patch-and-apply">Updates to existing resources</h2><p>Kubernetes provides several ways to update existing objects.
You can read <a href="#update-mechanism-choose">choosing an update mechanism</a> to
learn about which approach might be best for your use case.</p><p>You can overwrite (<strong>update</strong>) an existing resource - for example, a ConfigMap -
using an HTTP PUT. For a PUT request, it is the client's responsibility to specify
the <code>resourceVersion</code> (taking this from the object being updated). Kubernetes uses
that <code>resourceVersion</code> information so that the API server can detect lost updates
and reject requests made by a client that is out of date with the cluster.
In the event that the resource has changed (the <code>resourceVersion</code> the client
provided is stale), the API server returns a <code>409 Conflict</code> error response.</p><p>Instead of sending a PUT request, the client can send an instruction to the API
server to <strong>patch</strong> an existing resource. A <strong>patch</strong> is typically appropriate
if the change that the client wants to make isn't conditional on the existing data.
Clients that need effective detection of lost updates should consider
making their request conditional on the existing <code>resourceVersion</code> (either HTTP PUT or HTTP PATCH),
and then handle any retries that are needed in case there is a conflict.</p><p>The Kubernetes API supports four different PATCH operations, determined by their
corresponding HTTP <code>Content-Type</code> header:</p><dl><dt><code>application/apply-patch+yaml</code></dt><dd>Server Side Apply YAML (a Kubernetes-specific extension, based on YAML).
All JSON documents are valid YAML, so you can also submit JSON using this
media type. See <a href="/docs/reference/using-api/server-side-apply/#serialization">Server Side Apply serialization</a>
for more details.
To Kubernetes, this is a <strong>create</strong> operation if the object does not exist,
or a <strong>patch</strong> operation if the object already exists.</dd><dt><code>application/json-patch+json</code></dt><dd>JSON Patch, as defined in <a href="https://tools.ietf.org/html/rfc6902">RFC6902</a>.
A JSON patch is a sequence of operations that are executed on the resource;
for example <code>{"op": "add", "path": "/a/b/c", "value": [ "foo", "bar" ]}</code>.
To Kubernetes, this is a <strong>patch</strong> operation.<p>A <strong>patch</strong> using <code>application/json-patch+json</code> can include conditions to
validate consistency, allowing the operation to fail if those conditions
are not met (for example, to avoid a lost update).</p></dd><dt><code>application/merge-patch+json</code></dt><dd>JSON Merge Patch, as defined in <a href="https://tools.ietf.org/html/rfc7386">RFC7386</a>.
A JSON Merge Patch is essentially a partial representation of the resource.
The submitted JSON is combined with the current resource to create a new one,
then the new one is saved.
To Kubernetes, this is a <strong>patch</strong> operation.</dd><dt><code>application/strategic-merge-patch+json</code></dt><dd>Strategic Merge Patch (a Kubernetes-specific extension based on JSON).
Strategic Merge Patch is a custom implementation of JSON Merge Patch.
You can only use Strategic Merge Patch with built-in APIs, or with aggregated
API servers that have special support for it. You cannot use
<code>application/strategic-merge-patch+json</code> with any API
defined using a <a class="glossary-tooltip" title="Custom code that defines a resource to add to your Kubernetes API server without building a complete custom server." data-toggle="tooltip" data-placement="top" href="/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/" target="_blank" aria-label="CustomResourceDefinition">CustomResourceDefinition</a>.<div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>The Kubernetes <em>server side apply</em> mechanism has superseded Strategic Merge
Patch.</div></dd></dl><p>Kubernetes' <a href="/docs/reference/using-api/server-side-apply/">Server Side Apply</a>
feature allows the control plane to track managed fields for newly created objects.
Server Side Apply provides a clear pattern for managing field conflicts,
offers server-side <strong>apply</strong> and <strong>update</strong> operations, and replaces the
client-side functionality of <code>kubectl apply</code>.</p><p>For Server-Side Apply, Kubernetes treats the request as a <strong>create</strong> if the object
does not yet exist, and a <strong>patch</strong> otherwise. For other requests that use PATCH
at the HTTP level, the logical Kubernetes operation is always <strong>patch</strong>.</p><p>See <a href="/docs/reference/using-api/server-side-apply/">Server Side Apply</a> for more details.</p><h3 id="update-mechanism-choose">Choosing an update mechanism</h3><h4 id="update-mechanism-update">HTTP PUT to replace existing resource</h4><p>The <strong>update</strong> (HTTP <code>PUT</code>) operation is simple to implement and flexible,
but has drawbacks:</p><ul><li>You need to handle conflicts where the <code>resourceVersion</code> of the object changes
between your client reading it and trying to write it back. Kubernetes always
detects the conflict, but you as the client author need to implement retries.</li><li>You might accidentally drop fields if you decode an object locally (for example,
using client-go, you could receive fields that your client does not know how to
handle - and then drop them as part of your update.</li><li>If there's a lot of contention on the object (even on a field, or set of fields,
that you're not trying to edit), you might have trouble sending the update.
The problem is worse for larger objects and for objects with many fields.</li></ul><h4 id="update-mechanism-json-patch">HTTP PATCH using JSON Patch</h4><p>A <strong>patch</strong> update is helpful, because:</p><ul><li>As you're only sending differences, you have less data to send in the <code>PATCH</code>
request.</li><li>You can make changes that rely on existing values, such as copying the
value of a particular field into an annotation.</li><li>Unlike with an <strong>update</strong> (HTTP <code>PUT</code>), making your change can happen right away
even if there are frequent changes to unrelated fields): you usually would
not need to retry.<ul><li>You might still need to specify the <code>resourceVersion</code> (to match an existing object)
if you want to be extra careful to avoid lost updates</li><li>It's still good practice to write in some retry logic in case of errors.</li></ul></li><li>You can use test conditions to careful craft specific update conditions.
For example, you can increment a counter without reading it if the existing
value matches what you expect. You can do this with no lost update risk,
even if the object has changed in other ways since you last wrote to it.
(If the test condition fails, you can fall back to reading the current value
and then write back the changed number).</li></ul><p>However:</p><ul><li>You need more local (client) logic to build the patch; it helps a lot if you have
a library implementation of JSON Patch, or even for making a JSON Patch specifically against Kubernetes.</li><li>As the author of client software, you need to be careful when building the patch
(the HTTP request body) not to drop fields (the order of operations matters).</li></ul><h4 id="update-mechanism-server-side-apply">HTTP PATCH using Server-Side Apply</h4><p>Server-Side Apply has some clear benefits:</p><ul><li>A single round trip: it rarely requires making a <code>GET</code> request first.<ul><li>and you can still detect conflicts for unexpected changes</li><li>you have the option to force override a conflict, if appropriate</li></ul></li><li>Client implementations are easy to make.</li><li>You get an atomic create-or-update operation without extra effort
(similar to <code>UPSERT</code> in some SQL dialects).</li></ul><p>However:</p><ul><li>Server-Side Apply does not work at all for field changes that depend on a current value of the object.</li><li>You can only apply updates to objects. Some resources in the Kubernetes HTTP API are
not objects (they do not have a <code>.metadata</code> field), and Server-Side Apply
is only relevant for Kubernetes objects.</li></ul><h2 id="resource-versions">Resource versions</h2><p>Resource versions are strings that identify the server's internal version of an
object. Resource versions can be used by clients to determine when objects have
changed, or to express data consistency requirements when getting, listing and
watching resources. Resource versions must be treated as opaque by clients and passed
unmodified back to the server.</p><p>You must not assume resource versions are numeric or collatable. API clients may
only compare two resource versions for equality (this means that you must not compare
resource versions for greater-than or less-than relationships).</p><h3 id="resourceversion-in-metadata"><code>resourceVersion</code> fields in metadata</h3><p>Clients find resource versions in resources, including the resources from the response
stream for a <strong>watch</strong>, or when using <strong>list</strong> to enumerate resources.</p><p><a href="/docs/reference/generated/kubernetes-api/v1.34/#objectmeta-v1-meta">v1.meta/ObjectMeta</a> -
The <code>metadata.resourceVersion</code> of a resource instance identifies the resource version the instance was last modified at.</p><p><a href="/docs/reference/generated/kubernetes-api/v1.34/#listmeta-v1-meta">v1.meta/ListMeta</a> -
The <code>metadata.resourceVersion</code> of a resource collection (the response to a <strong>list</strong>) identifies the
resource version at which the collection was constructed.</p><h3 id="the-resourceversion-parameter"><code>resourceVersion</code> parameters in query strings</h3><p>The <strong>get</strong>, <strong>list</strong>, and <strong>watch</strong> operations support the <code>resourceVersion</code> parameter.
From version v1.19, Kubernetes API servers also support the <code>resourceVersionMatch</code>
parameter on <em>list</em> requests.</p><p>The API server interprets the <code>resourceVersion</code> parameter differently depending
on the operation you request, and on the value of <code>resourceVersion</code>. If you set
<code>resourceVersionMatch</code> then this also affects the way matching happens.</p><h3 id="semantics-for-get-and-list">Semantics for <strong>get</strong> and <strong>list</strong></h3><p>For <strong>get</strong> and <strong>list</strong>, the semantics of <code>resourceVersion</code> are:</p><p><strong>get:</strong></p><table><thead><tr><th>resourceVersion unset</th><th>resourceVersion="0"</th><th>resourceVersion="{value other than 0}"</th></tr></thead><tbody><tr><td>Most Recent</td><td>Any</td><td>Not older than</td></tr></tbody></table><p><strong>list:</strong></p><p>From version v1.19, Kubernetes API servers support the <code>resourceVersionMatch</code> parameter
on <em>list</em> requests. If you set both <code>resourceVersion</code> and <code>resourceVersionMatch</code>, the
<code>resourceVersionMatch</code> parameter determines how the API server interprets
<code>resourceVersion</code>.</p><p>You should always set the <code>resourceVersionMatch</code> parameter when setting
<code>resourceVersion</code> on a <strong>list</strong> request. However, be prepared to handle the case
where the API server that responds is unaware of <code>resourceVersionMatch</code>
and ignores it.</p><p>Unless you have strong consistency requirements, using <code>resourceVersionMatch=NotOlderThan</code> and
a known <code>resourceVersion</code> is preferable since it can achieve better performance and scalability
of your cluster than leaving <code>resourceVersion</code> and <code>resourceVersionMatch</code> unset, which requires
quorum read to be served.</p><p>Setting the <code>resourceVersionMatch</code> parameter without setting <code>resourceVersion</code> is not valid.</p><p>This table explains the behavior of <strong>list</strong> requests with various combinations of
<code>resourceVersion</code> and <code>resourceVersionMatch</code>:</p><table><caption style="display:none">resourceVersionMatch and paging parameters for list</caption><thead><tr><th>resourceVersionMatch param</th><th>paging params</th><th>resourceVersion not set</th><th>resourceVersion="0"</th><th>resourceVersion="{value other than 0}"</th></tr></thead><tbody><tr><td><em>unset</em></td><td><em>limit unset</em></td><td>Most Recent</td><td>Any</td><td>Not older than</td></tr><tr><td><em>unset</em></td><td>limit=&lt;n&gt;, <em>continue unset</em></td><td>Most Recent</td><td>Any</td><td>Exact</td></tr><tr><td><em>unset</em></td><td>limit=&lt;n&gt;, continue=&lt;token&gt;</td><td>Continuation</td><td>Continuation</td><td>Invalid, HTTP <code>400 Bad Request</code></td></tr><tr><td><code>resourceVersionMatch=Exact</code></td><td><em>limit unset</em></td><td>Invalid</td><td>Invalid</td><td>Exact</td></tr><tr><td><code>resourceVersionMatch=Exact</code></td><td>limit=&lt;n&gt;, <em>continue unset</em></td><td>Invalid</td><td>Invalid</td><td>Exact</td></tr><tr><td><code>resourceVersionMatch=NotOlderThan</code></td><td><em>limit unset</em></td><td>Invalid</td><td>Any</td><td>Not older than</td></tr><tr><td><code>resourceVersionMatch=NotOlderThan</code></td><td>limit=&lt;n&gt;, <em>continue unset</em></td><td>Invalid</td><td>Any</td><td>Not older than</td></tr></tbody></table><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>If your cluster's API server does not honor the <code>resourceVersionMatch</code> parameter,
the behavior is the same as if you did not set it.</div><p>The meaning of the <strong>get</strong> and <strong>list</strong> semantics are:</p><dl><dt>Any</dt><dd>Return data at any resource version. The newest available resource version is preferred,
but strong consistency is not required; data at any resource version may be served. It is possible
for the request to return data at a much older resource version that the client has previously
observed, particularly in high availability configurations, due to partitions or stale
caches. Clients that cannot tolerate this should not use this semantic.
Always served from <em>watch cache</em>, improving performance and reducing etcd load.</dd><dt>Most recent</dt><dd>Return data at the most recent resource version. The returned data must be
consistent (in detail: served from etcd via a quorum read).
For etcd v3.4.31+ and v3.5.13+, Kubernetes 1.34 serves most recent reads from the <em>watch cache</em>:
an internal, in-memory store within the API server that caches and mirrors the state of data
persisted into etcd. Kubernetes requests progress notification to maintain cache consistency against
the etcd persistence layer. Kubernetes v1.28 through to v1.30 also supported this
feature, although as Alpha it was not recommended for production nor enabled by default until the v1.31 release.</dd><dt>Not older than</dt><dd>Return data at least as new as the provided <code>resourceVersion</code>. The newest
available data is preferred, but any data not older than the provided <code>resourceVersion</code> may be
served. For <strong>list</strong> requests to servers that honor the <code>resourceVersionMatch</code> parameter, this
guarantees that the collection's <code>.metadata.resourceVersion</code> is not older than the requested
<code>resourceVersion</code>, but does not make any guarantee about the <code>.metadata.resourceVersion</code> of any
of the items in that collection.
Always served from <em>watch cache</em>, improving performance and reducing etcd load.</dd><dt>Exact</dt><dd>Return data at the exact resource version provided. If the provided <code>resourceVersion</code> is
unavailable, the server responds with HTTP <code>410 Gone</code>. For <strong>list</strong> requests to servers that honor the
<code>resourceVersionMatch</code> parameter, this guarantees that the collection's <code>.metadata.resourceVersion</code>
is the same as the <code>resourceVersion</code> you requested in the query string. That guarantee does
not apply to the <code>.metadata.resourceVersion</code> of any items within that collection.
With the <code>ListFromCacheSnapshot</code> feature gate enabled by default,
API server will attempt to serve the response from snapshots if one is available with <code>resourceVersion</code> older than requested.
This improves performance and reduces etcd load. API server starts with no snapshots,
creates a new snapshot on every watch event and keeps them until it detects etcd is compacted or if cache is full with events older than 75 seconds.
If the provided <code>resourceVersion</code> is unavailable, the server will fallback to etcd.</dd><dt>Continuation</dt><dd>Return the next page of data for a paginated list request, ensuring consistency with the exact <code>resourceVersion</code> established by the initial request in the sequence.
Response to <strong>list</strong> requests with limit include <em>continue token</em>, that encodes the <code>resourceVersion</code> and last observed position from which to resume the list.
If the <code>resourceVersion</code> in the provided <em>continue token</em> is unavailable, the server responds with HTTP <code>410 Gone</code>.
With the <code>ListFromCacheSnapshot</code> feature gate enabled by default,
API server will attempt to serve the response from snapshots if one is available with <code>resourceVersion</code> older than requested.
This improves performance and reduces etcd load. API server starts with no snapshots,
creates a new snapshot on every watch event and keeps them until it detects etcd is compacted or if cache is full with events older than 75 seconds.
If the <code>resourceVersion</code> in provided <em>continue token</em> is unavailable, the server will fallback to etcd.</dd></dl><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>When you <strong>list</strong> resources and receive a collection response, the response includes the
<a href="/docs/reference/generated/kubernetes-api/v1.34/#listmeta-v1-meta">list metadata</a>
of the collection as well as
<a href="/docs/reference/generated/kubernetes-api/v1.34/#objectmeta-v1-meta">object metadata</a>
for each item in that collection. For individual objects found within a collection response,
<code>.metadata.resourceVersion</code> tracks when that object was last updated, and not how up-to-date
the object is when served.</div><p>When using <code>resourceVersionMatch=NotOlderThan</code> and limit is set, clients must
handle HTTP <code>410 Gone</code> responses. For example, the client might retry with a
newer <code>resourceVersion</code> or fall back to <code>resourceVersion=""</code>.</p><p>When using <code>resourceVersionMatch=Exact</code> and <code>limit</code> is unset, clients must
verify that the collection's <code>.metadata.resourceVersion</code> matches
the requested <code>resourceVersion</code>, and handle the case where it does not. For
example, the client might fall back to a request with <code>limit</code> set.</p><h3 id="semantics-for-watch">Semantics for <strong>watch</strong></h3><p>For <strong>watch</strong>, the semantics of resource version are:</p><p><strong>watch:</strong></p><table><caption style="display:none">resourceVersion for watch</caption><thead><tr><th>resourceVersion unset</th><th>resourceVersion="0"</th><th>resourceVersion="{value other than 0}"</th></tr></thead><tbody><tr><td>Get State and Start at Most Recent</td><td>Get State and Start at Any</td><td>Start at Exact</td></tr></tbody></table><p>The meaning of those <strong>watch</strong> semantics are:</p><dl><dt>Get State and Start at Any</dt><dd>Start a <strong>watch</strong> at any resource version; the most recent resource version
available is preferred, but not required. Any starting resource version is
allowed. It is possible for the <strong>watch</strong> to start at a much older resource
version that the client has previously observed, particularly in high availability
configurations, due to partitions or stale caches. Clients that cannot tolerate
this apparent rewinding should not start a <strong>watch</strong> with this semantic. To
establish initial state, the <strong>watch</strong> begins with synthetic "Added" events for
all resource instances that exist at the starting resource version. All following
watch events are for all changes that occurred after the resource version the
<strong>watch</strong> started at.<div class="alert alert-caution" role="alert"><h4 class="alert-heading">Caution:</h4><strong>watches</strong> initialized this way may return arbitrarily stale
data. Please review this semantic before using it, and favor the other semantics
where possible.</div></dd><dt>Get State and Start at Most Recent</dt><dd>Start a <strong>watch</strong> at the most recent resource version, which must be consistent
(in detail: served from etcd via a quorum read). To establish initial state,
the <strong>watch</strong> begins with synthetic "Added" events of all resources instances
that exist at the starting resource version. All following watch events are for
all changes that occurred after the resource version the <strong>watch</strong> started at.</dd><dt>Start at Exact</dt><dd>Start a <strong>watch</strong> at an exact resource version. The watch events are for all changes
after the provided resource version. Unlike "Get State and Start at Most Recent"
and "Get State and Start at Any", the <strong>watch</strong> is not started with synthetic
"Added" events for the provided resource version. The client is assumed to already
have the initial state at the starting resource version since the client provided
the resource version.</dd></dl><h3 id="410-gone-responses">"410 Gone" responses</h3><p>Servers are not required to serve all older resource versions and may return a HTTP
<code>410 (Gone)</code> status code if a client requests a <code>resourceVersion</code> older than the
server has retained. Clients must be able to tolerate <code>410 (Gone)</code> responses. See
<a href="#efficient-detection-of-changes">Efficient detection of changes</a> for details on
how to handle <code>410 (Gone)</code> responses when watching resources.</p><p>If you request a <code>resourceVersion</code> outside the applicable limit then, depending
on whether a request is served from cache or not, the API server may reply with a
<code>410 Gone</code> HTTP response.</p><h3 id="unavailable-resource-versions">Unavailable resource versions</h3><p>Servers are not required to serve unrecognized resource versions. If you request
<strong>list</strong> or <strong>get</strong> for a resource version that the API server does not recognize,
then the API server may either:</p><ul><li>wait briefly for the resource version to become available, then timeout with a
<code>504 (Gateway Timeout)</code> if the provided resource versions does not become available
in a reasonable amount of time;</li><li>respond with a <code>Retry-After</code> response header indicating how many seconds a client
should wait before retrying the request.</li></ul><p>If you request a resource version that an API server does not recognize, the
kube-apiserver additionally identifies its error responses with a message
<code>Too large resource version</code>.</p><p>If you make a <strong>watch</strong> request for an unrecognized resource version, the API server
may wait indefinitely (until the request timeout) for the resource version to become
available.</p></a></div>