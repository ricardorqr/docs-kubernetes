<div class="td-content"><h1 data-pagefind-weight="10">Controlling Access to the Kubernetes API</h1><p>This page provides an overview of controlling access to the Kubernetes API.</p><p>Users access the <a href="/docs/concepts/overview/kubernetes-api/">Kubernetes API</a> using <code>kubectl</code>,
client libraries, or by making REST requests. Both human users and
<a href="/docs/tasks/configure-pod-container/configure-service-account/">Kubernetes service accounts</a> can be
authorized for API access.
When a request reaches the API, it goes through several stages, illustrated in the
following diagram:</p><p><img alt="Diagram of request handling steps for Kubernetes API request" src="/images/docs/admin/access-control-overview.svg"/></p><h2 id="transport-security">Transport security</h2><p>By default, the Kubernetes API server listens on port 6443 on the first non-localhost
network interface, protected by TLS. In a typical production Kubernetes cluster, the
API serves on port 443. The port can be changed with the <code>--secure-port</code>, and the
listening IP address with the <code>--bind-address</code> flag.</p><p>The API server presents a certificate. This certificate may be signed using
a private certificate authority (CA), or based on a public key infrastructure linked
to a generally recognized CA. The certificate and corresponding private key can be set
by using the <code>--tls-cert-file</code> and <code>--tls-private-key-file</code> flags.</p><p>If your cluster uses a private certificate authority, you need a copy of that CA
certificate configured into your <code>~/.kube/config</code> on the client, so that you can
trust the connection and be confident it was not intercepted.</p><p>Your client can present a TLS client certificate at this stage.</p><h2 id="authentication">Authentication</h2><p>Once TLS is established, the HTTP request moves to the Authentication step.
This is shown as step <strong>1</strong> in the diagram.
The cluster creation script or cluster admin configures the API server to run
one or more Authenticator modules.
Authenticators are described in more detail in
<a href="/docs/reference/access-authn-authz/authentication/">Authentication</a>.</p><p>The input to the authentication step is the entire HTTP request; however, it typically
examines the headers and/or client certificate.</p><p>Authentication modules include client certificates, password, and plain tokens,
bootstrap tokens, and JSON Web Tokens (used for service accounts).</p><p>Multiple authentication modules can be specified, in which case each one is tried in sequence,
until one of them succeeds.</p><p>If the request cannot be authenticated, it is rejected with HTTP status code 401.
Otherwise, the user is authenticated as a specific <code>username</code>, and the user name
is available to subsequent steps to use in their decisions. Some authenticators
also provide the group memberships of the user, while other authenticators
do not.</p><p>While Kubernetes uses usernames for access control decisions and in request logging,
it does not have a <code>User</code> object nor does it store usernames or other information about
users in its API.</p><h2 id="authorization">Authorization</h2><p>After the request is authenticated as coming from a specific user, the request must
be authorized. This is shown as step <strong>2</strong> in the diagram.</p><p>A request must include the username of the requester, the requested action, and
the object affected by the action. The request is authorized if an existing policy
declares that the user has permissions to complete the requested action.</p><p>For example, if Bob has the policy below, then he can read pods only in the namespace <code>projectCaribou</code>:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json"><span style="display:flex"><span>{
</span></span><span style="display:flex"><span>    <span style="color:green;font-weight:700">"apiVersion"</span>: <span style="color:#b44">"abac.authorization.kubernetes.io/v1beta1"</span>,
</span></span><span style="display:flex"><span>    <span style="color:green;font-weight:700">"kind"</span>: <span style="color:#b44">"Policy"</span>,
</span></span><span style="display:flex"><span>    <span style="color:green;font-weight:700">"spec"</span>: {
</span></span><span style="display:flex"><span>        <span style="color:green;font-weight:700">"user"</span>: <span style="color:#b44">"bob"</span>,
</span></span><span style="display:flex"><span>        <span style="color:green;font-weight:700">"namespace"</span>: <span style="color:#b44">"projectCaribou"</span>,
</span></span><span style="display:flex"><span>        <span style="color:green;font-weight:700">"resource"</span>: <span style="color:#b44">"pods"</span>,
</span></span><span style="display:flex"><span>        <span style="color:green;font-weight:700">"readonly"</span>: <span style="color:#a2f;font-weight:700">true</span>
</span></span><span style="display:flex"><span>    }
</span></span><span style="display:flex"><span>}
</span></span></code></pre></div><p>If Bob makes the following request, the request is authorized because he is
allowed to read objects in the <code>projectCaribou</code> namespace:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json"><span style="display:flex"><span>{
</span></span><span style="display:flex"><span>  <span style="color:green;font-weight:700">"apiVersion"</span>: <span style="color:#b44">"authorization.k8s.io/v1beta1"</span>,
</span></span><span style="display:flex"><span>  <span style="color:green;font-weight:700">"kind"</span>: <span style="color:#b44">"SubjectAccessReview"</span>,
</span></span><span style="display:flex"><span>  <span style="color:green;font-weight:700">"spec"</span>: {
</span></span><span style="display:flex"><span>    <span style="color:green;font-weight:700">"resourceAttributes"</span>: {
</span></span><span style="display:flex"><span>      <span style="color:green;font-weight:700">"namespace"</span>: <span style="color:#b44">"projectCaribou"</span>,
</span></span><span style="display:flex"><span>      <span style="color:green;font-weight:700">"verb"</span>: <span style="color:#b44">"get"</span>,
</span></span><span style="display:flex"><span>      <span style="color:green;font-weight:700">"group"</span>: <span style="color:#b44">"unicorn.example.org"</span>,
</span></span><span style="display:flex"><span>      <span style="color:green;font-weight:700">"resource"</span>: <span style="color:#b44">"pods"</span>
</span></span><span style="display:flex"><span>    }
</span></span><span style="display:flex"><span>  }
</span></span><span style="display:flex"><span>}
</span></span></code></pre></div><p>If Bob makes a request to write (<code>create</code> or <code>update</code>) to the objects in the
<code>projectCaribou</code> namespace, his authorization is denied. If Bob makes a request
to read (<code>get</code>) objects in a different namespace such as <code>projectFish</code>, then his authorization is denied.</p><p>Kubernetes authorization requires that you use common REST attributes to interact
with existing organization-wide or cloud-provider-wide access control systems.
It is important to use REST formatting because these control systems might
interact with other APIs besides the Kubernetes API.</p><p>Kubernetes supports multiple authorization modules, such as ABAC mode, RBAC Mode,
and Webhook mode. When an administrator creates a cluster, they configure the
authorization modules that should be used in the API server. If more than one
authorization modules are configured, Kubernetes checks each module, and if
any module authorizes the request, then the request can proceed. If all of
the modules deny the request, then the request is denied (HTTP status code 403).</p><p>To learn more about Kubernetes authorization, including details about creating
policies using the supported authorization modules, see <a href="/docs/reference/access-authn-authz/authorization/">Authorization</a>.</p><h2 id="admission-control">Admission control</h2><p>Admission Control modules are software modules that can modify or reject requests.
In addition to the attributes available to Authorization modules, Admission
Control modules can access the contents of the object that is being created or modified.</p><p>Admission controllers act on requests that create, modify, delete, or connect to (proxy) an object.
Admission controllers do not act on requests that merely read objects.
When multiple admission controllers are configured, they are called in order.</p><p>This is shown as step <strong>3</strong> in the diagram.</p><p>Unlike Authentication and Authorization modules, if any admission controller module
rejects, then the request is immediately rejected.</p><p>In addition to rejecting objects, admission controllers can also set complex defaults for
fields.</p><p>The available Admission Control modules are described in <a href="/docs/reference/access-authn-authz/admission-controllers/">Admission Controllers</a>.</p><p>Once a request passes all admission controllers, it is validated using the validation routines
for the corresponding API object, and then written to the object store (shown as step <strong>4</strong>).</p><h2 id="auditing">Auditing</h2><p>Kubernetes auditing provides a security-relevant, chronological set of records documenting the sequence of actions in a cluster.
The cluster audits the activities generated by users, by applications that use the Kubernetes API, and by the control plane itself.</p><p>For more information, see <a href="/docs/tasks/debug/debug-cluster/audit/">Auditing</a>.</p><h2 id="what-s-next">What's next</h2><p>Read more documentation on authentication, authorization and API access control:</p><ul><li><a href="/docs/reference/access-authn-authz/authentication/">Authenticating</a><ul><li><a href="/docs/reference/access-authn-authz/bootstrap-tokens/">Authenticating with Bootstrap Tokens</a></li></ul></li><li><a href="/docs/reference/access-authn-authz/admission-controllers/">Admission Controllers</a><ul><li><a href="/docs/reference/access-authn-authz/extensible-admission-controllers/">Dynamic Admission Control</a></li></ul></li><li><a href="/docs/reference/access-authn-authz/authorization/">Authorization</a><ul><li><a href="/docs/reference/access-authn-authz/rbac/">Role Based Access Control</a></li><li><a href="/docs/reference/access-authn-authz/abac/">Attribute Based Access Control</a></li><li><a href="/docs/reference/access-authn-authz/node/">Node Authorization</a></li><li><a href="/docs/reference/access-authn-authz/webhook/">Webhook Authorization</a></li></ul></li><li><a href="/docs/reference/access-authn-authz/certificate-signing-requests/">Certificate Signing Requests</a><ul><li>including <a href="/docs/reference/access-authn-authz/certificate-signing-requests/#approval-rejection">CSR approval</a>
and <a href="/docs/reference/access-authn-authz/certificate-signing-requests/#signing">certificate signing</a></li></ul></li><li>Service accounts<ul><li><a href="/docs/tasks/configure-pod-container/configure-service-account/">Developer guide</a></li><li><a href="/docs/reference/access-authn-authz/service-accounts-admin/">Administration</a></li></ul></li></ul><p>You can learn about:</p><ul><li>how Pods can use
<a href="/docs/concepts/configuration/secret/#service-accounts-automatically-create-and-attach-secrets-with-api-credentials">Secrets</a>
to obtain API credentials.</li></ul></div>