<div class="td-content"><h1 data-pagefind-weight="10">Mixed Version Proxy</h1><div class="feature-state-notice feature-alpha" title="Feature Gate: UnknownVersionInteroperabilityProxy"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.28 [alpha]</code> (enabled by default: false)</div><p>Kubernetes 1.34 includes an alpha feature that lets an
<a class="glossary-tooltip" title="Control plane component that serves the Kubernetes API." data-toggle="tooltip" data-placement="top" href="/docs/concepts/architecture/#kube-apiserver" target="_blank" aria-label="API Server">API Server</a>
proxy a resource requests to other <em>peer</em> API servers. This is useful when there are multiple
API servers running different versions of Kubernetes in one cluster
(for example, during a long-lived rollout to a new release of Kubernetes).</p><p>This enables cluster administrators to configure highly available clusters that can be upgraded
more safely, by directing resource requests (made during the upgrade) to the correct kube-apiserver.
That proxying prevents users from seeing unexpected 404 Not Found errors that stem
from the upgrade process.</p><p>This mechanism is called the <em>Mixed Version Proxy</em>.</p><h2 id="enabling-the-mixed-version-proxy">Enabling the Mixed Version Proxy</h2><p>Ensure that <code>UnknownVersionInteroperabilityProxy</code> <a href="/docs/reference/command-line-tools-reference/feature-gates/">feature gate</a>
is enabled when you start the <a class="glossary-tooltip" title="Control plane component that serves the Kubernetes API." data-toggle="tooltip" data-placement="top" href="/docs/concepts/architecture/#kube-apiserver" target="_blank" aria-label="API Server">API Server</a>:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kube-apiserver <span style="color:#b62;font-weight:700">\
</span></span></span><span style="display:flex"><span><span style="color:#b62;font-weight:700"/>--feature-gates<span style="color:#666">=</span><span style="color:#b8860b">UnknownVersionInteroperabilityProxy</span><span style="color:#666">=</span><span style="color:#a2f">true</span> <span style="color:#b62;font-weight:700">\
</span></span></span><span style="display:flex"><span><span style="color:#b62;font-weight:700"/><span style="color:#080;font-style:italic"># required command line arguments for this feature</span>
</span></span><span style="display:flex"><span>--peer-ca-file<span style="color:#666">=</span>&lt;path to kube-apiserver CA cert&gt;
</span></span><span style="display:flex"><span>--proxy-client-cert-file<span style="color:#666">=</span>&lt;path to aggregator proxy cert&gt;,
</span></span><span style="display:flex"><span>--proxy-client-key-file<span style="color:#666">=</span>&lt;path to aggregator proxy key&gt;,
</span></span><span style="display:flex"><span>--requestheader-client-ca-file<span style="color:#666">=</span>&lt;path to aggregator CA cert&gt;,
</span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"># requestheader-allowed-names can be set to blank to allow any Common Name</span>
</span></span><span style="display:flex"><span>--requestheader-allowed-names<span style="color:#666">=</span>&lt;valid Common Names to verify proxy client cert against&gt;,
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"># optional flags for this feature</span>
</span></span><span style="display:flex"><span>--peer-advertise-ip<span style="color:#666">=</span><span style="color:#b44">`</span>IP of this kube-apiserver that should be used by peers to proxy requests<span style="color:#b44">`</span>
</span></span><span style="display:flex"><span>--peer-advertise-port<span style="color:#666">=</span><span style="color:#b44">`</span>port of this kube-apiserver that should be used by peers to proxy requests<span style="color:#b44">`</span>
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"># â€¦and other flags as usual</span>
</span></span></code></pre></div><h3 id="transport-and-authn">Proxy transport and authentication between API servers</h3><ul><li><p>The source kube-apiserver reuses the
<a href="/docs/tasks/extend-kubernetes/configure-aggregation-layer/#kubernetes-apiserver-client-authentication">existing APIserver client authentication flags</a>
<code>--proxy-client-cert-file</code> and <code>--proxy-client-key-file</code> to present its identity that
will be verified by its peer (the destination kube-apiserver). The destination API server
verifies that peer connection based on the configuration you specify using the
<code>--requestheader-client-ca-file</code> command line argument.</p></li><li><p>To authenticate the destination server's serving certs, you must configure a certificate
authority bundle by specifying the <code>--peer-ca-file</code> command line argument to the <strong>source</strong> API server.</p></li></ul><h3 id="configuration-for-peer-api-server-connectivity">Configuration for peer API server connectivity</h3><p>To set the network location of a kube-apiserver that peers will use to proxy requests, use the
<code>--peer-advertise-ip</code> and <code>--peer-advertise-port</code> command line arguments to kube-apiserver or specify
these fields in the API server configuration file.
If these flags are unspecified, peers will use the value from either <code>--advertise-address</code> or
<code>--bind-address</code> command line argument to the kube-apiserver.
If those too, are unset, the host's default interface is used.</p><h2 id="mixed-version-proxying">Mixed version proxying</h2><p>When you enable mixed version proxying, the <a href="/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/">aggregation layer</a>
loads a special filter that does the following:</p><ul><li>When a resource request reaches an API server that cannot serve that API
(either because it is at a version pre-dating the introduction of the API or the API is turned off on the API server)
the API server attempts to send the request to a peer API server that can serve the requested API.
It does so by identifying API groups / versions / resources that the local server doesn't recognise,
and tries to proxy those requests to a peer API server that is capable of handling the request.</li><li>If the peer API server fails to respond, the <em>source</em> API server responds with 503 ("Service Unavailable") error.</li></ul><h3 id="how-it-works-under-the-hood">How it works under the hood</h3><p>When an API Server receives a resource request, it first checks which API servers can
serve the requested resource. This check happens using the internal
<a href="/docs/reference/generated/kubernetes-api/v1.34/#storageversioncondition-v1alpha1-internal-apiserver-k8s-io"><code>StorageVersion</code> API</a>.</p><ul><li><p>If the resource is known to the API server that received the request
(for example, <code>GET /api/v1/pods/some-pod</code>), the request is handled locally.</p></li><li><p>If there is no internal <code>StorageVersion</code> object found for the requested resource
(for example, <code>GET /my-api/v1/my-resource</code>) and the configured APIService specifies proxying
to an extension API server, that proxying happens following the usual
<a href="/docs/tasks/extend-kubernetes/configure-aggregation-layer/">flow</a> for extension APIs.</p></li><li><p>If a valid internal <code>StorageVersion</code> object is found for the requested resource
(for example, <code>GET /batch/v1/jobs</code>) and the API server trying to handle the request
(the <em>handling API server</em>) has the <code>batch</code> API disabled, then the <em>handling API server</em>
fetches the peer API servers that do serve the relevant API group / version / resource
(<code>api/v1/batch</code> in this case) using the information in the fetched <code>StorageVersion</code> object.
The <em>handling API server</em> then proxies the request to one of the matching peer kube-apiservers
that are aware of the requested resource.</p><ul><li><p>If there is no peer known for that API group / version / resource, the handling API server
passes the request to its own handler chain which should eventually return a 404 ("Not Found") response.</p></li><li><p>If the handling API server has identified and selected a peer API server, but that peer fails
to respond (for reasons such as network connectivity issues, or a data race between the request
being received and a controller registering the peer's info into the control plane), then the handling
API server responds with a 503 ("Service Unavailable") error.</p></li></ul></li></ul></div>