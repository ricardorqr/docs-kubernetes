<div class="td-content"><h1 data-pagefind-weight="10">Images</h1><p>A container image represents binary data that encapsulates an application and all its
software dependencies. Container images are executable software bundles that can run
standalone and that make very well-defined assumptions about their runtime environment.</p><p>You typically create a container image of your application and push it to a registry
before referring to it in a <a class="glossary-tooltip" title="A Pod represents a set of running containers in your cluster." data-toggle="tooltip" data-placement="top" href="/docs/concepts/workloads/pods/" target="_blank" aria-label="Pod">Pod</a>.</p><p>This page provides an outline of the container image concept.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>If you are looking for the container images for a Kubernetes
release (such as v1.34, the latest minor release),
visit <a href="https://kubernetes.io/releases/download/">Download Kubernetes</a>.</div><h2 id="image-names">Image names</h2><p>Container images are usually given a name such as <code>pause</code>, <code>example/mycontainer</code>, or <code>kube-apiserver</code>.
Images can also include a registry hostname; for example: <code>fictional.registry.example/imagename</code>,
and possibly a port number as well; for example: <code>fictional.registry.example:10443/imagename</code>.</p><p>If you don't specify a registry hostname, Kubernetes assumes that you mean the <a href="https://hub.docker.com/">Docker public registry</a>.
You can change this behavior by setting a default image registry in the
<a href="/docs/setup/production-environment/container-runtimes/">container runtime</a> configuration.</p><p>After the image name part you can add a <em>tag</em> or <em>digest</em> (in the same way you would when using with commands
like <code>docker</code> or <code>podman</code>). Tags let you identify different versions of the same series of images.
Digests are a unique identifier for a specific version of an image. Digests are hashes of the image's content,
and are immutable. Tags can be moved to point to different images, but digests are fixed.</p><p>Image tags consist of lowercase and uppercase letters, digits, underscores (<code>_</code>),
periods (<code>.</code>), and dashes (<code>-</code>). A tag can be up to 128 characters long, and must
conform to the following regex pattern: <code>[a-zA-Z0-9_][a-zA-Z0-9._-]{0,127}</code>.
You can read more about it and find the validation regex in the
<a href="https://github.com/opencontainers/distribution-spec/blob/master/spec.md#workflow-categories">OCI Distribution Specification</a>.
If you don't specify a tag, Kubernetes assumes you mean the tag <code>latest</code>.</p><p>Image digests consists of a hash algorithm (such as <code>sha256</code>) and a hash value. For example:
<code>sha256:1ff6c18fbef2045af6b9c16bf034cc421a29027b800e4f9b68ae9b1cb3e9ae07</code>.
You can find more information about the digest format in the
<a href="https://github.com/opencontainers/image-spec/blob/master/descriptor.md#digests">OCI Image Specification</a>.</p><p>Some image name examples that Kubernetes can use are:</p><ul><li><code>busybox</code> — Image name only, no tag or digest. Kubernetes will use the Docker
public registry and latest tag. Equivalent to <code>docker.io/library/busybox:latest</code>.</li><li><code>busybox:1.32.0</code> — Image name with tag. Kubernetes will use the Docker
public registry. Equivalent to <code>docker.io/library/busybox:1.32.0</code>.</li><li><code>registry.k8s.io/pause:latest</code> — Image name with a custom registry and latest tag.</li><li><code>registry.k8s.io/pause:3.5</code> — Image name with a custom registry and non-latest tag.</li><li><code>registry.k8s.io/pause@sha256:1ff6c18fbef2045af6b9c16bf034cc421a29027b800e4f9b68ae9b1cb3e9ae07</code> —
Image name with digest.</li><li><code>registry.k8s.io/pause:3.5@sha256:1ff6c18fbef2045af6b9c16bf034cc421a29027b800e4f9b68ae9b1cb3e9ae07</code> —
Image name with tag and digest. Only the digest will be used for pulling.</li></ul><h2 id="updating-images">Updating images</h2><p>When you first create a <a class="glossary-tooltip" title="Manages a replicated application on your cluster." data-toggle="tooltip" data-placement="top" href="/docs/concepts/workloads/controllers/deployment/" target="_blank" aria-label="Deployment">Deployment</a>,
<a class="glossary-tooltip" title="A StatefulSet manages deployment and scaling of a set of Pods, with durable storage and persistent identifiers for each Pod." data-toggle="tooltip" data-placement="top" href="/docs/concepts/workloads/controllers/statefulset/" target="_blank" aria-label="StatefulSet">StatefulSet</a>, Pod, or other
object that includes a PodTemplate, and a pull policy was not explicitly specified,
then by default the pull policy of all containers in that Pod will be set to
<code>IfNotPresent</code>. This policy causes the
<a class="glossary-tooltip" title="An agent that runs on each node in the cluster. It makes sure that containers are running in a pod." data-toggle="tooltip" data-placement="top" href="/docs/reference/command-line-tools-reference/kubelet" target="_blank" aria-label="kubelet">kubelet</a> to skip pulling an
image if it already exists.</p><h3 id="image-pull-policy">Image pull policy</h3><p>The <code>imagePullPolicy</code> for a container and the tag of the image both affect <em>when</em> the
<a href="/docs/reference/command-line-tools-reference/kubelet/">kubelet</a> attempts to pull
(download) the specified image.</p><p>Here's a list of the values you can set for <code>imagePullPolicy</code> and the effects
these values have:</p><dl><dt><code>IfNotPresent</code></dt><dd>the image is pulled only if it is not already present locally.</dd><dt><code>Always</code></dt><dd>every time the kubelet launches a container, the kubelet queries the container
image registry to resolve the name to an image
<a href="https://docs.docker.com/engine/reference/commandline/pull/#pull-an-image-by-digest-immutable-identifier">digest</a>.
If the kubelet has a container image with that exact digest cached locally, the kubelet uses its
cached image; otherwise, the kubelet pulls the image with the resolved digest, and uses that image
to launch the container.</dd><dt><code>Never</code></dt><dd>the kubelet does not try fetching the image. If the image is somehow already present
locally, the kubelet attempts to start the container; otherwise, startup fails.
See <a href="#pre-pulled-images">pre-pulled images</a> for more details.</dd></dl><p>The caching semantics of the underlying image provider make even
<code>imagePullPolicy: Always</code> efficient, as long as the registry is reliably accessible.
Your container runtime can notice that the image layers already exist on the node
so that they don't need to be downloaded again.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4><p>You should avoid using the <code>:latest</code> tag when deploying containers in production as
it is harder to track which version of the image is running and more difficult to
roll back properly.</p><p>Instead, specify a meaningful tag such as <code>v1.42.0</code> and/or a digest.</p></div><p>To make sure the Pod always uses the same version of a container image, you can specify
the image's digest;
replace <code>&lt;image-name&gt;:&lt;tag&gt;</code> with <code>&lt;image-name&gt;@&lt;digest&gt;</code>
(for example, <code>image@sha256:45b23dee08af5e43a7fea6c4cf9c25ccf269ee113168c19722f87876677c5cb2</code>).</p><p>When using image tags, if the image registry were to change the code that the tag on that image
represents, you might end up with a mix of Pods running the old and new code. An image digest
uniquely identifies a specific version of the image, so Kubernetes runs the same code every time
it starts a container with that image name and digest specified. Specifying an image by digest
pins the code that you run so that a change at the registry cannot lead to that mix of versions.</p><p>There are third-party <a href="/docs/reference/access-authn-authz/admission-controllers/">admission controllers</a>
that mutate Pods (and PodTemplates) when they are created, so that the
running workload is defined based on an image digest rather than a tag.
That might be useful if you want to make sure that your entire workload is
running the same code no matter what tag changes happen at the registry.</p><h4 id="imagepullpolicy-defaulting">Default image pull policy</h4><p>When you (or a controller) submit a new Pod to the API server, your cluster sets the
<code>imagePullPolicy</code> field when specific conditions are met:</p><ul><li>if you omit the <code>imagePullPolicy</code> field, and you specify the digest for the
container image, the <code>imagePullPolicy</code> is automatically set to <code>IfNotPresent</code>.</li><li>if you omit the <code>imagePullPolicy</code> field, and the tag for the container image is
<code>:latest</code>, <code>imagePullPolicy</code> is automatically set to <code>Always</code>.</li><li>if you omit the <code>imagePullPolicy</code> field, and you don't specify the tag for the
container image, <code>imagePullPolicy</code> is automatically set to <code>Always</code>.</li><li>if you omit the <code>imagePullPolicy</code> field, and you specify a tag for the container
image that isn't <code>:latest</code>, the <code>imagePullPolicy</code> is automatically set to
<code>IfNotPresent</code>.</li></ul><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4><p>The value of <code>imagePullPolicy</code> of the container is always set when the object is
first <em>created</em>, and is not updated if the image's tag or digest later changes.</p><p>For example, if you create a Deployment with an image whose tag is <em>not</em>
<code>:latest</code>, and later update that Deployment's image to a <code>:latest</code> tag, the
<code>imagePullPolicy</code> field will <em>not</em> change to <code>Always</code>. You must manually change
the pull policy of any object after its initial creation.</p></div><h4 id="required-image-pull">Required image pull</h4><p>If you would like to always force a pull, you can do one of the following:</p><ul><li>Set the <code>imagePullPolicy</code> of the container to <code>Always</code>.</li><li>Omit the <code>imagePullPolicy</code> and use <code>:latest</code> as the tag for the image to use;
Kubernetes will set the policy to <code>Always</code> when you submit the Pod.</li><li>Omit the <code>imagePullPolicy</code> and the tag for the image to use;
Kubernetes will set the policy to <code>Always</code> when you submit the Pod.</li><li>Enable the <a href="/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages">AlwaysPullImages</a>
admission controller.</li></ul><h3 id="imagepullbackoff">ImagePullBackOff</h3><p>When a kubelet starts creating containers for a Pod using a container runtime,
it might be possible the container is in <a href="/docs/concepts/workloads/pods/pod-lifecycle/#container-state-waiting">Waiting</a>
state because of <code>ImagePullBackOff</code>.</p><p>The status <code>ImagePullBackOff</code> means that a container could not start because Kubernetes
could not pull a container image (for reasons such as invalid image name, or pulling
from a private registry without <code>imagePullSecret</code>). The <code>BackOff</code> part indicates
that Kubernetes will keep trying to pull the image, with an increasing back-off delay.</p><p>Kubernetes raises the delay between each attempt until it reaches a compiled-in limit,
which is 300 seconds (5 minutes).</p><h3 id="image-pull-per-runtime-class">Image pull per runtime class</h3><p><div class="feature-state-notice feature-alpha" title="Feature Gate: RuntimeClassInImageCriApi"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.29 [alpha]</code> (enabled by default: false)</div>Kubernetes includes alpha support for performing image pulls based on the RuntimeClass of a Pod.</p><p>If you enable the <code>RuntimeClassInImageCriApi</code> <a href="/docs/reference/command-line-tools-reference/feature-gates/">feature gate</a>,
the kubelet references container images by a tuple of image name and runtime handler
rather than just the image name or digest. Your
<a class="glossary-tooltip" title="The container runtime is the software that is responsible for running containers." data-toggle="tooltip" data-placement="top" href="/docs/setup/production-environment/container-runtimes" target="_blank" aria-label="container runtime">container runtime</a>
may adapt its behavior based on the selected runtime handler.
Pulling images based on runtime class is useful for VM-based containers, such as
Windows Hyper-V containers.</p><h2 id="serial-and-parallel-image-pulls">Serial and parallel image pulls</h2><p>By default, the kubelet pulls images serially. In other words, the kubelet sends
only one image pull request to the image service at a time. Other image pull
requests have to wait until the one being processed is complete.</p><p>Nodes make image pull decisions in isolation. Even when you use serialized image
pulls, two different nodes can pull the same image in parallel.</p><p>If you would like to enable parallel image pulls, you can set the field
<code>serializeImagePulls</code> to false in the <a href="/docs/reference/config-api/kubelet-config.v1beta1/">kubelet configuration</a>.
With <code>serializeImagePulls</code> set to false, image pull requests will be sent to the image service immediately,
and multiple images will be pulled at the same time.</p><p>When enabling parallel image pulls, ensure that the image service of your container
runtime can handle parallel image pulls.</p><p>The kubelet never pulls multiple images in parallel on behalf of one Pod. For example,
if you have a Pod that has an init container and an application container, the image
pulls for the two containers will not be parallelized. However, if you have two
Pods that use different images, and the parallel image pull feature is enabled,
the kubelet will pull the images in parallel on behalf of the two different Pods.</p><h3 id="maximum-parallel-image-pulls">Maximum parallel image pulls</h3><div class="feature-state-notice feature-beta"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.32 [beta]</code></div><p>When <code>serializeImagePulls</code> is set to false, the kubelet defaults to no limit on
the maximum number of images being pulled at the same time. If you would like to
limit the number of parallel image pulls, you can set the field <code>maxParallelImagePulls</code>
in the kubelet configuration. With <code>maxParallelImagePulls</code> set to <em>n</em>, only <em>n</em>
images can be pulled at the same time, and any image pull beyond <em>n</em> will have to
wait until at least one ongoing image pull is complete.</p><p>Limiting the number of parallel image pulls prevents image pulling from consuming
too much network bandwidth or disk I/O, when parallel image pulling is enabled.</p><p>You can set <code>maxParallelImagePulls</code> to a positive number that is greater than or
equal to 1. If you set <code>maxParallelImagePulls</code> to be greater than or equal to 2,
you must set <code>serializeImagePulls</code> to false. The kubelet will fail to start
with an invalid <code>maxParallelImagePulls</code> setting.</p><h2 id="multi-architecture-images-with-image-indexes">Multi-architecture images with image indexes</h2><p>As well as providing binary images, a container registry can also serve a
<a href="https://github.com/opencontainers/image-spec/blob/master/image-index.md">container image index</a>.
An image index can point to multiple <a href="https://github.com/opencontainers/image-spec/blob/master/manifest.md">image manifests</a>
for architecture-specific versions of a container. The idea is that you can have
a name for an image (for example: <code>pause</code>, <code>example/mycontainer</code>, <code>kube-apiserver</code>)
and allow different systems to fetch the right binary image for the machine
architecture they are using.</p><p>The Kubernetes project typically creates container images for its releases with
names that include the suffix <code>-$(ARCH)</code>. For backward compatibility, generate
older images with suffixes. For instance, an image named as <code>pause</code> would be a
multi-architecture image containing manifests for all supported architectures,
while <code>pause-amd64</code> would be a backward-compatible version for older configurations,
or for YAML files with hardcoded image names containing suffixes.</p><h2 id="using-a-private-registry">Using a private registry</h2><p>Private registries may require authentication to be able to discover and/or pull
images from them.
Credentials can be provided in several ways:</p><ul><li><p><a href="#specifying-imagepullsecrets-on-a-pod">Specifying <code>imagePullSecrets</code> when you define a Pod</a></p><p>Only Pods which provide their own keys can access the private registry.</p></li><li><p><a href="#configuring-nodes-to-authenticate-to-a-private-registry">Configuring Nodes to Authenticate to a Private Registry</a></p><ul><li>All Pods can read any configured private registries.</li><li>Requires node configuration by cluster administrator.</li></ul></li><li><p>Using a <em>kubelet credential provider</em> plugin to <a href="#kubelet-credential-provider">dynamically fetch credentials for private registries</a></p><p>The kubelet can be configured to use credential provider exec plugin for the
respective private registry.</p></li><li><p><a href="#pre-pulled-images">Pre-pulled Images</a></p><ul><li>All Pods can use any images cached on a node.</li><li>Requires root access to all nodes to set up.</li></ul></li><li><p>Vendor-specific or local extensions</p><p>If you're using a custom node configuration, you (or your cloud provider) can
implement your mechanism for authenticating the node to the container registry.</p></li></ul><p>These options are explained in more detail below.</p><h3 id="specifying-imagepullsecrets-on-a-pod">Specifying <code>imagePullSecrets</code> on a Pod</h3><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>This is the recommended approach to run containers based on images
in private registries.</div><p>Kubernetes supports specifying container image registry keys on a Pod.
All <code>imagePullSecrets</code> must be Secrets that exist in the same
<a class="glossary-tooltip" title="An abstraction used by Kubernetes to support isolation of groups of resources within a single cluster." data-toggle="tooltip" data-placement="top" href="/docs/concepts/overview/working-with-objects/namespaces" target="_blank" aria-label="Namespace">Namespace</a> as the
Pod. These Secrets must be of type <code>kubernetes.io/dockercfg</code> or <code>kubernetes.io/dockerconfigjson</code>.</p><h3 id="configuring-nodes-to-authenticate-to-a-private-registry">Configuring nodes to authenticate to a private registry</h3><p>Specific instructions for setting credentials depends on the container runtime and registry you
chose to use. You should refer to your solution's documentation for the most accurate information.</p><p>For an example of configuring a private container image registry, see the
<a href="/docs/tasks/configure-pod-container/pull-image-private-registry/">Pull an Image from a Private Registry</a>
task. That example uses a private registry in Docker Hub.</p><h3 id="kubelet-credential-provider">Kubelet credential provider for authenticated image pulls</h3><p>You can configure the kubelet to invoke a plugin binary to dynamically fetch
registry credentials for a container image. This is the most robust and versatile
way to fetch credentials for private registries, but also requires kubelet-level
configuration to enable.</p><p>This technique can be especially useful for running <a class="glossary-tooltip" title="A pod managed directly by the kubelet daemon on a specific node." data-toggle="tooltip" data-placement="top" href="/docs/tasks/configure-pod-container/static-pod/" target="_blank" aria-label="static Pods">static Pods</a>
that require container images hosted in a private registry.
Using a <a class="glossary-tooltip" title="Provides an identity for processes that run in a Pod." data-toggle="tooltip" data-placement="top" href="/docs/tasks/configure-pod-container/configure-service-account/" target="_blank" aria-label="ServiceAccount">ServiceAccount</a> or a
<a class="glossary-tooltip" title="Stores sensitive information, such as passwords, OAuth tokens, and ssh keys." data-toggle="tooltip" data-placement="top" href="/docs/concepts/configuration/secret/" target="_blank" aria-label="Secret">Secret</a> to provide private registry credentials
is not possible in the specification of a static Pod, because it <em>cannot</em>
have references to other API resources in its specification.</p><p>See <a href="/docs/tasks/administer-cluster/kubelet-credential-provider/">Configure a kubelet image credential provider</a> for more details.</p><h3 id="config-json">Interpretation of config.json</h3><p>The interpretation of <code>config.json</code> varies between the original Docker
implementation and the Kubernetes interpretation. In Docker, the <code>auths</code> keys
can only specify root URLs, whereas Kubernetes allows glob URLs as well as
prefix-matched paths. The only limitation is that glob patterns (<code>*</code>) have to
include the dot (<code>.</code>) for each subdomain. The amount of matched subdomains has
to be equal to the amount of glob patterns (<code>*.</code>), for example:</p><ul><li><code>*.kubernetes.io</code> will <em>not</em> match <code>kubernetes.io</code>, but will match
<code>abc.kubernetes.io</code>.</li><li><code>*.*.kubernetes.io</code> will <em>not</em> match <code>abc.kubernetes.io</code>, but will match
<code>abc.def.kubernetes.io</code>.</li><li><code>prefix.*.io</code> will match <code>prefix.kubernetes.io</code>.</li><li><code>*-good.kubernetes.io</code> will match <code>prefix-good.kubernetes.io</code>.</li></ul><p>This means that a <code>config.json</code> like this is valid:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json"><span style="display:flex"><span>{
</span></span><span style="display:flex"><span>    <span style="color:green;font-weight:700">"auths"</span>: {
</span></span><span style="display:flex"><span>        <span style="color:green;font-weight:700">"my-registry.example/images"</span>: { <span style="color:green;font-weight:700">"auth"</span>: <span style="color:#b44">"…"</span> },
</span></span><span style="display:flex"><span>        <span style="color:green;font-weight:700">"*.my-registry.example/images"</span>: { <span style="color:green;font-weight:700">"auth"</span>: <span style="color:#b44">"…"</span> }
</span></span><span style="display:flex"><span>    }
</span></span><span style="display:flex"><span>}
</span></span></code></pre></div><p>Image pull operations pass the credentials to the CRI container runtime for every
valid pattern. For example, the following container image names would match
successfully:</p><ul><li><code>my-registry.example/images</code></li><li><code>my-registry.example/images/my-image</code></li><li><code>my-registry.example/images/another-image</code></li><li><code>sub.my-registry.example/images/my-image</code></li></ul><p>However, these container image names would <em>not</em> match:</p><ul><li><code>a.sub.my-registry.example/images/my-image</code></li><li><code>a.b.sub.my-registry.example/images/my-image</code></li></ul><p>The kubelet performs image pulls sequentially for every found credential. This
means that multiple entries in <code>config.json</code> for different paths are possible, too:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json"><span style="display:flex"><span>{
</span></span><span style="display:flex"><span>    <span style="color:green;font-weight:700">"auths"</span>: {
</span></span><span style="display:flex"><span>        <span style="color:green;font-weight:700">"my-registry.example/images"</span>: {
</span></span><span style="display:flex"><span>            <span style="color:green;font-weight:700">"auth"</span>: <span style="color:#b44">"…"</span>
</span></span><span style="display:flex"><span>        },
</span></span><span style="display:flex"><span>        <span style="color:green;font-weight:700">"my-registry.example/images/subpath"</span>: {
</span></span><span style="display:flex"><span>            <span style="color:green;font-weight:700">"auth"</span>: <span style="color:#b44">"…"</span>
</span></span><span style="display:flex"><span>        }
</span></span><span style="display:flex"><span>    }
</span></span><span style="display:flex"><span>}
</span></span></code></pre></div><p>If now a container specifies an image <code>my-registry.example/images/subpath/my-image</code>
to be pulled, then the kubelet will try to download it using both authentication
sources if one of them fails.</p><h3 id="pre-pulled-images">Pre-pulled images</h3><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>This approach is suitable if you can control node configuration. It
will not work reliably if your cloud provider manages nodes and replaces
them automatically.</div><p>By default, the kubelet tries to pull each image from the specified registry.
However, if the <code>imagePullPolicy</code> property of the container is set to <code>IfNotPresent</code> or <code>Never</code>,
then a local image is used (preferentially or exclusively, respectively).</p><p>If you want to rely on pre-pulled images as a substitute for registry authentication,
you must ensure all nodes in the cluster have the same pre-pulled images.</p><p>This can be used to preload certain images for speed or as an alternative to
authenticating to a private registry.</p><p>Similar to the usage of the <a href="#kubelet-credential-provider">kubelet credential provider</a>,
pre-pulled images are also suitable for launching
<a class="glossary-tooltip" title="A pod managed directly by the kubelet daemon on a specific node." data-toggle="tooltip" data-placement="top" href="/docs/tasks/configure-pod-container/static-pod/" target="_blank" aria-label="static Pods">static Pods</a> that depend
on images hosted in a private registry.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4><div class="feature-state-notice feature-alpha" title="Feature Gate: KubeletEnsureSecretPulledImages"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.33 [alpha]</code> (enabled by default: false)</div><p>Access to pre-pulled images may be authorized according to <a href="#ensureimagepullcredentialverification">image pull credential verification</a>.</p></div><h4 id="ensureimagepullcredentialverification">Ensure image pull credential verification</h4><div class="feature-state-notice feature-alpha" title="Feature Gate: KubeletEnsureSecretPulledImages"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.33 [alpha]</code> (enabled by default: false)</div><p>If the <code>KubeletEnsureSecretPulledImages</code> feature gate is enabled for your cluster,
Kubernetes will validate image credentials for every image that requires credentials
to be pulled, even if that image is already present on the node. This validation
ensures that images in a Pod request which have not been successfully pulled
with the provided credentials must re-pull the images from the registry.
Additionally, image pulls that re-use the same credentials
which previously resulted in a successful image pull will not need to re-pull from
the registry and are instead validated locally without accessing the registry
(provided the image is available locally).
This is controlled by the<code>imagePullCredentialsVerificationPolicy</code> field in the
<a href="/docs/reference/config-api/kubelet-config.v1beta1/#kubelet-config-k8s-io-v1beta1-ImagePullCredentialsVerificationPolicy">Kubelet configuration</a>.</p><p>This configuration controls when image pull credentials must be verified if the
image is already present on the node:</p><ul><li><code>NeverVerify</code>: Mimics the behavior of having this feature gate disabled.
If the image is present locally, image pull credentials are not verified.</li><li><code>NeverVerifyPreloadedImages</code>: Images pulled outside the kubelet are not verified,
but all other images will have their credentials verified. This is the default behavior.</li><li><code>NeverVerifyAllowListedImages</code>: Images pulled outside the kubelet and mentioned within the
<code>preloadedImagesVerificationAllowlist</code> specified in the kubelet config are not verified.</li><li><code>AlwaysVerify</code>: All images will have their credentials verified
before they can be used.</li></ul><p>This verification applies to <a href="#pre-pulled-images">pre-pulled images</a>,
images pulled using node-wide secrets, and images pulled using Pod-level secrets.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>In the case of credential rotation, the credentials previously used to pull the image
will continue to verify without the need to access the registry. New or rotated credentials
will require the image to be re-pulled from the registry.</div><h4 id="creating-a-secret-with-a-docker-config">Creating a Secret with a Docker config</h4><p>You need to know the username, registry password and client email address for authenticating
to the registry, as well as its hostname.
Run the following command, substituting placeholders with the appropriate values:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl create secret docker-registry &lt;name&gt; <span style="color:#b62;font-weight:700">\
</span></span></span><span style="display:flex"><span><span style="color:#b62;font-weight:700"/>  --docker-server<span style="color:#666">=</span>&lt;docker-registry-server&gt; <span style="color:#b62;font-weight:700">\
</span></span></span><span style="display:flex"><span><span style="color:#b62;font-weight:700"/>  --docker-username<span style="color:#666">=</span>&lt;docker-user&gt; <span style="color:#b62;font-weight:700">\
</span></span></span><span style="display:flex"><span><span style="color:#b62;font-weight:700"/>  --docker-password<span style="color:#666">=</span>&lt;docker-password&gt; <span style="color:#b62;font-weight:700">\
</span></span></span><span style="display:flex"><span><span style="color:#b62;font-weight:700"/>  --docker-email<span style="color:#666">=</span>&lt;docker-email&gt;
</span></span></code></pre></div><p>If you already have a Docker credentials file then, rather than using the above
command, you can import the credentials file as a Kubernetes
<a class="glossary-tooltip" title="Stores sensitive information, such as passwords, OAuth tokens, and ssh keys." data-toggle="tooltip" data-placement="top" href="/docs/concepts/configuration/secret/" target="_blank" aria-label="Secret">Secret</a>.
<a href="/docs/tasks/configure-pod-container/pull-image-private-registry/#registry-secret-existing-credentials">Create a Secret based on existing Docker credentials</a>
explains how to set this up.</p><p>This is particularly useful if you are using multiple private container
registries, as <code>kubectl create secret docker-registry</code> creates a Secret that
only works with a single private registry.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>Pods can only reference image pull secrets in their own namespace,
so this process needs to be done one time per namespace.</div><h4 id="referring-to-imagepullsecrets-on-a-pod">Referring to <code>imagePullSecrets</code> on a Pod</h4><p>Now, you can create pods which reference that secret by adding the <code>imagePullSecrets</code>
section to a Pod definition. Each item in the <code>imagePullSecrets</code> array can only
reference one Secret in the same namespace.</p><p>For example:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>cat <span style="color:#b44">&lt;&lt;EOF &gt; pod.yaml
</span></span></span><span style="display:flex"><span><span style="color:#b44">apiVersion: v1
</span></span></span><span style="display:flex"><span><span style="color:#b44">kind: Pod
</span></span></span><span style="display:flex"><span><span style="color:#b44">metadata:
</span></span></span><span style="display:flex"><span><span style="color:#b44">  name: foo
</span></span></span><span style="display:flex"><span><span style="color:#b44">  namespace: awesomeapps
</span></span></span><span style="display:flex"><span><span style="color:#b44">spec:
</span></span></span><span style="display:flex"><span><span style="color:#b44">  containers:
</span></span></span><span style="display:flex"><span><span style="color:#b44">    - name: foo
</span></span></span><span style="display:flex"><span><span style="color:#b44">      image: janedoe/awesomeapp:v1
</span></span></span><span style="display:flex"><span><span style="color:#b44">  imagePullSecrets:
</span></span></span><span style="display:flex"><span><span style="color:#b44">    - name: myregistrykey
</span></span></span><span style="display:flex"><span><span style="color:#b44">EOF</span>
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span>cat <span style="color:#b44">&lt;&lt;EOF &gt;&gt; ./kustomization.yaml
</span></span></span><span style="display:flex"><span><span style="color:#b44">resources:
</span></span></span><span style="display:flex"><span><span style="color:#b44">- pod.yaml
</span></span></span><span style="display:flex"><span><span style="color:#b44">EOF</span>
</span></span></code></pre></div><p>This needs to be done for each Pod that is using a private registry.</p><p>However, you can automate this process by specifying the <code>imagePullSecrets</code> section
in a <a href="/docs/tasks/configure-pod-container/configure-service-account/">ServiceAccount</a>
resource. See <a href="/docs/tasks/configure-pod-container/configure-service-account/#add-imagepullsecrets-to-a-service-account">Add ImagePullSecrets to a Service Account</a>
for detailed instructions.</p><p>You can use this in conjunction with a per-node <code>.docker/config.json</code>. The credentials
will be merged.</p><h2 id="use-cases">Use cases</h2><p>There are a number of solutions for configuring private registries. Here are some
common use cases and suggested solutions.</p><ol><li>Cluster running only non-proprietary (e.g. open-source) images. No need to hide images.<ul><li>Use public images from a public registry<ul><li>No configuration required.</li><li>Some cloud providers automatically cache or mirror public images, which improves
availability and reduces the time to pull images.</li></ul></li></ul></li><li>Cluster running some proprietary images which should be hidden to those outside the company, but
visible to all cluster users.<ul><li>Use a hosted private registry<ul><li>Manual configuration may be required on the nodes that need to access to private registry.</li></ul></li><li>Or, run an internal private registry behind your firewall with open read access.<ul><li>No Kubernetes configuration is required.</li></ul></li><li>Use a hosted container image registry service that controls image access<ul><li>It will work better with Node autoscaling than manual node configuration.</li></ul></li><li>Or, on a cluster where changing the node configuration is inconvenient, use <code>imagePullSecrets</code>.</li></ul></li><li>Cluster with proprietary images, a few of which require stricter access control.<ul><li>Ensure <a href="/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages">AlwaysPullImages admission controller</a>
is active. Otherwise, all Pods potentially have access to all images.</li><li>Move sensitive data into a Secret resource, instead of packaging it in an image.</li></ul></li><li>A multi-tenant cluster where each tenant needs own private registry.<ul><li>Ensure <a href="/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages">AlwaysPullImages admission controller</a>
is active. Otherwise, all Pods of all tenants potentially have access to all images.</li><li>Run a private registry with authorization required.</li><li>Generate registry credentials for each tenant, store into a Secret, and propagate
the Secret to every tenant namespace.</li><li>The tenant then adds that Secret to <code>imagePullSecrets</code> of each namespace.</li></ul></li></ol><p>If you need access to multiple registries, you can create one Secret per registry.</p><h2 id="legacy-built-in-kubelet-credential-provider">Legacy built-in kubelet credential provider</h2><p>In older versions of Kubernetes, the kubelet had a direct integration with cloud
provider credentials. This provided the ability to dynamically fetch credentials
for image registries.</p><p>There were three built-in implementations of the kubelet credential provider
integration: ACR (Azure Container Registry), ECR (Elastic Container Registry),
and GCR (Google Container Registry).</p><p>Starting with version 1.26 of Kubernetes, the legacy mechanism has been removed,
so you would need to either:</p><ul><li>configure a kubelet image credential provider on each node; or</li><li>specify image pull credentials using <code>imagePullSecrets</code> and at least one Secret.</li></ul><h2 id="what-s-next">What's next</h2><ul><li>Read the <a href="https://github.com/opencontainers/image-spec/blob/main/manifest.md">OCI Image Manifest Specification</a>.</li><li>Learn about <a href="/docs/concepts/architecture/garbage-collection/#container-image-garbage-collection">container image garbage collection</a>.</li><li>Learn more about <a href="/docs/tasks/configure-pod-container/pull-image-private-registry/">pulling an Image from a Private Registry</a>.</li></ul></div>