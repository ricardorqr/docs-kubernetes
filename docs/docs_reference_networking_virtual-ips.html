<div class="td-content"><h1 data-pagefind-weight="10">Virtual IPs and Service Proxies</h1><p>Every <a class="glossary-tooltip" title="A node is a worker machine in Kubernetes." data-toggle="tooltip" data-placement="top" href="/docs/concepts/architecture/nodes/" target="_blank" aria-label="node">node</a> in a Kubernetes
<a class="glossary-tooltip" title="A set of worker machines, called nodes, that run containerized applications. Every cluster has at least one worker node." data-toggle="tooltip" data-placement="top" href="/docs/reference/glossary/?all=true#term-cluster" target="_blank" aria-label="cluster">cluster</a> runs a
<a href="/docs/reference/command-line-tools-reference/kube-proxy/">kube-proxy</a>
(unless you have deployed your own alternative component in place of <code>kube-proxy</code>).</p><p>The <code>kube-proxy</code> component is responsible for implementing a <em>virtual IP</em>
mechanism for <a class="glossary-tooltip" title="A way to expose an application running on a set of Pods as a network service." data-toggle="tooltip" data-placement="top" href="/docs/concepts/services-networking/service/" target="_blank" aria-label="Services">Services</a>
of <code>type</code> other than
<a href="/docs/concepts/services-networking/service/#externalname"><code>ExternalName</code></a>.
Each instance of kube-proxy watches the Kubernetes
<a class="glossary-tooltip" title="The container orchestration layer that exposes the API and interfaces to define, deploy, and manage the lifecycle of containers." data-toggle="tooltip" data-placement="top" href="/docs/reference/glossary/?all=true#term-control-plane" target="_blank" aria-label="control plane">control plane</a>
for the addition and removal of Service and <a class="glossary-tooltip" title="EndpointSlices track the IP addresses of Pods for Services." data-toggle="tooltip" data-placement="top" href="/docs/concepts/services-networking/endpoint-slices/" target="_blank" aria-label="EndpointSlice">EndpointSlice</a>
<a class="glossary-tooltip" title="An entity in the Kubernetes system, representing part of the state of your cluster." data-toggle="tooltip" data-placement="top" href="/docs/concepts/overview/working-with-objects/#kubernetes-objects" target="_blank" aria-label="objects">objects</a>. For each Service, kube-proxy
calls appropriate APIs (depending on the kube-proxy mode) to configure
the node to capture traffic to the Service's <code>clusterIP</code> and <code>port</code>,
and redirect that traffic to one of the Service's endpoints
(usually a Pod, but possibly an arbitrary user-provided IP address). A control
loop ensures that the rules on each node are reliably synchronized with
the Service and EndpointSlice state as indicated by the API server.</p><figure class="diagram-medium"><img src="/images/docs/services-iptables-overview.svg"/><figcaption><h4>Virtual IP mechanism for Services, using iptables mode</h4></figcaption></figure><p>A question that pops up every now and then is why Kubernetes relies on
proxying to forward inbound traffic to backends. What about other
approaches? For example, would it be possible to configure DNS records that
have multiple A values (or AAAA for IPv6), and rely on round-robin name
resolution?</p><p>There are a few reasons for using proxying for Services:</p><ul><li>There is a long history of DNS implementations not respecting record TTLs,
and caching the results of name lookups after they should have expired.</li><li>Some apps do DNS lookups only once and cache the results indefinitely.</li><li>Even if apps and libraries did proper re-resolution, the low or zero TTLs
on the DNS records could impose a high load on DNS that then becomes
difficult to manage.</li></ul><p>Later in this page you can read about how various kube-proxy implementations work.
Overall, you should note that, when running <code>kube-proxy</code>, kernel level rules may be modified
(for example, iptables rules might get created), which won't get cleaned up, in some
cases until you reboot. Thus, running kube-proxy is something that should only be done
by an administrator who understands the consequences of having a low level, privileged
network proxying service on a computer. Although the <code>kube-proxy</code> executable supports a
<code>cleanup</code> function, this function is not an official feature and thus is only available
to use as-is.</p><p><a id="example"/>Some of the details in this reference refer to an example: the backend
<a class="glossary-tooltip" title="A Pod represents a set of running containers in your cluster." data-toggle="tooltip" data-placement="top" href="/docs/concepts/workloads/pods/" target="_blank" aria-label="Pods">Pods</a> for a stateless
image-processing workloads, running with
three replicas. Those replicas are
fungible—frontends do not care which backend they use. While the actual Pods that
compose the backend set may change, the frontend clients should not need to be aware of that,
nor should they need to keep track of the set of backends themselves.</p><h2 id="proxy-modes">Proxy modes</h2><p>The kube-proxy starts up in different modes, which are determined by its configuration.</p><p>On Linux nodes, the available modes for kube-proxy are:</p><dl><dt><a href="#proxy-mode-iptables"><code>iptables</code></a></dt><dd>A mode where the kube-proxy configures packet forwarding rules using iptables.</dd><dt><a href="#proxy-mode-ipvs"><code>ipvs</code></a></dt><dd>a mode where the kube-proxy configures packet forwarding rules using ipvs.</dd><dt><a href="#proxy-mode-nftables"><code>nftables</code></a></dt><dd>a mode where the kube-proxy configures packet forwarding rules using nftables.</dd></dl><p>There is only one mode available for kube-proxy on Windows:</p><dl><dt><a href="#proxy-mode-kernelspace"><code>kernelspace</code></a></dt><dd>a mode where the kube-proxy configures packet forwarding rules in the Windows kernel</dd></dl><h3 id="proxy-mode-iptables"><code>iptables</code> proxy mode</h3><p><em>This proxy mode is only available on Linux nodes.</em></p><p>In this mode, kube-proxy configures packet forwarding rules using the
iptables API of the kernel netfilter subsystem. For each endpoint, it
installs iptables rules which, by default, select a backend Pod at
random.</p><h4 id="packet-processing-iptables">Example</h4><p>As an example, consider the image processing application described <a href="#example">earlier</a>
in the page.
When the backend Service is created, the Kubernetes control plane assigns a virtual
IP address, for example 10.0.0.1. For this example, assume that the
Service port is 1234.
All of the kube-proxy instances in the cluster observe the creation of the new
Service.</p><p>When kube-proxy on a node sees a new Service, it installs a series of iptables rules
which redirect from the virtual IP address to more iptables rules, defined per Service.
The per-Service rules link to further rules for each backend endpoint, and the per-
endpoint rules redirect traffic (using destination NAT) to the backends.</p><p>When a client connects to the Service's virtual IP address the iptables rule kicks in.
A backend is chosen (either based on session affinity or randomly) and packets are
redirected to the backend without rewriting the client IP address.</p><p>This same basic flow executes when traffic comes in through a <code>type: NodePort</code> Service, or
through a load-balancer, though in those cases the client IP address does get altered.</p><h4 id="optimizing-iptables-mode-performance">Optimizing iptables mode performance</h4><p>In iptables mode, kube-proxy creates a few iptables rules for every
Service, and a few iptables rules for each endpoint IP address. In
clusters with tens of thousands of Pods and Services, this means tens
of thousands of iptables rules, and kube-proxy may take a long time to update the rules
in the kernel when Services (or their EndpointSlices) change. You can adjust the syncing
behavior of kube-proxy via options in the
<a href="/docs/reference/config-api/kube-proxy-config.v1alpha1/#kubeproxy-config-k8s-io-v1alpha1-KubeProxyIPTablesConfiguration"><code>iptables</code> section</a>
of the kube-proxy <a href="/docs/reference/config-api/kube-proxy-config.v1alpha1/">configuration file</a>
(which you specify via <code>kube-proxy --config &lt;path&gt;</code>):</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:#00f;font-weight:700">...</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">iptables</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">minSyncPeriod</span>:<span style="color:#bbb"> </span>1s<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">syncPeriod</span>:<span style="color:#bbb"> </span>30s<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:#00f;font-weight:700">...</span><span style="color:#bbb">
</span></span></span></code></pre></div><h5 id="minsyncperiod"><code>minSyncPeriod</code></h5><p>The <code>minSyncPeriod</code> parameter sets the minimum duration between
attempts to resynchronize iptables rules with the kernel. If it is
<code>0s</code>, then kube-proxy will always immediately synchronize the rules
every time any Service or EndpointSlice changes. This works fine in very
small clusters, but it results in a lot of redundant work when lots of
things change in a small time period. For example, if you have a
Service backed by a <a class="glossary-tooltip" title="Manages a replicated application on your cluster." data-toggle="tooltip" data-placement="top" href="/docs/concepts/workloads/controllers/deployment/" target="_blank" aria-label="Deployment">Deployment</a>
with 100 pods, and you delete the
Deployment, then with <code>minSyncPeriod: 0s</code>, kube-proxy would end up
removing the Service's endpoints from the iptables rules one by one,
resulting in a total of 100 updates. With a larger <code>minSyncPeriod</code>, multiple
Pod deletion events would get aggregated together, so kube-proxy might
instead end up making, say, 5 updates, each removing 20 endpoints,
which will be much more efficient in terms of CPU, and result in the
full set of changes being synchronized faster.</p><p>The larger the value of <code>minSyncPeriod</code>, the more work that can be
aggregated, but the downside is that each individual change may end up
waiting up to the full <code>minSyncPeriod</code> before being processed, meaning
that the iptables rules spend more time being out-of-sync with the
current API server state.</p><p>The default value of <code>1s</code> should work well in most clusters, but in very
large clusters it may be necessary to set it to a larger value.
Especially, if kube-proxy's <code>sync_proxy_rules_duration_seconds</code> metric
indicates an average time much larger than 1 second, then bumping up
<code>minSyncPeriod</code> may make updates more efficient.</p><h5 id="minimize-iptables-restore">Updating legacy <code>minSyncPeriod</code> configuration</h5><p>Older versions of kube-proxy updated all the rules for all Services on
every sync; this led to performance issues (update lag) in large
clusters, and the recommended solution was to set a larger
<code>minSyncPeriod</code>. Since Kubernetes v1.28, the iptables mode of
kube-proxy uses a more minimal approach, only making updates where
Services or EndpointSlices have actually changed.</p><p>If you were previously overriding <code>minSyncPeriod</code>, you should try
removing that override and letting kube-proxy use the default value
(<code>1s</code>) or at least a smaller value than you were using before upgrading.</p><p>If you are not running kube-proxy from Kubernetes 1.34, check
the behavior and associated advice for the version that you are actually running.</p><h5 id="syncperiod"><code>syncPeriod</code></h5><p>The <code>syncPeriod</code> parameter controls a handful of synchronization
operations that are not directly related to changes in individual
Services and EndpointSlices. In particular, it controls how quickly
kube-proxy notices if an external component has interfered with
kube-proxy's iptables rules. In large clusters, kube-proxy also only
performs certain cleanup operations once every <code>syncPeriod</code> to avoid
unnecessary work.</p><p>For the most part, increasing <code>syncPeriod</code> is not expected to have much
impact on performance, but in the past, it was sometimes useful to set
it to a very large value (eg, <code>1h</code>). This is no longer recommended,
and is likely to hurt functionality more than it improves performance.</p><h3 id="proxy-mode-ipvs">IPVS proxy mode</h3><p><em>This proxy mode is only available on Linux nodes.</em></p><p>In <code>ipvs</code> mode, kube-proxy uses the kernel IPVS and iptables APIs to
create rules to redirect traffic from Service IPs to endpoint IPs.</p><p>The IPVS proxy mode is based on netfilter hook function that is similar to
iptables mode, but uses a hash table as the underlying data structure and works
in the kernel space.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4><p>The <code>ipvs</code> proxy mode was an experiment in providing a Linux
kube-proxy backend with better rule-synchronizing performance and
higher network-traffic throughput than the <code>iptables</code> mode. While it
succeeded in those goals, the kernel IPVS API turned out to be a bad
match for the Kubernetes Services API, and the <code>ipvs</code> backend was
never able to implement all of the edge cases of Kubernetes Service
functionality correctly. At some point in the future, it is expected
to be formally deprecated as a feature.</p><p>The <code>nftables</code> proxy mode (described below) is essentially a
replacement for both the <code>iptables</code> and <code>ipvs</code> modes, with better
performance than either of them, and is recommended as a replacement
for <code>ipvs</code>. If you are deploying onto Linux systems that are too old
to run the <code>nftables</code> proxy mode, you should also consider trying the
<code>iptables</code> mode rather than <code>ipvs</code>, since the performance of
<code>iptables</code> mode has improved greatly since the <code>ipvs</code> mode was first
introduced.</p></div><p>IPVS provides more options for balancing traffic to backend Pods;
these are:</p><ul><li><p><code>rr</code> (Round Robin): Traffic is equally distributed amongst the backing servers.</p></li><li><p><code>wrr</code> (Weighted Round Robin): Traffic is routed to the backing servers based on
the weights of the servers. Servers with higher weights receive new connections
and get more requests than servers with lower weights.</p></li><li><p><code>lc</code> (Least Connection): More traffic is assigned to servers with fewer active connections.</p></li><li><p><code>wlc</code> (Weighted Least Connection): More traffic is routed to servers with fewer connections
relative to their weights, that is, connections divided by weight.</p></li><li><p><code>lblc</code> (Locality based Least Connection): Traffic for the same IP address is sent to the
same backing server if the server is not overloaded and available; otherwise the traffic
is sent to servers with fewer connections, and keep it for future assignment.</p></li><li><p><code>lblcr</code> (Locality Based Least Connection with Replication): Traffic for the same IP
address is sent to the server with least connections. If all the backing servers are
overloaded, it picks up one with fewer connections and adds it to the target set.
If the target set has not changed for the specified time, the server with the highest load
is removed from the set, in order to avoid a high degree of replication.</p></li><li><p><code>sh</code> (Source Hashing): Traffic is sent to a backing server by looking up a statically
assigned hash table based on the source IP addresses.</p></li><li><p><code>dh</code> (Destination Hashing): Traffic is sent to a backing server by looking up a
statically assigned hash table based on their destination addresses.</p></li><li><p><code>sed</code> (Shortest Expected Delay): Traffic forwarded to a backing server with the shortest
expected delay. The expected delay is <code>(C + 1) / U</code> if sent to a server, where <code>C</code> is
the number of connections on the server and <code>U</code> is the fixed service rate (weight) of
the server.</p></li><li><p><code>nq</code> (Never Queue): Traffic is sent to an idle server if there is one, instead of
waiting for a fast one; if all servers are busy, the algorithm falls back to the <code>sed</code>
behavior.</p></li><li><p><code>mh</code> (Maglev Hashing): Assigns incoming jobs based on
<a href="https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/44824.pdf">Google's Maglev hashing algorithm</a>,
This scheduler has two flags: <code>mh-fallback</code>, which enables fallback to a different
server if the selected server is unavailable, and <code>mh-port</code>, which adds the source port number to
the hash computation. When using <code>mh</code>, kube-proxy always sets the <code>mh-port</code> flag and does not
enable the <code>mh-fallback</code> flag.
In proxy-mode=ipvs <code>mh</code> will work as source-hashing (<code>sh</code>), but with ports.</p></li></ul><p>These scheduling algorithms are configured through the
<a href="/docs/reference/config-api/kube-proxy-config.v1alpha1/#kubeproxy-config-k8s-io-v1alpha1-KubeProxyIPVSConfiguration"><code>ipvs.scheduler</code></a>
field in the kube-proxy configuration.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4><p>To run kube-proxy in IPVS mode, you must make IPVS available on
the node before starting kube-proxy.</p><p>When kube-proxy starts in IPVS proxy mode, it verifies whether IPVS
kernel modules are available. If the IPVS kernel modules are not detected, then kube-proxy
exits with an error.</p></div><figure class="diagram-medium"><img src="/images/docs/services-ipvs-overview.svg"/><figcaption><h4>Virtual IP address mechanism for Services, using IPVS mode</h4></figcaption></figure><h3 id="proxy-mode-nftables"><code>nftables</code> proxy mode</h3><div class="feature-state-notice feature-stable" title="Feature Gate: NFTablesProxyMode"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.33 [stable]</code> (enabled by default: true)</div><p><em>This proxy mode is only available on Linux nodes, and requires kernel
5.13 or later.</em></p><p>In this mode, kube-proxy configures packet forwarding rules using the
nftables API of the kernel netfilter subsystem. For each endpoint, it
installs nftables rules which, by default, select a backend Pod at
random.</p><p>The nftables API is the successor to the iptables API and is designed
to provide better performance and scalability than iptables. The
<code>nftables</code> proxy mode is able to process changes to service endpoints
faster and more efficiently than the <code>iptables</code> mode, and is also able
to more efficiently process packets in the kernel (though this only
becomes noticeable in clusters with tens of thousands of services).</p><p>As of Kubernetes 1.34, the <code>nftables</code> mode is
still relatively new, and may not be compatible with all network
plugins; consult the documentation for your network plugin.</p><h4 id="migrating-from-iptables-mode-to-nftables">Migrating from <code>iptables</code> mode to <code>nftables</code></h4><p>Users who want to switch from the default <code>iptables</code> mode to the
<code>nftables</code> mode should be aware that some features work slightly
differently the <code>nftables</code> mode:</p><ul><li><p><strong>NodePort interfaces</strong>: In <code>iptables</code> mode, by default,
<a href="/docs/concepts/services-networking/service/#type-nodeport">NodePort services</a>
are reachable on all local IP addresses. This is usually not what
users want, so the <code>nftables</code> mode defaults to
<code>--nodeport-addresses primary</code>, meaning Services using <code>type: NodePort</code> are only
reachable on the node's primary IPv4 and/or IPv6 addresses. You can
override this by specifying an explicit value for that option:
e.g., <code>--nodeport-addresses 0.0.0.0/0</code> to listen on all (local)
IPv4 IPs.</p></li><li><p><code>type: NodePort</code> <strong>Services on <code>127.0.0.1</code></strong>: In <code>iptables</code> mode, if the
<code>--nodeport-addresses</code> range includes <code>127.0.0.1</code> (and the option
<code>--iptables-localhost-nodeports false</code> option is not passed), then
Services of <code>type: NodePort</code> are reachable even on "localhost" (<code>127.0.0.1</code>).
In <code>nftables</code> mode (and <code>ipvs</code> mode), this will not work. If you
are not sure if you are depending on this functionality, you can
check kube-proxy's
<code>iptables_localhost_nodeports_accepted_packets_total</code> metric; if it
is non-0, that means that some client has connected to a <code>type: NodePort</code>
Service via localhost/loopback.</p></li><li><p><strong>NodePort interaction with firewalls</strong>: The <code>iptables</code> mode of
kube-proxy tries to be compatible with overly-aggressive firewalls;
for each <code>type: NodePort</code> service, it will add rules to accept inbound
traffic on that port, in case that traffic would otherwise be
blocked by a firewall. This approach will not work with firewalls
based on nftables, so kube-proxy's <code>nftables</code> mode does not do
anything here; if you have a local firewall, you must ensure that
it is properly configured to allow Kubernetes traffic through
(e.g., by allowing inbound traffic on the entire NodePort range).</p></li><li><p><strong>Conntrack bug workarounds</strong>: Linux kernels prior to 6.1 have a
bug that can result in long-lived TCP connections to service IPs
being closed with the error "Connection reset by peer". The
<code>iptables</code> mode of kube-proxy installs a workaround for this bug,
but this workaround was later found to cause other problems in some
clusters. The <code>nftables</code> mode does not install any workaround by
default, but you can check kube-proxy's
<code>iptables_ct_state_invalid_dropped_packets_total</code> metric to see if
your cluster is depending on the workaround, and if so, you can run
kube-proxy with the option <code>--conntrack-tcp-be-liberal</code> to work
around the problem in <code>nftables</code> mode.</p></li></ul><h3 id="proxy-mode-kernelspace"><code>kernelspace</code> proxy mode</h3><p><em>This proxy mode is only available on Windows nodes.</em></p><p>The kube-proxy configures packet filtering rules in the Windows <em>Virtual Filtering Platform</em> (VFP),
an extension to Windows vSwitch. These rules process encapsulated packets within the node-level
virtual networks, and rewrite packets so that the destination IP address (and layer 2 information)
is correct for getting the packet routed to the correct destination.
The Windows VFP is analogous to tools such as Linux <code>nftables</code> or <code>iptables</code>. The Windows VFP extends
the <em>Hyper-V Switch</em>, which was initially implemented to support virtual machine networking.</p><p>When a Pod on a node sends traffic to a virtual IP address, and the kube-proxy selects a Pod on
a different node as the load balancing target, the <code>kernelspace</code> proxy mode rewrites that packet
to be destined to the target backend Pod. The Windows <em>Host Networking Service</em> (HNS) ensures that
packet rewriting rules are configured so that the return traffic appears to come from the virtual
IP address and not the specific backend Pod.</p><h4 id="windows-direct-server-return">Direct server return for <code>kernelspace</code> mode</h4><div class="feature-state-notice feature-stable" title="Feature Gate: WinDSR"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.34 [stable]</code> (enabled by default: true)</div><p>As an alternative to the basic operation, a node that hosts the backend Pod for a Service can
apply the packet rewriting directly, rather than placing this burden on the node where the client
Pod is running. This is called <em>direct server return</em>.</p><p>To use this, you must run kube-proxy with the <code>--enable-dsr</code> command line argument <strong>and</strong>
enable the <code>WinDSR</code> <a href="/docs/reference/command-line-tools-reference/feature-gates/">feature gate</a>.</p><p>Direct server return also optimizes the case for Pod return traffic even when both Pods
are running on the same node.</p><h2 id="session-affinity">Session affinity</h2><p>In these proxy models, the traffic bound for the Service's IP:Port is
proxied to an appropriate backend without the clients knowing anything
about Kubernetes or Services or Pods.</p><p>If you want to make sure that connections from a particular client
are passed to the same Pod each time, you can select the session affinity based
on the client's IP addresses by setting <code>.spec.sessionAffinity</code> to <code>ClientIP</code>
for a Service (the default is <code>None</code>).</p><h3 id="session-stickiness-timeout">Session stickiness timeout</h3><p>You can also set the maximum session sticky time by setting
<code>.spec.sessionAffinityConfig.clientIP.timeoutSeconds</code> appropriately for a Service.
(the default value is 10800, which works out to be 3 hours).</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>On Windows, setting the maximum session sticky time for Services is not supported.</div><h2 id="ip-address-assignment-to-services">IP address assignment to Services</h2><p>Unlike Pod IP addresses, which actually route to a fixed destination,
Service IPs are not actually answered by a single host. Instead, kube-proxy
uses packet processing logic (such as Linux iptables) to define <em>virtual</em> IP
addresses which are transparently redirected as needed.</p><p>When clients connect to the VIP, their traffic is automatically transported to an
appropriate endpoint. The environment variables and DNS for Services are actually
populated in terms of the Service's virtual IP address (and port).</p><h3 id="avoiding-collisions">Avoiding collisions</h3><p>One of the primary philosophies of Kubernetes is that you should not be
exposed to situations that could cause your actions to fail through no fault
of your own. For the design of the Service resource, this means not making
you choose your own IP address if that choice might collide with
someone else's choice. That is an isolation failure.</p><p>In order to allow you to choose an IP address for your Services, we must
ensure that no two Services can collide. Kubernetes does that by allocating each
Service its own IP address from within the <code>service-cluster-ip-range</code>
CIDR range that is configured for the <a class="glossary-tooltip" title="Control plane component that serves the Kubernetes API." data-toggle="tooltip" data-placement="top" href="/docs/concepts/architecture/#kube-apiserver" target="_blank" aria-label="API Server">API Server</a>.</p><h3 id="ip-address-allocation-tracking">IP address allocation tracking</h3><p>To ensure each Service receives a unique IP address, an internal allocator atomically
updates a global allocation map in <a class="glossary-tooltip" title="Consistent and highly-available key value store used as backing store of Kubernetes for all cluster data." data-toggle="tooltip" data-placement="top" href="/docs/tasks/administer-cluster/configure-upgrade-etcd/" target="_blank" aria-label="etcd">etcd</a>
prior to creating each Service. The map object must exist in the registry for
Services to get IP address assignments, otherwise creations will
fail with a message indicating an IP address could not be allocated.</p><p>In the control plane, a background controller is responsible for creating that
map (needed to support migrating from older versions of Kubernetes that used
in-memory locking). Kubernetes also uses controllers to check for invalid
assignments (for example: due to administrator intervention) and for cleaning up allocated
IP addresses that are no longer used by any Services.</p><h4 id="ip-address-objects">IP address allocation tracking using the Kubernetes API</h4><div class="feature-state-notice feature-stable" title="Feature Gate: MultiCIDRServiceAllocator"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.33 [stable]</code> (enabled by default: true)</div><p>The control plane replaces the existing etcd allocator with a revised implementation
that uses IPAddress and ServiceCIDR objects instead of an internal global allocation map.
Each cluster IP address associated to a Service then references an IPAddress object.</p><p>Enabling the feature gate also replaces a background controller with an alternative
that handles the IPAddress objects and supports migration from the old allocator model.
Kubernetes 1.34 does not support migrating from IPAddress
objects to the internal allocation map.</p><p>One of the main benefits of the revised allocator is that it removes the size limitations
for the IP address range that can be used for the cluster IP address of Services.
With <code>MultiCIDRServiceAllocator</code> enabled, there are no limitations for IPv4, and for IPv6
you can use IP address netmasks that are a /64 or smaller (as opposed to /108 with the
legacy implementation).</p><p>Making IP address allocations available via the API means that you as a cluster administrator
can allow users to inspect the IP addresses assigned to their Services.
Kubernetes extensions, such as the <a href="/docs/concepts/services-networking/gateway/">Gateway API</a>,
can use the IPAddress API to extend Kubernetes' inherent networking capabilities.</p><p>Here is a brief example of a user querying for IP addresses:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl get services
</span></span></code></pre></div><pre tabindex="0"><code>NAME         TYPE        CLUSTER-IP        EXTERNAL-IP   PORT(S)   AGE
kubernetes   ClusterIP   2001:db8:1:2::1   &lt;none&gt;        443/TCP   3d1h
</code></pre><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl get ipaddresses
</span></span></code></pre></div><pre tabindex="0"><code>NAME              PARENTREF
2001:db8:1:2::1   services/default/kubernetes
2001:db8:1:2::a   services/kube-system/kube-dns
</code></pre><p>Kubernetes also allow users to dynamically define the available IP ranges for Services using
ServiceCIDR objects. During bootstrap, a default ServiceCIDR object named <code>kubernetes</code> is created
from the value of the <code>--service-cluster-ip-range</code> command line argument to kube-apiserver:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl get servicecidrs
</span></span></code></pre></div><pre tabindex="0"><code>NAME         CIDRS         AGE
kubernetes   10.96.0.0/28  17m
</code></pre><p>Users can create or delete new ServiceCIDR objects to manage the available IP ranges for Services:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>cat <span style="color:#b44">&lt;&lt;'EOF' | kubectl apply -f -
</span></span></span><span style="display:flex"><span><span style="color:#b44">apiVersion: networking.k8s.io/v1
</span></span></span><span style="display:flex"><span><span style="color:#b44">kind: ServiceCIDR
</span></span></span><span style="display:flex"><span><span style="color:#b44">metadata:
</span></span></span><span style="display:flex"><span><span style="color:#b44">  name: newservicecidr
</span></span></span><span style="display:flex"><span><span style="color:#b44">spec:
</span></span></span><span style="display:flex"><span><span style="color:#b44">  cidrs:
</span></span></span><span style="display:flex"><span><span style="color:#b44">  - 10.96.0.0/24
</span></span></span><span style="display:flex"><span><span style="color:#b44">EOF</span>
</span></span></code></pre></div><pre tabindex="0"><code>servicecidr.networking.k8s.io/newcidr1 created
</code></pre><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl get servicecidrs
</span></span></code></pre></div><pre tabindex="0"><code>NAME             CIDRS         AGE
kubernetes       10.96.0.0/28  17m
newservicecidr   10.96.0.0/24  7m
</code></pre><p>Distributions or administrators of Kubernetes clusters may want to control that
new Service CIDRs added to the cluster does not overlap with other networks on
the cluster, that only belong to a specific range of IPs or just simple retain
the existing behavior of only having one ServiceCIDR per cluster. An example of
a Validation Admission Policy to achieve this is:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:#00f;font-weight:700">---</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>admissionregistration.k8s.io/v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>ValidatingAdmissionPolicy<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">metadata</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span><span style="color:#b44">"servicecidrs-default"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">spec</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">failurePolicy</span>:<span style="color:#bbb"> </span>Fail<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">matchConstraints</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">resourceRules</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span>- <span style="color:green;font-weight:700">apiGroups</span>:<span style="color:#bbb">   </span>[<span style="color:#b44">"networking.k8s.io"</span>]<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">apiVersions</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">"v1"</span>,<span style="color:#b44">"v1beta1"</span>]<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">operations</span>:<span style="color:#bbb">  </span>[<span style="color:#b44">"CREATE"</span>,<span style="color:#bbb"> </span><span style="color:#b44">"UPDATE"</span>]<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">resources</span>:<span style="color:#bbb">   </span>[<span style="color:#b44">"servicecidrs"</span>]<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">matchConditions</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span><span style="color:#b44">'exclude-default-servicecidr'</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">expression</span>:<span style="color:#bbb"> </span><span style="color:#b44">"object.metadata.name != 'kubernetes'"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">variables</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>allowed<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">expression</span>:<span style="color:#bbb"> </span><span style="color:#b44">"['10.96.0.0/16','2001:db8::/64']"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">validations</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span>- <span style="color:green;font-weight:700">expression</span>:<span style="color:#bbb"> </span><span style="color:#b44">"object.spec.cidrs.all(i , variables.allowed.exists(j , cidr(j).containsCIDR(i)))"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:#00f;font-weight:700">---</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>admissionregistration.k8s.io/v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>ValidatingAdmissionPolicyBinding<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">metadata</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span><span style="color:#b44">"servicecidrs-binding"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">spec</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">policyName</span>:<span style="color:#bbb"> </span><span style="color:#b44">"servicecidrs-default"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">validationActions</span>:<span style="color:#bbb"> </span>[Deny,Audit]<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:#00f;font-weight:700">---</span><span style="color:#bbb">
</span></span></span></code></pre></div><h3 id="service-ip-static-sub-range">IP address ranges for Service virtual IP addresses</h3><div class="feature-state-notice feature-stable"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.26 [stable]</code></div><p>Kubernetes divides the <code>ClusterIP</code> range into two bands, based on
the size of the configured <code>service-cluster-ip-range</code> by using the following formula
<code>min(max(16, cidrSize / 16), 256)</code>. That formula means the result is <em>never less than 16 or
more than 256, with a graduated step function between them</em>.</p><p>Kubernetes prefers to allocate dynamic IP addresses to Services by choosing from the upper band,
which means that if you want to assign a specific IP address to a <code>type: ClusterIP</code>
Service, you should manually assign an IP address from the <strong>lower</strong> band. That approach
reduces the risk of a conflict over allocation.</p><h2 id="traffic-policies">Traffic policies</h2><p>You can set the <code>.spec.internalTrafficPolicy</code> and <code>.spec.externalTrafficPolicy</code> fields
to control how Kubernetes routes traffic to healthy (“ready”) backends.</p><h3 id="internal-traffic-policy">Internal traffic policy</h3><div class="feature-state-notice feature-stable"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.26 [stable]</code></div><p>You can set the <code>.spec.internalTrafficPolicy</code> field to control how traffic from
internal sources is routed. Valid values are <code>Cluster</code> and <code>Local</code>. Set the field to
<code>Cluster</code> to route internal traffic to all ready endpoints and <code>Local</code> to only route
to ready node-local endpoints. If the traffic policy is <code>Local</code> and there are no
node-local endpoints, traffic is dropped by kube-proxy.</p><h3 id="external-traffic-policy">External traffic policy</h3><p>You can set the <code>.spec.externalTrafficPolicy</code> field to control how traffic from
external sources is routed. Valid values are <code>Cluster</code> and <code>Local</code>. Set the field
to <code>Cluster</code> to route external traffic to all ready endpoints and <code>Local</code> to only
route to ready node-local endpoints. If the traffic policy is <code>Local</code> and there
are no node-local endpoints, the kube-proxy does not forward any traffic for the
relevant Service.</p><p>If <code>Cluster</code> is specified, all nodes are eligible load balancing targets <em>as long as</em>
the node is not being deleted and kube-proxy is healthy. In this mode: load balancer
health checks are configured to target the service proxy's readiness port and path.
In the case of kube-proxy this evaluates to: <code>${NODE_IP}:10256/healthz</code>. kube-proxy
will return either an HTTP code 200 or 503. kube-proxy's load balancer health check
endpoint returns 200 if:</p><ol><li><p>kube-proxy is healthy, meaning:</p><p>it's able to progress programming the network and isn't timing out while doing
so (the timeout is defined to be: <strong>2 × <code>iptables.syncPeriod</code></strong>); and</p></li><li><p>the node is not being deleted (there is no deletion timestamp set for the Node).</p></li></ol><p>kube-proxy returns 503 and marks the node as not
eligible when it's being deleted because it supports connection
draining for terminating nodes. A couple of important things occur from the point
of view of a Kubernetes-managed load balancer when a node <em>is being</em> / <em>is</em> deleted.</p><p>While deleting:</p><ul><li>kube-proxy will start failing its readiness probe and essentially mark the
node as not eligible for load balancer traffic. The load balancer health
check failing causes load balancers which support connection draining to
allow existing connections to terminate, and block new connections from
establishing.</li></ul><p>When deleted:</p><ul><li>The service controller in the Kubernetes cloud controller manager removes the
node from the referenced set of eligible targets. Removing any instance from
the load balancer's set of backend targets immediately terminates all
connections. This is also the reason kube-proxy first fails the health check
while the node is deleting.</li></ul><p>It's important to note for Kubernetes vendors that if any vendor configures the
kube-proxy readiness probe as a liveness probe: that kube-proxy will start
restarting continuously when a node is deleting until it has been fully deleted.
kube-proxy exposes a <code>/livez</code> path which, as opposed to the <code>/healthz</code> one, does
<strong>not</strong> consider the Node's deleting state and only its progress programming the
network. <code>/livez</code> is therefore the recommended path for anyone looking to define
a livenessProbe for kube-proxy.</p><p>Users deploying kube-proxy can inspect both the readiness / liveness state by
evaluating the metrics: <code>proxy_livez_total</code> / <code>proxy_healthz_total</code>. Both
metrics publish two series, one with the 200 label and one with the 503 one.</p><p>For <code>Local</code> Services: kube-proxy will return 200 if</p><ol><li>kube-proxy is healthy/ready, and</li><li>has a local endpoint on the node in question.</li></ol><p>Node deletion does <strong>not</strong> have an impact on kube-proxy's return
code for what concerns load balancer health checks. The reason for this is:
deleting nodes could end up causing an ingress outage should all endpoints
simultaneously be running on said nodes.</p><p>The Kubernetes project recommends that cloud provider integration code
configures load balancer health checks that target the service proxy's healthz
port. If you are using or implementing your own virtual IP implementation,
that people can use instead of kube-proxy, you should set up a similar health
checking port with logic that matches the kube-proxy implementation.</p><h3 id="traffic-to-terminating-endpoints">Traffic to terminating endpoints</h3><div class="feature-state-notice feature-stable"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.28 [stable]</code></div><p>If the <code>ProxyTerminatingEndpoints</code>
<a href="/docs/reference/command-line-tools-reference/feature-gates/">feature gate</a>
is enabled in kube-proxy and the traffic policy is <code>Local</code>, that node's
kube-proxy uses a more complicated algorithm to select endpoints for a Service.
With the feature enabled, kube-proxy checks if the node
has local endpoints and whether or not all the local endpoints are marked as terminating.
If there are local endpoints and <strong>all</strong> of them are terminating, then kube-proxy
will forward traffic to those terminating endpoints. Otherwise, kube-proxy will always
prefer forwarding traffic to endpoints that are not terminating.</p><p>This forwarding behavior for terminating endpoints exists to allow <code>NodePort</code> and <code>LoadBalancer</code>
Services to gracefully drain connections when using <code>externalTrafficPolicy: Local</code>.</p><p>As a deployment goes through a rolling update, nodes backing a load balancer may transition from
N to 0 replicas of that deployment. In some cases, external load balancers can send traffic to
a node with 0 replicas in between health check probes. Routing traffic to terminating endpoints
ensures that Nodes that are scaling down Pods can gracefully receive and drain traffic to
those terminating Pods. By the time the Pod completes termination, the external load balancer
should have seen the node's health check failing and fully removed the node from the backend
pool.</p><h2 id="traffic-distribution">Traffic Distribution</h2><div class="feature-state-notice feature-stable" title="Feature Gate: ServiceTrafficDistribution"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.33 [stable]</code> (enabled by default: true)</div><p>The <code>spec.trafficDistribution</code> field within a Kubernetes Service allows you to
express preferences for how traffic should be routed to Service endpoints.</p><dl><dt><code>PreferClose</code></dt><dd>This prioritizes sending traffic to endpoints in the same zone as the client.
The EndpointSlice controller updates EndpointSlices with <code>hints</code> to
communicate this preference, which kube-proxy then uses for routing decisions.
If a client's zone does not have any available endpoints, traffic will be
routed cluster-wide for that client.</dd></dl><div class="feature-state-notice feature-beta" title="Feature Gate: PreferSameTrafficDistribution"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.34 [beta]</code> (enabled by default: true)</div><p>In Kubernetes 1.34, two additional values are
available (unless the <code>PreferSameTrafficDistribution</code> <a href="/docs/reference/command-line-tools-reference/feature-gates/">feature
gate</a> is
disabled):</p><dl><dt><code>PreferSameZone</code></dt><dd>This means the same thing as <code>PreferClose</code>, but is more explicit. (Originally,
the intention was that <code>PreferClose</code> might later include functionality other
than just "prefer same zone", but this is no longer planned. In the future,
<code>PreferSameZone</code> will be the recommended value to use for this functionality,
and <code>PreferClose</code> will be considered a deprecated alias for it.)</dd><dt><code>PreferSameNode</code></dt><dd>This prioritizes sending traffic to endpoints on the same node as the client.
As with <code>PreferClose</code>/<code>PreferSameZone</code>, the EndpointSlice controller updates
EndpointSlices with <code>hints</code> indicating that a slice should be used for a
particular node. If a client's node does not have any available endpoints,
then the service proxy will fall back to "same zone" behavior, or cluster-wide
if there are no same-zone endpoints either.</dd></dl><p>In the absence of any value for <code>trafficDistribution</code>, the default strategy is
to distribute traffic evenly to all endpoints in the cluster.</p><h3 id="comparison-with-service-kubernetes-io-topology-mode-auto">Comparison with <code>service.kubernetes.io/topology-mode: Auto</code></h3><p>The <code>trafficDistribution</code> field with <code>PreferClose</code>/<code>PreferSameZone</code>, and the older "Topology-Aware
Routing" feature using the <code>service.kubernetes.io/topology-mode: Auto</code>
annotation both aim to prioritize same-zone traffic. However, there is a key
difference in their approaches:</p><ul><li><p><code>service.kubernetes.io/topology-mode: Auto</code> attempts to distribute traffic
proportionally across zones based on allocatable CPU resources. This heuristic
includes safeguards (such as the <a href="/docs/concepts/services-networking/topology-aware-routing/#three-or-more-endpoints-per-zone">fallback
behavior</a>
for small numbers of endpoints), sacrificing some predictability in favor of
potentially better load balancing.</p></li><li><p><code>trafficDistribution: PreferClose</code> aims to be simpler and more predictable:
"If there are endpoints in the zone, they will receive all traffic for that
zone, if there are no endpoints in a zone, the traffic will be distributed to
other zones". This approach offers more predictability, but it means that you
are responsible for <a href="#considerations-for-using-traffic-distribution-control">avoiding endpoint
overload</a>.</p></li></ul><p>If the <code>service.kubernetes.io/topology-mode</code> annotation is set to <code>Auto</code>, it
will take precedence over <code>trafficDistribution</code>. The annotation may be deprecated
in the future in favor of the <code>trafficDistribution</code> field.</p><h3 id="interaction-with-traffic-policies">Interaction with Traffic Policies</h3><p>When compared to the <code>trafficDistribution</code> field, the traffic policy fields
(<code>externalTrafficPolicy</code> and <code>internalTrafficPolicy</code>) are meant to offer a
stricter traffic locality requirements. Here's how <code>trafficDistribution</code>
interacts with them:</p><ul><li><p>Precedence of Traffic Policies: For a given Service, if a traffic policy
(<code>externalTrafficPolicy</code> or <code>internalTrafficPolicy</code>) is set to <code>Local</code>, it
takes precedence over <code>trafficDistribution</code> for the corresponding
traffic type (external or internal, respectively).</p></li><li><p><code>trafficDistribution</code> Influence: For a given Service, if a traffic policy
(<code>externalTrafficPolicy</code> or <code>internalTrafficPolicy</code>) is set to <code>Cluster</code> (the
default), or if the fields are not set, then <code>trafficDistribution</code>
guides the routing behavior for the corresponding traffic type
(external or internal, respectively). This means that an attempt will be made
to route traffic to an endpoint that is in the same zone as the client.</p></li></ul><h3 id="considerations-for-using-traffic-distribution-control">Considerations for using traffic distribution control</h3><p>A Service using <code>trafficDistribution</code> will attempt to route traffic to (healthy)
endpoints within the appropriate topology, even if this means that some
endpoints receive much more traffic than other endpoints. If you do not have a
sufficient number of endpoints within the same topology ("same zone", "same
node", etc.) as the clients, then endpoints may become overloaded. This is
especially likely if incoming traffic is not proportionally distributed across
the topology. To mitigate this, consider the following strategies:</p><ul><li><p><a href="/docs/concepts/scheduling-eviction/topology-spread-constraints/">Pod Topology Spread Constraints</a>:
Use Pod Topology Spread Constraints to distribute your pods evenly
across zones or nodes.</p></li><li><p>Zone-specific Deployments: If you are using "same zone" traffic
distribution, but expect to see different traffic patterns in
different zones, you can create a separate Deployment for each zone.
This approach allows the separate workloads to scale independently.
There are also workload management addons available from the
ecosystem, outside the Kubernetes project itself, that can help
here.</p></li></ul><h2 id="what-s-next">What's next</h2><p>To learn more about Services,
read <a href="/docs/tutorials/services/connect-applications-service/">Connecting Applications with Services</a>.</p><p>You can also:</p><ul><li>Read about <a href="/docs/concepts/services-networking/service/">Services</a> as a concept</li><li>Read about <a href="/docs/concepts/services-networking/ingress/">Ingresses</a> as a concept</li><li>Read the <a href="/docs/reference/kubernetes-api/service-resources/service-v1/">API reference</a> for the Service API</li></ul></div>