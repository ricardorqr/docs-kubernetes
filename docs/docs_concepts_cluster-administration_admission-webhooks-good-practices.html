<div class="td-content"><h1 data-pagefind-weight="10">Admission Webhook Good Practices</h1><div class="lead">Recommendations for designing and deploying admission webhooks in Kubernetes.</div><p>This page provides good practices and considerations when designing
<em>admission webhooks</em> in Kubernetes. This information is intended for
cluster operators who run admission webhook servers or third-party applications
that modify or validate your API requests.</p><p>Before reading this page, ensure that you're familiar with the following
concepts:</p><ul><li><a href="/docs/reference/access-authn-authz/admission-controllers/">Admission controllers</a></li><li><a href="/docs/reference/access-authn-authz/extensible-admission-controllers/#what-are-admission-webhooks">Admission webhooks</a></li></ul><h2 id="why-good-webhook-design-matters">Importance of good webhook design</h2><p>Admission control occurs when any create, update, or delete request
is sent to the Kubernetes API. Admission controllers intercept requests that
match specific criteria that you define. These requests are then sent to
mutating admission webhooks or validating admission webhooks. These webhooks are
often written to ensure that specific fields in object specifications exist or
have specific allowed values.</p><p>Webhooks are a powerful mechanism to extend the Kubernetes API. Badly-designed
webhooks often result in workload disruptions because of how much control
the webhooks have over objects in the cluster. Like other API extension
mechanisms, webhooks are challenging to test at scale for compatibility with
all of your workloads, other webhooks, add-ons, and plugins.</p><p>Additionally, with every release, Kubernetes adds or modifies the API with new
features, feature promotions to beta or stable status, and deprecations. Even
stable Kubernetes APIs are likely to change. For example, the <code>Pod</code> API changed
in v1.29 to add the
<a href="/docs/concepts/workloads/pods/sidecar-containers/">Sidecar containers</a> feature.
While it's rare for a Kubernetes object to enter a broken state because of a new
Kubernetes API, webhooks that worked as expected with earlier versions of an API
might not be able to reconcile more recent changes to that API. This can result
in unexpected behavior after you upgrade your clusters to newer versions.</p><p>This page describes common webhook failure scenarios and how to avoid them by
cautiously and thoughtfully designing and implementing your webhooks.</p><h2 id="identify-admission-webhooks">Identify whether you use admission webhooks</h2><p>Even if you don't run your own admission webhooks, some third-party applications
that you run in your clusters might use mutating or validating admission
webhooks.</p><p>To check whether your cluster has any mutating admission webhooks, run the
following command:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl get mutatingwebhookconfigurations
</span></span></code></pre></div><p>The output lists any mutating admission controllers in the cluster.</p><p>To check whether your cluster has any validating admission webhooks, run the
following command:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl get validatingwebhookconfigurations
</span></span></code></pre></div><p>The output lists any validating admission controllers in the cluster.</p><h2 id="choose-admission-mechanism">Choose an admission control mechanism</h2><p>Kubernetes includes multiple admission control and policy enforcement options.
Knowing when to use a specific option can help you to improve latency and
performance, reduce management overhead, and avoid issues during version
upgrades. The following table describes the mechanisms that let you mutate or
validate resources during admission:</p><table><caption>Mutating and validating admission control in Kubernetes</caption><thead><tr><th>Mechanism</th><th>Description</th><th>Use cases</th></tr></thead><tbody><tr><td><a href="/docs/reference/access-authn-authz/extensible-admission-controllers/">Mutating admission webhook</a></td><td>Intercept API requests before admission and modify as needed using
custom logic.</td><td><ul><li>Make critical modifications that must happen before resource
admission.</li><li>Make complex modifications that require advanced logic, like calling
external APIs.</li></ul></td></tr><tr><td><a href="/docs/reference/access-authn-authz/mutating-admission-policy/">Mutating admission policy</a></td><td>Intercept API requests before admission and modify as needed using
Common Expression Language (CEL) expressions.</td><td><ul><li>Make critical modifications that must happen before resource
admission.</li><li>Make simple modifications, such as adjusting labels or replica
counts.</li></ul></td></tr><tr><td><a href="/docs/reference/access-authn-authz/extensible-admission-controllers/">Validating admission webhook</a></td><td>Intercept API requests before admission and validate against complex
policy declarations.</td><td><ul><li>Validate critical configurations before resource admission.</li><li>Enforce complex policy logic before admission.</li></ul></td></tr><tr><td><a href="/docs/reference/access-authn-authz/validating-admission-policy/">Validating admission policy</a></td><td>Intercept API requests before admission and validate against CEL
expressions.</td><td><ul><li>Validate critical configurations before resource admission.</li><li>Enforce policy logic using CEL expressions.</li></ul></td></tr></tbody></table><p>In general, use <em>webhook</em> admission control when you want an extensible way to
declare or configure the logic. Use built-in CEL-based admission control when
you want to declare simpler logic without the overhead of running a webhook
server. The Kubernetes project recommends that you use CEL-based admission
control when possible.</p><h3 id="no-crd-validation-defaulting">Use built-in validation and defaulting for CustomResourceDefinitions</h3><p>If you use
<a class="glossary-tooltip" title="Custom code that defines a resource to add to your Kubernetes API server without building a complete custom server." data-toggle="tooltip" data-placement="top" href="/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/" target="_blank" aria-label="CustomResourceDefinitions">CustomResourceDefinitions</a>,
don't use admission webhooks to validate values in CustomResource specifications
or to set default values for fields. Kubernetes lets you define validation rules
and default field values when you create CustomResourceDefinitions.</p><p>To learn more, see the following resources:</p><ul><li><a href="/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#validation-rules">Validation rules</a></li><li><a href="/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#defaulting">Defaulting</a></li></ul><h2 id="performance-latency">Performance and latency</h2><p>This section describes recommendations for improving performance and reducing
latency. In summary, these are as follows:</p><ul><li>Consolidate webhooks and limit the number of API calls per webhook.</li><li>Use audit logs to check for webhooks that repeatedly do the same action.</li><li>Use load balancing for webhook availability.</li><li>Set a small timeout value for each webhook.</li><li>Consider cluster availability needs during webhook design.</li></ul><h3 id="design-admission-webhooks-low-latency">Design admission webhooks for low latency</h3><p>Mutating admission webhooks are called in sequence. Depending on the mutating
webhook setup, some webhooks might be called multiple times. Every mutating
webhook call adds latency to the admission process. This is unlike validating
webhooks, which get called in parallel.</p><p>When designing your mutating webhooks, consider your latency requirements and
tolerance. The more mutating webhooks there are in your cluster, the greater the
chance of latency increases.</p><p>Consider the following to reduce latency:</p><ul><li>Consolidate webhooks that perform a similar mutation on different objects.</li><li>Reduce the number of API calls made in the mutating webhook server logic.</li><li>Limit the match conditions of each mutating webhook to reduce how many
webhooks are triggered by a specific API request.</li><li>Consolidate small webhooks into one server and configuration to help with
ordering and organization.</li></ul><h3 id="prevent-loops-competing-controllers">Prevent loops caused by competing controllers</h3><p>Consider any other components that run in your cluster that might conflict with
the mutations that your webhook makes. For example, if your webhook adds a label
that a different controller removes, your webhook gets called again. This leads
to a loop.</p><p>To detect these loops, try the following:</p><ol><li><p>Update your cluster audit policy to log audit events. Use the following
parameters:</p><ul><li><code>level</code>: <code>RequestResponse</code></li><li><code>verbs</code>: <code>["patch"]</code></li><li><code>omitStages</code>: <code>RequestReceived</code></li></ul><p>Set the audit rule to create events for the specific resources that your
webhook mutates.</p></li><li><p>Check your audit events for webhooks being reinvoked multiple times with the
same patch being applied to the same object, or for an object having
a field updated and reverted multiple times.</p></li></ol><h3 id="small-timeout">Set a small timeout value</h3><p>Admission webhooks should evaluate as quickly as possible (typically in
milliseconds), since they add to API request latency. Use a small timeout for
webhooks.</p><p>For details, see
<a href="/docs/reference/access-authn-authz/extensible-admission-controllers/#timeouts">Timeouts</a>.</p><h3 id="load-balancer-webhook">Use a load balancer to ensure webhook availability</h3><p>Admission webhooks should leverage some form of load-balancing to provide high
availability and performance benefits. If a webhook is running within the
cluster, you can run multiple webhook backends behind a Service of type
<code>ClusterIP</code>.</p><h3 id="ha-deployment">Use a high-availability deployment model</h3><p>Consider your cluster's availability requirements when designing your webhook.
For example, during node downtime or zonal outages, Kubernetes marks Pods as
<code>NotReady</code> to allow load balancers to reroute traffic to available zones and
nodes. These updates to Pods might trigger your mutating webhooks. Depending on
the number of affected Pods, the mutating webhook server has a risk of timing
out or causing delays in Pod processing. As a result, traffic won't get
rerouted as quickly as you need.</p><p>Consider situations like the preceding example when writing your webhooks.
Exclude operations that are a result of Kubernetes responding to unavoidable
incidents.</p><h2 id="request-filtering">Request filtering</h2><p>This section provides recommendations for filtering which requests trigger
specific webhooks. In summary, these are as follows:</p><ul><li>Limit the webhook scope to avoid system components and read-only requests.</li><li>Limit webhooks to specific namespaces.</li><li>Use match conditions to perform fine-grained request filtering.</li><li>Match all versions of an object.</li></ul><h3 id="webhook-limit-scope">Limit the scope of each webhook</h3><p>Admission webhooks are only called when an API request matches the corresponding
webhook configuration. Limit the scope of each webhook to reduce unnecessary
calls to the webhook server. Consider the following scope limitations:</p><ul><li>Avoid matching objects in the <code>kube-system</code> namespace. If you run your own
Pods in the <code>kube-system</code> namespace, use an
<a href="/docs/reference/access-authn-authz/extensible-admission-controllers/#matching-requests-objectselector"><code>objectSelector</code></a>
to avoid mutating a critical workload.</li><li>Don't mutate node leases, which exist as Lease objects in the
<code>kube-node-lease</code> system namespace. Mutating node leases might result in
failed node upgrades. Only apply validation controls to Lease objects in this
namespace if you're confident that the controls won't put your cluster at
risk.</li><li>Don't mutate TokenReview or SubjectAccessReview objects. These are always
read-only requests. Modifying these objects might break your cluster.</li><li>Limit each webhook to a specific namespace by using a
<a href="/docs/reference/access-authn-authz/extensible-admission-controllers/#matching-requests-namespaceselector"><code>namespaceSelector</code></a>.</li></ul><h3 id="filter-match-conditions">Filter for specific requests by using match conditions</h3><p>Admission controllers support multiple fields that you can use to match requests
that meet specific criteria. For example, you can use a <code>namespaceSelector</code> to
filter for requests that target a specific namespace.</p><p>For more fine-grained request filtering, use the <code>matchConditions</code> field in your
webhook configuration. This field lets you write multiple CEL expressions that
must evaluate to <code>true</code> for a request to trigger your admission webhook. Using
<code>matchConditions</code> might significantly reduce the number of calls to your webhook
server.</p><p>For details, see
<a href="/docs/reference/access-authn-authz/extensible-admission-controllers/#matching-requests-matchconditions">Matching requests: <code>matchConditions</code></a>.</p><h3 id="match-all-versions">Match all versions of an API</h3><p>By default, admission webhooks run on any API versions that affect a specified
resource. The <code>matchPolicy</code> field in the webhook configuration controls this
behavior. Specify a value of <code>Equivalent</code> in the <code>matchPolicy</code> field or omit
the field to allow the webhook to run on any API version.</p><p>For details, see
<a href="/docs/reference/access-authn-authz/extensible-admission-controllers/#matching-requests-matchpolicy">Matching requests: <code>matchPolicy</code></a>.</p><h2 id="mutation-scope-considerations">Mutation scope and field considerations</h2><p>This section provides recommendations for the scope of mutations and any special
considerations for object fields. In summary, these are as follows:</p><ul><li>Patch only the fields that you need to patch.</li><li>Don't overwrite array values.</li><li>Avoid side effects in mutations when possible.</li><li>Avoid self-mutations.</li><li>Fail open and validate the final state.</li><li>Plan for future field updates in later versions.</li><li>Prevent webhooks from self-triggering.</li><li>Don't change immutable objects.</li></ul><h3 id="patch-required-fields">Patch only required fields</h3><p>Admission webhook servers send HTTP responses to indicate what to do with a
specific Kubernetes API request. This response is an AdmissionReview object.
A mutating webhook can add specific fields to mutate before allowing admission
by using the <code>patchType</code> field and the <code>patch</code> field in the response. Ensure
that you only modify the fields that require a change.</p><p>For example, consider a mutating webhook that's configured to ensure that
<code>web-server</code> Deployments have at least three replicas. When a request to
create a Deployment object matches your webhook configuration, the webhook
should only update the value in the <code>spec.replicas</code> field.</p><h3 id="dont-overwrite-arrays">Don't overwrite array values</h3><p>Fields in Kubernetes object specifications might include arrays. Some arrays
contain key:value pairs (like the <code>envVar</code> field in a container specification),
while other arrays are unkeyed (like the <code>readinessGates</code> field in a Pod
specification). The order of values in an array field might matter in some
situations. For example, the order of arguments in the <code>args</code> field of a
container specification might affect the container.</p><p>Consider the following when modifying arrays:</p><ul><li>Whenever possible, use the <code>add</code> JSONPatch operation instead of <code>replace</code> to
avoid accidentally replacing a required value.</li><li>Treat arrays that don't use key:value pairs as sets.</li><li>Ensure that the values in the field that you modify aren't required to be
in a specific order.</li><li>Don't overwrite existing key:value pairs unless absolutely necessary.</li><li>Use caution when modifying label fields. An accidental modification might
cause label selectors to break, resulting in unintended behavior.</li></ul><h3 id="avoid-side-effects">Avoid side effects</h3><p>Ensure that your webhooks operate only on the content of the AdmissionReview
that's sent to them, and do not make out-of-band changes. These additional
changes, called <em>side effects</em>, might cause conflicts during admission if they
aren't reconciled properly. The <code>.webhooks[].sideEffects</code> field should
be set to <code>None</code> if a webhook doesn't have any side effect.</p><p>If side effects are required during the admission evaluation, they must be
suppressed when processing an AdmissionReview object with <code>dryRun</code> set to
<code>true</code>, and the <code>.webhooks[].sideEffects</code> field should be set to <code>NoneOnDryRun</code>.</p><p>For details, see
<a href="/docs/reference/access-authn-authz/extensible-admission-controllers/#side-effects">Side effects</a>.</p><h3 id="avoid-self-mutation">Avoid self-mutations</h3><p>A webhook running inside the cluster might cause deadlocks for its own
deployment if it is configured to intercept resources required to start its own
Pods.</p><p>For example, a mutating admission webhook is configured to admit <strong>create</strong> Pod
requests only if a certain label is set in the Pod (such as <code>env: prod</code>).
The webhook server runs in a Deployment that doesn't set the <code>env</code> label.</p><p>When a node that runs the webhook server Pods becomes unhealthy, the webhook
Deployment tries to reschedule the Pods to another node. However, the existing
webhook server rejects the requests since the <code>env</code> label is unset. As a
result, the migration cannot happen.</p><p>Exclude the namespace where your webhook is running with a
<a href="/docs/reference/access-authn-authz/extensible-admission-controllers/#matching-requests-namespaceselector"><code>namespaceSelector</code></a>.</p><h3 id="avoid-dependency-loops">Avoid dependency loops</h3><p>Dependency loops can occur in scenarios like the following:</p><ul><li>Two webhooks check each other's Pods. If both webhooks become unavailable
at the same time, neither webhook can start.</li><li>Your webhook intercepts cluster add-on components, such as networking plugins
or storage plugins, that your webhook depends on. If both the webhook and the
dependent add-on become unavailable, neither component can function.</li></ul><p>To avoid these dependency loops, try the following:</p><ul><li>Use
<a href="/docs/reference/access-authn-authz/validating-admission-policy/">ValidatingAdmissionPolicies</a>
to avoid introducing dependencies.</li><li>Prevent webhooks from validating or mutating other webhooks. Consider
<a href="/docs/reference/access-authn-authz/extensible-admission-controllers/#matching-requests-namespaceselector">excluding specific namespaces</a>
from triggering your webhook.</li><li>Prevent your webhooks from acting on dependent add-ons by using an
<a href="/docs/reference/access-authn-authz/extensible-admission-controllers/#matching-requests-objectselector"><code>objectSelector</code></a>.</li></ul><h3 id="fail-open-validate-final-state">Fail open and validate the final state</h3><p>Mutating admission webhooks support the <code>failurePolicy</code> configuration field.
This field indicates whether the API server should admit or reject the request
if the webhook fails. Webhook failures might occur because of timeouts or errors
in the server logic.</p><p>By default, admission webhooks set the <code>failurePolicy</code> field to Fail. The API
server rejects a request if the webhook fails. However, rejecting requests by
default might result in compliant requests being rejected during webhook
downtime.</p><p>Let your mutating webhooks "fail open" by setting the <code>failurePolicy</code> field to
Ignore. Use a validating controller to check the state of requests to ensure
that they comply with your policies.</p><p>This approach has the following benefits:</p><ul><li>Mutating webhook downtime doesn't affect compliant resources from deploying.</li><li>Policy enforcement occurs during validating admission control.</li><li>Mutating webhooks don't interfere with other controllers in the cluster.</li></ul><h3 id="plan-future-field-updates">Plan for future updates to fields</h3><p>In general, design your webhooks under the assumption that Kubernetes APIs might
change in a later version. Don't write a server that takes the stability of an
API for granted. For example, the release of sidecar containers in Kubernetes
added a <code>restartPolicy</code> field to the Pod API.</p><h3 id="prevent-webhook-self-trigger">Prevent your webhook from triggering itself</h3><p>Mutating webhooks that respond to a broad range of API requests might
unintentionally trigger themselves. For example, consider a webhook that
responds to all requests in the cluster. If you configure the webhook to create
Event objects for every mutation, it'll respond to its own Event object
creation requests.</p><p>To avoid this, consider setting a unique label in any resources that your
webhook creates. Exclude this label from your webhook match conditions.</p><h3 id="dont-change-immutable-objects">Don't change immutable objects</h3><p>Some Kubernetes objects in the API server can't change. For example, when you
deploy a <a class="glossary-tooltip" title="A pod managed directly by the kubelet daemon on a specific node." data-toggle="tooltip" data-placement="top" href="/docs/tasks/configure-pod-container/static-pod/" target="_blank" aria-label="static Pod">static Pod</a>, the
kubelet on the node creates a
<a class="glossary-tooltip" title="An object in the API server that tracks a static pod on a kubelet." data-toggle="tooltip" data-placement="top" href="/docs/reference/glossary/?all=true#term-mirror-pod" target="_blank" aria-label="mirror Pod">mirror Pod</a> in the API
server to track the static Pod. However, changes to the mirror Pod don't
propagate to the static Pod.</p><p>Don't attempt to mutate these objects during admission. All mirror Pods have the
<code>kubernetes.io/config.mirror</code> annotation. To exclude mirror Pods while reducing
the security risk of ignoring an annotation, allow static Pods to only run in
specific namespaces.</p><h2 id="ordering-idempotence">Mutating webhook ordering and idempotence</h2><p>This section provides recommendations for webhook order and designing idempotent
webhooks. In summary, these are as follows:</p><ul><li>Don't rely on a specific order of execution.</li><li>Validate mutations before admission.</li><li>Check for mutations being overwritten by other controllers.</li><li>Ensure that the set of mutating webhooks is idempotent, not just the
individual webhooks.</li></ul><h3 id="dont-rely-webhook-order">Don't rely on mutating webhook invocation order</h3><p>Mutating admission webhooks don't run in a consistent order. Various factors
might change when a specific webhook is called. Don't rely on your webhook
running at a specific point in the admission process. Other webhooks could still
mutate your modified object.</p><p>The following recommendations might help to minimize the risk of unintended
changes:</p><ul><li><a href="#validate-mutations">Validate mutations before admission</a></li><li>Use a reinvocation policy to observe changes to an object by other plugins
and re-run the webhook as needed. For details, see
<a href="/docs/reference/access-authn-authz/extensible-admission-controllers/#reinvocation-policy">Reinvocation policy</a>.</li></ul><h3 id="ensure-mutating-webhook-idempotent">Ensure that the mutating webhooks in your cluster are idempotent</h3><p>Every mutating admission webhook should be <em>idempotent</em>. The webhook should be
able to run on an object that it already modified without making additional
changes beyond the original change.</p><p>Additionally, all of the mutating webhooks in your cluster should, as a
collection, be idempotent. After the mutation phase of admission control ends,
every individual mutating webhook should be able to run on an object without
making additional changes to the object.</p><p>Depending on your environment, ensuring idempotence at scale might be
challenging. The following recommendations might help:</p><ul><li>Use validating admission controllers to verify the final state of
critical workloads.</li><li>Test your deployments in a staging cluster to see if any objects get modified
multiple times by the same webhook.</li><li>Ensure that the scope of each mutating webhook is specific and limited.</li></ul><p>The following examples show idempotent mutation logic:</p><ol><li><p>For a <strong>create</strong> Pod request, set the field
<code>.spec.securityContext.runAsNonRoot</code> of the Pod to true.</p></li><li><p>For a <strong>create</strong> Pod request, if the field
<code>.spec.containers[].resources.limits</code> of a container is not set, set default
resource limits.</p></li><li><p>For a <strong>create</strong> Pod request, inject a sidecar container with name
<code>foo-sidecar</code> if no container with the name <code>foo-sidecar</code> already exists.</p></li></ol><p>In these cases, the webhook can be safely reinvoked, or admit an object that
already has the fields set.</p><p>The following examples show non-idempotent mutation logic:</p><ol><li><p>For a <strong>create</strong> Pod request, inject a sidecar container with name
<code>foo-sidecar</code> suffixed with the current timestamp (such as
<code>foo-sidecar-19700101-000000</code>).</p><p>Reinvoking the webhook can result in the same sidecar being injected multiple
times to a Pod, each time with a different container name. Similarly, the
webhook can inject duplicated containers if the sidecar already exists in
a user-provided pod.</p></li><li><p>For a <strong>create</strong>/<strong>update</strong> Pod request, reject if the Pod has label <code>env</code>
set, otherwise add an <code>env: prod</code> label to the Pod.</p><p>Reinvoking the webhook will result in the webhook failing on its own output.</p></li><li><p>For a <strong>create</strong> Pod request, append a sidecar container named <code>foo-sidecar</code>
without checking whether a <code>foo-sidecar</code> container exists.</p><p>Reinvoking the webhook will result in duplicated containers in the Pod, which
makes the request invalid and rejected by the API server.</p></li></ol><h2 id="mutation-testing-validation">Mutation testing and validation</h2><p>This section provides recommendations for testing your mutating webhooks and
validating mutated objects. In summary, these are as follows:</p><ul><li>Test webhooks in staging environments.</li><li>Avoid mutations that violate validations.</li><li>Test minor version upgrades for regressions and conflicts.</li><li>Validate mutated objects before admission.</li></ul><h3 id="test-in-staging-environments">Test webhooks in staging environments</h3><p>Robust testing should be a core part of your release cycle for new or updated
webhooks. If possible, test any changes to your cluster webhooks in a staging
environment that closely resembles your production clusters. At the very least,
consider using a tool like <a href="https://minikube.sigs.k8s.io/docs/">minikube</a> or
<a href="https://kind.sigs.k8s.io/">kind</a> to create a small test cluster for webhook
changes.</p><h3 id="ensure-mutations-dont-violate-validations">Ensure that mutations don't violate validations</h3><p>Your mutating webhooks shouldn't break any of the validations that apply to an
object before admission. For example, consider a mutating webhook that sets the
default CPU request of a Pod to a specific value. If the CPU limit of that Pod
is set to a lower value than the mutated request, the Pod fails admission.</p><p>Test every mutating webhook against the validations that run in your cluster.</p><h3 id="test-minor-version-upgrades">Test minor version upgrades to ensure consistent behavior</h3><p>Before upgrading your production clusters to a new minor version, test your
webhooks and workloads in a staging environment. Compare the results to ensure
that your webhooks continue to function as expected after the upgrade.</p><p>Additionally, use the following resources to stay informed about API changes:</p><ul><li><a href="/releases/">Kubernetes release notes</a></li><li><a href="/blog/">Kubernetes blog</a></li></ul><h3 id="validate-mutations">Validate mutations before admission</h3><p>Mutating webhooks run to completion before any validating webhooks run. There is
no stable order in which mutations are applied to objects. As a result, your
mutations could get overwritten by a mutating webhook that runs at a later time.</p><p>Add a validating admission controller like a ValidatingAdmissionWebhook or a
ValidatingAdmissionPolicy to your cluster to ensure that your mutations
are still present. For example, consider a mutating webhook that inserts the
<code>restartPolicy: Always</code> field to specific init containers to make them run as
sidecar containers. You could run a validating webhook to ensure that those
init containers retained the <code>restartPolicy: Always</code> configuration after all
mutations were completed.</p><p>For details, see the following resources:</p><ul><li><a href="/docs/reference/access-authn-authz/validating-admission-policy/">Validating Admission Policy</a></li><li><a href="/docs/reference/access-authn-authz/admission-controllers/#validatingadmissionwebhook">ValidatingAdmissionWebhooks</a></li></ul><h2 id="mutating-webhook-deployment">Mutating webhook deployment</h2><p>This section provides recommendations for deploying your mutating admission
webhooks. In summary, these are as follows:</p><ul><li>Gradually roll out the webhook configuration and monitor for issues by
namespace.</li><li>Limit access to edit the webhook configuration resources.</li><li>Limit access to the namespace that runs the webhook server, if the server is
in-cluster.</li></ul><h3 id="install-enable-mutating-webhook">Install and enable a mutating webhook</h3><p>When you're ready to deploy your mutating webhook to a cluster, use the
following order of operations:</p><ol><li>Install the webhook server and start it.</li><li>Set the <code>failurePolicy</code> field in the MutatingWebhookConfiguration manifest
to Ignore. This lets you avoid disruptions caused by misconfigured webhooks.</li><li>Set the <code>namespaceSelector</code> field in the MutatingWebhookConfiguration
manifest to a test namespace.</li><li>Deploy the MutatingWebhookConfiguration to your cluster.</li></ol><p>Monitor the webhook in the test namespace to check for any issues, then roll the
webhook out to other namespaces. If the webhook intercepts an API request that
it wasn't meant to intercept, pause the rollout and adjust the scope of the
webhook configuration.</p><h3 id="limit-edit-access">Limit edit access to mutating webhooks</h3><p>Mutating webhooks are powerful Kubernetes controllers. Use RBAC or another
authorization mechanism to limit access to your webhook configurations and
servers. For RBAC, ensure that the following access is only available to trusted
entities:</p><ul><li>Verbs: <strong>create</strong>, <strong>update</strong>, <strong>patch</strong>, <strong>delete</strong>, <strong>deletecollection</strong></li><li>API group: <code>admissionregistration.k8s.io/v1</code></li><li>API kind: MutatingWebhookConfigurations</li></ul><p>If your mutating webhook server runs in the cluster, limit access to create or
modify any resources in that namespace.</p><h2 id="example-good-implementations">Examples of good implementations</h2><div class="alert alert-secondary callout third-party-content" role="alert"><strong>Note:</strong>â€ˆThis section links to third party projects that provide functionality required by Kubernetes. The Kubernetes project authors aren't responsible for these projects, which are listed alphabetically. To add a project to this list, read the <a href="/docs/contribute/style/content-guide/#third-party-content">content guide</a> before submitting a change. <a href="#third-party-content-disclaimer">More information.</a></div><p>The following projects are examples of "good" custom webhook server
implementations. You can use them as a starting point when designing your own
webhooks. Don't use these examples as-is; use them as a starting point and
design your webhooks to run well in your specific environment.</p><ul><li><a href="https://github.com/cert-manager/cert-manager/tree/master/internal/webhook"><code>cert-manager</code></a></li><li><a href="https://open-policy-agent.github.io/gatekeeper/website/docs/mutation">Gatekeeper Open Policy Agent (OPA)</a></li></ul><h2 id="what-s-next">What's next</h2><ul><li><a href="/docs/reference/access-authn-authz/webhook/">Use webhooks for authentication and authorization</a></li><li><a href="/docs/reference/access-authn-authz/mutating-admission-policy/">Learn about MutatingAdmissionPolicies</a></li><li><a href="/docs/reference/access-authn-authz/validating-admission-policy/">Learn about ValidatingAdmissionPolicies</a></li></ul></div>