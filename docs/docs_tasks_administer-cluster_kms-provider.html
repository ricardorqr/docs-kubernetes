<div class="td-content"><h1 data-pagefind-weight="10">Using a KMS provider for data encryption</h1><p>This page shows how to configure a Key Management Service (KMS) provider and plugin to enable secret data encryption.
In Kubernetes 1.34 there are two versions of KMS at-rest encryption.
You should use KMS v2 if feasible because KMS v1 is deprecated (since Kubernetes v1.28) and disabled by default (since Kubernetes v1.29).
KMS v2 offers significantly better performance characteristics than KMS v1.</p><div class="alert alert-caution" role="alert"><h4 class="alert-heading">Caution:</h4>This documentation is for the generally available implementation of KMS v2 (and for the
deprecated version 1 implementation).
If you are using any control plane components older than Kubernetes v1.29, please check
the equivalent page in the documentation for the version of Kubernetes that your cluster
is running. Earlier releases of Kubernetes had different behavior that may be relevant
for information security.</div><h2 id="before-you-begin">Before you begin</h2><p>You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. It is recommended to run this tutorial on a cluster with at least two nodes that are not acting as control plane hosts. If you do not already have a
cluster, you can create one by using
<a href="https://minikube.sigs.k8s.io/docs/tutorials/multi_node/">minikube</a>
or you can use one of these Kubernetes playgrounds:</p><ul><li><a href="https://labs.iximiuz.com/playgrounds?category=kubernetes&amp;filter=all">iximiuz Labs</a></li><li><a href="https://killercoda.com/playgrounds/scenario/kubernetes">Killercoda</a></li><li><a href="https://kodekloud.com/public-playgrounds">KodeKloud</a></li><li><a href="https://labs.play-with-k8s.com/">Play with Kubernetes</a></li></ul><p>The version of Kubernetes that you need depends on which KMS API version
you have selected. Kubernetes recommends using KMS v2.</p><ul><li>If you selected KMS API v1 to support clusters prior to version v1.27
or if you have a legacy KMS plugin that only supports KMS v1,
any supported Kubernetes version will work. This API is deprecated as of Kubernetes v1.28.
Kubernetes does not recommend the use of this API.</li></ul><p>To check the version, enter <code>kubectl version</code>.</p><h3 id="kms-v1">KMS v1</h3><div class="feature-state-notice feature-deprecated"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.28 [deprecated]</code></div><ul><li><p>Kubernetes version 1.10.0 or later is required</p></li><li><p>For version 1.29 and later, the v1 implementation of KMS is disabled by default.
To enable the feature, set <code>--feature-gates=KMSv1=true</code> to configure a KMS v1 provider.</p></li><li><p>Your cluster must use etcd v3 or later</p></li></ul><h3 id="kms-v2">KMS v2</h3><div class="feature-state-notice feature-stable"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.29 [stable]</code></div><ul><li>Your cluster must use etcd v3 or later</li></ul><h2 id="kms-encryption-and-per-object-encryption-keys">KMS encryption and per-object encryption keys</h2><p>The KMS encryption provider uses an envelope encryption scheme to encrypt data in etcd.
The data is encrypted using a data encryption key (DEK).
The DEKs are encrypted with a key encryption key (KEK) that is stored and managed in a remote KMS.</p><p>If you use the (deprecated) v1 implementation of KMS, a new DEK is generated for each encryption.</p><p>With KMS v2, a new DEK is generated <strong>per encryption</strong>: the API server uses a
<em>key derivation function</em> to generate single use data encryption keys from a secret seed
combined with some random data.
The seed is rotated whenever the KEK is rotated
(see the <em>Understanding key_id and Key Rotation</em> section below for more details).</p><p>The KMS provider uses gRPC to communicate with a specific KMS plugin over a UNIX domain socket.
The KMS plugin, which is implemented as a gRPC server and deployed on the same host(s)
as the Kubernetes control plane, is responsible for all communication with the remote KMS.</p><h2 id="configuring-the-kms-provider">Configuring the KMS provider</h2><p>To configure a KMS provider on the API server, include a provider of type <code>kms</code> in the
<code>providers</code> array in the encryption configuration file and set the following properties:</p><h3 id="configuring-the-kms-provider-kms-v1">KMS v1</h3><ul><li><code>apiVersion</code>: API Version for KMS provider. Leave this value empty or set it to <code>v1</code>.</li><li><code>name</code>: Display name of the KMS plugin. Cannot be changed once set.</li><li><code>endpoint</code>: Listen address of the gRPC server (KMS plugin). The endpoint is a UNIX domain socket.</li><li><code>cachesize</code>: Number of data encryption keys (DEKs) to be cached in the clear.
When cached, DEKs can be used without another call to the KMS;
whereas DEKs that are not cached require a call to the KMS to unwrap.</li><li><code>timeout</code>: How long should <code>kube-apiserver</code> wait for kms-plugin to respond before
returning an error (default is 3 seconds).</li></ul><h3 id="configuring-the-kms-provider-kms-v2">KMS v2</h3><ul><li><code>apiVersion</code>: API Version for KMS provider. Set this to <code>v2</code>.</li><li><code>name</code>: Display name of the KMS plugin. Cannot be changed once set.</li><li><code>endpoint</code>: Listen address of the gRPC server (KMS plugin). The endpoint is a UNIX domain socket.</li><li><code>timeout</code>: How long should <code>kube-apiserver</code> wait for kms-plugin to respond before
returning an error (default is 3 seconds).</li></ul><p>KMS v2 does not support the <code>cachesize</code> property. All data encryption keys (DEKs) will be cached in
the clear once the server has unwrapped them via a call to the KMS. Once cached, DEKs can be used
to perform decryption indefinitely without making a call to the KMS.</p><p>See <a href="/docs/tasks/administer-cluster/encrypt-data/">Understanding the encryption at rest configuration</a>.</p><h2 id="implementing-a-kms-plugin">Implementing a KMS plugin</h2><p>To implement a KMS plugin, you can develop a new plugin gRPC server or enable a KMS plugin
already provided by your cloud provider.
You then integrate the plugin with the remote KMS and deploy it on the Kubernetes control plane.</p><h3 id="enabling-the-kms-supported-by-your-cloud-provider">Enabling the KMS supported by your cloud provider</h3><p>Refer to your cloud provider for instructions on enabling the cloud provider-specific KMS plugin.</p><h3 id="developing-a-kms-plugin-grpc-server">Developing a KMS plugin gRPC server</h3><p>You can develop a KMS plugin gRPC server using a stub file available for Go. For other languages,
you use a proto file to create a stub file that you can use to develop the gRPC server code.</p><h4 id="developing-a-kms-plugin-gRPC-server-kms-v1">KMS v1</h4><ul><li><p>Using Go: Use the functions and data structures in the stub file:
<a href="https://github.com/kubernetes/kms/blob/release-1.34/apis/v1beta1/api.pb.go">api.pb.go</a>
to develop the gRPC server code</p></li><li><p>Using languages other than Go: Use the protoc compiler with the proto file:
<a href="https://github.com/kubernetes/kms/blob/release-1.34/apis/v1beta1/api.proto">api.proto</a>
to generate a stub file for the specific language</p></li></ul><h4 id="developing-a-kms-plugin-gRPC-server-kms-v2">KMS v2</h4><ul><li><p>Using Go: A high level
<a href="https://github.com/kubernetes/kms/blob/release-1.34/pkg/service/interface.go">library</a>
is provided to make the process easier. Low level implementations
can use the functions and data structures in the stub file:
<a href="https://github.com/kubernetes/kms/blob/release-1.34/apis/v2/api.pb.go">api.pb.go</a>
to develop the gRPC server code</p></li><li><p>Using languages other than Go: Use the protoc compiler with the proto file:
<a href="https://github.com/kubernetes/kms/blob/release-1.34/apis/v2/api.proto">api.proto</a>
to generate a stub file for the specific language</p></li></ul><p>Then use the functions and data structures in the stub file to develop the server code.</p><h4 id="notes">Notes</h4><h5 id="developing-a-kms-plugin-gRPC-server-notes-kms-v1">KMS v1</h5><ul><li><p>kms plugin version: <code>v1beta1</code></p><p>In response to procedure call Version, a compatible KMS plugin should return <code>v1beta1</code> as <code>VersionResponse.version</code>.</p></li><li><p>message version: <code>v1beta1</code></p><p>All messages from KMS provider have the version field set to <code>v1beta1</code>.</p></li><li><p>protocol: UNIX domain socket (<code>unix</code>)</p><p>The plugin is implemented as a gRPC server that listens at UNIX domain socket. The plugin deployment should create a file on the file system to run the gRPC unix domain socket connection. The API server (gRPC client) is configured with the KMS provider (gRPC server) unix domain socket endpoint in order to communicate with it. An abstract Linux socket may be used by starting the endpoint with <code>/@</code>, i.e. <code>unix:///@foo</code>. Care must be taken when using this type of socket as they do not have concept of ACL (unlike traditional file based sockets). However, they are subject to Linux networking namespace, so will only be accessible to containers within the same pod unless host networking is used.</p></li></ul><h5 id="developing-a-kms-plugin-gRPC-server-notes-kms-v2">KMS v2</h5><ul><li><p>KMS plugin version: <code>v2</code></p><p>In response to the <code>Status</code> remote procedure call, a compatible KMS plugin should return its KMS compatibility
version as <code>StatusResponse.version</code>. That status response should also include
"ok" as <code>StatusResponse.healthz</code> and a <code>key_id</code> (remote KMS KEK ID) as <code>StatusResponse.key_id</code>.
The Kubernetes project recommends you make your plugin
compatible with the stable <code>v2</code> KMS API. Kubernetes 1.34 also supports the
<code>v2beta1</code> API for KMS; future Kubernetes releases are likely to continue supporting that beta version.</p><p>The API server polls the <code>Status</code> procedure call approximately every minute when everything is healthy,
and every 10 seconds when the plugin is not healthy. Plugins must take care to optimize this call as it will be
under constant load.</p></li><li><p>Encryption</p><p>The <code>EncryptRequest</code> procedure call provides the plaintext and a UID for logging purposes. The response must include
the ciphertext, the <code>key_id</code> for the KEK used, and, optionally, any metadata that the KMS plugin needs to aid in
future <code>DecryptRequest</code> calls (via the <code>annotations</code> field). The plugin must guarantee that any distinct plaintext
results in a distinct response <code>(ciphertext, key_id, annotations)</code>.</p><p>If the plugin returns a non-empty <code>annotations</code> map, all map keys must be fully qualified domain names such as
<code>example.com</code>. An example use case of <code>annotation</code> is <code>{"kms.example.io/remote-kms-auditid":"&lt;audit ID used by the remote KMS&gt;"}</code></p><p>The API server does not perform the <code>EncryptRequest</code> procedure call at a high rate. Plugin implementations should
still aim to keep each request's latency at under 100 milliseconds.</p></li><li><p>Decryption</p><p>The <code>DecryptRequest</code> procedure call provides the <code>(ciphertext, key_id, annotations)</code> from <code>EncryptRequest</code> and a UID
for logging purposes. As expected, it is the inverse of the <code>EncryptRequest</code> call. Plugins must verify that the
<code>key_id</code> is one that they understand - they must not attempt to decrypt data unless they are sure that it was
encrypted by them at an earlier time.</p><p>The API server may perform thousands of <code>DecryptRequest</code> procedure calls on startup to fill its watch cache. Thus
plugin implementations must perform these calls as quickly as possible, and should aim to keep each request's latency
at under 10 milliseconds.</p></li><li><p>Understanding <code>key_id</code> and Key Rotation</p><p>The <code>key_id</code> is the public, non-secret name of the remote KMS KEK that is currently in use. It may be logged
during regular operation of the API server, and thus must not contain any private data. Plugin implementations
are encouraged to use a hash to avoid leaking any data. The KMS v2 metrics take care to hash this value before
exposing it via the <code>/metrics</code> endpoint.</p><p>The API server considers the <code>key_id</code> returned from the <code>Status</code> procedure call to be authoritative. Thus, a change
to this value signals to the API server that the remote KEK has changed, and data encrypted with the old KEK should
be marked stale when a no-op write is performed (as described below). If an <code>EncryptRequest</code> procedure call returns a
<code>key_id</code> that is different from <code>Status</code>, the response is thrown away and the plugin is considered unhealthy. Thus
implementations must guarantee that the <code>key_id</code> returned from <code>Status</code> will be the same as the one returned by
<code>EncryptRequest</code>. Furthermore, plugins must ensure that the <code>key_id</code> is stable and does not flip-flop between values
(i.e. during a remote KEK rotation).</p><p>Plugins must not re-use <code>key_id</code>s, even in situations where a previously used remote KEK has been reinstated. For
example, if a plugin was using <code>key_id=A</code>, switched to <code>key_id=B</code>, and then went back to <code>key_id=A</code> - instead of
reporting <code>key_id=A</code> the plugin should report some derivative value such as <code>key_id=A_001</code> or use a new value such
as <code>key_id=C</code>.</p><p>Since the API server polls <code>Status</code> about every minute, <code>key_id</code> rotation is not immediate. Furthermore, the API
server will coast on the last valid state for about three minutes. Thus if a user wants to take a passive approach
to storage migration (i.e. by waiting), they must schedule a migration to occur at <code>3 + N + M</code> minutes after the
remote KEK has been rotated (<code>N</code> is how long it takes the plugin to observe the <code>key_id</code> change and <code>M</code> is the
desired buffer to allow config changes to be processed - a minimum <code>M</code> of five minutes is recommend). Note that no
API server restart is required to perform KEK rotation.</p><div class="alert alert-caution" role="alert"><h4 class="alert-heading">Caution:</h4>Because you don't control the number of writes performed with the DEK,
the Kubernetes project recommends rotating the KEK at least every 90 days.</div></li><li><p>protocol: UNIX domain socket (<code>unix</code>)</p><p>The plugin is implemented as a gRPC server that listens at UNIX domain socket.
The plugin deployment should create a file on the file system to run the gRPC unix domain socket connection.
The API server (gRPC client) is configured with the KMS provider (gRPC server) unix
domain socket endpoint in order to communicate with it.
An abstract Linux socket may be used by starting the endpoint with <code>/@</code>, i.e. <code>unix:///@foo</code>.
Care must be taken when using this type of socket as they do not have concept of ACL
(unlike traditional file based sockets).
However, they are subject to Linux networking namespace, so will only be accessible to
containers within the same pod unless host networking is used.</p></li></ul><h3 id="integrating-a-kms-plugin-with-the-remote-kms">Integrating a KMS plugin with the remote KMS</h3><p>The KMS plugin can communicate with the remote KMS using any protocol supported by the KMS.
All configuration data, including authentication credentials the KMS plugin uses to communicate with the remote KMS,
are stored and managed by the KMS plugin independently.
The KMS plugin can encode the ciphertext with additional metadata that may be required before sending it to the KMS
for decryption (KMS v2 makes this process easier by providing a dedicated <code>annotations</code> field).</p><h3 id="deploying-the-kms-plugin">Deploying the KMS plugin</h3><p>Ensure that the KMS plugin runs on the same host(s) as the Kubernetes API server(s).</p><h2 id="encrypting-your-data-with-the-kms-provider">Encrypting your data with the KMS provider</h2><p>To encrypt the data:</p><ol><li><p>Create a new <code>EncryptionConfiguration</code> file using the appropriate properties for the <code>kms</code> provider
to encrypt resources like Secrets and ConfigMaps. If you want to encrypt an extension API that is
defined in a CustomResourceDefinition, your cluster must be running Kubernetes v1.26 or newer.</p></li><li><p>Set the <code>--encryption-provider-config</code> flag on the kube-apiserver to point to the location of the configuration file.</p></li><li><p><code>--encryption-provider-config-automatic-reload</code> boolean argument
determines if the file set by <code>--encryption-provider-config</code> should be
<a href="/docs/tasks/administer-cluster/encrypt-data/#configure-automatic-reloading">automatically reloaded</a>
if the disk contents change.</p></li><li><p>Restart your API server.</p></li></ol><h3 id="encrypting-your-data-with-the-kms-provider-kms-v1">KMS v1</h3><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>apiserver.config.k8s.io/v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>EncryptionConfiguration<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">resources</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span>- <span style="color:green;font-weight:700">resources</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span>- secrets<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span>- configmaps<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span>- pandas.awesome.bears.example<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">providers</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span>- <span style="color:green;font-weight:700">kms</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">          </span><span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>myKmsPluginFoo<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">          </span><span style="color:green;font-weight:700">endpoint</span>:<span style="color:#bbb"> </span>unix:///tmp/socketfile-foo.sock<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">          </span><span style="color:green;font-weight:700">cachesize</span>:<span style="color:#bbb"> </span><span style="color:#666">100</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">          </span><span style="color:green;font-weight:700">timeout</span>:<span style="color:#bbb"> </span>3s<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span>- <span style="color:green;font-weight:700">kms</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">          </span><span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>myKmsPluginBar<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">          </span><span style="color:green;font-weight:700">endpoint</span>:<span style="color:#bbb"> </span>unix:///tmp/socketfile-bar.sock<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">          </span><span style="color:green;font-weight:700">cachesize</span>:<span style="color:#bbb"> </span><span style="color:#666">100</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">          </span><span style="color:green;font-weight:700">timeout</span>:<span style="color:#bbb"> </span>3s<span style="color:#bbb">
</span></span></span></code></pre></div><h3 id="encrypting-your-data-with-the-kms-provider-kms-v2">KMS v2</h3><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>apiserver.config.k8s.io/v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>EncryptionConfiguration<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">resources</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span>- <span style="color:green;font-weight:700">resources</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span>- secrets<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span>- configmaps<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span>- pandas.awesome.bears.example<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">providers</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span>- <span style="color:green;font-weight:700">kms</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">          </span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>v2<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">          </span><span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>myKmsPluginFoo<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">          </span><span style="color:green;font-weight:700">endpoint</span>:<span style="color:#bbb"> </span>unix:///tmp/socketfile-foo.sock<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">          </span><span style="color:green;font-weight:700">timeout</span>:<span style="color:#bbb"> </span>3s<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span>- <span style="color:green;font-weight:700">kms</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">          </span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>v2<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">          </span><span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>myKmsPluginBar<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">          </span><span style="color:green;font-weight:700">endpoint</span>:<span style="color:#bbb"> </span>unix:///tmp/socketfile-bar.sock<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">          </span><span style="color:green;font-weight:700">timeout</span>:<span style="color:#bbb"> </span>3s<span style="color:#bbb">
</span></span></span></code></pre></div><p>Setting <code>--encryption-provider-config-automatic-reload</code> to <code>true</code> collapses all health checks to a single health check endpoint. Individual health checks are only available when KMS v1 providers are in use and the encryption config is not auto-reloaded.</p><p>The following table summarizes the health check endpoints for each KMS version:</p><table><thead><tr><th>KMS configurations</th><th>Without Automatic Reload</th><th>With Automatic Reload</th></tr></thead><tbody><tr><td>KMS v1 only</td><td>Individual Healthchecks</td><td>Single Healthcheck</td></tr><tr><td>KMS v2 only</td><td>Single Healthcheck</td><td>Single Healthcheck</td></tr><tr><td>Both KMS v1 and v2</td><td>Individual Healthchecks</td><td>Single Healthcheck</td></tr><tr><td>No KMS</td><td>None</td><td>Single Healthcheck</td></tr></tbody></table><p><code>Single Healthcheck</code> means that the only health check endpoint is <code>/healthz/kms-providers</code>.</p><p><code>Individual Healthchecks</code> means that each KMS plugin has an associated health check endpoint based on its location in the encryption config: <code>/healthz/kms-provider-0</code>, <code>/healthz/kms-provider-1</code> etc.</p><p>These healthcheck endpoint paths are hard coded and generated/controlled by the server. The indices for individual healthchecks corresponds to the order in which the KMS encryption config is processed.</p><p>Until the steps defined in <a href="#ensuring-all-secrets-are-encrypted">Ensuring all secrets are encrypted</a> are performed, the <code>providers</code> list should end with the <code>identity: {}</code> provider to allow unencrypted data to be read. Once all resources are encrypted, the <code>identity</code> provider should be removed to prevent the API server from honoring unencrypted data.</p><p>For details about the <code>EncryptionConfiguration</code> format, please check the
<a href="/docs/reference/config-api/apiserver-config.v1/">API server encryption API reference</a>.</p><h2 id="verifying-that-the-data-is-encrypted">Verifying that the data is encrypted</h2><p>When encryption at rest is correctly configured, resources are encrypted on write.
After restarting your <code>kube-apiserver</code>, any newly created or updated Secret or other resource types
configured in <code>EncryptionConfiguration</code> should be encrypted when stored. To verify,
you can use the <code>etcdctl</code> command line program to retrieve the contents of your secret data.</p><ol><li><p>Create a new secret called <code>secret1</code> in the <code>default</code> namespace:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl create secret generic secret1 -n default --from-literal<span style="color:#666">=</span><span style="color:#b8860b">mykey</span><span style="color:#666">=</span>mydata
</span></span></code></pre></div></li><li><p>Using the <code>etcdctl</code> command line, read that secret out of etcd:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span><span style="color:#b8860b">ETCDCTL_API</span><span style="color:#666">=</span><span style="color:#666">3</span> etcdctl get /kubernetes.io/secrets/default/secret1 <span style="color:#666">[</span>...<span style="color:#666">]</span> | hexdump -C
</span></span></code></pre></div><p>where <code>[...]</code> contains the additional arguments for connecting to the etcd server.</p></li><li><p>Verify the stored secret is prefixed with <code>k8s:enc:kms:v1:</code> for KMS v1 or prefixed with <code>k8s:enc:kms:v2:</code> for KMS v2, which indicates that the <code>kms</code> provider has encrypted the resulting data.</p></li><li><p>Verify that the secret is correctly decrypted when retrieved via the API:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl describe secret secret1 -n default
</span></span></code></pre></div><p>The Secret should contain <code>mykey: mydata</code></p></li></ol><h2 id="ensuring-all-secrets-are-encrypted">Ensuring all secrets are encrypted</h2><p>When encryption at rest is correctly configured, resources are encrypted on write.
Thus we can perform an in-place no-op update to ensure that data is encrypted.</p><p>The following command reads all secrets and then updates them to apply server side encryption.
If an error occurs due to a conflicting write, retry the command.
For larger clusters, you may wish to subdivide the secrets by namespace or script an update.</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl get secrets --all-namespaces -o json | kubectl replace -f -
</span></span></code></pre></div><h2 id="switching-from-a-local-encryption-provider-to-the-kms-provider">Switching from a local encryption provider to the KMS provider</h2><p>To switch from a local encryption provider to the <code>kms</code> provider and re-encrypt all of the secrets:</p><ol><li><p>Add the <code>kms</code> provider as the first entry in the configuration file as shown in the following example.</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>apiserver.config.k8s.io/v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>EncryptionConfiguration<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">resources</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span>- <span style="color:green;font-weight:700">resources</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span>- secrets<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">providers</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span>- <span style="color:green;font-weight:700">kms</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">          </span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>v2<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">          </span><span style="color:green;font-weight:700">name </span>:<span style="color:#bbb"> </span>myKmsPlugin<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">          </span><span style="color:green;font-weight:700">endpoint</span>:<span style="color:#bbb"> </span>unix:///tmp/socketfile.sock<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span>- <span style="color:green;font-weight:700">aescbc</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">          </span><span style="color:green;font-weight:700">keys</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">            </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>key1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">              </span><span style="color:green;font-weight:700">secret</span>:<span style="color:#bbb"> </span>&lt;BASE 64 ENCODED SECRET&gt;<span style="color:#bbb">
</span></span></span></code></pre></div></li><li><p>Restart all <code>kube-apiserver</code> processes.</p></li><li><p>Run the following command to force all secrets to be re-encrypted using the <code>kms</code> provider.</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl get secrets --all-namespaces -o json | kubectl replace -f -
</span></span></code></pre></div></li></ol><h2 id="what-s-next">What's next</h2><a id="disabling-encryption-at-rest"><p>If you no longer want to use encryption for data persisted in the Kubernetes API, read
<a href="/docs/tasks/administer-cluster/decrypt-data/">decrypt data that are already stored at rest</a>.</p></a></div>