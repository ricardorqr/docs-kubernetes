<div class="td-content"><h1 data-pagefind-weight="10">Resize CPU and Memory Resources assigned to Containers</h1><div class="feature-state-notice feature-beta" title="Feature Gate: InPlacePodVerticalScaling"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.33 [beta]</code> (enabled by default: true)</div><p>This page explains how to change the CPU and memory resource requests and limits
assigned to a container <em>without recreating the Pod</em>.</p><p>Traditionally, changing a Pod's resource requirements necessitated deleting the existing Pod
and creating a replacement, often managed by a <a href="/docs/concepts/workloads/controllers/">workload controller</a>.
In-place Pod Resize allows changing the CPU/memory allocation of container(s) within a running Pod
while potentially avoiding application disruption.</p><p><strong>Key Concepts:</strong></p><ul><li><strong>Desired Resources:</strong> A container's <code>spec.containers[*].resources</code> represent
the <em>desired</em> resources for the container, and are mutable for CPU and memory.</li><li><strong>Actual Resources:</strong> The <code>status.containerStatuses[*].resources</code> field
reflects the resources <em>currently configured</em> for a running container.
For containers that haven't started or were restarted,
it reflects the resources allocated upon their next start.</li><li><strong>Triggering a Resize:</strong> You can request a resize by updating the desired <code>requests</code>
and <code>limits</code> in the Pod's specification.
This is typically done using <code>kubectl patch</code>, <code>kubectl apply</code>, or <code>kubectl edit</code>
targeting the Pod's <code>resize</code> subresource.
When the desired resources don't match the allocated resources,
the Kubelet will attempt to resize the container.</li><li><strong>Allocated Resources (Advanced):</strong>
The <code>status.containerStatuses[*].allocatedResources</code> field tracks resource values
confirmed by the Kubelet, primarily used for internal scheduling logic.
For most monitoring and validation purposes, focus on <code>status.containerStatuses[*].resources</code>.</li></ul><p>If a node has pods with a pending or incomplete resize (see <a href="#pod-resize-status">Pod Resize Status</a> below),
the <a class="glossary-tooltip" title="Control plane component that watches for newly created pods with no assigned node, and selects a node for them to run on." data-toggle="tooltip" data-placement="top" href="/docs/reference/command-line-tools-reference/kube-scheduler/" target="_blank" aria-label="scheduler">scheduler</a> uses
the <em>maximum</em> of a container's desired requests, allocated requests,
and actual requests from the status when making scheduling decisions.</p><h2 id="before-you-begin">Before you begin</h2><p><p>You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. It is recommended to run this tutorial on a cluster with at least two nodes that are not acting as control plane hosts. If you do not already have a
cluster, you can create one by using
<a href="https://minikube.sigs.k8s.io/docs/tutorials/multi_node/">minikube</a>
or you can use one of these Kubernetes playgrounds:</p><ul><li><a href="https://labs.iximiuz.com/playgrounds?category=kubernetes&amp;filter=all">iximiuz Labs</a></li><li><a href="https://killercoda.com/playgrounds/scenario/kubernetes">Killercoda</a></li><li><a href="https://kodekloud.com/public-playgrounds">KodeKloud</a></li><li><a href="https://labs.play-with-k8s.com/">Play with Kubernetes</a></li></ul>Your Kubernetes server must be at or later than version 1.33.<p>To check the version, enter <code>kubectl version</code>.</p></p><p>The <code>InPlacePodVerticalScaling</code> <a href="/docs/reference/command-line-tools-reference/feature-gates/">feature gate</a>
must be enabled
for your control plane and for all nodes in your cluster.</p><p>The <code>kubectl</code> client version must be at least v1.32 to use the <code>--subresource=resize</code> flag.</p><h2 id="pod-resize-status">Pod resize status</h2><p>The Kubelet updates the Pod's status conditions to indicate the state of a resize request:</p><ul><li><code>type: PodResizePending</code>: The Kubelet cannot immediately grant the request.
The <code>message</code> field provides an explanation of why.<ul><li><code>reason: Infeasible</code>: The requested resize is impossible on the current node
(for example, requesting more resources than the node has).</li><li><code>reason: Deferred</code>: The requested resize is currently not possible,
but might become feasible later (for example if another pod is removed).
The Kubelet will retry the resize.</li></ul></li><li><code>type: PodResizeInProgress</code>: The Kubelet has accepted the resize and allocated resources,
but the changes are still being applied.
This is usually brief but might take longer depending on the resource type and runtime behavior.
Any errors during actuation are reported in the <code>message</code> field (along with <code>reason: Error</code>).</li></ul><h3 id="how-kubelet-retries-deferred-resizes">How kubelet retries Deferred resizes</h3><p>If the requested resize is <em>Deferred</em>, the kubelet will periodically re-attempt the resize,
for example when another pod is removed or scaled down. If there are multiple deferred
resizes, they are retried according to the following priority:</p><ul><li>Pods with a higher Priority (based on PriorityClass) will have their resize request retried first.</li><li>If two pods have the same Priority, resize of guaranteed pods will be retried before the resize of burstable pods.</li><li>If all else is the same, pods that have been in the Deferred state longer will be prioritized.</li></ul><p>A higher priority resize being marked as pending will not block the remaining pending resizes from being attempted;
all remaining pending resizes will still be retried even if a higher-priority resize gets deferred again.</p><h3 id="leveraging-observedgeneration-fields">Leveraging <code>observedGeneration</code> Fields</h3><div class="feature-state-notice feature-beta" title="Feature Gate: PodObservedGenerationTracking"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.34 [beta]</code> (enabled by default: true)</div><ul><li>The top-level <code>status.observedGeneration</code> field shows the <code>metadata.generation</code> corresponding to the latest pod specification that the kubelet has acknowledged. You can use this to determine the most recent resize request the kubelet has processed.</li><li>In the <code>PodResizeInProgress</code> condition, the <code>conditions[].observedGeneration</code> field indicates the <code>metadata.generation</code> of the podSpec when the current in-progress resize was initiated.</li><li>In the <code>PodResizePending</code> condition, the <code>conditions[].observedGeneration</code> field indicates the <code>metadata.generation</code> of the podSpec when the pending resize's allocation was last attempted.</li></ul><h2 id="container-resize-policies">Container resize policies</h2><p>You can control whether a container should be restarted when resizing
by setting <code>resizePolicy</code> in the container specification.
This allows fine-grained control based on resource type (CPU or memory).</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">resizePolicy</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span>- <span style="color:green;font-weight:700">resourceName</span>:<span style="color:#bbb"> </span>cpu<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">restartPolicy</span>:<span style="color:#bbb"> </span>NotRequired<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span>- <span style="color:green;font-weight:700">resourceName</span>:<span style="color:#bbb"> </span>memory<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">restartPolicy</span>:<span style="color:#bbb"> </span>RestartContainer<span style="color:#bbb">
</span></span></span></code></pre></div><ul><li><code>NotRequired</code>: (Default) Apply the resource change to the running container without restarting it.</li><li><code>RestartContainer</code>: Restart the container to apply the new resource values.
This is often necessary for memory changes because many applications
and runtimes cannot adjust their memory allocation dynamically.</li></ul><p>If <code>resizePolicy[*].restartPolicy</code> is not specified for a resource, it defaults to <code>NotRequired</code>.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>If a Pod's overall <code>restartPolicy</code> is <code>Never</code>, then any container <code>resizePolicy</code> must be <code>NotRequired</code> for all resources.
You cannot configure a resize policy that would require a restart in such Pods.</div><p><strong>Example Scenario:</strong></p><p>Consider a container configured with <code>restartPolicy: NotRequired</code> for CPU and <code>restartPolicy: RestartContainer</code> for memory.</p><ul><li>If only CPU resources are changed, the container is resized in-place.</li><li>If only memory resources are changed, the container is restarted.</li><li>If <em>both</em> CPU and memory resources are changed simultaneously, the container is restarted (due to the memory policy).</li></ul><h2 id="limitations">Limitations</h2><p>For Kubernetes 1.34, resizing pod resources in-place has the following limitations:</p><ul><li><strong>Resource Types:</strong> Only CPU and memory resources can be resized.</li><li><strong>Memory Decrease:</strong> If the memory resize restart policy is <code>NotRequired</code> (or unspecified), the kubelet will make a
best-effort attempt to prevent oom-kills when decreasing memory limits, but doesn't provide any guarantees.
Before decreasing container memory limits, if memory usage exceeds the requested limit, the resize will be skipped
and the status will remain in an "In Progress" state. This is considered best-effort because it is still subject
to a race condition where memory usage may spike right after the check is performed.</li><li><strong>QoS Class:</strong> The Pod's original <a href="/docs/concepts/workloads/pods/pod-qos/">Quality of Service (QoS) class</a>
(Guaranteed, Burstable, or BestEffort) is determined at creation and <strong>cannot</strong> be changed by a resize.
The resized resource values must still adhere to the rules of the original QoS class:<ul><li><em>Guaranteed</em>: Requests must continue to equal limits for both CPU and memory after resizing.</li><li><em>Burstable</em>: Requests and limits cannot become equal for <em>both</em> CPU and memory simultaneously
(as this would change it to Guaranteed).</li><li><em>BestEffort</em>: Resource requirements (<code>requests</code> or <code>limits</code>) cannot be added
(as this would change it to Burstable or Guaranteed).</li></ul></li><li><strong>Container Types:</strong> Non-restartable <a class="glossary-tooltip" title="One or more initialization containers that must run to completion before any app containers run." data-toggle="tooltip" data-placement="top" href="/docs/concepts/workloads/pods/init-containers/" target="_blank" aria-label="init containers">init containers</a> and
<a class="glossary-tooltip" title="A type of container type that you can temporarily run inside a Pod" data-toggle="tooltip" data-placement="top" href="/docs/concepts/workloads/pods/ephemeral-containers/" target="_blank" aria-label="ephemeral containers">ephemeral containers</a> cannot be resized.
<a href="/docs/concepts/workloads/pods/sidecar-containers/">Sidecar containers</a> can be resized.</li><li><strong>Resource Removal:</strong> Resource requests and limits cannot be entirely removed once set;
they can only be changed to different values.</li><li><strong>Operating System:</strong> Windows pods do not support in-place resize.</li><li><strong>Node Policies:</strong> Pods managed by <a href="/docs/tasks/administer-cluster/cpu-management-policies/">static CPU or Memory manager policies</a>
cannot be resized in-place.</li><li><strong>Swap:</strong> Pods utilizing <a href="/docs/concepts/architecture/nodes/#swap-memory">swap memory</a> cannot resize memory requests
unless the <code>resizePolicy</code> for memory is <code>RestartContainer</code>.</li></ul><p>These restrictions might be relaxed in future Kubernetes versions.</p><h2 id="example-1-resizing-cpu-without-restart">Example 1: Resizing CPU without restart</h2><p>First, create a Pod designed for in-place CPU resize and restart-required memory resize.</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/pods/resource/pod-resize.yaml" download="pods/resource/pod-resize.yaml"><code>pods/resource/pod-resize.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" onclick="copyCode(&quot;pods-resource-pod-resize-yaml&quot;)" title="Copy pods/resource/pod-resize.yaml to clipboard"/></div><div class="includecode" id="pods-resource-pod-resize-yaml"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>Pod<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">metadata</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>resize-demo<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">spec</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">containers</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>pause<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">image</span>:<span style="color:#bbb"> </span>registry.k8s.io/pause:3.8<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">resizePolicy</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span>- <span style="color:green;font-weight:700">resourceName</span>:<span style="color:#bbb"> </span>cpu<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">restartPolicy</span>:<span style="color:#bbb"> </span>NotRequired<span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># Default, but explicit here</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span>- <span style="color:green;font-weight:700">resourceName</span>:<span style="color:#bbb"> </span>memory<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">restartPolicy</span>:<span style="color:#bbb"> </span>RestartContainer<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">resources</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">limits</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">memory</span>:<span style="color:#bbb"> </span><span style="color:#b44">"200Mi"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">cpu</span>:<span style="color:#bbb"> </span><span style="color:#b44">"700m"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">requests</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">memory</span>:<span style="color:#bbb"> </span><span style="color:#b44">"200Mi"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">cpu</span>:<span style="color:#bbb"> </span><span style="color:#b44">"700m"</span><span style="color:#bbb">
</span></span></span></code></pre></div></div></div><p>Create the pod:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl create -f pod-resize.yaml
</span></span></code></pre></div><p>This pod starts in the Guaranteed QoS class. Verify its initial state:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span><span style="color:#080;font-style:italic"># Wait a moment for the pod to be running</span>
</span></span><span style="display:flex"><span>kubectl get pod resize-demo --output<span style="color:#666">=</span>yaml
</span></span></code></pre></div><p>Observe the <code>spec.containers[0].resources</code> and <code>status.containerStatuses[0].resources</code>.
They should match the manifest (700m CPU, 200Mi memory). Note the <code>status.containerStatuses[0].restartCount</code> (should be 0).</p><p>Now, increase the CPU request and limit to <code>800m</code>. You use <code>kubectl patch</code> with the <code>--subresource resize</code> command line argument.</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl patch pod resize-demo --subresource resize --patch <span style="color:#b62;font-weight:700">\
</span></span></span><span style="display:flex"><span><span style="color:#b62;font-weight:700"/>  <span style="color:#b44">'{"spec":{"containers":[{"name":"pause", "resources":{"requests":{"cpu":"800m"}, "limits":{"cpu":"800m"}}}]}}'</span>
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"># Alternative methods:</span>
</span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"># kubectl -n qos-example edit pod resize-demo --subresource resize</span>
</span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"># kubectl -n qos-example apply -f &lt;updated-manifest&gt; --subresource resize --server-side</span>
</span></span></code></pre></div><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>The <code>--subresource resize</code> command line argument requires <code>kubectl</code> client version v1.32.0 or later.
Older versions will report an <code>invalid subresource</code> error.</div><p>Check the pod status again after patching:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl get pod resize-demo --output<span style="color:#666">=</span>yaml --namespace<span style="color:#666">=</span>qos-example
</span></span></code></pre></div><p>You should see:</p><ul><li><code>spec.containers[0].resources</code> now shows <code>cpu: 800m</code>.</li><li><code>status.containerStatuses[0].resources</code> also shows <code>cpu: 800m</code>, indicating the resize was successful on the node.</li><li><code>status.containerStatuses[0].restartCount</code> remains <code>0</code>, because the CPU <code>resizePolicy</code> was <code>NotRequired</code>.</li></ul><h2 id="example-2-resizing-memory-with-restart">Example 2: Resizing memory with restart</h2><p>Now, resize the memory for the <em>same</em> pod by increasing it to <code>300Mi</code>.
Since the memory <code>resizePolicy</code> is <code>RestartContainer</code>, the container is expected to restart.</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl patch pod resize-demo --subresource resize --patch <span style="color:#b62;font-weight:700">\
</span></span></span><span style="display:flex"><span><span style="color:#b62;font-weight:700"/>  <span style="color:#b44">'{"spec":{"containers":[{"name":"pause", "resources":{"requests":{"memory":"300Mi"}, "limits":{"memory":"300Mi"}}}]}}'</span>
</span></span></code></pre></div><p>Check the pod status shortly after patching:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl get pod resize-demo --output<span style="color:#666">=</span>yaml
</span></span></code></pre></div><p>You should now observe:</p><ul><li><code>spec.containers[0].resources</code> shows <code>memory: 300Mi</code>.</li><li><code>status.containerStatuses[0].resources</code> also shows <code>memory: 300Mi</code>.</li><li><code>status.containerStatuses[0].restartCount</code> has increased to <code>1</code> (or more, if restarts happened previously),
indicating the container was restarted to apply the memory change.</li></ul><h2 id="troubleshooting-infeasible-resize-request">Troubleshooting: Infeasible resize request</h2><p>Next, try requesting an unreasonable amount of CPU, such as 1000 full cores (written as <code>"1000"</code> instead of <code>"1000m"</code> for millicores), which likely exceeds node capacity.</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span><span style="color:#080;font-style:italic"># Attempt to patch with an excessively large CPU request</span>
</span></span><span style="display:flex"><span>kubectl patch pod resize-demo --subresource resize --patch <span style="color:#b62;font-weight:700">\
</span></span></span><span style="display:flex"><span><span style="color:#b62;font-weight:700"/>  <span style="color:#b44">'{"spec":{"containers":[{"name":"pause", "resources":{"requests":{"cpu":"1000"}, "limits":{"cpu":"1000"}}}]}}'</span>
</span></span></code></pre></div><p>Query the Pod's details:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl get pod resize-demo --output<span style="color:#666">=</span>yaml
</span></span></code></pre></div><p>You'll see changes indicating the problem:</p><ul><li>The <code>spec.containers[0].resources</code> reflects the <em>desired</em> state (<code>cpu: "1000"</code>).</li><li>A condition with <code>type: PodResizePending</code> and <code>reason: Infeasible</code> was added to the Pod.</li><li>The condition's <code>message</code> will explain why (<code>Node didn't have enough capacity: cpu, requested: 800000, capacity: ...</code>)</li><li>Crucially, <code>status.containerStatuses[0].resources</code> will <em>still show the previous values</em> (<code>cpu: 800m</code>, <code>memory: 300Mi</code>),
because the infeasible resize was not applied by the Kubelet.</li><li>The <code>restartCount</code> will not have changed due to this failed attempt.</li></ul><p>To fix this, you would need to patch the pod again with feasible resource values.</p><h2 id="clean-up">Clean up</h2><p>Delete the pod:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl delete pod resize-demo
</span></span></code></pre></div><h2 id="what-s-next">What's next</h2><h3 id="for-application-developers">For application developers</h3><ul><li><p><a href="/docs/tasks/configure-pod-container/assign-memory-resource/">Assign Memory Resources to Containers and Pods</a></p></li><li><p><a href="/docs/tasks/configure-pod-container/assign-cpu-resource/">Assign CPU Resources to Containers and Pods</a></p></li><li><p><a href="/docs/tasks/configure-pod-container/assign-pod-level-resources/">Assign Pod-level CPU and memory resources</a></p></li></ul><h3 id="for-cluster-administrators">For cluster administrators</h3><ul><li><p><a href="/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/">Configure Default Memory Requests and Limits for a Namespace</a></p></li><li><p><a href="/docs/tasks/administer-cluster/manage-resources/cpu-default-namespace/">Configure Default CPU Requests and Limits for a Namespace</a></p></li><li><p><a href="/docs/tasks/administer-cluster/manage-resources/memory-constraint-namespace/">Configure Minimum and Maximum Memory Constraints for a Namespace</a></p></li><li><p><a href="/docs/tasks/administer-cluster/manage-resources/cpu-constraint-namespace/">Configure Minimum and Maximum CPU Constraints for a Namespace</a></p></li><li><p><a href="/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/">Configure Memory and CPU Quotas for a Namespace</a></p></li></ul></div>