<div class="td-content"><h1 data-pagefind-weight="10">Good practices for Kubernetes Secrets</h1><div class="lead">Principles and practices for good Secret management for cluster administrators and application developers.</div><p><p>In Kubernetes, a Secret is an object that stores sensitive information, such as passwords, OAuth tokens, and SSH keys.</p></p><p>Secrets give you more control over how sensitive information is used and reduces
the risk of accidental exposure. Secret values are encoded as base64 strings and
are stored unencrypted by default, but can be configured to be
<a href="/docs/tasks/administer-cluster/encrypt-data/#ensure-all-secrets-are-encrypted">encrypted at rest</a>.</p><p>A <a class="glossary-tooltip" title="A Pod represents a set of running containers in your cluster." data-toggle="tooltip" data-placement="top" href="/docs/concepts/workloads/pods/" target="_blank" aria-label="Pod">Pod</a> can reference the Secret in
a variety of ways, such as in a volume mount or as an environment variable.
Secrets are designed for confidential data and
<a href="/docs/tasks/configure-pod-container/configure-pod-configmap/">ConfigMaps</a> are
designed for non-confidential data.</p><p>The following good practices are intended for both cluster administrators and
application developers. Use these guidelines to improve the security of your
sensitive information in Secret objects, as well as to more effectively manage
your Secrets.</p><h2 id="cluster-administrators">Cluster administrators</h2><p>This section provides good practices that cluster administrators can use to
improve the security of confidential information in the cluster.</p><h3 id="configure-encryption-at-rest">Configure encryption at rest</h3><p>By default, Secret objects are stored unencrypted in <a class="glossary-tooltip" title="Consistent and highly-available key value store used as backing store of Kubernetes for all cluster data." data-toggle="tooltip" data-placement="top" href="/docs/tasks/administer-cluster/configure-upgrade-etcd/" target="_blank" aria-label="etcd">etcd</a>. You should configure encryption of your Secret
data in <code>etcd</code>. For instructions, refer to
<a href="/docs/tasks/administer-cluster/encrypt-data/">Encrypt Secret Data at Rest</a>.</p><h3 id="least-privilege-secrets">Configure least-privilege access to Secrets</h3><p>When planning your access control mechanism, such as Kubernetes
<a class="glossary-tooltip" title="Manages authorization decisions, allowing admins to dynamically configure access policies through the Kubernetes API." data-toggle="tooltip" data-placement="top" href="/docs/reference/access-authn-authz/rbac/" target="_blank" aria-label="Role-based Access Control">Role-based Access Control</a> <a href="/docs/reference/access-authn-authz/rbac/">(RBAC)</a>,
consider the following guidelines for access to <code>Secret</code> objects. You should
also follow the other guidelines in
<a href="/docs/concepts/security/rbac-good-practices/">RBAC good practices</a>.</p><ul><li><strong>Components</strong>: Restrict <code>watch</code> or <code>list</code> access to only the most
privileged, system-level components. Only grant <code>get</code> access for Secrets if
the component's normal behavior requires it.</li><li><strong>Humans</strong>: Restrict <code>get</code>, <code>watch</code>, or <code>list</code> access to Secrets. Only allow
cluster administrators to access <code>etcd</code>. This includes read-only access. For
more complex access control, such as restricting access to Secrets with
specific annotations, consider using third-party authorization mechanisms.</li></ul><div class="alert alert-caution" role="alert"><h4 class="alert-heading">Caution:</h4>Granting <code>list</code> access to Secrets implicitly lets the subject fetch the
contents of the Secrets.</div><p>A user who can create a Pod that uses a Secret can also see the value of that
Secret. Even if cluster policies do not allow a user to read the Secret
directly, the same user could have access to run a Pod that then exposes the
Secret. You can detect or limit the impact caused by Secret data being exposed,
either intentionally or unintentionally, by a user with this access. Some
recommendations include:</p><ul><li>Use short-lived Secrets</li><li>Implement audit rules that alert on specific events, such as concurrent
reading of multiple Secrets by a single user</li></ul><h4 id="restrict-access-for-secrets">Restrict Access for Secrets</h4><p>Use separate namespaces to isolate access to mounted secrets.</p><h3 id="improve-etcd-management-policies">Improve etcd management policies</h3><p>Consider wiping or shredding the durable storage used by <code>etcd</code> once it is
no longer in use.</p><p>If there are multiple <code>etcd</code> instances, configure encrypted SSL/TLS
communication between the instances to protect the Secret data in transit.</p><h3 id="configure-access-to-external-secrets">Configure access to external Secrets</h3><div class="alert alert-secondary callout third-party-content" role="alert"><strong>Note:</strong>â€ˆThis section links to third party projects that provide functionality required by Kubernetes. The Kubernetes project authors aren't responsible for these projects, which are listed alphabetically. To add a project to this list, read the <a href="/docs/contribute/style/content-guide/#third-party-content">content guide</a> before submitting a change. <a href="#third-party-content-disclaimer">More information.</a></div><p>You can use third-party Secrets store providers to keep your confidential data
outside your cluster and then configure Pods to access that information.
The <a href="https://secrets-store-csi-driver.sigs.k8s.io/">Kubernetes Secrets Store CSI Driver</a>
is a DaemonSet that lets the kubelet retrieve Secrets from external stores, and
mount the Secrets as a volume into specific Pods that you authorize to access
the data.</p><p>For a list of supported providers, refer to
<a href="https://secrets-store-csi-driver.sigs.k8s.io/concepts.html#provider-for-the-secrets-store-csi-driver">Providers for the Secret Store CSI Driver</a>.</p><h2 id="good-practices-for-using-swap-memory">Good practices for using swap memory</h2><p>For best practices for setting swap memory for Linux nodes, please refer to
<a href="/docs/concepts/cluster-administration/swap-memory-management/#good-practice-for-using-swap-in-a-kubernetes-cluster">swap memory management</a>.</p><h2 id="developers">Developers</h2><p>This section provides good practices for developers to use to improve the
security of confidential data when building and deploying Kubernetes resources.</p><h3 id="restrict-secret-access-to-specific-containers">Restrict Secret access to specific containers</h3><p>If you are defining multiple containers in a Pod, and only one of those
containers needs access to a Secret, define the volume mount or environment
variable configuration so that the other containers do not have access to that
Secret.</p><h3 id="protect-secret-data-after-reading">Protect Secret data after reading</h3><p>Applications still need to protect the value of confidential information after
reading it from an environment variable or volume. For example, your
application must avoid logging the secret data in the clear or transmitting it
to an untrusted party.</p><h3 id="avoid-sharing-secret-manifests">Avoid sharing Secret manifests</h3><p>If you configure a Secret through a
<a class="glossary-tooltip" title="A serialized specification of one or more Kubernetes API objects." data-toggle="tooltip" data-placement="top" href="/docs/reference/glossary/?all=true#term-manifest" target="_blank" aria-label="manifest">manifest</a>, with the secret
data encoded as base64, sharing this file or checking it in to a source
repository means the secret is available to everyone who can read the manifest.</p><div class="alert alert-caution" role="alert"><h4 class="alert-heading">Caution:</h4>Base64 encoding is <em>not</em> an encryption method, it provides no additional
confidentiality over plain text.</div></div>