<div class="td-content"><h1 data-pagefind-weight="10">Security Checklist</h1><div class="lead">Baseline checklist for ensuring security in Kubernetes clusters.</div><p>This checklist aims at providing a basic list of guidance with links to more
comprehensive documentation on each topic. It does not claim to be exhaustive
and is meant to evolve.</p><p>On how to read and use this document:</p><ul><li>The order of topics does not reflect an order of priority.</li><li>Some checklist items are detailed in the paragraph below the list of each section.</li></ul><div class="alert alert-caution" role="alert"><h4 class="alert-heading">Caution:</h4>Checklists are <strong>not</strong> sufficient for attaining a good security posture on their
own. A good security posture requires constant attention and improvement, but a
checklist can be the first step on the never-ending journey towards security
preparedness. Some of the recommendations in this checklist may be too
restrictive or too lax for your specific security needs. Since Kubernetes
security is not "one size fits all", each category of checklist items should be
evaluated on its merits.</div><h2 id="authentication-authorization">Authentication &amp; Authorization</h2><ul><li><input disabled="" type="checkbox"/> <code>system:masters</code> group is not used for user or component authentication after bootstrapping.</li><li><input disabled="" type="checkbox"/> The kube-controller-manager is running with <code>--use-service-account-credentials</code>
enabled.</li><li><input disabled="" type="checkbox"/> The root certificate is protected (either an offline CA, or a managed
online CA with effective access controls).</li><li><input disabled="" type="checkbox"/> Intermediate and leaf certificates have an expiry date no more than 3
years in the future.</li><li><input disabled="" type="checkbox"/> A process exists for periodic access review, and reviews occur no more
than 24 months apart.</li><li><input disabled="" type="checkbox"/> The <a href="/docs/concepts/security/rbac-good-practices/">Role Based Access Control Good Practices</a>
are followed for guidance related to authentication and authorization.</li></ul><p>After bootstrapping, neither users nor components should authenticate to the
Kubernetes API as <code>system:masters</code>. Similarly, running all of
kube-controller-manager as <code>system:masters</code> should be avoided. In fact,
<code>system:masters</code> should only be used as a break-glass mechanism, as opposed to
an admin user.</p><h2 id="network-security">Network security</h2><ul><li><input disabled="" type="checkbox"/> CNI plugins in use support network policies.</li><li><input disabled="" type="checkbox"/> Ingress and egress network policies are applied to all workloads in the
cluster.</li><li><input disabled="" type="checkbox"/> Default network policies within each namespace, selecting all pods, denying
everything, are in place.</li><li><input disabled="" type="checkbox"/> If appropriate, a service mesh is used to encrypt all communications inside of the cluster.</li><li><input disabled="" type="checkbox"/> The Kubernetes API, kubelet API and etcd are not exposed publicly on Internet.</li><li><input disabled="" type="checkbox"/> Access from the workloads to the cloud metadata API is filtered.</li><li><input disabled="" type="checkbox"/> Use of LoadBalancer and ExternalIPs is restricted.</li></ul><p>A number of <a href="/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/">Container Network Interface (CNI) plugins</a>
plugins provide the functionality to
restrict network resources that pods may communicate with. This is most commonly done
through <a href="/docs/concepts/services-networking/network-policies/">Network Policies</a>
which provide a namespaced resource to define rules. Default network policies
that block all egress and ingress, in each namespace, selecting all pods, can be
useful to adopt an allow list approach to ensure that no workloads are missed.</p><p>Not all CNI plugins provide encryption in transit. If the chosen plugin lacks this
feature, an alternative solution could be to use a service mesh to provide that
functionality.</p><p>The etcd datastore of the control plane should have controls to limit access and
not be publicly exposed on the Internet. Furthermore, mutual TLS (mTLS) should
be used to communicate securely with it. The certificate authority for this
should be unique to etcd.</p><p>External Internet access to the Kubernetes API server should be restricted to
not expose the API publicly. Be careful, as many managed Kubernetes distributions
are publicly exposing the API server by default. You can then use a bastion host
to access the server.</p><p>The <a href="/docs/reference/command-line-tools-reference/kubelet/">kubelet</a> API access
should be restricted and not exposed publicly, the default authentication and
authorization settings, when no configuration file specified with the <code>--config</code>
flag, are overly permissive.</p><p>If a cloud provider is used for hosting Kubernetes, the access from pods to the cloud
metadata API <code>169.254.169.254</code> should also be restricted or blocked if not needed
because it may leak information.</p><p>For restricted LoadBalancer and ExternalIPs use, see
<a href="https://github.com/kubernetes/kubernetes/issues/97076">CVE-2020-8554: Man in the middle using LoadBalancer or ExternalIPs</a>
and the <a href="/docs/reference/access-authn-authz/admission-controllers/#denyserviceexternalips">DenyServiceExternalIPs admission controller</a>
for further information.</p><h2 id="pod-security">Pod security</h2><ul><li><input disabled="" type="checkbox"/> RBAC rights to <code>create</code>, <code>update</code>, <code>patch</code>, <code>delete</code> workloads is only granted if necessary.</li><li><input disabled="" type="checkbox"/> Appropriate Pod Security Standards policy is applied for all namespaces and enforced.</li><li><input disabled="" type="checkbox"/> Memory limit is set for the workloads with a limit equal or inferior to the request.</li><li><input disabled="" type="checkbox"/> CPU limit might be set on sensitive workloads.</li><li><input disabled="" type="checkbox"/> For nodes that support it, Seccomp is enabled with appropriate syscalls
profile for programs.</li><li><input disabled="" type="checkbox"/> For nodes that support it, AppArmor or SELinux is enabled with appropriate
profile for programs.</li></ul><p>RBAC authorization is crucial but
<a href="/docs/concepts/security/rbac-good-practices/#workload-creation">cannot be granular enough to have authorization on the Pods' resources</a>
(or on any resource that manages Pods). The only granularity is the API verbs
on the resource itself, for example, <code>create</code> on Pods. Without
additional admission, the authorization to create these resources allows direct
unrestricted access to the schedulable nodes of a cluster.</p><p>The <a href="/docs/concepts/security/pod-security-standards/">Pod Security Standards</a>
define three different policies, privileged, baseline and restricted that limit
how fields can be set in the <code>PodSpec</code> regarding security.
These standards can be enforced at the namespace level with the new
<a href="/docs/concepts/security/pod-security-admission/">Pod Security</a> admission,
enabled by default, or by third-party admission webhook. Please note that,
contrary to the removed PodSecurityPolicy admission it replaces,
<a href="/docs/concepts/security/pod-security-admission/">Pod Security</a>
admission can be easily combined with admission webhooks and external services.</p><p>Pod Security admission <code>restricted</code> policy, the most restrictive policy of the
<a href="/docs/concepts/security/pod-security-standards/">Pod Security Standards</a> set,
<a href="/docs/concepts/security/pod-security-admission/#pod-security-admission-labels-for-namespaces">can operate in several modes</a>,
<code>warn</code>, <code>audit</code> or <code>enforce</code> to gradually apply the most appropriate
<a href="/docs/tasks/configure-pod-container/security-context/">security context</a>
according to security best practices. Nevertheless, pods'
<a href="/docs/tasks/configure-pod-container/security-context/">security context</a>
should be separately investigated to limit the privileges and access pods may
have on top of the predefined security standards, for specific use cases.</p><p>For a hands-on tutorial on <a href="/docs/concepts/security/pod-security-admission/">Pod Security</a>,
see the blog post
<a href="/blog/2021/12/09/pod-security-admission-beta/">Kubernetes 1.23: Pod Security Graduates to Beta</a>.</p><p><a href="/docs/concepts/configuration/manage-resources-containers/">Memory and CPU limits</a>
should be set in order to restrict the memory and CPU resources a pod can
consume on a node, and therefore prevent potential DoS attacks from malicious or
breached workloads. Such policy can be enforced by an admission controller.
Please note that CPU limits will throttle usage and thus can have unintended
effects on auto-scaling features or efficiency i.e. running the process in best
effort with the CPU resource available.</p><div class="alert alert-caution" role="alert"><h4 class="alert-heading">Caution:</h4>Memory limit superior to request can expose the whole node to OOM issues.</div><h3 id="enabling-seccomp">Enabling Seccomp</h3><p>Seccomp stands for secure computing mode and has been a feature of the Linux kernel since version 2.6.12.
It can be used to sandbox the privileges of a process, restricting the calls it is able to make
from userspace into the kernel. Kubernetes lets you automatically apply seccomp profiles loaded onto
a node to your Pods and containers.</p><p>Seccomp can improve the security of your workloads by reducing the Linux kernel syscall attack
surface available inside containers. The seccomp filter mode leverages BPF to create an allow or
deny list of specific syscalls, named profiles.</p><p>Since Kubernetes 1.27, you can enable the use of <code>RuntimeDefault</code> as the default seccomp profile
for all workloads. A <a href="/docs/tutorials/security/seccomp/">security tutorial</a> is available on this
topic. In addition, the
<a href="https://github.com/kubernetes-sigs/security-profiles-operator">Kubernetes Security Profiles Operator</a>
is a project that facilitates the management and use of seccomp in clusters.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>Seccomp is only available on Linux nodes.</div><h3 id="enabling-apparmor-or-selinux">Enabling AppArmor or SELinux</h3><h4 id="apparmor">AppArmor</h4><p><a href="/docs/tutorials/security/apparmor/">AppArmor</a> is a Linux kernel security module that can
provide an easy way to implement Mandatory Access Control (MAC) and better
auditing through system logs. A default AppArmor profile is enforced on nodes that support it, or a custom profile can be configured.
Like seccomp, AppArmor is also configured
through profiles, where each profile is either running in enforcing mode, which
blocks access to disallowed resources or complain mode, which only reports
violations. AppArmor profiles are enforced on a per-container basis, with an
annotation, allowing for processes to gain just the right privileges.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>AppArmor is only available on Linux nodes, and enabled in
<a href="https://gitlab.com/apparmor/apparmor/-/wikis/home#distributions-and-ports">some Linux distributions</a>.</div><h4 id="selinux">SELinux</h4><p><a href="https://github.com/SELinuxProject/selinux-notebook/blob/main/src/selinux_overview.md">SELinux</a> is also a
Linux kernel security module that can provide a mechanism for supporting access
control security policies, including Mandatory Access Controls (MAC). SELinux
labels can be assigned to containers or pods
<a href="/docs/tasks/configure-pod-container/security-context/#assign-selinux-labels-to-a-container">via their <code>securityContext</code> section</a>.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>SELinux is only available on Linux nodes, and enabled in
<a href="https://en.wikipedia.org/wiki/Security-Enhanced_Linux#Implementations">some Linux distributions</a>.</div><h2 id="logs-and-auditing">Logs and auditing</h2><ul><li><input disabled="" type="checkbox"/> Audit logs, if enabled, are protected from general access.</li></ul><h2 id="pod-placement">Pod placement</h2><ul><li><input disabled="" type="checkbox"/> Pod placement is done in accordance with the tiers of sensitivity of the
application.</li><li><input disabled="" type="checkbox"/> Sensitive applications are running isolated on nodes or with specific
sandboxed runtimes.</li></ul><p>Pods that are on different tiers of sensitivity, for example, an application pod
and the Kubernetes API server, should be deployed onto separate nodes. The
purpose of node isolation is to prevent an application container breakout to
directly providing access to applications with higher level of sensitivity to easily
pivot within the cluster. This separation should be enforced to prevent pods
accidentally being deployed onto the same node. This could be enforced with the
following features:</p><dl><dt><a href="/docs/concepts/scheduling-eviction/assign-pod-node/">Node Selectors</a></dt><dd>Key-value pairs, as part of the pod specification, that specify which nodes to
deploy onto. These can be enforced at the namespace and cluster level with the
<a href="/docs/reference/access-authn-authz/admission-controllers/#podnodeselector">PodNodeSelector</a>
admission controller.</dd><dt><a href="/docs/reference/access-authn-authz/admission-controllers/#podtolerationrestriction">PodTolerationRestriction</a></dt><dd>An admission controller that allows administrators to restrict permitted
<a href="/docs/concepts/scheduling-eviction/taint-and-toleration/">tolerations</a> within a
namespace. Pods within a namespace may only utilize the tolerations specified on
the namespace object annotation keys that provide a set of default and allowed
tolerations.</dd><dt><a href="/docs/concepts/containers/runtime-class/">RuntimeClass</a></dt><dd>RuntimeClass is a feature for selecting the container runtime configuration.
The container runtime configuration is used to run a Pod's containers and can
provide more or less isolation from the host at the cost of performance
overhead.</dd></dl><h2 id="secrets">Secrets</h2><ul><li><input disabled="" type="checkbox"/> ConfigMaps are not used to hold confidential data.</li><li><input disabled="" type="checkbox"/> Encryption at rest is configured for the Secret API.</li><li><input disabled="" type="checkbox"/> If appropriate, a mechanism to inject secrets stored in third-party storage
is deployed and available.</li><li><input disabled="" type="checkbox"/> Service account tokens are not mounted in pods that don't require them.</li><li><input disabled="" type="checkbox"/> <a href="/docs/reference/access-authn-authz/service-accounts-admin/#bound-service-account-token-volume">Bound service account token volume</a>
is in-use instead of non-expiring tokens.</li></ul><p>Secrets required for pods should be stored within Kubernetes Secrets as opposed
to alternatives such as ConfigMap. Secret resources stored within etcd should
be <a href="/docs/tasks/administer-cluster/encrypt-data/">encrypted at rest</a>.</p><p>Pods needing secrets should have these automatically mounted through volumes,
preferably stored in memory like with the <a href="/docs/concepts/storage/volumes/#emptydir"><code>emptyDir.medium</code> option</a>.
Mechanism can be used to also inject secrets from third-party storages as
volume, like the <a href="https://secrets-store-csi-driver.sigs.k8s.io/">Secrets Store CSI Driver</a>.
This should be done preferentially as compared to providing the pods service
account RBAC access to secrets. This would allow adding secrets into the pod as
environment variables or files. Please note that the environment variable method
might be more prone to leakage due to crash dumps in logs and the
non-confidential nature of environment variable in Linux, as opposed to the
permission mechanism on files.</p><p>Service account tokens should not be mounted into pods that do not require them. This can be configured by setting
<a href="/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server"><code>automountServiceAccountToken</code></a>
to <code>false</code> either within the service account to apply throughout the namespace
or specifically for a pod. For Kubernetes v1.22 and above, use
<a href="/docs/reference/access-authn-authz/service-accounts-admin/#bound-service-account-token-volume">Bound Service Accounts</a>
for time-bound service account credentials.</p><h2 id="images">Images</h2><ul><li><input disabled="" type="checkbox"/> Minimize unnecessary content in container images.</li><li><input disabled="" type="checkbox"/> Container images are configured to be run as unprivileged user.</li><li><input disabled="" type="checkbox"/> References to container images are made by sha256 digests (rather than
tags) or the provenance of the image is validated by verifying the image's
digital signature at deploy time <a href="/docs/tasks/administer-cluster/verify-signed-artifacts/#verifying-image-signatures-with-admission-controller">via admission control</a>.</li><li><input disabled="" type="checkbox"/> Container images are regularly scanned during creation and in deployment, and
known vulnerable software is patched.</li></ul><p>Container image should contain the bare minimum to run the program they
package. Preferably, only the program and its dependencies, building the image
from the minimal possible base. In particular, image used in production should not
contain shells or debugging utilities, as an
<a href="/docs/tasks/debug/debug-application/debug-running-pod/#ephemeral-container">ephemeral debug container</a>
can be used for troubleshooting.</p><p>Build images to directly start with an unprivileged user by using the
<a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#user"><code>USER</code> instruction in Dockerfile</a>.
The <a href="/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-pod">Security Context</a>
allows a container image to be started with a specific user and group with
<code>runAsUser</code> and <code>runAsGroup</code>, even if not specified in the image manifest.
However, the file permissions in the image layers might make it impossible to just
start the process with a new unprivileged user without image modification.</p><p>Avoid using image tags to reference an image, especially the <code>latest</code> tag, the
image behind a tag can be easily modified in a registry. Prefer using the
complete <code>sha256</code> digest which is unique to the image manifest. This policy can be
enforced via an <a href="/docs/reference/access-authn-authz/admission-controllers/#imagepolicywebhook">ImagePolicyWebhook</a>.
Image signatures can also be automatically <a href="/docs/tasks/administer-cluster/verify-signed-artifacts/#verifying-image-signatures-with-admission-controller">verified with an admission controller</a>
at deploy time to validate their authenticity and integrity.</p><p>Scanning a container image can prevent critical vulnerabilities from being
deployed to the cluster alongside the container image. Image scanning should be
completed before deploying a container image to a cluster and is usually done
as part of the deployment process in a CI/CD pipeline. The purpose of an image
scan is to obtain information about possible vulnerabilities and their
prevention in the container image, such as a
<a href="https://www.first.org/cvss/">Common Vulnerability Scoring System (CVSS)</a>
score. If the result of the image scans is combined with the pipeline
compliance rules, only properly patched container images will end up in
Production.</p><h2 id="admission-controllers">Admission controllers</h2><ul><li><input disabled="" type="checkbox"/> An appropriate selection of admission controllers is enabled.</li><li><input disabled="" type="checkbox"/> A pod security policy is enforced by the Pod Security Admission or/and a
webhook admission controller.</li><li><input disabled="" type="checkbox"/> The admission chain plugins and webhooks are securely configured.</li></ul><p>Admission controllers can help improve the security of the cluster. However,
they can present risks themselves as they extend the API server and
<a href="/blog/2022/01/19/secure-your-admission-controllers-and-webhooks/">should be properly secured</a>.</p><p>The following lists present a number of admission controllers that could be
considered to enhance the security posture of your cluster and application. It
includes controllers that may be referenced in other parts of this document.</p><p>This first group of admission controllers includes plugins
<a href="/docs/reference/access-authn-authz/admission-controllers/#which-plugins-are-enabled-by-default">enabled by default</a>,
consider to leave them enabled unless you know what you are doing:</p><dl><dt><a href="/docs/reference/access-authn-authz/admission-controllers/#certificateapproval"><code>CertificateApproval</code></a></dt><dd>Performs additional authorization checks to ensure the approving user has
permission to approve certificate request.</dd><dt><a href="/docs/reference/access-authn-authz/admission-controllers/#certificatesigning"><code>CertificateSigning</code></a></dt><dd>Performs additional authorization checks to ensure the signing user has
permission to sign certificate requests.</dd><dt><a href="/docs/reference/access-authn-authz/admission-controllers/#certificatesubjectrestriction"><code>CertificateSubjectRestriction</code></a></dt><dd>Rejects any certificate request that specifies a 'group' (or 'organization
attribute') of <code>system:masters</code>.</dd><dt><a href="/docs/reference/access-authn-authz/admission-controllers/#limitranger"><code>LimitRanger</code></a></dt><dd>Enforces the LimitRange API constraints.</dd><dt><a href="/docs/reference/access-authn-authz/admission-controllers/#mutatingadmissionwebhook"><code>MutatingAdmissionWebhook</code></a></dt><dd>Allows the use of custom controllers through webhooks, these controllers may
mutate requests that they review.</dd><dt><a href="/docs/reference/access-authn-authz/admission-controllers/#podsecurity"><code>PodSecurity</code></a></dt><dd>Replacement for Pod Security Policy, restricts security contexts of deployed
Pods.</dd><dt><a href="/docs/reference/access-authn-authz/admission-controllers/#resourcequota"><code>ResourceQuota</code></a></dt><dd>Enforces resource quotas to prevent over-usage of resources.</dd><dt><a href="/docs/reference/access-authn-authz/admission-controllers/#validatingadmissionwebhook"><code>ValidatingAdmissionWebhook</code></a></dt><dd>Allows the use of custom controllers through webhooks, these controllers do
not mutate requests that it reviews.</dd></dl><p>The second group includes plugins that are not enabled by default but are in general
availability state and are recommended to improve your security posture:</p><dl><dt><a href="/docs/reference/access-authn-authz/admission-controllers/#denyserviceexternalips"><code>DenyServiceExternalIPs</code></a></dt><dd>Rejects all net-new usage of the <code>Service.spec.externalIPs</code> field. This is a mitigation for
<a href="https://github.com/kubernetes/kubernetes/issues/97076">CVE-2020-8554: Man in the middle using LoadBalancer or ExternalIPs</a>.</dd><dt><a href="/docs/reference/access-authn-authz/admission-controllers/#noderestriction"><code>NodeRestriction</code></a></dt><dd>Restricts kubelet's permissions to only modify the pods API resources they own
or the node API resource that represent themselves. It also prevents kubelet
from using the <code>node-restriction.kubernetes.io/</code> annotation, which can be used
by an attacker with access to the kubelet's credentials to influence pod
placement to the controlled node.</dd></dl><p>The third group includes plugins that are not enabled by default but could be
considered for certain use cases:</p><dl><dt><a href="/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages"><code>AlwaysPullImages</code></a></dt><dd>Enforces the usage of the latest version of a tagged image and ensures that the deployer
has permissions to use the image.</dd><dt><a href="/docs/reference/access-authn-authz/admission-controllers/#imagepolicywebhook"><code>ImagePolicyWebhook</code></a></dt><dd>Allows enforcing additional controls for images through webhooks.</dd></dl><h2 id="what-s-next">What's next</h2><ul><li><a href="/docs/reference/access-authn-authz/authorization/#privilege-escalation-via-pod-creation">Privilege escalation via Pod creation</a>
warns you about a specific access control risk; check how you're managing that
threat.<ul><li>If you use Kubernetes RBAC, read
<a href="/docs/concepts/security/rbac-good-practices/">RBAC Good Practices</a> for
further information on authorization.</li></ul></li><li><a href="/docs/tasks/administer-cluster/securing-a-cluster/">Securing a Cluster</a> for
information on protecting a cluster from accidental or malicious access.</li><li><a href="/docs/concepts/security/multi-tenancy/">Cluster Multi-tenancy guide</a> for
configuration options recommendations and best practices on multi-tenancy.</li><li><a href="/blog/2021/10/05/nsa-cisa-kubernetes-hardening-guidance/#building-secure-container-images">Blog post "A Closer Look at NSA/CISA Kubernetes Hardening Guidance"</a>
for complementary resource on hardening Kubernetes clusters.</li></ul></div>