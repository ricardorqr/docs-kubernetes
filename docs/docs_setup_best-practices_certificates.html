<div class="td-content"><h1 data-pagefind-weight="10">PKI certificates and requirements</h1><p>Kubernetes requires PKI certificates for authentication over TLS.
If you install Kubernetes with <a href="/docs/reference/setup-tools/kubeadm/">kubeadm</a>, the certificates
that your cluster requires are automatically generated.
You can also generate your own certificates -- for example, to keep your private keys more secure
by not storing them on the API server.
This page explains the certificates that your cluster requires.</p><h2 id="how-certificates-are-used-by-your-cluster">How certificates are used by your cluster</h2><p>Kubernetes requires PKI for the following operations:</p><h3 id="server-certificates">Server certificates</h3><ul><li>Server certificate for the API server endpoint</li><li>Server certificate for the etcd server</li><li><a href="/docs/reference/access-authn-authz/kubelet-tls-bootstrapping/#client-and-serving-certificates">Server certificates</a>
for each kubelet (every <a class="glossary-tooltip" title="A node is a worker machine in Kubernetes." data-toggle="tooltip" data-placement="top" href="/docs/concepts/architecture/nodes/" target="_blank" aria-label="node">node</a> runs a kubelet)</li><li>Optional server certificate for the <a href="/docs/tasks/extend-kubernetes/configure-aggregation-layer/">front-proxy</a></li></ul><h3 id="client-certificates">Client certificates</h3><ul><li>Client certificates for each kubelet, used to authenticate to the API server as a client of
the Kubernetes API</li><li>Client certificate for each API server, used to authenticate to etcd</li><li>Client certificate for the controller manager to securely communicate with the API server</li><li>Client certificate for the scheduler to securely communicate with the API server</li><li>Client certificates, one for each node, for kube-proxy to authenticate to the API server</li><li>Optional client certificates for administrators of the cluster to authenticate to the API server</li><li>Optional client certificate for the <a href="/docs/tasks/extend-kubernetes/configure-aggregation-layer/">front-proxy</a></li></ul><h3 id="kubelet-s-server-and-client-certificates">Kubelet's server and client certificates</h3><p>To establish a secure connection and authenticate itself to the kubelet, the API Server
requires a client certificate and key pair.</p><p>In this scenario, there are two approaches for certificate usage:</p><ul><li><p>Shared Certificates: The kube-apiserver can utilize the same certificate and key pair it uses
to authenticate its clients. This means that the existing certificates, such as <code>apiserver.crt</code>
and <code>apiserver.key</code>, can be used for communicating with the kubelet servers.</p></li><li><p>Separate Certificates: Alternatively, the kube-apiserver can generate a new client certificate
and key pair to authenticate its communication with the kubelet servers. In this case,
a distinct certificate named <code>kubelet-client.crt</code> and its corresponding private key,
<code>kubelet-client.key</code> are created.</p></li></ul><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4><code>front-proxy</code> certificates are required only if you run kube-proxy to support
<a href="/docs/tasks/extend-kubernetes/setup-extension-api-server/">an extension API server</a>.</div><p>etcd also implements mutual TLS to authenticate clients and peers.</p><h2 id="where-certificates-are-stored">Where certificates are stored</h2><p>If you install Kubernetes with kubeadm, most certificates are stored in <code>/etc/kubernetes/pki</code>.
All paths in this documentation are relative to that directory, with the exception of user account
certificates which kubeadm places in <code>/etc/kubernetes</code>.</p><h2 id="configure-certificates-manually">Configure certificates manually</h2><p>If you don't want kubeadm to generate the required certificates, you can create them using a
single root CA or by providing all certificates. See <a href="/docs/tasks/administer-cluster/certificates/">Certificates</a>
for details on creating your own certificate authority. See
<a href="/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/">Certificate Management with kubeadm</a>
for more on managing certificates.</p><h3 id="single-root-ca">Single root CA</h3><p>You can create a single root CA, controlled by an administrator. This root CA can then create
multiple intermediate CAs, and delegate all further creation to Kubernetes itself.</p><p>Required CAs:</p><table><thead><tr><th>Path</th><th>Default CN</th><th>Description</th></tr></thead><tbody><tr><td>ca.crt,key</td><td>kubernetes-ca</td><td>Kubernetes general CA</td></tr><tr><td>etcd/ca.crt,key</td><td>etcd-ca</td><td>For all etcd-related functions</td></tr><tr><td>front-proxy-ca.crt,key</td><td>kubernetes-front-proxy-ca</td><td>For the <a href="/docs/tasks/extend-kubernetes/configure-aggregation-layer/">front-end proxy</a></td></tr></tbody></table><p>On top of the above CAs, it is also necessary to get a public/private key pair for service account
management, <code>sa.key</code> and <code>sa.pub</code>.
The following example illustrates the CA key and certificate files shown in the previous table:</p><pre tabindex="0"><code>/etc/kubernetes/pki/ca.crt
/etc/kubernetes/pki/ca.key
/etc/kubernetes/pki/etcd/ca.crt
/etc/kubernetes/pki/etcd/ca.key
/etc/kubernetes/pki/front-proxy-ca.crt
/etc/kubernetes/pki/front-proxy-ca.key
</code></pre><h3 id="all-certificates">All certificates</h3><p>If you don't wish to copy the CA private keys to your cluster, you can generate all certificates yourself.</p><p>Required certificates:</p><table><thead><tr><th>Default CN</th><th>Parent CA</th><th>O (in Subject)</th><th>kind</th><th>hosts (SAN)</th></tr></thead><tbody><tr><td>kube-etcd</td><td>etcd-ca</td><td/><td>server, client</td><td><code>&lt;hostname&gt;</code>, <code>&lt;Host_IP&gt;</code>, <code>localhost</code>, <code>127.0.0.1</code></td></tr><tr><td>kube-etcd-peer</td><td>etcd-ca</td><td/><td>server, client</td><td><code>&lt;hostname&gt;</code>, <code>&lt;Host_IP&gt;</code>, <code>localhost</code>, <code>127.0.0.1</code></td></tr><tr><td>kube-etcd-healthcheck-client</td><td>etcd-ca</td><td/><td>client</td><td/></tr><tr><td>kube-apiserver-etcd-client</td><td>etcd-ca</td><td/><td>client</td><td/></tr><tr><td>kube-apiserver</td><td>kubernetes-ca</td><td/><td>server</td><td><code>&lt;hostname&gt;</code>, <code>&lt;Host_IP&gt;</code>, <code>&lt;advertise_IP&gt;</code><sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></td></tr><tr><td>kube-apiserver-kubelet-client</td><td>kubernetes-ca</td><td>system:masters</td><td>client</td><td/></tr><tr><td>front-proxy-client</td><td>kubernetes-front-proxy-ca</td><td/><td>client</td><td/></tr></tbody></table><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>Instead of using the super-user group <code>system:masters</code> for <code>kube-apiserver-kubelet-client</code>
a less privileged group can be used. kubeadm uses the <code>kubeadm:cluster-admins</code> group for
that purpose.</div><p>where <code>kind</code> maps to one or more of the x509 key usage, which is also documented in the
<code>.spec.usages</code> of a <a href="/docs/reference/kubernetes-api/authentication-resources/certificate-signing-request-v1/#CertificateSigningRequest">CertificateSigningRequest</a>
type:</p><table><thead><tr><th>kind</th><th>Key usage</th></tr></thead><tbody><tr><td>server</td><td>digital signature, key encipherment, server auth</td></tr><tr><td>client</td><td>digital signature, key encipherment, client auth</td></tr></tbody></table><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>Hosts/SAN listed above are the recommended ones for getting a working cluster; if required by a
specific setup, it is possible to add additional SANs on all the server certificates.</div><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4><p>For kubeadm users only:</p><ul><li>The scenario where you are copying to your cluster CA certificates without private keys is
referred as external CA in the kubeadm documentation.</li><li>If you are comparing the above list with a kubeadm generated PKI, please be aware that
<code>kube-etcd</code>, <code>kube-etcd-peer</code> and <code>kube-etcd-healthcheck-client</code> certificates are not generated
in case of external etcd.</li></ul></div><h3 id="certificate-paths">Certificate paths</h3><p>Certificates should be placed in a recommended path (as used by <a href="/docs/reference/setup-tools/kubeadm/">kubeadm</a>).
Paths should be specified using the given argument regardless of location.</p><table><thead><tr><th>DefaultCN</th><th>recommendedkeypath</th><th>recommendedcertpath</th><th>command</th><th>keyargument</th><th>certargument</th></tr></thead><tbody><tr><td>etcd-ca</td><td>etcd/ca.key</td><td>etcd/ca.crt</td><td>kube-apiserver</td><td/><td>--etcd-cafile</td></tr><tr><td>kube-apiserver-etcd-client</td><td>apiserver-etcd-client.key</td><td>apiserver-etcd-client.crt</td><td>kube-apiserver</td><td>--etcd-keyfile</td><td>--etcd-certfile</td></tr><tr><td>kubernetes-ca</td><td>ca.key</td><td>ca.crt</td><td>kube-apiserver</td><td/><td>--client-ca-file</td></tr><tr><td>kubernetes-ca</td><td>ca.key</td><td>ca.crt</td><td>kube-controller-manager</td><td>--cluster-signing-key-file</td><td>--client-ca-file,--root-ca-file,--cluster-signing-cert-file</td></tr><tr><td>kube-apiserver</td><td>apiserver.key</td><td>apiserver.crt</td><td>kube-apiserver</td><td>--tls-private-key-file</td><td>--tls-cert-file</td></tr><tr><td>kube-apiserver-kubelet-client</td><td>apiserver-kubelet-client.key</td><td>apiserver-kubelet-client.crt</td><td>kube-apiserver</td><td>--kubelet-client-key</td><td>--kubelet-client-certificate</td></tr><tr><td>front-proxy-ca</td><td>front-proxy-ca.key</td><td>front-proxy-ca.crt</td><td>kube-apiserver</td><td/><td>--requestheader-client-ca-file</td></tr><tr><td>front-proxy-ca</td><td>front-proxy-ca.key</td><td>front-proxy-ca.crt</td><td>kube-controller-manager</td><td/><td>--requestheader-client-ca-file</td></tr><tr><td>front-proxy-client</td><td>front-proxy-client.key</td><td>front-proxy-client.crt</td><td>kube-apiserver</td><td>--proxy-client-key-file</td><td>--proxy-client-cert-file</td></tr><tr><td>etcd-ca</td><td>etcd/ca.key</td><td>etcd/ca.crt</td><td>etcd</td><td/><td>--trusted-ca-file,--peer-trusted-ca-file</td></tr><tr><td>kube-etcd</td><td>etcd/server.key</td><td>etcd/server.crt</td><td>etcd</td><td>--key-file</td><td>--cert-file</td></tr><tr><td>kube-etcd-peer</td><td>etcd/peer.key</td><td>etcd/peer.crt</td><td>etcd</td><td>--peer-key-file</td><td>--peer-cert-file</td></tr><tr><td>etcd-ca</td><td/><td>etcd/ca.crt</td><td>etcdctl</td><td/><td>--cacert</td></tr><tr><td>kube-etcd-healthcheck-client</td><td>etcd/healthcheck-client.key</td><td>etcd/healthcheck-client.crt</td><td>etcdctl</td><td>--key</td><td>--cert</td></tr></tbody></table><p>Same considerations apply for the service account key pair:</p><table><thead><tr><th>private key path</th><th>public key path</th><th>command</th><th>argument</th></tr></thead><tbody><tr><td>sa.key</td><td/><td>kube-controller-manager</td><td>--service-account-private-key-file</td></tr><tr><td/><td>sa.pub</td><td>kube-apiserver</td><td>--service-account-key-file</td></tr></tbody></table><p>The following example illustrates the file paths <a href="#certificate-paths">from the previous tables</a>
you need to provide if you are generating all of your own keys and certificates:</p><pre tabindex="0"><code>/etc/kubernetes/pki/etcd/ca.key
/etc/kubernetes/pki/etcd/ca.crt
/etc/kubernetes/pki/apiserver-etcd-client.key
/etc/kubernetes/pki/apiserver-etcd-client.crt
/etc/kubernetes/pki/ca.key
/etc/kubernetes/pki/ca.crt
/etc/kubernetes/pki/apiserver.key
/etc/kubernetes/pki/apiserver.crt
/etc/kubernetes/pki/apiserver-kubelet-client.key
/etc/kubernetes/pki/apiserver-kubelet-client.crt
/etc/kubernetes/pki/front-proxy-ca.key
/etc/kubernetes/pki/front-proxy-ca.crt
/etc/kubernetes/pki/front-proxy-client.key
/etc/kubernetes/pki/front-proxy-client.crt
/etc/kubernetes/pki/etcd/server.key
/etc/kubernetes/pki/etcd/server.crt
/etc/kubernetes/pki/etcd/peer.key
/etc/kubernetes/pki/etcd/peer.crt
/etc/kubernetes/pki/etcd/healthcheck-client.key
/etc/kubernetes/pki/etcd/healthcheck-client.crt
/etc/kubernetes/pki/sa.key
/etc/kubernetes/pki/sa.pub
</code></pre><h2 id="configure-certificates-for-user-accounts">Configure certificates for user accounts</h2><p>You must manually configure these administrator accounts and service accounts:</p><table><thead><tr><th>Filename</th><th>Credential name</th><th>Default CN</th><th>O (in Subject)</th></tr></thead><tbody><tr><td>admin.conf</td><td>default-admin</td><td>kubernetes-admin</td><td><code>&lt;admin-group&gt;</code></td></tr><tr><td>super-admin.conf</td><td>default-super-admin</td><td>kubernetes-super-admin</td><td>system:masters</td></tr><tr><td>kubelet.conf</td><td>default-auth</td><td>system:node:<code>&lt;nodeName&gt;</code> (see note)</td><td>system:nodes</td></tr><tr><td>controller-manager.conf</td><td>default-controller-manager</td><td>system:kube-controller-manager</td><td/></tr><tr><td>scheduler.conf</td><td>default-scheduler</td><td>system:kube-scheduler</td><td/></tr></tbody></table><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>The value of <code>&lt;nodeName&gt;</code> for <code>kubelet.conf</code> <strong>must</strong> match precisely the value of the node name
provided by the kubelet as it registers with the apiserver. For further details, read the
<a href="/docs/reference/access-authn-authz/node/">Node Authorization</a>.</div><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4><p>In the above example <code>&lt;admin-group&gt;</code> is implementation specific. Some tools sign the
certificate in the default <code>admin.conf</code> to be part of the <code>system:masters</code> group.
<code>system:masters</code> is a break-glass, super user group can bypass the authorization
layer of Kubernetes, such as RBAC. Also some tools do not generate a separate
<code>super-admin.conf</code> with a certificate bound to this super user group.</p><p>kubeadm generates two separate administrator certificates in kubeconfig files.
One is in <code>admin.conf</code> and has <code>Subject: O = kubeadm:cluster-admins, CN = kubernetes-admin</code>.
<code>kubeadm:cluster-admins</code> is a custom group bound to the <code>cluster-admin</code> ClusterRole.
This file is generated on all kubeadm managed control plane machines.</p><p>Another is in <code>super-admin.conf</code> that has <code>Subject: O = system:masters, CN = kubernetes-super-admin</code>.
This file is generated only on the node where <code>kubeadm init</code> was called.</p></div><ol><li><p>For each configuration, generate an x509 certificate/key pair with the
given Common Name (CN) and Organization (O).</p></li><li><p>Run <code>kubectl</code> as follows for each configuration:</p><pre tabindex="0"><code>KUBECONFIG=&lt;filename&gt; kubectl config set-cluster default-cluster --server=https://&lt;host ip&gt;:6443 --certificate-authority &lt;path-to-kubernetes-ca&gt; --embed-certs
KUBECONFIG=&lt;filename&gt; kubectl config set-credentials &lt;credential-name&gt; --client-key &lt;path-to-key&gt;.pem --client-certificate &lt;path-to-cert&gt;.pem --embed-certs
KUBECONFIG=&lt;filename&gt; kubectl config set-context default-system --cluster default-cluster --user &lt;credential-name&gt;
KUBECONFIG=&lt;filename&gt; kubectl config use-context default-system
</code></pre></li></ol><p>These files are used as follows:</p><table><thead><tr><th>Filename</th><th>Command</th><th>Comment</th></tr></thead><tbody><tr><td>admin.conf</td><td>kubectl</td><td>Configures administrator user for the cluster</td></tr><tr><td>super-admin.conf</td><td>kubectl</td><td>Configures super administrator user for the cluster</td></tr><tr><td>kubelet.conf</td><td>kubelet</td><td>One required for each node in the cluster.</td></tr><tr><td>controller-manager.conf</td><td>kube-controller-manager</td><td>Must be added to manifest in <code>manifests/kube-controller-manager.yaml</code></td></tr><tr><td>scheduler.conf</td><td>kube-scheduler</td><td>Must be added to manifest in <code>manifests/kube-scheduler.yaml</code></td></tr></tbody></table><p>The following files illustrate full paths to the files listed in the previous table:</p><pre tabindex="0"><code>/etc/kubernetes/admin.conf
/etc/kubernetes/super-admin.conf
/etc/kubernetes/kubelet.conf
/etc/kubernetes/controller-manager.conf
/etc/kubernetes/scheduler.conf
</code></pre><div class="footnotes" role="doc-endnotes"><hr/><ol><li id="fn:1"><p>any other IP or DNS name you contact your cluster on (as used by <a href="/docs/reference/setup-tools/kubeadm/">kubeadm</a>
the load balancer stable IP and/or DNS name, <code>kubernetes</code>, <code>kubernetes.default</code>, <code>kubernetes.default.svc</code>,
<code>kubernetes.default.svc.cluster</code>, <code>kubernetes.default.svc.cluster.local</code>) <a href="#fnref:1" class="footnote-backref" role="doc-backlink">↩︎</a></p></li></ol></div></div>