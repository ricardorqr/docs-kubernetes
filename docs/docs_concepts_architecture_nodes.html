<div class="td-content"><h1 data-pagefind-weight="10">Nodes</h1><p>Kubernetes runs your <a class="glossary-tooltip" title="A workload is an application running on Kubernetes." data-toggle="tooltip" data-placement="top" href="/docs/concepts/workloads/" target="_blank" aria-label="workload">workload</a>
by placing containers into Pods to run on <em>Nodes</em>.
A node may be a virtual or physical machine, depending on the cluster. Each node
is managed by the
<a class="glossary-tooltip" title="The container orchestration layer that exposes the API and interfaces to define, deploy, and manage the lifecycle of containers." data-toggle="tooltip" data-placement="top" href="/docs/reference/glossary/?all=true#term-control-plane" target="_blank" aria-label="control plane">control plane</a>
and contains the services necessary to run
<a class="glossary-tooltip" title="A Pod represents a set of running containers in your cluster." data-toggle="tooltip" data-placement="top" href="/docs/concepts/workloads/pods/" target="_blank" aria-label="Pods">Pods</a>.</p><p>Typically you have several nodes in a cluster; in a learning or resource-limited
environment, you might have only one node.</p><p>The <a href="/docs/concepts/architecture/#node-components">components</a> on a node include the
<a class="glossary-tooltip" title="An agent that runs on each node in the cluster. It makes sure that containers are running in a pod." data-toggle="tooltip" data-placement="top" href="/docs/reference/command-line-tools-reference/kubelet" target="_blank" aria-label="kubelet">kubelet</a>, a
<a class="glossary-tooltip" title="The container runtime is the software that is responsible for running containers." data-toggle="tooltip" data-placement="top" href="/docs/setup/production-environment/container-runtimes" target="_blank" aria-label="container runtime">container runtime</a>, and the
<a class="glossary-tooltip" title="kube-proxy is a network proxy that runs on each node in the cluster." data-toggle="tooltip" data-placement="top" href="/docs/reference/command-line-tools-reference/kube-proxy/" target="_blank" aria-label="kube-proxy">kube-proxy</a>.</p><h2 id="management">Management</h2><p>There are two main ways to have Nodes added to the
<a class="glossary-tooltip" title="Control plane component that serves the Kubernetes API." data-toggle="tooltip" data-placement="top" href="/docs/concepts/architecture/#kube-apiserver" target="_blank" aria-label="API server">API server</a>:</p><ol><li>The kubelet on a node self-registers to the control plane</li><li>You (or another human user) manually add a Node object</li></ol><p>After you create a Node <a class="glossary-tooltip" title="An entity in the Kubernetes system, representing part of the state of your cluster." data-toggle="tooltip" data-placement="top" href="/docs/concepts/overview/working-with-objects/#kubernetes-objects" target="_blank" aria-label="object">object</a>,
or the kubelet on a node self-registers, the control plane checks whether the new Node object
is valid. For example, if you try to create a Node from the following JSON manifest:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json"><span style="display:flex"><span>{
</span></span><span style="display:flex"><span>  <span style="color:green;font-weight:700">"kind"</span>: <span style="color:#b44">"Node"</span>,
</span></span><span style="display:flex"><span>  <span style="color:green;font-weight:700">"apiVersion"</span>: <span style="color:#b44">"v1"</span>,
</span></span><span style="display:flex"><span>  <span style="color:green;font-weight:700">"metadata"</span>: {
</span></span><span style="display:flex"><span>    <span style="color:green;font-weight:700">"name"</span>: <span style="color:#b44">"10.240.79.157"</span>,
</span></span><span style="display:flex"><span>    <span style="color:green;font-weight:700">"labels"</span>: {
</span></span><span style="display:flex"><span>      <span style="color:green;font-weight:700">"name"</span>: <span style="color:#b44">"my-first-k8s-node"</span>
</span></span><span style="display:flex"><span>    }
</span></span><span style="display:flex"><span>  }
</span></span><span style="display:flex"><span>}
</span></span></code></pre></div><p>Kubernetes creates a Node object internally (the representation). Kubernetes checks
that a kubelet has registered to the API server that matches the <code>metadata.name</code>
field of the Node. If the node is healthy (i.e. all necessary services are running),
then it is eligible to run a Pod. Otherwise, that node is ignored for any cluster activity
until it becomes healthy.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4><p>Kubernetes keeps the object for the invalid Node and continues checking to see whether
it becomes healthy.</p><p>You, or a <a class="glossary-tooltip" title="A control loop that watches the shared state of the cluster through the apiserver and makes changes attempting to move the current state towards the desired state." data-toggle="tooltip" data-placement="top" href="/docs/concepts/architecture/controller/" target="_blank" aria-label="controller">controller</a>, must explicitly
delete the Node object to stop that health checking.</p></div><p>The name of a Node object must be a valid
<a href="/docs/concepts/overview/working-with-objects/names/#dns-subdomain-names">DNS subdomain name</a>.</p><h3 id="node-name-uniqueness">Node name uniqueness</h3><p>The <a href="/docs/concepts/overview/working-with-objects/names/#names">name</a> identifies a Node. Two Nodes
cannot have the same name at the same time. Kubernetes also assumes that a resource with the same
name is the same object. In case of a Node, it is implicitly assumed that an instance using the
same name will have the same state (e.g. network settings, root disk contents) and attributes like
node labels. This may lead to inconsistencies if an instance was modified without changing its name.
If the Node needs to be replaced or updated significantly, the existing Node object needs to be
removed from API server first and re-added after the update.</p><h3 id="self-registration-of-nodes">Self-registration of Nodes</h3><p>When the kubelet flag <code>--register-node</code> is true (the default), the kubelet will attempt to
register itself with the API server. This is the preferred pattern, used by most distros.</p><p>For self-registration, the kubelet is started with the following options:</p><ul><li><p><code>--kubeconfig</code> - Path to credentials to authenticate itself to the API server.</p></li><li><p><code>--cloud-provider</code> - How to talk to a <a class="glossary-tooltip" title="An organization that offers a cloud computing platform." data-toggle="tooltip" data-placement="top" href="/docs/reference/glossary/?all=true#term-cloud-provider" target="_blank" aria-label="cloud provider">cloud provider</a>
to read metadata about itself.</p></li><li><p><code>--register-node</code> - Automatically register with the API server.</p></li><li><p><code>--register-with-taints</code> - Register the node with the given list of
<a class="glossary-tooltip" title="A core object consisting of three required properties: key, value, and effect. Taints prevent the scheduling of pods on nodes or node groups." data-toggle="tooltip" data-placement="top" href="/docs/concepts/scheduling-eviction/taint-and-toleration/" target="_blank" aria-label="taints">taints</a> (comma separated <code>&lt;key&gt;=&lt;value&gt;:&lt;effect&gt;</code>).</p><p>No-op if <code>register-node</code> is false.</p></li><li><p><code>--node-ip</code> - Optional comma-separated list of the IP addresses for the node.
You can only specify a single address for each address family.
For example, in a single-stack IPv4 cluster, you set this value to be the IPv4 address that the
kubelet should use for the node.
See <a href="/docs/concepts/services-networking/dual-stack/#configure-ipv4-ipv6-dual-stack">configure IPv4/IPv6 dual stack</a>
for details of running a dual-stack cluster.</p><p>If you don't provide this argument, the kubelet uses the node's default IPv4 address, if any;
if the node has no IPv4 addresses then the kubelet uses the node's default IPv6 address.</p></li><li><p><code>--node-labels</code> - <a class="glossary-tooltip" title="Tags objects with identifying attributes that are meaningful and relevant to users." data-toggle="tooltip" data-placement="top" href="/docs/concepts/overview/working-with-objects/labels" target="_blank" aria-label="Labels">Labels</a> to add when registering the node
in the cluster (see label restrictions enforced by the
<a href="/docs/reference/access-authn-authz/admission-controllers/#noderestriction">NodeRestriction admission plugin</a>).</p></li><li><p><code>--node-status-update-frequency</code> - Specifies how often kubelet posts its node status to the API server.</p></li></ul><p>When the <a href="/docs/reference/access-authn-authz/node/">Node authorization mode</a> and
<a href="/docs/reference/access-authn-authz/admission-controllers/#noderestriction">NodeRestriction admission plugin</a>
are enabled, kubelets are only authorized to create/modify their own Node resource.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4><p>As mentioned in the <a href="#node-name-uniqueness">Node name uniqueness</a> section,
when Node configuration needs to be updated, it is a good practice to re-register
the node with the API server. For example, if the kubelet is being restarted with
a new set of <code>--node-labels</code>, but the same Node name is used, the change will
not take effect, as labels are only set (or modified) upon Node registration with the API server.</p><p>Pods already scheduled on the Node may misbehave or cause issues if the Node
configuration will be changed on kubelet restart. For example, already running
Pod may be tainted against the new labels assigned to the Node, while other
Pods, that are incompatible with that Pod will be scheduled based on this new
label. Node re-registration ensures all Pods will be drained and properly
re-scheduled.</p></div><h3 id="manual-node-administration">Manual Node administration</h3><p>You can create and modify Node objects using
<a class="glossary-tooltip" title="A command line tool for communicating with a Kubernetes cluster." data-toggle="tooltip" data-placement="top" href="/docs/reference/kubectl/" target="_blank" aria-label="kubectl">kubectl</a>.</p><p>When you want to create Node objects manually, set the kubelet flag <code>--register-node=false</code>.</p><p>You can modify Node objects regardless of the setting of <code>--register-node</code>.
For example, you can set labels on an existing Node or mark it unschedulable.</p><p>You can set optional node role(s) for nodes by adding one or more <code>node-role.kubernetes.io/&lt;role&gt;: &lt;role&gt;</code> labels to the node where characters of <code>&lt;role&gt;</code>
are limited by the <a href="/docs/concepts/overview/working-with-objects/labels/#syntax-and-character-set">syntax</a> rules for labels.</p><p>Kubernetes ignores the label value for node roles; by convention, you can set it to the same string you used for the node role in the label key.</p><p>You can use labels on Nodes in conjunction with node selectors on Pods to control
scheduling. For example, you can constrain a Pod to only be eligible to run on
a subset of the available nodes.</p><p>Marking a node as unschedulable prevents the scheduler from placing new pods onto
that Node but does not affect existing Pods on the Node. This is useful as a
preparatory step before a node reboot or other maintenance.</p><p>To mark a Node unschedulable, run:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl cordon <span style="color:#b8860b">$NODENAME</span>
</span></span></code></pre></div><p>See <a href="/docs/tasks/administer-cluster/safely-drain-node/">Safely Drain a Node</a>
for more details.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>Pods that are part of a <a class="glossary-tooltip" title="Ensures a copy of a Pod is running across a set of nodes in a cluster." data-toggle="tooltip" data-placement="top" href="/docs/concepts/workloads/controllers/daemonset" target="_blank" aria-label="DaemonSet">DaemonSet</a> tolerate
being run on an unschedulable Node. DaemonSets typically provide node-local services
that should run on the Node even if it is being drained of workload applications.</div><h2 id="node-status">Node status</h2><p>A Node's status contains the following information:</p><ul><li><a href="/docs/reference/node/node-status/#addresses">Addresses</a></li><li><a href="/docs/reference/node/node-status/#condition">Conditions</a></li><li><a href="/docs/reference/node/node-status/#capacity">Capacity and Allocatable</a></li><li><a href="/docs/reference/node/node-status/#info">Info</a></li></ul><p>You can use <code>kubectl</code> to view a Node's status and other details:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl describe node &lt;insert-node-name-here&gt;
</span></span></code></pre></div><p>See <a href="/docs/reference/node/node-status/">Node Status</a> for more details.</p><h2 id="node-heartbeats">Node heartbeats</h2><p>Heartbeats, sent by Kubernetes nodes, help your cluster determine the
availability of each node, and to take action when failures are detected.</p><p>For nodes there are two forms of heartbeats:</p><ul><li>Updates to the <a href="/docs/reference/node/node-status/"><code>.status</code></a> of a Node.</li><li><a href="/docs/concepts/architecture/leases/">Lease</a> objects
within the <code>kube-node-lease</code>
<a class="glossary-tooltip" title="An abstraction used by Kubernetes to support isolation of groups of resources within a single cluster." data-toggle="tooltip" data-placement="top" href="/docs/concepts/overview/working-with-objects/namespaces" target="_blank" aria-label="namespace">namespace</a>.
Each Node has an associated Lease object.</li></ul><h2 id="node-controller">Node controller</h2><p>The node <a class="glossary-tooltip" title="A control loop that watches the shared state of the cluster through the apiserver and makes changes attempting to move the current state towards the desired state." data-toggle="tooltip" data-placement="top" href="/docs/concepts/architecture/controller/" target="_blank" aria-label="controller">controller</a> is a
Kubernetes control plane component that manages various aspects of nodes.</p><p>The node controller has multiple roles in a node's life. The first is assigning a
CIDR block to the node when it is registered (if CIDR assignment is turned on).</p><p>The second is keeping the node controller's internal list of nodes up to date with
the cloud provider's list of available machines. When running in a cloud
environment and whenever a node is unhealthy, the node controller asks the cloud
provider if the VM for that node is still available. If not, the node
controller deletes the node from its list of nodes.</p><p>The third is monitoring the nodes' health. The node controller is
responsible for:</p><ul><li>In the case that a node becomes unreachable, updating the <code>Ready</code> condition
in the Node's <code>.status</code> field. In this case the node controller sets the
<code>Ready</code> condition to <code>Unknown</code>.</li><li>If a node remains unreachable: triggering
<a href="/docs/concepts/scheduling-eviction/api-eviction/">API-initiated eviction</a>
for all of the Pods on the unreachable node. By default, the node controller
waits 5 minutes between marking the node as <code>Unknown</code> and submitting
the first eviction request.</li></ul><p>By default, the node controller checks the state of each node every 5 seconds.
This period can be configured using the <code>--node-monitor-period</code> flag on the
<code>kube-controller-manager</code> component.</p><h3 id="rate-limits-on-eviction">Rate limits on eviction</h3><p>In most cases, the node controller limits the eviction rate to
<code>--node-eviction-rate</code> (default 0.1) per second, meaning it won't evict pods
from more than 1 node per 10 seconds.</p><p>The node eviction behavior changes when a node in a given availability zone
becomes unhealthy. The node controller checks what percentage of nodes in the zone
are unhealthy (the <code>Ready</code> condition is <code>Unknown</code> or <code>False</code>) at the same time:</p><ul><li>If the fraction of unhealthy nodes is at least <code>--unhealthy-zone-threshold</code>
(default 0.55), then the eviction rate is reduced.</li><li>If the cluster is small (i.e. has less than or equal to
<code>--large-cluster-size-threshold</code> nodes - default 50), then evictions are stopped.</li><li>Otherwise, the eviction rate is reduced to <code>--secondary-node-eviction-rate</code>
(default 0.01) per second.</li></ul><p>The reason these policies are implemented per availability zone is because one
availability zone might become partitioned from the control plane while the others remain
connected. If your cluster does not span multiple cloud provider availability zones,
then the eviction mechanism does not take per-zone unavailability into account.</p><p>A key reason for spreading your nodes across availability zones is so that the
workload can be shifted to healthy zones when one entire zone goes down.
Therefore, if all nodes in a zone are unhealthy, then the node controller evicts at
the normal rate of <code>--node-eviction-rate</code>. The corner case is when all zones are
completely unhealthy (none of the nodes in the cluster are healthy). In such a
case, the node controller assumes that there is some problem with connectivity
between the control plane and the nodes, and doesn't perform any evictions.
(If there has been an outage and some nodes reappear, the node controller does
evict pods from the remaining nodes that are unhealthy or unreachable).</p><p>The node controller is also responsible for evicting pods running on nodes with
<code>NoExecute</code> taints, unless those pods tolerate that taint.
The node controller also adds <a class="glossary-tooltip" title="A core object consisting of three required properties: key, value, and effect. Taints prevent the scheduling of pods on nodes or node groups." data-toggle="tooltip" data-placement="top" href="/docs/concepts/scheduling-eviction/taint-and-toleration/" target="_blank" aria-label="taints">taints</a>
corresponding to node problems like node unreachable or not ready. This means
that the scheduler won't place Pods onto unhealthy nodes.</p><h2 id="node-capacity">Resource capacity tracking</h2><p>Node objects track information about the Node's resource capacity: for example, the amount
of memory available and the number of CPUs.
Nodes that <a href="#self-registration-of-nodes">self register</a> report their capacity during
registration. If you <a href="#manual-node-administration">manually</a> add a Node, then
you need to set the node's capacity information when you add it.</p><p>The Kubernetes <a class="glossary-tooltip" title="Control plane component that watches for newly created pods with no assigned node, and selects a node for them to run on." data-toggle="tooltip" data-placement="top" href="/docs/reference/command-line-tools-reference/kube-scheduler/" target="_blank" aria-label="scheduler">scheduler</a> ensures that
there are enough resources for all the Pods on a Node. The scheduler checks that the sum
of the requests of containers on the node is no greater than the node's capacity.
That sum of requests includes all containers managed by the kubelet, but excludes any
containers started directly by the container runtime, and also excludes any
processes running outside of the kubelet's control.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>If you want to explicitly reserve resources for non-Pod processes, see
<a href="/docs/tasks/administer-cluster/reserve-compute-resources/#system-reserved">reserve resources for system daemons</a>.</div><h2 id="node-topology">Node topology</h2><div class="feature-state-notice feature-stable" title="Feature Gate: TopologyManager"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.27 [stable]</code> (enabled by default: true)</div><p>If you have enabled the <code>TopologyManager</code>
<a href="/docs/reference/command-line-tools-reference/feature-gates/">feature gate</a>, then
the kubelet can use topology hints when making resource assignment decisions.
See <a href="/docs/tasks/administer-cluster/topology-manager/">Control Topology Management Policies on a Node</a>
for more information.</p><h2 id="what-s-next">What's next</h2><p>Learn more about the following:</p><ul><li><a href="/docs/concepts/architecture/#node-components">Components</a> that make up a node.</li><li><a href="/docs/reference/generated/kubernetes-api/v1.34/#node-v1-core">API definition for Node</a>.</li><li><a href="https://git.k8s.io/design-proposals-archive/architecture/architecture.md#the-kubernetes-node">Node</a>
section of the architecture design document.</li><li><a href="/docs/concepts/cluster-administration/node-shutdown/">Graceful/non-graceful node shutdown</a>.</li><li><a href="/docs/concepts/cluster-administration/node-autoscaling/">Node autoscaling</a> to
manage the number and size of nodes in your cluster.</li><li><a href="/docs/concepts/scheduling-eviction/taint-and-toleration/">Taints and Tolerations</a>.</li><li><a href="/docs/concepts/policy/node-resource-managers/">Node Resource Managers</a>.</li><li><a href="/docs/concepts/configuration/windows-resource-management/">Resource Management for Windows nodes</a>.</li></ul></div>