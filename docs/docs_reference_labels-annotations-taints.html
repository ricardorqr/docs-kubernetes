<div class="td-content"><h1 data-pagefind-weight="10">Well-Known Labels, Annotations and Taints</h1><p>Kubernetes reserves all labels, annotations and taints in the <code>kubernetes.io</code> and <code>k8s.io</code> namespaces.</p><p>This document serves both as a reference to the values and as a coordination point for assigning values.</p><h2 id="labels-annotations-and-taints-used-on-api-objects">Labels, annotations and taints used on API objects</h2><h3 id="apf-kubernetes-io-autoupdate-spec">apf.kubernetes.io/autoupdate-spec</h3><p>Type: Annotation</p><p>Example: <code>apf.kubernetes.io/autoupdate-spec: "true"</code></p><p>Used on: <a href="/docs/concepts/cluster-administration/flow-control/#defaults"><code>FlowSchema</code> and <code>PriorityLevelConfiguration</code> Objects</a></p><p>If this annotation is set to true on a FlowSchema or PriorityLevelConfiguration, the <code>spec</code> for that object
is managed by the kube-apiserver. If the API server does not recognize an APF object, and you annotate it
for automatic update, the API server deletes the entire object. Otherwise, the API server does not manage the
object spec.
For more details, read <a href="/docs/concepts/cluster-administration/flow-control/#maintenance-of-the-mandatory-and-suggested-configuration-objects">Maintenance of the Mandatory and Suggested Configuration Objects</a>.</p><h3 id="app-kubernetes-io-component">app.kubernetes.io/component</h3><p>Type: Label</p><p>Example: <code>app.kubernetes.io/component: "database"</code></p><p>Used on: All Objects (typically used on <a href="/docs/reference/kubernetes-api/workload-resources/">workload resources</a>).</p><p>The component within the application architecture.</p><p>One of the <a href="/docs/concepts/overview/working-with-objects/common-labels/#labels">recommended labels</a>.</p><h3 id="app-kubernetes-io-created-by-deprecated">app.kubernetes.io/created-by (deprecated)</h3><p>Type: Label</p><p>Example: <code>app.kubernetes.io/created-by: "controller-manager"</code></p><p>Used on: All Objects (typically used on <a href="/docs/reference/kubernetes-api/workload-resources/">workload resources</a>).</p><p>The controller/user who created this resource.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>Starting from v1.9, this label is deprecated.</div><h3 id="app-kubernetes-io-instance">app.kubernetes.io/instance</h3><p>Type: Label</p><p>Example: <code>app.kubernetes.io/instance: "mysql-abcxyz"</code></p><p>Used on: All Objects (typically used on
<a href="/docs/reference/kubernetes-api/workload-resources/">workload resources</a>).</p><p>A unique name identifying the instance of an application.
To assign a non-unique name, use <a href="#app-kubernetes-io-name">app.kubernetes.io/name</a>.</p><p>One of the <a href="/docs/concepts/overview/working-with-objects/common-labels/#labels">recommended labels</a>.</p><h3 id="app-kubernetes-io-managed-by">app.kubernetes.io/managed-by</h3><p>Type: Label</p><p>Example: <code>app.kubernetes.io/managed-by: "helm"</code></p><p>Used on: All Objects (typically used on
<a href="/docs/reference/kubernetes-api/workload-resources/">workload resources</a>).</p><p>The tool being used to manage the operation of an application.</p><p>One of the <a href="/docs/concepts/overview/working-with-objects/common-labels/#labels">recommended labels</a>.</p><h3 id="app-kubernetes-io-name">app.kubernetes.io/name</h3><p>Type: Label</p><p>Example: <code>app.kubernetes.io/name: "mysql"</code></p><p>Used on: All Objects (typically used on
<a href="/docs/reference/kubernetes-api/workload-resources/">workload resources</a>).</p><p>The name of the application.</p><p>One of the <a href="/docs/concepts/overview/working-with-objects/common-labels/#labels">recommended labels</a>.</p><h3 id="app-kubernetes-io-part-of">app.kubernetes.io/part-of</h3><p>Type: Label</p><p>Example: <code>app.kubernetes.io/part-of: "wordpress"</code></p><p>Used on: All Objects (typically used on
<a href="/docs/reference/kubernetes-api/workload-resources/">workload resources</a>).</p><p>The name of a higher-level application this object is part of.</p><p>One of the <a href="/docs/concepts/overview/working-with-objects/common-labels/#labels">recommended labels</a>.</p><h3 id="app-kubernetes-io-version">app.kubernetes.io/version</h3><p>Type: Label</p><p>Example: <code>app.kubernetes.io/version: "5.7.21"</code></p><p>Used on: All Objects (typically used on
<a href="/docs/reference/kubernetes-api/workload-resources/">workload resources</a>).</p><p>The current version of the application.</p><p>Common forms of values include:</p><ul><li><a href="https://semver.org/spec/v1.0.0.html">semantic version</a></li><li>the Git <a href="https://git-scm.com/book/en/v2/Git-Tools-Revision-Selection#_single_revisions">revision hash</a>
for the source code.</li></ul><p>One of the <a href="/docs/concepts/overview/working-with-objects/common-labels/#labels">recommended labels</a>.</p><h3 id="applyset-kubernetes-io-additional-namespaces">applyset.kubernetes.io/additional-namespaces (alpha)</h3><p>Type: Annotation</p><p>Example: <code>applyset.kubernetes.io/additional-namespaces: "namespace1,namespace2"</code></p><p>Used on: Objects being used as ApplySet parents.</p><p>Use of this annotation is Alpha.
For Kubernetes version 1.34, you can use this annotation on Secrets,
ConfigMaps, or custom resources if the
<a class="glossary-tooltip" title="Custom code that defines a resource to add to your Kubernetes API server without building a complete custom server." data-toggle="tooltip" data-placement="top" href="/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/" target="_blank" aria-label="CustomResourceDefinition">CustomResourceDefinition</a>
defining them has the <code>applyset.kubernetes.io/is-parent-type</code> label.</p><p>Part of the specification used to implement
<a href="/docs/tasks/manage-kubernetes-objects/declarative-config/#alternative-kubectl-apply-f-directory-prune">ApplySet-based pruning in kubectl</a>.
This annotation is applied to the parent object used to track an ApplySet to extend the scope of
the ApplySet beyond the parent object's own namespace (if any).
The value is a comma-separated list of the names of namespaces other than the parent's namespace
in which objects are found.</p><h3 id="applyset-kubernetes-io-contains-group-kinds">applyset.kubernetes.io/contains-group-kinds (alpha)</h3><p>Type: Annotation</p><p>Example: <code>applyset.kubernetes.io/contains-group-kinds: "certificates.cert-manager.io,configmaps,deployments.apps,secrets,services"</code></p><p>Used on: Objects being used as ApplySet parents.</p><p>Use of this annotation is Alpha.
For Kubernetes version 1.34, you can use this annotation on Secrets, ConfigMaps,
or custom resources if the CustomResourceDefinition
defining them has the <code>applyset.kubernetes.io/is-parent-type</code> label.</p><p>Part of the specification used to implement
<a href="/docs/tasks/manage-kubernetes-objects/declarative-config/#alternative-kubectl-apply-f-directory-prune">ApplySet-based pruning in kubectl</a>.
This annotation is applied to the parent object used to track an ApplySet to optimize listing of
ApplySet member objects. It is optional in the ApplySet specification, as tools can perform discovery
or use a different optimization. However, as of Kubernetes version 1.34,
it is required by kubectl. When present, the value of this annotation must be a comma separated list
of the group-kinds, in the fully-qualified name format, i.e. <code>&lt;resource&gt;.&lt;group&gt;</code>.</p><h3 id="applyset-kubernetes-io-contains-group-resources">applyset.kubernetes.io/contains-group-resources (deprecated)</h3><p>Type: Annotation</p><p>Example: <code>applyset.kubernetes.io/contains-group-resources: "certificates.cert-manager.io,configmaps,deployments.apps,secrets,services"</code></p><p>Used on: Objects being used as ApplySet parents.</p><p>For Kubernetes version 1.34, you can use this annotation on Secrets, ConfigMaps,
or custom resources if the CustomResourceDefinition
defining them has the <code>applyset.kubernetes.io/is-parent-type</code> label.</p><p>Part of the specification used to implement
<a href="/docs/tasks/manage-kubernetes-objects/declarative-config/#alternative-kubectl-apply-f-directory-prune">ApplySet-based pruning in kubectl</a>.
This annotation is applied to the parent object used to track an ApplySet to optimize listing of
ApplySet member objects. It is optional in the ApplySet specification, as tools can perform discovery
or use a different optimization. However, in Kubernetes version 1.34,
it is required by kubectl. When present, the value of this annotation must be a comma separated list
of the group-kinds, in the fully-qualified name format, i.e. <code>&lt;resource&gt;.&lt;group&gt;</code>.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>This annotation is currently deprecated and replaced by <a href="#applyset-kubernetes-io-contains-group-kinds"><code>applyset.kubernetes.io/contains-group-kinds</code></a>,
support for this will be removed in applyset beta or GA.</div><h3 id="applyset-kubernetes-io-id">applyset.kubernetes.io/id (alpha)</h3><p>Type: Label</p><p>Example: <code>applyset.kubernetes.io/id: "applyset-0eFHV8ySqp7XoShsGvyWFQD3s96yqwHmzc4e0HR1dsY-v1"</code></p><p>Used on: Objects being used as ApplySet parents.</p><p>Use of this label is Alpha.
For Kubernetes version 1.34, you can use this label on Secrets, ConfigMaps,
or custom resources if the CustomResourceDefinition
defining them has the <code>applyset.kubernetes.io/is-parent-type</code> label.</p><p>Part of the specification used to implement
<a href="/docs/tasks/manage-kubernetes-objects/declarative-config/#alternative-kubectl-apply-f-directory-prune">ApplySet-based pruning in kubectl</a>.
This label is what makes an object an ApplySet parent object.
Its value is the unique ID of the ApplySet, which is derived from the identity of the parent
object itself. This ID <strong>must</strong> be the base64 encoding (using the URL safe encoding of RFC4648) of
the hash of the group-kind-name-namespace of the object it is on, in the form:
<code>&lt;base64(sha256(&lt;name&gt;.&lt;namespace&gt;.&lt;kind&gt;.&lt;group&gt;))&gt;</code>.
There is no relation between the value of this label and object UID.</p><h3 id="applyset-kubernetes-io-is-parent-type">applyset.kubernetes.io/is-parent-type (alpha)</h3><p>Type: Label</p><p>Example: <code>applyset.kubernetes.io/is-parent-type: "true"</code></p><p>Used on: Custom Resource Definition (CRD)</p><p>Use of this label is Alpha.
Part of the specification used to implement
<a href="/docs/tasks/manage-kubernetes-objects/declarative-config/#alternative-kubectl-apply-f-directory-prune">ApplySet-based pruning in kubectl</a>.
You can set this label on a CustomResourceDefinition (CRD) to identify the custom resource type it
defines (not the CRD itself) as an allowed parent for an ApplySet.
The only permitted value for this label is <code>"true"</code>; if you want to mark a CRD as
not being a valid parent for ApplySets, omit this label.</p><h3 id="applyset-kubernetes-io-part-of">applyset.kubernetes.io/part-of (alpha)</h3><p>Type: Label</p><p>Example: <code>applyset.kubernetes.io/part-of: "applyset-0eFHV8ySqp7XoShsGvyWFQD3s96yqwHmzc4e0HR1dsY-v1"</code></p><p>Used on: All objects.</p><p>Use of this label is Alpha.
Part of the specification used to implement
<a href="/docs/tasks/manage-kubernetes-objects/declarative-config/#alternative-kubectl-apply-f-directory-prune">ApplySet-based pruning in kubectl</a>.
This label is what makes an object a member of an ApplySet.
The value of the label <strong>must</strong> match the value of the <code>applyset.kubernetes.io/id</code>
label on the parent object.</p><h3 id="applyset-kubernetes-io-tooling">applyset.kubernetes.io/tooling (alpha)</h3><p>Type: Annotation</p><p>Example: <code>applyset.kubernetes.io/tooling: "kubectl/v1.34"</code></p><p>Used on: Objects being used as ApplySet parents.</p><p>Use of this annotation is Alpha.
For Kubernetes version 1.34, you can use this annotation on Secrets,
ConfigMaps, or custom resources if the CustomResourceDefinitiondefining them has the
<code>applyset.kubernetes.io/is-parent-type</code> label.</p><p>Part of the specification used to implement
<a href="/docs/tasks/manage-kubernetes-objects/declarative-config/#alternative-kubectl-apply-f-directory-prune">ApplySet-based pruning in kubectl</a>.
This annotation is applied to the parent object used to track an ApplySet to indicate which
tooling manages that ApplySet. Tooling should refuse to mutate ApplySets belonging to other tools.
The value must be in the format <code>&lt;toolname&gt;/&lt;semver&gt;</code>.</p><h3 id="apps-kubernetes.io-pod-index">apps.kubernetes.io/pod-index (beta)</h3><p>Type: Label</p><p>Example: <code>apps.kubernetes.io/pod-index: "0"</code></p><p>Used on: Pod</p><p>When a StatefulSet controller creates a Pod for the StatefulSet, it sets this label on that Pod.
The value of the label is the ordinal index of the pod being created.</p><p>See <a href="/docs/concepts/workloads/controllers/statefulset/#pod-index-label">Pod Index Label</a>
in the StatefulSet topic for more details.
Note the <a href="/docs/reference/command-line-tools-reference/feature-gates/">PodIndexLabel</a>
feature gate must be enabled for this label to be added to pods.</p><h3 id="resource-kubernetes-io-pod-claim-name">resource.kubernetes.io/pod-claim-name</h3><p>Type: Annotation</p><p>Example: <code>resource.kubernetes.io/pod-claim-name: "my-pod-claim"</code></p><p>Used on: ResourceClaim</p><p>This annotation is assigned to generated ResourceClaims.
Its value corresponds to the name of the resource claim in the <code>.spec</code> of any Pod(s) for which the ResourceClaim was created.
This annotation is an internal implementation detail of <a href="/docs/concepts/scheduling-eviction/dynamic-resource-allocation/">dynamic resource allocation</a>.
You should not need to read or modify the value of this annotation.</p><h3 id="cluster-autoscaler-kubernetes-io-safe-to-evict">cluster-autoscaler.kubernetes.io/safe-to-evict</h3><p>Type: Annotation</p><p>Example: <code>cluster-autoscaler.kubernetes.io/safe-to-evict: "true"</code></p><p>Used on: Pod</p><p>When this annotation is set to <code>"true"</code>, the cluster autoscaler is allowed to evict a Pod
even if other rules would normally prevent that.
The cluster autoscaler never evicts Pods that have this annotation explicitly set to
<code>"false"</code>; you could set that on an important Pod that you want to keep running.
If this annotation is not set then the cluster autoscaler follows its Pod-level behavior.</p><h3 id="config-kubernetes-io-local-config">config.kubernetes.io/local-config</h3><p>Type: Annotation</p><p>Example: <code>config.kubernetes.io/local-config: "true"</code></p><p>Used on: All objects</p><p>This annotation is used in manifests to mark an object as local configuration that
should not be submitted to the Kubernetes API.</p><p>A value of <code>"true"</code> for this annotation declares that the object is only consumed by
client-side tooling and should not be submitted to the API server.</p><p>A value of <code>"false"</code> can be used to declare that the object should be submitted to
the API server even when it would otherwise be assumed to be local.</p><p>This annotation is part of the Kubernetes Resource Model (KRM) Functions Specification,
which is used by Kustomize and similar third-party tools.
For example, Kustomize removes objects with this annotation from its final build output.</p><h3 id="container-apparmor-security-beta-kubernetes-io">container.apparmor.security.beta.kubernetes.io/* (deprecated)</h3><p>Type: Annotation</p><p>Example: <code>container.apparmor.security.beta.kubernetes.io/my-container: my-custom-profile</code></p><p>Used on: Pods</p><p>This annotation allows you to specify the AppArmor security profile for a container within a
Kubernetes pod. As of Kubernetes v1.30, this should be set with the <code>appArmorProfile</code> field instead.
To learn more, see the <a href="/docs/tutorials/security/apparmor/">AppArmor</a> tutorial.
The tutorial illustrates using AppArmor to restrict a container's abilities and access.</p><p>The profile specified dictates the set of rules and restrictions that the containerized process must
adhere to. This helps enforce security policies and isolation for your containers.</p><h3 id="internal.config.kubernetes.io-reserved-wildcard">internal.config.kubernetes.io/* (reserved prefix)</h3><p>Type: Annotation</p><p>Used on: All objects</p><p>This prefix is reserved for internal use by tools that act as orchestrators in accordance
with the Kubernetes Resource Model (KRM) Functions Specification.
Annotations with this prefix are internal to the orchestration process and are not persisted to
the manifests on the filesystem. In other words, the orchestrator tool should set these
annotations when reading files from the local filesystem and remove them when writing the output
of functions back to the filesystem.</p><p>A KRM function <strong>must not</strong> modify annotations with this prefix, unless otherwise specified for a
given annotation. This enables orchestrator tools to add additional internal annotations, without
requiring changes to existing functions.</p><h3 id="internal-config-kubernetes-io-path">internal.config.kubernetes.io/path</h3><p>Type: Annotation</p><p>Example: <code>internal.config.kubernetes.io/path: "relative/file/path.yaml"</code></p><p>Used on: All objects</p><p>This annotation records the slash-delimited, OS-agnostic, relative path to the manifest file the
object was loaded from. The path is relative to a fixed location on the filesystem, determined by
the orchestrator tool.</p><p>This annotation is part of the Kubernetes Resource Model (KRM) Functions Specification, which is
used by Kustomize and similar third-party tools.</p><p>A KRM Function <strong>should not</strong> modify this annotation on input objects unless it is modifying the
referenced files. A KRM Function <strong>may</strong> include this annotation on objects it generates.</p><h3 id="internal-config-kubernetes-io-index">internal.config.kubernetes.io/index</h3><p>Type: Annotation</p><p>Example: <code>internal.config.kubernetes.io/index: "2"</code></p><p>Used on: All objects</p><p>This annotation records the zero-indexed position of the YAML document that contains the object
within the manifest file the object was loaded from. Note that YAML documents are separated by
three dashes (<code>---</code>) and can each contain one object. When this annotation is not specified, a
value of 0 is implied.</p><p>This annotation is part of the Kubernetes Resource Model (KRM) Functions Specification,
which is used by Kustomize and similar third-party tools.</p><p>A KRM Function <strong>should not</strong> modify this annotation on input objects unless it is modifying the
referenced files. A KRM Function <strong>may</strong> include this annotation on objects it generates.</p><h3 id="kube-scheduler-simulator-sigs-k8s-io-bind-result">kube-scheduler-simulator.sigs.k8s.io/bind-result</h3><p>Type: Annotation</p><p>Example: <code>kube-scheduler-simulator.sigs.k8s.io/bind-result: '{"DefaultBinder":"success"}'</code></p><p>Used on: Pod</p><p>This annotation records the result of bind scheduler plugins, used by <a href="https://sigs.k8s.io/kube-scheduler-simulator">https://sigs.k8s.io/kube-scheduler-simulator</a>.</p><h3 id="kube-scheduler-simulator-sigs-k8s-io-filter-result">kube-scheduler-simulator.sigs.k8s.io/filter-result</h3><p>Type: Annotation</p><p>Example:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">kube-scheduler-simulator.sigs.k8s.io/filter-result</span>:<span style="color:#bbb"> </span>&gt;-<span style="color:#b44;font-style:italic">
</span></span></span><span style="display:flex"><span><span style="color:#b44;font-style:italic">      {"node-282x7":{"AzureDiskLimits":"passed","EBSLimits":"passed","GCEPDLimits":"passed","InterPodAffinity":"passed","NodeAffinity":"passed","NodeName":"passed","NodePorts":"passed","NodeResourcesFit":"passed","NodeUnschedulable":"passed","NodeVolumeLimits":"passed","PodTopologySpread":"passed","TaintToleration":"passed","VolumeBinding":"passed","VolumeRestrictions":"passed","VolumeZone":"passed"},"node-gp9t4":{"AzureDiskLimits":"passed","EBSLimits":"passed","GCEPDLimits":"passed","InterPodAffinity":"passed","NodeAffinity":"passed","NodeName":"passed","NodePorts":"passed","NodeResourcesFit":"passed","NodeUnschedulable":"passed","NodeVolumeLimits":"passed","PodTopologySpread":"passed","TaintToleration":"passed","VolumeBinding":"passed","VolumeRestrictions":"passed","VolumeZone":"passed"}}</span><span style="color:#bbb">      
</span></span></span></code></pre></div><p>Used on: Pod</p><p>This annotation records the result of filter scheduler plugins, used by <a href="https://sigs.k8s.io/kube-scheduler-simulator">https://sigs.k8s.io/kube-scheduler-simulator</a>.</p><h3 id="kube-scheduler-simulator-sigs-k8s-io-finalscore-result">kube-scheduler-simulator.sigs.k8s.io/finalscore-result</h3><p>Type: Annotation</p><p>Example:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">kube-scheduler-simulator.sigs.k8s.io/finalscore-result</span>:<span style="color:#bbb"> </span>&gt;-<span style="color:#b44;font-style:italic">
</span></span></span><span style="display:flex"><span><span style="color:#b44;font-style:italic">      {"node-282x7":{"ImageLocality":"0","InterPodAffinity":"0","NodeAffinity":"0","NodeNumber":"0","NodeResourcesBalancedAllocation":"76","NodeResourcesFit":"73","PodTopologySpread":"200","TaintToleration":"300","VolumeBinding":"0"},"node-gp9t4":{"ImageLocality":"0","InterPodAffinity":"0","NodeAffinity":"0","NodeNumber":"0","NodeResourcesBalancedAllocation":"76","NodeResourcesFit":"73","PodTopologySpread":"200","TaintToleration":"300","VolumeBinding":"0"}}</span><span style="color:#bbb">      
</span></span></span></code></pre></div><p>Used on: Pod</p><p>This annotation records the final scores that the scheduler calculates from the scores from score scheduler plugins,
used by <a href="https://sigs.k8s.io/kube-scheduler-simulator">https://sigs.k8s.io/kube-scheduler-simulator</a>.</p><h3 id="kube-scheduler-simulator-sigs-k8s-io-permit-result">kube-scheduler-simulator.sigs.k8s.io/permit-result</h3><p>Type: Annotation</p><p>Example: <code>kube-scheduler-simulator.sigs.k8s.io/permit-result: '{"CustomPermitPlugin":"success"}'</code></p><p>Used on: Pod</p><p>This annotation records the result of permit scheduler plugins, used by <a href="https://sigs.k8s.io/kube-scheduler-simulator">https://sigs.k8s.io/kube-scheduler-simulator</a>.</p><h3 id="kube-scheduler-simulator-sigs-k8s-io-permit-result-timeout">kube-scheduler-simulator.sigs.k8s.io/permit-result-timeout</h3><p>Type: Annotation</p><p>Example: <code>kube-scheduler-simulator.sigs.k8s.io/permit-result-timeout: '{"CustomPermitPlugin":"10s"}'</code></p><p>Used on: Pod</p><p>This annotation records the timeouts returned from permit scheduler plugins, used by <a href="https://sigs.k8s.io/kube-scheduler-simulator">https://sigs.k8s.io/kube-scheduler-simulator</a>.</p><h3 id="kube-scheduler-simulator-sigs-k8s-io-postfilter-result">kube-scheduler-simulator.sigs.k8s.io/postfilter-result</h3><p>Type: Annotation</p><p>Example: <code>kube-scheduler-simulator.sigs.k8s.io/postfilter-result: '{"DefaultPreemption":"success"}'</code></p><p>Used on: Pod</p><p>This annotation records the result of postfilter scheduler plugins, used by <a href="https://sigs.k8s.io/kube-scheduler-simulator">https://sigs.k8s.io/kube-scheduler-simulator</a>.</p><h3 id="kube-scheduler-simulator-sigs-k8s-io-prebind-result">kube-scheduler-simulator.sigs.k8s.io/prebind-result</h3><p>Type: Annotation</p><p>Example: <code>kube-scheduler-simulator.sigs.k8s.io/prebind-result: '{"VolumeBinding":"success"}'</code></p><p>Used on: Pod</p><p>This annotation records the result of prebind scheduler plugins, used by <a href="https://sigs.k8s.io/kube-scheduler-simulator">https://sigs.k8s.io/kube-scheduler-simulator</a>.</p><h3 id="kube-scheduler-simulator-sigs-k8s-io-prefilter-result">kube-scheduler-simulator.sigs.k8s.io/prefilter-result</h3><p>Type: Annotation</p><p>Example: <code>kube-scheduler-simulator.sigs.k8s.io/prebind-result: '{"NodeAffinity":"[\"node-\a"]"}'</code></p><p>Used on: Pod</p><p>This annotation records the PreFilter result of prefilter scheduler plugins, used by <a href="https://sigs.k8s.io/kube-scheduler-simulator">https://sigs.k8s.io/kube-scheduler-simulator</a>.</p><h3 id="kube-scheduler-simulator-sigs-k8s-io-prefilter-result-status">kube-scheduler-simulator.sigs.k8s.io/prefilter-result-status</h3><p>Type: Annotation</p><p>Example:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">kube-scheduler-simulator.sigs.k8s.io/prefilter-result-status</span>:<span style="color:#bbb"> </span>&gt;-<span style="color:#b44;font-style:italic">
</span></span></span><span style="display:flex"><span><span style="color:#b44;font-style:italic">      {"InterPodAffinity":"success","NodeAffinity":"success","NodePorts":"success","NodeResourcesFit":"success","PodTopologySpread":"success","VolumeBinding":"success","VolumeRestrictions":"success"}</span><span style="color:#bbb">      
</span></span></span></code></pre></div><p>Used on: Pod</p><p>This annotation records the result of prefilter scheduler plugins, used by <a href="https://sigs.k8s.io/kube-scheduler-simulator">https://sigs.k8s.io/kube-scheduler-simulator</a>.</p><h3 id="kube-scheduler-simulator-sigs-k8s-io-prescore-result">kube-scheduler-simulator.sigs.k8s.io/prescore-result</h3><p>Type: Annotation</p><p>Example:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">kube-scheduler-simulator.sigs.k8s.io/prescore-result</span>:<span style="color:#bbb"> </span>&gt;-<span style="color:#b44;font-style:italic">
</span></span></span><span style="display:flex"><span><span style="color:#b44;font-style:italic">      {"InterPodAffinity":"success","NodeAffinity":"success","NodeNumber":"success","PodTopologySpread":"success","TaintToleration":"success"}</span><span style="color:#bbb">      
</span></span></span></code></pre></div><p>Used on: Pod</p><p>This annotation records the result of prefilter scheduler plugins, used by <a href="https://sigs.k8s.io/kube-scheduler-simulator">https://sigs.k8s.io/kube-scheduler-simulator</a>.</p><h3 id="kube-scheduler-simulator-sigs-k8s-io-reserve-result">kube-scheduler-simulator.sigs.k8s.io/reserve-result</h3><p>Type: Annotation</p><p>Example: <code>kube-scheduler-simulator.sigs.k8s.io/reserve-result: '{"VolumeBinding":"success"}'</code></p><p>Used on: Pod</p><p>This annotation records the result of reserve scheduler plugins, used by <a href="https://sigs.k8s.io/kube-scheduler-simulator">https://sigs.k8s.io/kube-scheduler-simulator</a>.</p><h3 id="kube-scheduler-simulator-sigs-k8s-io-result-history">kube-scheduler-simulator.sigs.k8s.io/result-history</h3><p>Type: Annotation</p><p>Example: <code>kube-scheduler-simulator.sigs.k8s.io/result-history: '[]'</code></p><p>Used on: Pod</p><p>This annotation records all the past scheduling results from scheduler plugins, used by <a href="https://sigs.k8s.io/kube-scheduler-simulator">https://sigs.k8s.io/kube-scheduler-simulator</a>.</p><h3 id="kube-scheduler-simulator-sigs-k8s-io-score-result">kube-scheduler-simulator.sigs.k8s.io/score-result</h3><p>Type: Annotation</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">kube-scheduler-simulator.sigs.k8s.io/score-result</span>:<span style="color:#bbb"> </span>&gt;-<span style="color:#b44;font-style:italic">
</span></span></span><span style="display:flex"><span><span style="color:#b44;font-style:italic">      {"node-282x7":{"ImageLocality":"0","InterPodAffinity":"0","NodeAffinity":"0","NodeNumber":"0","NodeResourcesBalancedAllocation":"76","NodeResourcesFit":"73","PodTopologySpread":"0","TaintToleration":"0","VolumeBinding":"0"},"node-gp9t4":{"ImageLocality":"0","InterPodAffinity":"0","NodeAffinity":"0","NodeNumber":"0","NodeResourcesBalancedAllocation":"76","NodeResourcesFit":"73","PodTopologySpread":"0","TaintToleration":"0","VolumeBinding":"0"}}</span><span style="color:#bbb">      
</span></span></span></code></pre></div><p>Used on: Pod</p><p>This annotation records the result of score scheduler plugins, used by <a href="https://sigs.k8s.io/kube-scheduler-simulator">https://sigs.k8s.io/kube-scheduler-simulator</a>.</p><h3 id="kube-scheduler-simulator-sigs-k8s-io-selected-node">kube-scheduler-simulator.sigs.k8s.io/selected-node</h3><p>Type: Annotation</p><p>Example: <code>kube-scheduler-simulator.sigs.k8s.io/selected-node: node-282x7</code></p><p>Used on: Pod</p><p>This annotation records the node that is selected by the scheduling cycle, used by <a href="https://sigs.k8s.io/kube-scheduler-simulator">https://sigs.k8s.io/kube-scheduler-simulator</a>.</p><h3 id="kubernetes-io-arch">kubernetes.io/arch</h3><p>Type: Label</p><p>Example: <code>kubernetes.io/arch: "amd64"</code></p><p>Used on: Node</p><p>The Kubelet populates this with <code>runtime.GOARCH</code> as defined by Go.
This can be handy if you are mixing ARM and x86 nodes.</p><h3 id="kubernetes-io-os">kubernetes.io/os</h3><p>Type: Label</p><p>Example: <code>kubernetes.io/os: "linux"</code></p><p>Used on: Node, Pod</p><p>For nodes, the kubelet populates this with <code>runtime.GOOS</code> as defined by Go. This can be handy if you are
mixing operating systems in your cluster (for example: mixing Linux and Windows nodes).</p><p>You can also set this label on a Pod. Kubernetes allows you to set any value for this label;
if you use this label, you should nevertheless set it to the Go <code>runtime.GOOS</code> string for the operating
system that this Pod actually works with.</p><p>When the <code>kubernetes.io/os</code> label value for a Pod does not match the label value on a Node,
the kubelet on the node will not admit the Pod. However, this is not taken into account by
the kube-scheduler. Alternatively, the kubelet refuses to run a Pod where you have specified a Pod OS, if
this isn't the same as the operating system for the node where that kubelet is running. Just
look for <a href="/docs/concepts/workloads/pods/#pod-os">Pods OS</a> for more details.</p><h3 id="kubernetes-io-metadata-name">kubernetes.io/metadata.name</h3><p>Type: Label</p><p>Example: <code>kubernetes.io/metadata.name: "mynamespace"</code></p><p>Used on: Namespaces</p><p>The Kubernetes API server (part of the <a class="glossary-tooltip" title="The container orchestration layer that exposes the API and interfaces to define, deploy, and manage the lifecycle of containers." data-toggle="tooltip" data-placement="top" href="/docs/reference/glossary/?all=true#term-control-plane" target="_blank" aria-label="control plane">control plane</a>)
sets this label on all namespaces. The label value is set
to the name of the namespace. You can't change this label's value.</p><p>This is useful if you want to target a specific namespace with a label
<a class="glossary-tooltip" title="Allows users to filter a list of resources based on labels." data-toggle="tooltip" data-placement="top" href="/docs/concepts/overview/working-with-objects/labels/" target="_blank" aria-label="selector">selector</a>.</p><h3 id="kubernetes-io-limit-ranger">kubernetes.io/limit-ranger</h3><p>Type: Annotation</p><p>Example: <code>kubernetes.io/limit-ranger: "LimitRanger plugin set: cpu, memory request for container nginx; cpu, memory limit for container nginx"</code></p><p>Used on: Pod</p><p>Kubernetes by default doesn't provide any resource limit, that means unless you explicitly define
limits, your container can consume unlimited CPU and memory.
You can define a default request or default limit for pods. You do this by creating a LimitRange
in the relevant namespace. Pods deployed after you define a LimitRange will have these limits
applied to them.
The annotation <code>kubernetes.io/limit-ranger</code> records that resource defaults were specified for the Pod,
and they were applied successfully.
For more details, read about <a href="/docs/concepts/policy/limit-range/">LimitRanges</a>.</p><h3 id="kubernetes-io-config-hash">kubernetes.io/config.hash</h3><p>Type: Annotation</p><p>Example: <code>kubernetes.io/config.hash: "df7cc47f8477b6b1226d7d23a904867b"</code></p><p>Used on: Pod</p><p>When the kubelet creates a static Pod based on a given manifest, it attaches this annotation
to the static Pod. The value of the annotation is the UID of the Pod.
Note that the kubelet also sets the <code>.spec.nodeName</code> to the current node name as if the Pod
was scheduled to the node.</p><h3 id="kubernetes-io-config-mirror">kubernetes.io/config.mirror</h3><p>Type: Annotation</p><p>Example: <code>kubernetes.io/config.mirror: "df7cc47f8477b6b1226d7d23a904867b"</code></p><p>Used on: Pod</p><p>For a static Pod created by the kubelet on a node, a <a class="glossary-tooltip" title="An object in the API server that tracks a static pod on a kubelet." data-toggle="tooltip" data-placement="top" href="/docs/reference/glossary/?all=true#term-mirror-pod" target="_blank" aria-label="mirror Pod">mirror Pod</a>
is created on the API server. The kubelet adds an annotation to indicate that this Pod is
actually a mirror Pod. The annotation value is copied from the <a href="#kubernetes-io-config-hash"><code>kubernetes.io/config.hash</code></a>
annotation, which is the UID of the Pod.</p><p>When updating a Pod with this annotation set, the annotation cannot be changed or removed.
If a Pod doesn't have this annotation, it cannot be added during a Pod update.</p><h3 id="kubernetes-io-config-source">kubernetes.io/config.source</h3><p>Type: Annotation</p><p>Example: <code>kubernetes.io/config.source: "file"</code></p><p>Used on: Pod</p><p>This annotation is added by the kubelet to indicate where the Pod comes from.
For static Pods, the annotation value could be one of <code>file</code> or <code>http</code> depending
on where the Pod manifest is located. For a Pod created on the API server and then
scheduled to the current node, the annotation value is <code>api</code>.</p><h3 id="kubernetes-io-config-seen">kubernetes.io/config.seen</h3><p>Type: Annotation</p><p>Example: <code>kubernetes.io/config.seen: "2023-10-27T04:04:56.011314488Z"</code></p><p>Used on: Pod</p><p>When the kubelet sees a Pod for the first time, it may add this annotation to
the Pod with a value of current timestamp in the RFC3339 format.</p><h3 id="addonmanager-kubernetes-io-mode">addonmanager.kubernetes.io/mode</h3><p>Type: Label</p><p>Example: <code>addonmanager.kubernetes.io/mode: "Reconcile"</code></p><p>Used on: All objects</p><p>To specify how an add-on should be managed, you can use the <code>addonmanager.kubernetes.io/mode</code> label.
This label can have one of three values: <code>Reconcile</code>, <code>EnsureExists</code>, or <code>Ignore</code>.</p><ul><li><code>Reconcile</code>: Addon resources will be periodically reconciled with the expected state.
If there are any differences, the add-on manager will recreate, reconfigure or delete
the resources as needed. This is the default mode if no label is specified.</li><li><code>EnsureExists</code>: Addon resources will be checked for existence only but will not be modified
after creation. The add-on manager will create or re-create the resources when there is
no instance of the resource with that name.</li><li><code>Ignore</code>: Addon resources will be ignored. This mode is useful for add-ons that are not
compatible with the add-on manager or that are managed by another controller.</li></ul><p>For more details, see <a href="https://github.com/kubernetes/kubernetes/blob/master/cluster/addons/addon-manager/README.md">Addon-manager</a>.</p><h3 id="beta-kubernetes-io-arch-deprecated">beta.kubernetes.io/arch (deprecated)</h3><p>Type: Label</p><p>This label has been deprecated. Please use <a href="#kubernetes-io-arch"><code>kubernetes.io/arch</code></a> instead.</p><h3 id="beta-kubernetes-io-os-deprecated">beta.kubernetes.io/os (deprecated)</h3><p>Type: Label</p><p>This label has been deprecated. Please use <a href="#kubernetes-io-os"><code>kubernetes.io/os</code></a> instead.</p><h3 id="kube-aggregator-kubernetesio-automanaged">kube-aggregator.kubernetes.io/automanaged</h3><p>Type: Label</p><p>Example: <code>kube-aggregator.kubernetes.io/automanaged: "onstart"</code></p><p>Used on: APIService</p><p>The <code>kube-apiserver</code> sets this label on any APIService object that the API server
has created automatically. The label marks how the control plane should manage that
APIService. You should not add, modify, or remove this label by yourself.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>Automanaged APIService objects are deleted by kube-apiserver when it has no built-in
or custom resource API corresponding to the API group/version of the APIService.</div><p>There are two possible values:</p><ul><li><code>onstart</code>: The APIService should be reconciled when an API server starts up, but not otherwise.</li><li><code>true</code>: The API server should reconcile this APIService continuously.</li></ul><h3 id="service-alpha-kubernetes-io-tolerate-unready-endpoints-deprecated">service.alpha.kubernetes.io/tolerate-unready-endpoints (deprecated)</h3><p>Type: Annotation</p><p>Used on: StatefulSet</p><p>This annotation on a Service denotes if the Endpoints controller should go ahead and create
Endpoints for unready Pods. Endpoints of these Services retain their DNS records and continue
receiving traffic for the Service from the moment the kubelet starts all containers in the pod
and marks it <em>Running</em>, til the kubelet stops all containers and deletes the pod from
the API server.</p><h3 id="autoscaling-alpha-kubernetes-io-behavior">autoscaling.alpha.kubernetes.io/behavior (deprecated)</h3><p>Type: Annotation</p><p>Used on: HorizontalPodAutoscaler</p><p>This annotation was used to configure the scaling behavior for a HorizontalPodAutoscaler (HPA) in earlier Kubernetes versions.
It allowed you to specify how the HPA should scale pods up or down, including setting stabilization windows and scaling policies.
Setting this annotation has no effect in any supported release of Kubernetes.</p><h3 id="kubernetesiohostname">kubernetes.io/hostname</h3><p>Type: Label</p><p>Example: <code>kubernetes.io/hostname: "ip-172-20-114-199.ec2.internal"</code></p><p>Used on: Node</p><p>The Kubelet populates this label with the hostname of the node. Note that the hostname
can be changed from the "actual" hostname by passing the <code>--hostname-override</code> flag to
the <code>kubelet</code>.</p><p>This label is also used as part of the topology hierarchy.
See <a href="#topologykubernetesiozone">topology.kubernetes.io/zone</a> for more information.</p><h3 id="change-cause">kubernetes.io/change-cause</h3><p>Type: Annotation</p><p>Example: <code>kubernetes.io/change-cause: "kubectl edit --record deployment foo"</code></p><p>Used on: All Objects</p><p>This annotation is a best guess at why something was changed.</p><p>It is populated when adding <code>--record</code> to a <code>kubectl</code> command that may change an object.</p><h3 id="description">kubernetes.io/description</h3><p>Type: Annotation</p><p>Example: <code>kubernetes.io/description: "Description of K8s object."</code></p><p>Used on: All Objects</p><p>This annotation is used for describing specific behaviour of given object.</p><h3 id="enforce-mountable-secrets">kubernetes.io/enforce-mountable-secrets (deprecated)</h3><p>Type: Annotation</p><p>Example: <code>kubernetes.io/enforce-mountable-secrets: "true"</code></p><p>Used on: ServiceAccount</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4><code>kubernetes.io/enforce-mountable-secrets</code> is deprecated since Kubernetes v1.32. Use separate namespaces to isolate access to mounted secrets.</div><p>The value for this annotation must be <strong>true</strong> to take effect.
When you set this annotation to "true", Kubernetes enforces the following rules for
Pods running as this ServiceAccount:</p><ol><li>Secrets mounted as volumes must be listed in the ServiceAccount's <code>secrets</code> field.</li><li>Secrets referenced in <code>envFrom</code> for containers (including sidecar containers and init containers)
must also be listed in the ServiceAccount's secrets field.
If any container in a Pod references a Secret not listed in the ServiceAccount's <code>secrets</code> field
(and even if the reference is marked as <code>optional</code>), then the Pod will fail to start,
and an error indicating the non-compliant secret reference will be generated.</li><li>Secrets referenced in a Pod's <code>imagePullSecrets</code> must be present in the
ServiceAccount's <code>imagePullSecrets</code> field, the Pod will fail to start,
and an error indicating the non-compliant image pull secret reference will be generated.</li></ol><p>When you create or update a Pod, these rules are checked. If a Pod doesn't follow them, it won't start and you'll see an error message.
If a Pod is already running and you change the <code>kubernetes.io/enforce-mountable-secrets</code> annotation
to true, or you edit the associated ServiceAccount to remove the reference to a Secret
that the Pod is already using, the Pod continues to run.</p><h3 id="node-kubernetes-io-exclude-from-external-load-balancers">node.kubernetes.io/exclude-from-external-load-balancers</h3><p>Type: Label</p><p>Example: <code>node.kubernetes.io/exclude-from-external-load-balancers</code></p><p>Used on: Node</p><p>You can add labels to particular worker nodes to exclude them from the list of backend servers used by external load balancers.
The following command can be used to exclude a worker node from the list of backend servers in a
backend set:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl label nodes &lt;node-name&gt; node.kubernetes.io/exclude-from-external-load-balancers<span style="color:#666">=</span><span style="color:#a2f">true</span>
</span></span></code></pre></div><h3 id="pod-deletion-cost">controller.kubernetes.io/pod-deletion-cost</h3><p>Type: Annotation</p><p>Example: <code>controller.kubernetes.io/pod-deletion-cost: "10"</code></p><p>Used on: Pod</p><p>This annotation is used to set <a href="/docs/concepts/workloads/controllers/replicaset/#pod-deletion-cost">Pod Deletion Cost</a>
which allows users to influence ReplicaSet downscaling order.
The annotation value parses into an <code>int32</code> type.</p><h3 id="cluster-autoscaler-kubernetes-io-enable-ds-eviction">cluster-autoscaler.kubernetes.io/enable-ds-eviction</h3><p>Type: Annotation</p><p>Example: <code>cluster-autoscaler.kubernetes.io/enable-ds-eviction: "true"</code></p><p>Used on: Pod</p><p>This annotation controls whether a DaemonSet pod should be evicted by a ClusterAutoscaler.
This annotation needs to be specified on DaemonSet pods in a DaemonSet manifest.
When this annotation is set to <code>"true"</code>, the ClusterAutoscaler is allowed to evict
a DaemonSet Pod, even if other rules would normally prevent that.
To disallow the ClusterAutoscaler from evicting DaemonSet pods,
you can set this annotation to <code>"false"</code> for important DaemonSet pods.
If this annotation is not set, then the ClusterAutoscaler follows its overall behavior
(i.e evict the DaemonSets based on its configuration).</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>This annotation only impacts DaemonSet Pods.</div><h3 id="kubernetes-io-ingress-bandwidth">kubernetes.io/ingress-bandwidth</h3><p>Type: Annotation</p><p>Example: <code>kubernetes.io/ingress-bandwidth: 10M</code></p><p>Used on: Pod</p><p>You can apply quality-of-service traffic shaping to a pod and effectively limit its available
bandwidth. Ingress traffic to a Pod is handled by shaping queued packets to effectively
handle data. To limit the bandwidth on a Pod, write an object definition JSON file and specify
the data traffic speed using <code>kubernetes.io/ingress-bandwidth</code> annotation. The unit used for
specifying ingress rate is bits per second, as a
<a href="/docs/reference/kubernetes-api/common-definitions/quantity/">Quantity</a>.
For example, <code>10M</code> means 10 megabits per second.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>Ingress traffic shaping annotation is an experimental feature.
If you want to enable traffic shaping support, you must add the <code>bandwidth</code> plugin to your CNI
configuration file (default <code>/etc/cni/net.d</code>) and ensure that the binary is included in your CNI
bin dir (default <code>/opt/cni/bin</code>).</div><h3 id="kubernetes-io-egress-bandwidth">kubernetes.io/egress-bandwidth</h3><p>Type: Annotation</p><p>Example: <code>kubernetes.io/egress-bandwidth: 10M</code></p><p>Used on: Pod</p><p>Egress traffic from a Pod is handled by policing, which simply drops packets in excess of the
configured rate. The limits you place on a Pod do not affect the bandwidth of other Pods.
To limit the bandwidth on a Pod, write an object definition JSON file and specify the data traffic
speed using <code>kubernetes.io/egress-bandwidth</code> annotation. The unit used for specifying egress rate
is bits per second, as a <a href="/docs/reference/kubernetes-api/common-definitions/quantity/">Quantity</a>.
For example, <code>10M</code> means 10 megabits per second.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>Egress traffic shaping annotation is an experimental feature.
If you want to enable traffic shaping support, you must add the <code>bandwidth</code> plugin to your CNI
configuration file (default <code>/etc/cni/net.d</code>) and ensure that the binary is included in your CNI
bin dir (default <code>/opt/cni/bin</code>).</div><h3 id="beta-kubernetes-io-instance-type-deprecated">beta.kubernetes.io/instance-type (deprecated)</h3><p>Type: Label</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>Starting in v1.17, this label is deprecated in favor of
<a href="#nodekubernetesioinstance-type">node.kubernetes.io/instance-type</a>.</div><h3 id="nodekubernetesioinstance-type">node.kubernetes.io/instance-type</h3><p>Type: Label</p><p>Example: <code>node.kubernetes.io/instance-type: "m3.medium"</code></p><p>Used on: Node</p><p>The Kubelet populates this with the instance type as defined by the cloud provider.
This will be set only if you are using a cloud provider. This setting is handy
if you want to target certain workloads to certain instance types, but typically you want
to rely on the Kubernetes scheduler to perform resource-based scheduling.
You should aim to schedule based on properties rather than on instance types
(for example: require a GPU, instead of requiring a <code>g2.2xlarge</code>).</p><h3 id="failure-domainbetakubernetesioregion">failure-domain.beta.kubernetes.io/region (deprecated)</h3><p>Type: Label</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>Starting in v1.17, this label is deprecated in favor of
<a href="#topologykubernetesioregion">topology.kubernetes.io/region</a>.</div><h3 id="failure-domainbetakubernetesiozone">failure-domain.beta.kubernetes.io/zone (deprecated)</h3><p>Type: Label</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>Starting in v1.17, this label is deprecated in favor of
<a href="#topologykubernetesiozone">topology.kubernetes.io/zone</a>.</div><h3 id="pv-kubernetesiobind-completed">pv.kubernetes.io/bind-completed</h3><p>Type: Annotation</p><p>Example: <code>pv.kubernetes.io/bind-completed: "yes"</code></p><p>Used on: PersistentVolumeClaim</p><p>When this annotation is set on a PersistentVolumeClaim (PVC), that indicates that the lifecycle
of the PVC has passed through initial binding setup. When present, that information changes
how the control plane interprets the state of PVC objects.
The value of this annotation does not matter to Kubernetes.</p><h3 id="pv-kubernetesioboundby-controller">pv.kubernetes.io/bound-by-controller</h3><p>Type: Annotation</p><p>Example: <code>pv.kubernetes.io/bound-by-controller: "yes"</code></p><p>Used on: PersistentVolume, PersistentVolumeClaim</p><p>If this annotation is set on a PersistentVolume or PersistentVolumeClaim, it indicates that a
storage binding (PersistentVolume → PersistentVolumeClaim, or PersistentVolumeClaim → PersistentVolume)
was installed by the <a class="glossary-tooltip" title="A control loop that watches the shared state of the cluster through the apiserver and makes changes attempting to move the current state towards the desired state." data-toggle="tooltip" data-placement="top" href="/docs/concepts/architecture/controller/" target="_blank" aria-label="controller">controller</a>.
If the annotation isn't set, and there is a storage binding in place, the absence of that
annotation means that the binding was done manually.
The value of this annotation does not matter.</p><h3 id="pv-kubernetesiodynamically-provisioned">pv.kubernetes.io/provisioned-by</h3><p>Type: Annotation</p><p>Example: <code>pv.kubernetes.io/provisioned-by: "kubernetes.io/rbd"</code></p><p>Used on: PersistentVolume</p><p>This annotation is added to a PersistentVolume(PV) that has been dynamically provisioned by Kubernetes.
Its value is the name of volume plugin that created the volume. It serves both users (to show where a PV
comes from) and Kubernetes (to recognize dynamically provisioned PVs in its decisions).</p><h3 id="pv-kubernetesio-migratedto">pv.kubernetes.io/migrated-to</h3><p>Type: Annotation</p><p>Example: <code>pv.kubernetes.io/migrated-to: pd.csi.storage.gke.io</code></p><p>Used on: PersistentVolume, PersistentVolumeClaim</p><p>It is added to a PersistentVolume(PV) and PersistentVolumeClaim(PVC) that is supposed to be
dynamically provisioned/deleted by its corresponding CSI driver through the <code>CSIMigration</code> feature gate.
When this annotation is set, the Kubernetes components will "stand-down" and the
<code>external-provisioner</code> will act on the objects.</p><h3 id="statefulsetkubernetesiopod-name">statefulset.kubernetes.io/pod-name</h3><p>Type: Label</p><p>Example: <code>statefulset.kubernetes.io/pod-name: "mystatefulset-7"</code></p><p>Used on: Pod</p><p>When a StatefulSet controller creates a Pod for the StatefulSet, the control plane
sets this label on that Pod. The value of the label is the name of the Pod being created.</p><p>See <a href="/docs/concepts/workloads/controllers/statefulset/#pod-name-label">Pod Name Label</a>
in the StatefulSet topic for more details.</p><h3 id="schedulerkubernetesnode-selector">scheduler.alpha.kubernetes.io/node-selector</h3><p>Type: Annotation</p><p>Example: <code>scheduler.alpha.kubernetes.io/node-selector: "name-of-node-selector"</code></p><p>Used on: Namespace</p><p>The <a href="/docs/reference/access-authn-authz/admission-controllers/#podnodeselector">PodNodeSelector</a>
uses this annotation key to assign node selectors to pods in namespaces.</p><h3 id="topologykubernetesioregion">topology.kubernetes.io/region</h3><p>Type: Label</p><p>Example: <code>topology.kubernetes.io/region: "us-east-1"</code></p><p>Used on: Node, PersistentVolume</p><p>See <a href="#topologykubernetesiozone">topology.kubernetes.io/zone</a>.</p><h3 id="topologykubernetesiozone">topology.kubernetes.io/zone</h3><p>Type: Label</p><p>Example: <code>topology.kubernetes.io/zone: "us-east-1c"</code></p><p>Used on: Node, PersistentVolume</p><p><strong>On Node</strong>: The <code>kubelet</code> or the external <code>cloud-controller-manager</code> populates this
with the information from the cloud provider. This will be set only if you are using
a cloud provider. However, you can consider setting this on nodes if it makes sense
in your topology.</p><p><strong>On PersistentVolume</strong>: topology-aware volume provisioners will automatically set
node affinity constraints on a <code>PersistentVolume</code>.</p><p>A zone represents a logical failure domain. It is common for Kubernetes clusters to
span multiple zones for increased availability. While the exact definition of a zone
is left to infrastructure implementations, common properties of a zone include
very low network latency within a zone, no-cost network traffic within a zone, and
failure independence from other zones.
For example, nodes within a zone might share a network switch, but nodes in different
zones should not.</p><p>A region represents a larger domain, made up of one or more zones.
It is uncommon for Kubernetes clusters to span multiple regions,
While the exact definition of a zone or region is left to infrastructure implementations,
common properties of a region include higher network latency between them than within them,
non-zero cost for network traffic between them, and failure independence from other zones or regions.
For example, nodes within a region might share power infrastructure (e.g. a UPS or generator),
but nodes in different regions typically would not.</p><p>Kubernetes makes a few assumptions about the structure of zones and regions:</p><ol><li>regions and zones are hierarchical: zones are strict subsets of regions and
no zone can be in 2 regions</li><li>zone names are unique across regions; for example region "africa-east-1" might be comprised
of zones "africa-east-1a" and "africa-east-1b"</li></ol><p>It should be safe to assume that topology labels do not change.
Even though labels are strictly mutable, consumers of them can assume that a given node
is not going to be moved between zones without being destroyed and recreated.</p><p>Kubernetes can use this information in various ways.
For example, the scheduler automatically tries to spread the Pods in a ReplicaSet across nodes
in a single-zone cluster (to reduce the impact of node failures, see
<a href="#kubernetesiohostname">kubernetes.io/hostname</a>).
With multiple-zone clusters, this spreading behavior also applies to zones (to reduce the impact of zone failures).
This is achieved via <em>SelectorSpreadPriority</em>.</p><p><em>SelectorSpreadPriority</em> is a best effort placement. If the zones in your cluster are
heterogeneous (for example: different numbers of nodes, different types of nodes, or different pod
resource requirements), this placement might prevent equal spreading of your Pods across zones.
If desired, you can use homogeneous zones (same number and types of nodes) to reduce the probability
of unequal spreading.</p><p>The scheduler (through the <em>VolumeZonePredicate</em> predicate) also will ensure that Pods,
that claim a given volume, are only placed into the same zone as that volume.
Volumes cannot be attached across zones.</p><p>If <code>PersistentVolumeLabel</code> does not support automatic labeling of your PersistentVolumes,
you should consider adding the labels manually (or adding support for <code>PersistentVolumeLabel</code>).
With <code>PersistentVolumeLabel</code>, the scheduler prevents Pods from mounting volumes in a different zone.
If your infrastructure doesn't have this constraint, you don't need to add the zone labels to the volumes at all.</p><h3 id="volume-beta-kubernetes-io-storage-provisioner-deprecated">volume.beta.kubernetes.io/storage-provisioner (deprecated)</h3><p>Type: Annotation</p><p>Example: <code>volume.beta.kubernetes.io/storage-provisioner: "k8s.io/minikube-hostpath"</code></p><p>Used on: PersistentVolumeClaim</p><p>This annotation has been deprecated since v1.23.
See <a href="#volume-kubernetes-io-storage-provisioner">volume.kubernetes.io/storage-provisioner</a>.</p><h3 id="volume-beta-kubernetes-io-storage-class-deprecated">volume.beta.kubernetes.io/storage-class (deprecated)</h3><p>Type: Annotation</p><p>Example: <code>volume.beta.kubernetes.io/storage-class: "example-class"</code></p><p>Used on: PersistentVolume, PersistentVolumeClaim</p><p>This annotation can be used for PersistentVolume(PV) or PersistentVolumeClaim(PVC)
to specify the name of <a href="/docs/concepts/storage/storage-classes/">StorageClass</a>.
When both the <code>storageClassName</code> attribute and the <code>volume.beta.kubernetes.io/storage-class</code>
annotation are specified, the annotation <code>volume.beta.kubernetes.io/storage-class</code>
takes precedence over the <code>storageClassName</code> attribute.</p><p>This annotation has been deprecated. Instead, set the
<a href="/docs/concepts/storage/persistent-volumes/#class"><code>storageClassName</code> field</a>
for the PersistentVolumeClaim or PersistentVolume.</p><h3 id="mount-options">volume.beta.kubernetes.io/mount-options (deprecated)</h3><p>Type: Annotation</p><p>Example : <code>volume.beta.kubernetes.io/mount-options: "ro,soft"</code></p><p>Used on: PersistentVolume</p><p>A Kubernetes administrator can specify additional
<a href="/docs/concepts/storage/persistent-volumes/#mount-options">mount options</a>
for when a PersistentVolume is mounted on a node.</p><h3 id="volume-kubernetes-io-storage-provisioner">volume.kubernetes.io/storage-provisioner</h3><p>Type: Annotation</p><p>Used on: PersistentVolumeClaim</p><p>This annotation is added to a PVC that is supposed to be dynamically provisioned.
Its value is the name of a volume plugin that is supposed to provision a volume
for this PVC.</p><h3 id="volume-kubernetes-io-selected-node">volume.kubernetes.io/selected-node</h3><p>Type: Annotation</p><p>Used on: PersistentVolumeClaim</p><p>This annotation is added to a PVC that is triggered by a scheduler to be
dynamically provisioned. Its value is the name of the selected node.</p><h3 id="volumes-kubernetes-io-controller-managed-attach-detach">volumes.kubernetes.io/controller-managed-attach-detach</h3><p>Type: Annotation</p><p>Used on: Node</p><p>If a node has the annotation <code>volumes.kubernetes.io/controller-managed-attach-detach</code>,
its storage attach and detach operations are being managed by the <em>volume attach/detach</em>
<a class="glossary-tooltip" title="A control loop that watches the shared state of the cluster through the apiserver and makes changes attempting to move the current state towards the desired state." data-toggle="tooltip" data-placement="top" href="/docs/concepts/architecture/controller/" target="_blank" aria-label="controller">controller</a>.</p><p>The value of the annotation isn't important.</p><h3 id="nodekubernetesiowindows-build">node.kubernetes.io/windows-build</h3><p>Type: Label</p><p>Example: <code>node.kubernetes.io/windows-build: "10.0.17763"</code></p><p>Used on: Node</p><p>When the kubelet is running on Microsoft Windows, it automatically labels its Node
to record the version of Windows Server in use.</p><p>The label's value is in the format "MajorVersion.MinorVersion.BuildNumber".</p><h3 id="storagealphakubernetesiomigrated-plugins">storage.alpha.kubernetes.io/migrated-plugins</h3><p>Type: Annotation</p><p>Example:<code>storage.alpha.kubernetes.io/migrated-plugins: "kubernetes.io/cinder"</code></p><p>Used on: CSINode (an extension API)</p><p>This annotation is automatically added for the CSINode object that maps to a node that
installs CSIDriver. This annotation shows the in-tree plugin name of the migrated plugin. Its
value depends on your cluster's in-tree cloud provider storage type.</p><p>For example, if the in-tree cloud provider storage type is <code>CSIMigrationvSphere</code>, the CSINodes instance for the node should be updated with:
<code>storage.alpha.kubernetes.io/migrated-plugins: "kubernetes.io/vsphere-volume"</code></p><h3 id="servicekubernetesioheadless">service.kubernetes.io/headless</h3><p>Type: Label</p><p>Example: <code>service.kubernetes.io/headless: ""</code></p><p>Used on: Endpoints</p><p>The control plane adds this label to an Endpoints object when the owning Service is headless.
To learn more, read <a href="/docs/concepts/services-networking/service/#headless-services">Headless Services</a>.</p><h3 id="servicekubernetesiotopology-aware-hints">service.kubernetes.io/topology-aware-hints (deprecated)</h3><p>Example: <code>service.kubernetes.io/topology-aware-hints: "Auto"</code></p><p>Used on: Service</p><p>This annotation was used for enabling <em>topology aware hints</em> on Services. Topology aware
hints have since been renamed: the concept is now called
<a href="/docs/concepts/services-networking/topology-aware-routing/">topology aware routing</a>.
Setting the annotation to <code>Auto</code>, on a Service, configured the Kubernetes control plane to
add topology hints on EndpointSlices associated with that Service. You can also explicitly
set the annotation to <code>Disabled</code>.</p><p>If you are running a version of Kubernetes older than 1.34,
check the documentation for that Kubernetes version to see how topology aware routing
works in that release.</p><p>There are no other valid values for this annotation. If you don't want topology aware hints
for a Service, don't add this annotation.</p><h3 id="service-kubernetes-io-topology-mode">service.kubernetes.io/topology-mode</h3><p>Type: Annotation</p><p>Example: <code>service.kubernetes.io/topology-mode: Auto</code></p><p>Used on: Service</p><p>This annotation provides a way to define how Services handle network topology;
for example, you can configure a Service so that Kubernetes prefers keeping traffic between
a client and server within a single topology zone.
In some cases this can help reduce costs or improve network performance.</p><p>See <a href="/docs/concepts/services-networking/topology-aware-routing/">Topology Aware Routing</a>
for more details.</p><h3 id="kubernetesioservice-name">kubernetes.io/service-name</h3><p>Type: Label</p><p>Example: <code>kubernetes.io/service-name: "my-website"</code></p><p>Used on: EndpointSlice</p><p>Kubernetes associates <a href="/docs/concepts/services-networking/endpoint-slices/">EndpointSlices</a> with
<a href="/docs/concepts/services-networking/service/">Services</a> using this label.</p><p>This label records the <a class="glossary-tooltip" title="A client-provided string that refers to an object in a resource URL, such as /api/v1/pods/some-name." data-toggle="tooltip" data-placement="top" href="/docs/concepts/overview/working-with-objects/names" target="_blank" aria-label="name">name</a> of the
Service that the EndpointSlice is backing. All EndpointSlices should have this label set to
the name of their associated Service.</p><h3 id="kubernetes-io-service-account-name">kubernetes.io/service-account.name</h3><p>Type: Annotation</p><p>Example: <code>kubernetes.io/service-account.name: "sa-name"</code></p><p>Used on: Secret</p><p>This annotation records the <a class="glossary-tooltip" title="A client-provided string that refers to an object in a resource URL, such as /api/v1/pods/some-name." data-toggle="tooltip" data-placement="top" href="/docs/concepts/overview/working-with-objects/names" target="_blank" aria-label="name">name</a> of the
ServiceAccount that the token (stored in the Secret of type <code>kubernetes.io/service-account-token</code>)
represents.</p><h3 id="kubernetes-io-service-account-uid">kubernetes.io/service-account.uid</h3><p>Type: Annotation</p><p>Example: <code>kubernetes.io/service-account.uid: da68f9c6-9d26-11e7-b84e-002dc52800da</code></p><p>Used on: Secret</p><p>This annotation records the <a class="glossary-tooltip" title="A Kubernetes systems-generated string to uniquely identify objects." data-toggle="tooltip" data-placement="top" href="/docs/concepts/overview/working-with-objects/names" target="_blank" aria-label="unique ID">unique ID</a> of the
ServiceAccount that the token (stored in the Secret of type <code>kubernetes.io/service-account-token</code>)
represents.</p><h3 id="kubernetes-io-legacy-token-last-used">kubernetes.io/legacy-token-last-used</h3><p>Type: Label</p><p>Example: <code>kubernetes.io/legacy-token-last-used: 2022-10-24</code></p><p>Used on: Secret</p><p>The control plane only adds this label to Secrets that have the type
<code>kubernetes.io/service-account-token</code>.
The value of this label records the date (ISO 8601 format, UTC time zone) when the control plane
last saw a request where the client authenticated using the service account token.</p><p>If a legacy token was last used before the cluster gained the feature (added in Kubernetes v1.26),
then the label isn't set.</p><h3 id="kubernetes-io-legacy-token-invalid-since">kubernetes.io/legacy-token-invalid-since</h3><p>Type: Label</p><p>Example: <code>kubernetes.io/legacy-token-invalid-since: 2023-10-27</code></p><p>Used on: Secret</p><p>The control plane automatically adds this label to auto-generated Secrets that
have the type <code>kubernetes.io/service-account-token</code>. This label marks the
Secret-based token as invalid for authentication. The value of this label
records the date (ISO 8601 format, UTC time zone) when the control plane detects
that the auto-generated Secret has not been used for a specified duration
(defaults to one year).</p><h3 id="endpoints-kubernetes-io-managed-by">endpoints.kubernetes.io/managed-by (deprecated)</h3><p>Type: Label</p><p>Example: <code>endpoints.kubernetes.io/managed-by: endpoint-controller</code></p><p>Used on: Endpoints</p><p>This label is used internally to mark Endpoints objects that were created by
Kubernetes (as opposed to Endpoints created by users or external controllers).</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>The <a href="/docs/reference/kubernetes-api/service-resources/endpoints-v1/">Endpoints</a>
API is deprecated in favor of
<a href="/docs/reference/kubernetes-api/service-resources/endpoint-slice-v1/">EndpointSlice</a>.</div><h3 id="endpointslicekubernetesiomanaged-by">endpointslice.kubernetes.io/managed-by</h3><p>Type: Label</p><p>Example: <code>endpointslice.kubernetes.io/managed-by: endpointslice-controller.k8s.io</code></p><p>Used on: EndpointSlices</p><p>The label is used to indicate the controller or entity that manages the EndpointSlice. This label
aims to enable different EndpointSlice objects to be managed by different controllers or entities
within the same cluster. The value <code>endpointslice-controller.k8s.io</code> indicates an
EndpointSlice object that was created automatically by Kubernetes for a Service with a
<a class="glossary-tooltip" title="Allows users to filter a list of resources based on labels." data-toggle="tooltip" data-placement="top" href="/docs/concepts/overview/working-with-objects/labels/" target="_blank" aria-label="selectors">selectors</a>.</p><h3 id="endpointslicekubernetesioskip-mirror">endpointslice.kubernetes.io/skip-mirror</h3><p>Type: Label</p><p>Example: <code>endpointslice.kubernetes.io/skip-mirror: "true"</code></p><p>Used on: Endpoints</p><p>The label can be set to <code>"true"</code> on an Endpoints resource to indicate that the
EndpointSliceMirroring controller should not mirror this resource with EndpointSlices.</p><h3 id="servicekubernetesioservice-proxy-name">service.kubernetes.io/service-proxy-name</h3><p>Type: Label</p><p>Example: <code>service.kubernetes.io/service-proxy-name: "foo-bar"</code></p><p>Used on: Service</p><p>Setting a value for this label tells kube-proxy to ignore this service for proxying purposes.
This allows for use of alternative proxy implementations for this service (e.g. running
a DaemonSet that manages nftables its own way). Multiple alternative proxy implementations
could be active simultaneously using this field, e.g. by having a value unique to each
alternative proxy implementation to be responsible for their respective services.</p><h3 id="experimental-windows-kubernetes-io-isolation-type">experimental.windows.kubernetes.io/isolation-type (deprecated)</h3><p>Type: Annotation</p><p>Example: <code>experimental.windows.kubernetes.io/isolation-type: "hyperv"</code></p><p>Used on: Pod</p><p>The annotation is used to run Windows containers with Hyper-V isolation.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>Starting from v1.20, this annotation is deprecated.
Experimental Hyper-V support was removed in 1.21.</div><h3 id="ingressclass-kubernetes-io-is-default-class">ingressclass.kubernetes.io/is-default-class</h3><p>Type: Annotation</p><p>Example: <code>ingressclass.kubernetes.io/is-default-class: "true"</code></p><p>Used on: IngressClass</p><p>When a IngressClass resource has this annotation set to <code>"true"</code>, new Ingress resource
without a class specified will be assigned this default class.</p><h3 id="nginx-ingress-kubernetes-io-configuration-snippet">nginx.ingress.kubernetes.io/configuration-snippet</h3><p>Type: Annotation</p><p>Example: <code>nginx.ingress.kubernetes.io/configuration-snippet: " more_set_headers \"Request-Id: $req_id\";\nmore_set_headers \"Example: 42\";\n"</code></p><p>Used on: Ingress</p><p>You can use this annotation to set extra configuration on an Ingress that
uses the <a href="https://github.com/kubernetes/ingress-nginx/">NGINX Ingress Controller</a>.
The <code>configuration-snippet</code> annotation is ignored
by default since version 1.9.0 of the ingress controller.
The NGINX ingress controller setting <code>allow-snippet-annotations.</code>
has to be explicitly enabled to use this annotation.
Enabling the annotation can be dangerous in a multi-tenant cluster, as it can lead people with otherwise
limited permissions being able to retrieve all Secrets in the cluster.</p><h3 id="kubernetes-io-ingress-class-deprecated">kubernetes.io/ingress.class (deprecated)</h3><p>Type: Annotation</p><p>Used on: Ingress</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>Starting in v1.18, this annotation is deprecated in favor of <code>spec.ingressClassName</code>.</div><h3 id="kubernetes-io-cluster-service">kubernetes.io/cluster-service (deprecated)</h3><p>Type: Label</p><p>Example: <code>kubernetes.io/cluster-service: "true"</code></p><p>Used on: Service</p><p>This label indicates that the Service provides a service to the cluster, if the value is set to true.
When you run <code>kubectl cluster-info</code>, the tool queries for Services with this label set to true.</p><p>However, setting this label on any Service is deprecated.</p><h3 id="storageclass-kubernetes-io-is-default-class">storageclass.kubernetes.io/is-default-class</h3><p>Type: Annotation</p><p>Example: <code>storageclass.kubernetes.io/is-default-class: "true"</code></p><p>Used on: StorageClass</p><p>When a single StorageClass resource has this annotation set to <code>"true"</code>, new PersistentVolumeClaim
resource without a class specified will be assigned this default class.</p><h3 id="alpha-kubernetes-io-provided-node-ip">alpha.kubernetes.io/provided-node-ip (alpha)</h3><p>Type: Annotation</p><p>Example: <code>alpha.kubernetes.io/provided-node-ip: "10.0.0.1"</code></p><p>Used on: Node</p><p>The kubelet can set this annotation on a Node to denote its configured IPv4 and/or IPv6 address.</p><p>When kubelet is started with the <code>--cloud-provider</code> flag set to any value (includes both external
and legacy in-tree cloud providers), it sets this annotation on the Node to denote an IP address
set from the command line flag (<code>--node-ip</code>). This IP is verified with the cloud provider as valid
by the cloud-controller-manager.</p><h3 id="batch-kubernetes-io-job-completion-index">batch.kubernetes.io/job-completion-index</h3><p>Type: Annotation, Label</p><p>Example: <code>batch.kubernetes.io/job-completion-index: "3"</code></p><p>Used on: Pod</p><p>The Job controller in the kube-controller-manager sets this as a label and annotation for Pods
created with Indexed <a href="/docs/concepts/workloads/controllers/job/#completion-mode">completion mode</a>.</p><p>Note the <a href="/docs/reference/command-line-tools-reference/feature-gates/">PodIndexLabel</a>
feature gate must be enabled for this to be added as a pod <strong>label</strong>,
otherwise it will just be an annotation.</p><h3 id="batch-kubernetes-io-cronjob-scheduled-timestamp">batch.kubernetes.io/cronjob-scheduled-timestamp</h3><p>Type: Annotation</p><p>Example: <code>batch.kubernetes.io/cronjob-scheduled-timestamp: "2016-05-19T03:00:00-07:00"</code></p><p>Used on: Jobs and Pods controlled by CronJobs</p><p>This annotation is used to record the original (expected) creation timestamp for a Job,
when that Job is part of a CronJob.
The control plane sets the value to that timestamp in RFC3339 format. If the Job belongs to a CronJob
with a timezone specified, then the timestamp is in that timezone. Otherwise, the timestamp is in controller-manager's local time.</p><h3 id="kubectl-kubernetes-io-default-container">kubectl.kubernetes.io/default-container</h3><p>Type: Annotation</p><p>Example: <code>kubectl.kubernetes.io/default-container: "front-end-app"</code></p><p>The value of the annotation is the container name that is default for this Pod.
For example, <code>kubectl logs</code> or <code>kubectl exec</code> without <code>-c</code> or <code>--container</code> flag
will use this default container.</p><h3 id="kubectl-kubernetes-io-default-logs-container-deprecated">kubectl.kubernetes.io/default-logs-container (deprecated)</h3><p>Type: Annotation</p><p>Example: <code>kubectl.kubernetes.io/default-logs-container: "front-end-app"</code></p><p>The value of the annotation is the container name that is the default logging container for this
Pod. For example, <code>kubectl logs</code> without <code>-c</code> or <code>--container</code> flag will use this default
container.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>This annotation is deprecated. You should use the
<a href="#kubectl-kubernetes-io-default-container"><code>kubectl.kubernetes.io/default-container</code></a>
annotation instead. Kubernetes versions 1.25 and newer ignore this annotation.</div><h3 id="kubectl-kubernetes-io-last-applied-configuration">kubectl.kubernetes.io/last-applied-configuration</h3><p>Type: Annotation</p><p>Example: <em>see following snippet</em></p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">kubectl.kubernetes.io/last-applied-configuration</span>:<span style="color:#bbb"> </span>&gt;<span style="color:#b44;font-style:italic">
</span></span></span><span style="display:flex"><span><span style="color:#b44;font-style:italic">      {"apiVersion":"apps/v1","kind":"Deployment","metadata":{"annotations":{},"name":"example","namespace":"default"},"spec":{"selector":{"matchLabels":{"app.kubernetes.io/name":foo}},"template":{"metadata":{"labels":{"app.kubernetes.io/name":"foo"}},"spec":{"containers":[{"image":"container-registry.example/foo-bar:1.42","name":"foo-bar","ports":[{"containerPort":42}]}]}}}}</span><span style="color:#bbb">      
</span></span></span></code></pre></div><p>Used on: all objects</p><p>The kubectl command line tool uses this annotation as a legacy mechanism
to track changes. That mechanism has been superseded by
<a href="/docs/reference/using-api/server-side-apply/">Server-side apply</a>.</p><h3 id="kubectl-k8s-io-restart-at">kubectl.kubernetes.io/restartedAt</h3><p>Type: Annotation</p><p>Example: <code>kubectl.kubernetes.io/restartedAt: "2024-06-21T17:27:41Z"</code></p><p>Used on: Deployment, ReplicaSet, StatefulSet, DaemonSet, Pod</p><p>This annotation contains the latest restart time of a resource (Deployment, ReplicaSet, StatefulSet or DaemonSet),
where kubectl triggered a rollout in order to force creation of new Pods.
The command <code>kubectl rollout restart &lt;RESOURCE&gt;</code> triggers a restart by patching the template
metadata of all the pods of resource with this annotation. In above example the latest restart time is shown as 21st June 2024 at 17:27:41 UTC.</p><p>You should not assume that this annotation represents the date / time of the most recent update;
a separate change could have been made since the last manually triggered rollout.</p><p>If you manually set this annotation on a Pod, nothing happens. The restarting side effect comes from
how workload management and Pod templating works.</p><h3 id="endpoints-kubernetes-io-over-capacity">endpoints.kubernetes.io/over-capacity</h3><p>Type: Annotation</p><p>Example: <code>endpoints.kubernetes.io/over-capacity:truncated</code></p><p>Used on: Endpoints</p><p>The <a class="glossary-tooltip" title="The container orchestration layer that exposes the API and interfaces to define, deploy, and manage the lifecycle of containers." data-toggle="tooltip" data-placement="top" href="/docs/reference/glossary/?all=true#term-control-plane" target="_blank" aria-label="control plane">control plane</a> adds this annotation to
an <a href="/docs/concepts/services-networking/service/#endpoints">Endpoints</a> object if the associated
<a class="glossary-tooltip" title="A way to expose an application running on a set of Pods as a network service." data-toggle="tooltip" data-placement="top" href="/docs/concepts/services-networking/service/" target="_blank" aria-label="Service">Service</a> has more than 1000 backing endpoints.
The annotation indicates that the Endpoints object is over capacity and the number of endpoints
has been truncated to 1000.</p><p>If the number of backend endpoints falls below 1000, the control plane removes this annotation.</p><h3 id="endpoints-kubernetes-io-last-change-trigger-time">endpoints.kubernetes.io/last-change-trigger-time</h3><p>Type: Annotation</p><p>Example: <code>endpoints.kubernetes.io/last-change-trigger-time: "2023-07-20T04:45:21Z"</code></p><p>Used on: Endpoints</p><p>This annotation set to an <a href="/docs/concepts/services-networking/service/#endpoints">Endpoints</a> object that
represents the timestamp (The timestamp is stored in RFC 3339 date-time string format. For example, '2018-10-22T19:32:52.1Z'). This is timestamp
of the last change in some Pod or Service object, that triggered the change to the Endpoints object.</p><h3 id="control-plane-alpha-kubernetes-io-leader">control-plane.alpha.kubernetes.io/leader (deprecated)</h3><p>Type: Annotation</p><p>Example: <code>control-plane.alpha.kubernetes.io/leader={"holderIdentity":"controller-0","leaseDurationSeconds":15,"acquireTime":"2023-01-19T13:12:57Z","renewTime":"2023-01-19T13:13:54Z","leaderTransitions":1}</code></p><p>Used on: Endpoints</p><p>The <a class="glossary-tooltip" title="The container orchestration layer that exposes the API and interfaces to define, deploy, and manage the lifecycle of containers." data-toggle="tooltip" data-placement="top" href="/docs/reference/glossary/?all=true#term-control-plane" target="_blank" aria-label="control plane">control plane</a> previously set annotation on
an <a href="/docs/concepts/services-networking/service/#endpoints">Endpoints</a> object. This annotation provided
the following detail:</p><ul><li>Who is the current leader.</li><li>The time when the current leadership was acquired.</li><li>The duration of the lease (of the leadership) in seconds.</li><li>The time the current lease (the current leadership) should be renewed.</li><li>The number of leadership transitions that happened in the past.</li></ul><p>Kubernetes now uses <a href="/docs/concepts/architecture/leases/">Leases</a> to
manage leader assignment for the Kubernetes control plane.</p><h3 id="batch-kubernetes-io-job-tracking">batch.kubernetes.io/job-tracking (deprecated)</h3><p>Type: Annotation</p><p>Example: <code>batch.kubernetes.io/job-tracking: ""</code></p><p>Used on: Jobs</p><p>The presence of this annotation on a Job used to indicate that the control plane is
<a href="/docs/concepts/workloads/controllers/job/#job-tracking-with-finalizers">tracking the Job status using finalizers</a>.
Adding or removing this annotation no longer has an effect (Kubernetes v1.27 and later)
All Jobs are tracked with finalizers.</p><h3 id="job-name">job-name (deprecated)</h3><p>Type: Label</p><p>Example: <code>job-name: "pi"</code></p><p>Used on: Jobs and Pods controlled by Jobs</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>Starting from Kubernetes 1.27, this label is deprecated.
Kubernetes 1.27 and newer ignore this label and use the prefixed <code>job-name</code> label.</div><h3 id="controller-uid">controller-uid (deprecated)</h3><p>Type: Label</p><p>Example: <code>controller-uid: "$UID"</code></p><p>Used on: Jobs and Pods controlled by Jobs</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>Starting from Kubernetes 1.27, this label is deprecated.
Kubernetes 1.27 and newer ignore this label and use the prefixed <code>controller-uid</code> label.</div><h3 id="batchkubernetesio-job-name">batch.kubernetes.io/job-name</h3><p>Type: Label</p><p>Example: <code>batch.kubernetes.io/job-name: "pi"</code></p><p>Used on: Jobs and Pods controlled by Jobs</p><p>This label is used as a user-friendly way to get Pods corresponding to a Job.
The <code>job-name</code> comes from the <code>name</code> of the Job and allows for an easy way to
get Pods corresponding to the Job.</p><h3 id="batchkubernetesio-controller-uid">batch.kubernetes.io/controller-uid</h3><p>Type: Label</p><p>Example: <code>batch.kubernetes.io/controller-uid: "$UID"</code></p><p>Used on: Jobs and Pods controlled by Jobs</p><p>This label is used as a programmatic way to get all Pods corresponding to a Job.<br/>The <code>controller-uid</code> is a unique identifier that gets set in the <code>selector</code> field so the Job
controller can get all the corresponding Pods.</p><h3 id="scheduleralphakubernetesio-defaulttolerations">scheduler.alpha.kubernetes.io/defaultTolerations</h3><p>Type: Annotation</p><p>Example: <code>scheduler.alpha.kubernetes.io/defaultTolerations: '[{"operator": "Equal", "value": "value1", "effect": "NoSchedule", "key": "dedicated-node"}]'</code></p><p>Used on: Namespace</p><p>This annotation requires the <a href="/docs/reference/access-authn-authz/admission-controllers/#podtolerationrestriction">PodTolerationRestriction</a>
admission controller to be enabled. This annotation key allows assigning tolerations to a
namespace and any new pods created in this namespace would get these tolerations added.</p><h3 id="schedulerkubernetestolerations-whitelist">scheduler.alpha.kubernetes.io/tolerationsWhitelist</h3><p>Type: Annotation</p><p>Example: <code>scheduler.alpha.kubernetes.io/tolerationsWhitelist: '[{"operator": "Exists", "effect": "NoSchedule", "key": "dedicated-node"}]'</code></p><p>Used on: Namespace</p><p>This annotation is only useful when the (Alpha)
<a href="/docs/reference/access-authn-authz/admission-controllers/#podtolerationrestriction">PodTolerationRestriction</a>
admission controller is enabled. The annotation value is a JSON document that defines a list of
allowed tolerations for the namespace it annotates. When you create a Pod or modify its
tolerations, the API server checks the tolerations to see if they are mentioned in the allow list.
The pod is admitted only if the check succeeds.</p><h3 id="scheduleralphakubernetesio-preferavoidpods">scheduler.alpha.kubernetes.io/preferAvoidPods (deprecated)</h3><p>Type: Annotation</p><p>Used on: Node</p><p>This annotation requires the <a href="/docs/reference/scheduling/config/#scheduling-plugins">NodePreferAvoidPods scheduling plugin</a>
to be enabled. The plugin is deprecated since Kubernetes 1.22.
Use <a href="/docs/concepts/scheduling-eviction/taint-and-toleration/">Taints and Tolerations</a> instead.</p><h3 id="node-kubernetes-io-not-ready">node.kubernetes.io/not-ready</h3><p>Type: Taint</p><p>Example: <code>node.kubernetes.io/not-ready: "NoExecute"</code></p><p>Used on: Node</p><p>The Node controller detects whether a Node is ready by monitoring its health
and adds or removes this taint accordingly.</p><h3 id="node-kubernetes-io-unreachable">node.kubernetes.io/unreachable</h3><p>Type: Taint</p><p>Example: <code>node.kubernetes.io/unreachable: "NoExecute"</code></p><p>Used on: Node</p><p>The Node controller adds the taint to a Node corresponding to the
<a href="/docs/concepts/architecture/nodes/#condition">NodeCondition</a> <code>Ready</code> being <code>Unknown</code>.</p><h3 id="node-kubernetes-io-unschedulable">node.kubernetes.io/unschedulable</h3><p>Type: Taint</p><p>Example: <code>node.kubernetes.io/unschedulable: "NoSchedule"</code></p><p>Used on: Node</p><p>The taint will be added to a node when initializing the node to avoid race condition.</p><h3 id="node-kubernetes-io-memory-pressure">node.kubernetes.io/memory-pressure</h3><p>Type: Taint</p><p>Example: <code>node.kubernetes.io/memory-pressure: "NoSchedule"</code></p><p>Used on: Node</p><p>The kubelet detects memory pressure based on <code>memory.available</code> and <code>allocatableMemory.available</code>
observed on a Node. The observed values are then compared to the corresponding thresholds that can
be set on the kubelet to determine if the Node condition and taint should be added/removed.</p><h3 id="node-kubernetes-io-disk-pressure">node.kubernetes.io/disk-pressure</h3><p>Type: Taint</p><p>Example: <code>node.kubernetes.io/disk-pressure :"NoSchedule"</code></p><p>Used on: Node</p><p>The kubelet detects disk pressure based on <code>imagefs.available</code>, <code>imagefs.inodesFree</code>,
<code>nodefs.available</code> and <code>nodefs.inodesFree</code>(Linux only) observed on a Node.
The observed values are then compared to the corresponding thresholds that can be set on the
kubelet to determine if the Node condition and taint should be added/removed.</p><h3 id="node-kubernetes-io-network-unavailable">node.kubernetes.io/network-unavailable</h3><p>Type: Taint</p><p>Example: <code>node.kubernetes.io/network-unavailable: "NoSchedule"</code></p><p>Used on: Node</p><p>This is initially set by the kubelet when the cloud provider used indicates a requirement for
additional network configuration. Only when the route on the cloud is configured properly will the
taint be removed by the cloud provider.</p><h3 id="node-kubernetes-io-pid-pressure">node.kubernetes.io/pid-pressure</h3><p>Type: Taint</p><p>Example: <code>node.kubernetes.io/pid-pressure: "NoSchedule"</code></p><p>Used on: Node</p><p>The kubelet checks D-value of the size of <code>/proc/sys/kernel/pid_max</code> and the PIDs consumed by
Kubernetes on a node to get the number of available PIDs that referred to as the <code>pid.available</code>
metric. The metric is then compared to the corresponding threshold that can be set on the kubelet
to determine if the node condition and taint should be added/removed.</p><h3 id="node-kubernetes-io-out-of-service">node.kubernetes.io/out-of-service</h3><p>Type: Taint</p><p>Example: <code>node.kubernetes.io/out-of-service:NoExecute</code></p><p>Used on: Node</p><p>A user can manually add the taint to a Node marking it out-of-service.
If a Node is marked out-of-service with this taint, the Pods on the node
will be forcefully deleted if there are no matching tolerations on it and
volume detach operations for the Pods terminating on the node will happen immediately.
This allows the Pods on the out-of-service node to recover quickly on a different node.</p><div class="alert alert-caution" role="alert"><h4 class="alert-heading">Caution:</h4>Refer to <a href="/docs/concepts/cluster-administration/node-shutdown/#non-graceful-node-shutdown">Non-graceful node shutdown</a>
for further details about when and how to use this taint.</div><h3 id="node-cloudprovider-kubernetes-io-uninitialized">node.cloudprovider.kubernetes.io/uninitialized</h3><p>Type: Taint</p><p>Example: <code>node.cloudprovider.kubernetes.io/uninitialized: "NoSchedule"</code></p><p>Used on: Node</p><p>Sets this taint on a Node to mark it as unusable, when kubelet is started with the "external"
cloud provider, until a controller from the cloud-controller-manager initializes this Node, and
then removes the taint.</p><h3 id="node-cloudprovider-kubernetes-io-shutdown">node.cloudprovider.kubernetes.io/shutdown</h3><p>Type: Taint</p><p>Example: <code>node.cloudprovider.kubernetes.io/shutdown: "NoSchedule"</code></p><p>Used on: Node</p><p>If a Node is in a cloud provider specified shutdown state, the Node gets tainted accordingly
with <code>node.cloudprovider.kubernetes.io/shutdown</code> and the taint effect of <code>NoSchedule</code>.</p><h3 id="feature-node-kubernetes-io">feature.node.kubernetes.io/*</h3><p>Type: Label</p><p>Example: <code>feature.node.kubernetes.io/network-sriov.capable: "true"</code></p><p>Used on: Node</p><p>These labels are used by the Node Feature Discovery (NFD) component to advertise
features on a node. All built-in labels use the <code>feature.node.kubernetes.io</code> label
namespace and have the format <code>feature.node.kubernetes.io/&lt;feature-name&gt;: "true"</code>.
NFD has many extension points for creating vendor and application-specific labels.
For details, see the <a href="https://kubernetes-sigs.github.io/node-feature-discovery/v0.12/usage/customization-guide">customization guide</a>.</p><h3 id="nfd-node-kubernetes-io-master-version">nfd.node.kubernetes.io/master.version</h3><p>Type: Annotation</p><p>Example: <code>nfd.node.kubernetes.io/master.version: "v0.6.0"</code></p><p>Used on: Node</p><p>For node(s) where the Node Feature Discovery (NFD)
<a href="https://kubernetes-sigs.github.io/node-feature-discovery/stable/usage/nfd-master.html">master</a>
is scheduled, this annotation records the version of the NFD master.
It is used for informative use only.</p><h3 id="nfd-node-kubernetes-io-worker-version">nfd.node.kubernetes.io/worker.version</h3><p>Type: Annotation</p><p>Example: <code>nfd.node.kubernetes.io/worker.version: "v0.4.0"</code></p><p>Used on: Nodes</p><p>This annotation records the version for a Node Feature Discovery's
<a href="https://kubernetes-sigs.github.io/node-feature-discovery/stable/usage/nfd-worker.html">worker</a>
if there is one running on a node. It's used for informative use only.</p><h3 id="nfd-node-kubernetes-io-feature-labels">nfd.node.kubernetes.io/feature-labels</h3><p>Type: Annotation</p><p>Example: <code>nfd.node.kubernetes.io/feature-labels: "cpu-cpuid.ADX,cpu-cpuid.AESNI,cpu-hardware_multithreading,kernel-version.full"</code></p><p>Used on: Nodes</p><p>This annotation records a comma-separated list of node feature labels managed by
<a href="https://kubernetes-sigs.github.io/node-feature-discovery/">Node Feature Discovery</a> (NFD).
NFD uses this for an internal mechanism. You should not edit this annotation yourself.</p><h3 id="nfd-node-kubernetes-io-extended-resources">nfd.node.kubernetes.io/extended-resources</h3><p>Type: Annotation</p><p>Example: <code>nfd.node.kubernetes.io/extended-resources: "accelerator.acme.example/q500,example.com/coprocessor-fx5"</code></p><p>Used on: Nodes</p><p>This annotation records a comma-separated list of
<a href="/docs/concepts/configuration/manage-resources-containers/#extended-resources">extended resources</a>
managed by <a href="https://kubernetes-sigs.github.io/node-feature-discovery/">Node Feature Discovery</a> (NFD).
NFD uses this for an internal mechanism. You should not edit this annotation yourself.</p><h3 id="nfd-node-kubernetes-io-node-name">nfd.node.kubernetes.io/node-name</h3><p>Type: Label</p><p>Example: <code>nfd.node.kubernetes.io/node-name: node-1</code></p><p>Used on: Nodes</p><p>It specifies which node the NodeFeature object is targeting.
Creators of NodeFeature objects must set this label and
consumers of the objects are supposed to use the label for
filtering features designated for a certain node.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>These Node Feature Discovery (NFD) labels or annotations only apply to
the nodes where NFD is running. To learn more about NFD and
its components go to its official <a href="https://kubernetes-sigs.github.io/node-feature-discovery/stable/get-started/">documentation</a>.</div><h3 id="service-beta-kubernetes-io-aws-load-balancer-access-log-emit-interval">service.beta.kubernetes.io/aws-load-balancer-access-log-emit-interval (beta)</h3><p>Example: <code>service.beta.kubernetes.io/aws-load-balancer-access-log-emit-interval: "5"</code></p><p>Used on: Service</p><p>The cloud controller manager integration with AWS elastic load balancing configures
the load balancer for a Service based on this annotation. The value determines
how often the load balancer writes log entries. For example, if you set the value
to 5, the log writes occur 5 seconds apart.</p><h3 id="service-beta-kubernetes-io-aws-load-balancer-access-log-enabled">service.beta.kubernetes.io/aws-load-balancer-access-log-enabled (beta)</h3><p>Example: <code>service.beta.kubernetes.io/aws-load-balancer-access-log-enabled: "false"</code></p><p>Used on: Service</p><p>The cloud controller manager integration with AWS elastic load balancing configures
the load balancer for a Service based on this annotation. Access logging is enabled
if you set the annotation to "true".</p><h3 id="service-beta-kubernetes-io-aws-load-balancer-access-log-s3-bucket-name">service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-name (beta)</h3><p>Example: <code>service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-name: example</code></p><p>Used on: Service</p><p>The cloud controller manager integration with AWS elastic load balancing configures
the load balancer for a Service based on this annotation. The load balancer
writes logs to an S3 bucket with the name you specify.</p><h3 id="service-beta-kubernetes-io-aws-load-balancer-access-log-s3-bucket-prefix">service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-prefix (beta)</h3><p>Example: <code>service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-prefix: "/example"</code></p><p>Used on: Service</p><p>The cloud controller manager integration with AWS elastic load balancing configures
the load balancer for a Service based on this annotation. The load balancer
writes log objects with the prefix that you specify.</p><h3 id="service-beta-kubernetes-io-aws-load-balancer-additional-resource-tags">service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags (beta)</h3><p>Example: <code>service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags: "Environment=demo,Project=example"</code></p><p>Used on: Service</p><p>The cloud controller manager integration with AWS elastic load balancing configures
tags (an AWS concept) for a load balancer based on the comma-separated key/value
pairs in the value of this annotation.</p><h3 id="service-beta-kubernetes-io-aws-load-balancer-alpn-policy">service.beta.kubernetes.io/aws-load-balancer-alpn-policy (beta)</h3><p>Example: <code>service.beta.kubernetes.io/aws-load-balancer-alpn-policy: HTTP2Optional</code></p><p>Used on: Service</p><p>The <a href="https://kubernetes-sigs.github.io/aws-load-balancer-controller/">AWS load balancer controller</a>
uses this annotation.
See <a href="https://kubernetes-sigs.github.io/aws-load-balancer-controller/latest/guide/service/annotations/">annotations</a>
in the AWS load balancer controller documentation.</p><h3 id="service-beta-kubernetes-io-aws-load-balancer-attributes">service.beta.kubernetes.io/aws-load-balancer-attributes (beta)</h3><p>Example: <code>service.beta.kubernetes.io/aws-load-balancer-attributes: "deletion_protection.enabled=true"</code></p><p>Used on: Service</p><p>The <a href="https://kubernetes-sigs.github.io/aws-load-balancer-controller/">AWS load balancer controller</a>
uses this annotation.
See <a href="https://kubernetes-sigs.github.io/aws-load-balancer-controller/latest/guide/service/annotations/">annotations</a>
in the AWS load balancer controller documentation.</p><h3 id="service-beta-kubernetes-io-aws-load-balancer-backend-protocol">service.beta.kubernetes.io/aws-load-balancer-backend-protocol (beta)</h3><p>Example: <code>service.beta.kubernetes.io/aws-load-balancer-backend-protocol: tcp</code></p><p>Used on: Service</p><p>The cloud controller manager integration with AWS elastic load balancing configures
the load balancer listener based on the value of this annotation.</p><h3 id="service-beta-kubernetes-io-aws-load-balancer-connection-draining-enabled">service.beta.kubernetes.io/aws-load-balancer-connection-draining-enabled (beta)</h3><p>Example: <code>service.beta.kubernetes.io/aws-load-balancer-connection-draining-enabled: "false"</code></p><p>Used on: Service</p><p>The cloud controller manager integration with AWS elastic load balancing configures
the load balancer based on this annotation. The load balancer's connection draining
setting depends on the value you set.</p><h3 id="service-beta-kubernetes-io-aws-load-balancer-connection-draining-timeout">service.beta.kubernetes.io/aws-load-balancer-connection-draining-timeout (beta)</h3><p>Example: <code>service.beta.kubernetes.io/aws-load-balancer-connection-draining-timeout: "60"</code></p><p>Used on: Service</p><p>If you configure <a href="#service-beta-kubernetes-io-aws-load-balancer-connection-draining-enabled">connection draining</a>
for a Service of <code>type: LoadBalancer</code>, and you use the AWS cloud, the integration configures
the draining period based on this annotation. The value you set determines the draining
timeout in seconds.</p><h3 id="service-beta-kubernetes-io-aws-load-balancer-ip-address-type">service.beta.kubernetes.io/aws-load-balancer-ip-address-type (beta)</h3><p>Example: <code>service.beta.kubernetes.io/aws-load-balancer-ip-address-type: ipv4</code></p><p>Used on: Service</p><p>The <a href="https://kubernetes-sigs.github.io/aws-load-balancer-controller/">AWS load balancer controller</a>
uses this annotation.
See <a href="https://kubernetes-sigs.github.io/aws-load-balancer-controller/latest/guide/service/annotations/">annotations</a>
in the AWS load balancer controller documentation.</p><h3 id="service-beta-kubernetes-io-aws-load-balancer-connection-idle-timeout">service.beta.kubernetes.io/aws-load-balancer-connection-idle-timeout (beta)</h3><p>Example: <code>service.beta.kubernetes.io/aws-load-balancer-connection-idle-timeout: "60"</code></p><p>Used on: Service</p><p>The cloud controller manager integration with AWS elastic load balancing configures
a load balancer based on this annotation. The load balancer has a configured idle
timeout period (in seconds) that applies to its connections. If no data has been
sent or received by the time that the idle timeout period elapses, the load balancer
closes the connection.</p><h3 id="service-beta-kubernetes-io-aws-load-balancer-cross-zone-load-balancing-enabled">service.beta.kubernetes.io/aws-load-balancer-cross-zone-load-balancing-enabled (beta)</h3><p>Example: <code>service.beta.kubernetes.io/aws-load-balancer-cross-zone-load-balancing-enabled: "true"</code></p><p>Used on: Service</p><p>The cloud controller manager integration with AWS elastic load balancing configures
a load balancer based on this annotation. If you set this annotation to "true",
each load balancer node distributes requests evenly across the registered targets
in all enabled <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-availability-zones">availability zones</a>.
If you disable cross-zone load balancing, each load balancer node distributes requests
evenly across the registered targets in its availability zone only.</p><h3 id="service-beta-kubernetes-io-aws-load-balancer-eip-allocations">service.beta.kubernetes.io/aws-load-balancer-eip-allocations (beta)</h3><p>Example: <code>service.beta.kubernetes.io/aws-load-balancer-eip-allocations: "eipalloc-01bcdef23bcdef456,eipalloc-def1234abc4567890"</code></p><p>Used on: Service</p><p>The cloud controller manager integration with AWS elastic load balancing configures
a load balancer based on this annotation. The value is a comma-separated list
of elastic IP address allocation IDs.</p><p>This annotation is only relevant for Services of <code>type: LoadBalancer</code>, where
the load balancer is an AWS Network Load Balancer.</p><h3 id="service-beta-kubernetes-io-aws-load-balancer-extra-security-groups">service.beta.kubernetes.io/aws-load-balancer-extra-security-groups (beta)</h3><p>Example: <code>service.beta.kubernetes.io/aws-load-balancer-extra-security-groups: "sg-12abcd3456,sg-34dcba6543"</code></p><p>Used on: Service</p><p>The cloud controller manager integration with AWS elastic load balancing configures
a load balancer based on this annotation. The annotation value is a comma-separated
list of extra AWS VPC security groups to configure for the load balancer.</p><h3 id="service-beta-kubernetes-io-aws-load-balancer-healthcheck-healthy-threshold">service.beta.kubernetes.io/aws-load-balancer-healthcheck-healthy-threshold (beta)</h3><p>Example: <code>service.beta.kubernetes.io/aws-load-balancer-healthcheck-healthy-threshold: "3"</code></p><p>Used on: Service</p><p>The cloud controller manager integration with AWS elastic load balancing configures
a load balancer based on this annotation. The annotation value specifies the number of
successive successful health checks required for a backend to be considered healthy
for traffic.</p><h3 id="service-beta-kubernetes-io-aws-load-balancer-healthcheck-interval">service.beta.kubernetes.io/aws-load-balancer-healthcheck-interval (beta)</h3><p>Example: <code>service.beta.kubernetes.io/aws-load-balancer-healthcheck-interval: "30"</code></p><p>Used on: Service</p><p>The cloud controller manager integration with AWS elastic load balancing configures
a load balancer based on this annotation. The annotation value specifies the interval,
in seconds, between health check probes made by the load balancer.</p><h3 id="service-beta-kubernetes-io-aws-load-balancer-healthcheck-papth">service.beta.kubernetes.io/aws-load-balancer-healthcheck-path (beta)</h3><p>Example: <code>service.beta.kubernetes.io/aws-load-balancer-healthcheck-path: /healthcheck</code></p><p>Used on: Service</p><p>The cloud controller manager integration with AWS elastic load balancing configures
a load balancer based on this annotation. The annotation value determines the
path part of the URL that is used for HTTP health checks.</p><h3 id="service-beta-kubernetes-io-aws-load-balancer-healthcheck-port">service.beta.kubernetes.io/aws-load-balancer-healthcheck-port (beta)</h3><p>Example: <code>service.beta.kubernetes.io/aws-load-balancer-healthcheck-port: "24"</code></p><p>Used on: Service</p><p>The cloud controller manager integration with AWS elastic load balancing configures
a load balancer based on this annotation. The annotation value determines which
port the load balancer connects to when performing health checks.</p><h3 id="service-beta-kubernetes-io-aws-load-balancer-healthcheck-protocol">service.beta.kubernetes.io/aws-load-balancer-healthcheck-protocol (beta)</h3><p>Example: <code>service.beta.kubernetes.io/aws-load-balancer-healthcheck-protocol: TCP</code></p><p>Used on: Service</p><p>The cloud controller manager integration with AWS elastic load balancing configures
a load balancer based on this annotation. The annotation value determines how the
load balancer checks the health of backend targets.</p><h3 id="service-beta-kubernetes-io-aws-load-balancer-healthcheck-timeout">service.beta.kubernetes.io/aws-load-balancer-healthcheck-timeout (beta)</h3><p>Example: <code>service.beta.kubernetes.io/aws-load-balancer-healthcheck-timeout: "3"</code></p><p>Used on: Service</p><p>The cloud controller manager integration with AWS elastic load balancing configures
a load balancer based on this annotation. The annotation value specifies the number
of seconds before a probe that hasn't yet succeeded is automatically treated as
having failed.</p><h3 id="service-beta-kubernetes-io-aws-load-balancer-healthcheck-unhealthy-threshold">service.beta.kubernetes.io/aws-load-balancer-healthcheck-unhealthy-threshold (beta)</h3><p>Example: <code>service.beta.kubernetes.io/aws-load-balancer-healthcheck-unhealthy-threshold: "3"</code></p><p>Used on: Service</p><p>The cloud controller manager integration with AWS elastic load balancing configures
a load balancer based on this annotation. The annotation value specifies the number of
successive unsuccessful health checks required for a backend to be considered unhealthy
for traffic.</p><h3 id="service-beta-kubernetes-io-aws-load-balancer-internal">service.beta.kubernetes.io/aws-load-balancer-internal (beta)</h3><p>Example: <code>service.beta.kubernetes.io/aws-load-balancer-internal: "true"</code></p><p>Used on: Service</p><p>The cloud controller manager integration with AWS elastic load balancing configures
a load balancer based on this annotation. When you set this annotation to "true",
the integration configures an internal load balancer.</p><p>If you use the <a href="https://kubernetes-sigs.github.io/aws-load-balancer-controller/">AWS load balancer controller</a>,
see <a href="#service-beta-kubernetes-io-aws-load-balancer-scheme"><code>service.beta.kubernetes.io/aws-load-balancer-scheme</code></a>.</p><h3 id="service-beta-kubernetes-io-aws-load-balancer-manage-backend-security-group-rules">service.beta.kubernetes.io/aws-load-balancer-manage-backend-security-group-rules (beta)</h3><p>Example: <code>service.beta.kubernetes.io/aws-load-balancer-manage-backend-security-group-rules: "true"</code></p><p>Used on: Service</p><p>The <a href="https://kubernetes-sigs.github.io/aws-load-balancer-controller/">AWS load balancer controller</a>
uses this annotation.
See <a href="https://kubernetes-sigs.github.io/aws-load-balancer-controller/latest/guide/service/annotations/">annotations</a>
in the AWS load balancer controller documentation.</p><h3 id="service-beta-kubernetes-io-aws-load-balancer-name">service.beta.kubernetes.io/aws-load-balancer-name (beta)</h3><p>Example: <code>service.beta.kubernetes.io/aws-load-balancer-name: my-elb</code></p><p>Used on: Service</p><p>If you set this annotation on a Service, and you also annotate that Service with
<code>service.beta.kubernetes.io/aws-load-balancer-type: "external"</code>, and you use the
<a href="https://kubernetes-sigs.github.io/aws-load-balancer-controller/">AWS load balancer controller</a>
in your cluster, then the AWS load balancer controller sets the name of that load
balancer to the value you set for <em>this</em> annotation.</p><p>See <a href="https://kubernetes-sigs.github.io/aws-load-balancer-controller/latest/guide/service/annotations/">annotations</a>
in the AWS load balancer controller documentation.</p><h3 id="service-beta-kubernetes-io-aws-load-balancer-nlb-target-type">service.beta.kubernetes.io/aws-load-balancer-nlb-target-type (beta)</h3><p>Example: <code>service.beta.kubernetes.io/aws-load-balancer-nlb-target-type: "true"</code></p><p>Used on: Service</p><p>The <a href="https://kubernetes-sigs.github.io/aws-load-balancer-controller/">AWS load balancer controller</a>
uses this annotation.
See <a href="https://kubernetes-sigs.github.io/aws-load-balancer-controller/latest/guide/service/annotations/">annotations</a>
in the AWS load balancer controller documentation.</p><h3 id="service-beta-kubernetes-io-aws-load-balancer-private-ipv4-addresses">service.beta.kubernetes.io/aws-load-balancer-private-ipv4-addresses (beta)</h3><p>Example: <code>service.beta.kubernetes.io/aws-load-balancer-private-ipv4-addresses: "198.51.100.0,198.51.100.64"</code></p><p>Used on: Service</p><p>The <a href="https://kubernetes-sigs.github.io/aws-load-balancer-controller/">AWS load balancer controller</a>
uses this annotation.
See <a href="https://kubernetes-sigs.github.io/aws-load-balancer-controller/latest/guide/service/annotations/">annotations</a>
in the AWS load balancer controller documentation.</p><h3 id="service-beta-kubernetes-io-aws-load-balancer-proxy-protocol">service.beta.kubernetes.io/aws-load-balancer-proxy-protocol (beta)</h3><p>Example: <code>service.beta.kubernetes.io/aws-load-balancer-proxy-protocol: "*"</code></p><p>Used on: Service</p><p>The official Kubernetes integration with AWS elastic load balancing configures
a load balancer based on this annotation. The only permitted value is <code>"*"</code>,
which indicates that the load balancer should wrap TCP connections to the backend
Pod with the PROXY protocol.</p><h3 id="service-beta-kubernetes-io-aws-load-balancer-scheme">service.beta.kubernetes.io/aws-load-balancer-scheme (beta)</h3><p>Example: <code>service.beta.kubernetes.io/aws-load-balancer-scheme: internal</code></p><p>Used on: Service</p><p>The <a href="https://kubernetes-sigs.github.io/aws-load-balancer-controller/">AWS load balancer controller</a>
uses this annotation.
See <a href="https://kubernetes-sigs.github.io/aws-load-balancer-controller/latest/guide/service/annotations/">annotations</a>
in the AWS load balancer controller documentation.</p><h3 id="service-beta-kubernetes-io-aws-load-balancer-security-groups">service.beta.kubernetes.io/aws-load-balancer-security-groups (deprecated)</h3><p>Example: <code>service.beta.kubernetes.io/aws-load-balancer-security-groups: "sg-53fae93f,sg-8725gr62r"</code></p><p>Used on: Service</p><p>The AWS load balancer controller uses this annotation to specify a comma separated list
of security groups you want to attach to an AWS load balancer. Both name and ID of security
are supported where name matches a <code>Name</code> tag, not the <code>groupName</code> attribute.</p><p>When this annotation is added to a Service, the load-balancer controller attaches the security groups
referenced by the annotation to the load balancer. If you omit this annotation, the AWS load balancer
controller automatically creates a new security group and attaches it to the load balancer.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>Kubernetes v1.27 and later do not directly set or read this annotation. However, the AWS
load balancer controller (part of the Kubernetes project) does still use the
<code>service.beta.kubernetes.io/aws-load-balancer-security-groups</code> annotation.</div><h3 id="service-beta-kubernetes-io-load-balancer-source-ranges">service.beta.kubernetes.io/load-balancer-source-ranges (deprecated)</h3><p>Example: <code>service.beta.kubernetes.io/load-balancer-source-ranges: "192.0.2.0/25"</code></p><p>Used on: Service</p><p>The <a href="https://kubernetes-sigs.github.io/aws-load-balancer-controller/">AWS load balancer controller</a>
uses this annotation. You should set <code>.spec.loadBalancerSourceRanges</code> for the Service instead.</p><h3 id="service-beta-kubernetes-io-aws-load-balancer-ssl-cert">service.beta.kubernetes.io/aws-load-balancer-ssl-cert (beta)</h3><p>Example: <code>service.beta.kubernetes.io/aws-load-balancer-ssl-cert: "arn:aws:acm:us-east-1:123456789012:certificate/12345678-1234-1234-1234-123456789012"</code></p><p>Used on: Service</p><p>The official integration with AWS elastic load balancing configures TLS for a Service of
<code>type: LoadBalancer</code> based on this annotation. The value of the annotation is the
AWS Resource Name (ARN) of the X.509 certificate that the load balancer listener should
use.</p><p>(The TLS protocol is based on an older technology that abbreviates to SSL.)</p><h3 id="service-beta-kubernetes-io-aws-load-balancer-ssl-negotiation-policy">service.beta.kubernetes.io/aws-load-balancer-ssl-negotiation-policy (beta)</h3><p>Example: <code>service.beta.kubernetes.io/aws-load-balancer-ssl-negotiation-policy: ELBSecurityPolicy-TLS-1-2-2017-01</code></p><p>The official integration with AWS elastic load balancing configures TLS for a Service of
<code>type: LoadBalancer</code> based on this annotation. The value of the annotation is the name
of an AWS policy for negotiating TLS with a client peer.</p><h3 id="service-beta-kubernetes-io-aws-load-balancer-ssl-ports">service.beta.kubernetes.io/aws-load-balancer-ssl-ports (beta)</h3><p>Example: <code>service.beta.kubernetes.io/aws-load-balancer-ssl-ports: "*"</code></p><p>The official integration with AWS elastic load balancing configures TLS for a Service of
<code>type: LoadBalancer</code> based on this annotation. The value of the annotation is either <code>"*"</code>,
which means that all the load balancer's ports should use TLS, or it is a comma separated
list of port numbers.</p><h3 id="service-beta-kubernetes-io-aws-load-balancer-subnets">service.beta.kubernetes.io/aws-load-balancer-subnets (beta)</h3><p>Example: <code>service.beta.kubernetes.io/aws-load-balancer-subnets: "private-a,private-b"</code></p><p>Kubernetes' official integration with AWS uses this annotation to configure a
load balancer and determine in which AWS availability zones to deploy the managed
load balancing service. The value is either a comma separated list of subnet names, or a
comma separated list of subnet IDs.</p><h3 id="service-beta-kubernetes-io-aws-load-balancer-target-group-attributes">service.beta.kubernetes.io/aws-load-balancer-target-group-attributes (beta)</h3><p>Example: <code>service.beta.kubernetes.io/aws-load-balancer-target-group-attributes: "stickiness.enabled=true,stickiness.type=source_ip"</code></p><p>Used on: Service</p><p>The <a href="https://kubernetes-sigs.github.io/aws-load-balancer-controller/">AWS load balancer controller</a>
uses this annotation.
See <a href="https://kubernetes-sigs.github.io/aws-load-balancer-controller/latest/guide/service/annotations/">annotations</a>
in the AWS load balancer controller documentation.</p><h3 id="service-beta-kubernetes-io-aws-target-node-labels">service.beta.kubernetes.io/aws-load-balancer-target-node-labels (beta)</h3><p>Example: <code>service.beta.kubernetes.io/aws-load-balancer-target-node-labels: "kubernetes.io/os=Linux,topology.kubernetes.io/region=us-east-2"</code></p><p>Kubernetes' official integration with AWS uses this annotation to determine which
nodes in your cluster should be considered as valid targets for the load balancer.</p><h3 id="service-beta-kubernetes-io-aws-load-balancer-type">service.beta.kubernetes.io/aws-load-balancer-type (beta)</h3><p>Example: <code>service.beta.kubernetes.io/aws-load-balancer-type: external</code></p><p>Kubernetes' official integrations with AWS use this annotation to determine
whether the AWS cloud provider integration should manage a Service of
<code>type: LoadBalancer</code>.</p><p>There are two permitted values:</p><dl><dt><code>nlb</code></dt><dd>the cloud controller manager configures a Network Load Balancer</dd><dt><code>external</code></dt><dd>the cloud controller manager does not configure any load balancer</dd></dl><p>If you deploy a Service of <code>type: LoadBalancer</code> on AWS, and you don't set any
<code>service.beta.kubernetes.io/aws-load-balancer-type</code> annotation,
the AWS integration deploys a classic Elastic Load Balancer. This behavior,
with no annotation present, is the default unless you specify otherwise.</p><p>When you set this annotation to <code>external</code> on a Service of <code>type: LoadBalancer</code>,
and your cluster has a working deployment of the AWS Load Balancer controller,
then the AWS Load Balancer controller attempts to deploy a load balancer based
on the Service specification.</p><div class="alert alert-caution" role="alert"><h4 class="alert-heading">Caution:</h4>Do not modify or add the <code>service.beta.kubernetes.io/aws-load-balancer-type</code> annotation
on an existing Service object. See the AWS documentation on this topic for more
details.</div><h3 id="service-beta-kubernetes-azure-load-balancer-disble-tcp-reset">service.beta.kubernetes.io/azure-load-balancer-disable-tcp-reset (deprecated)</h3><p>Example: <code>service.beta.kubernetes.io/azure-load-balancer-disable-tcp-reset: "false"</code></p><p>Used on: Service</p><p>This annotation only works for Azure standard load balancer backed service.
This annotation is used on the Service to specify whether the load balancer
should disable or enable TCP reset on idle timeout. If enabled, it helps
applications to behave more predictably, to detect the termination of a connection,
remove expired connections and initiate new connections.
You can set the value to be either true or false.</p><p>See <a href="https://learn.microsoft.com/en-gb/azure/load-balancer/load-balancer-tcp-reset">Load Balancer TCP Reset</a> for more information.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>This annotation is deprecated.</div><h3 id="pod-security-kubernetes-io-enforce">pod-security.kubernetes.io/enforce</h3><p>Type: Label</p><p>Example: <code>pod-security.kubernetes.io/enforce: "baseline"</code></p><p>Used on: Namespace</p><p>Value <strong>must</strong> be one of <code>privileged</code>, <code>baseline</code>, or <code>restricted</code> which correspond to
<a href="/docs/concepts/security/pod-security-standards/">Pod Security Standard</a> levels.
Specifically, the <code>enforce</code> label <em>prohibits</em> the creation of any Pod in the labeled
Namespace which does not meet the requirements outlined in the indicated level.</p><p>See <a href="/docs/concepts/security/pod-security-admission/">Enforcing Pod Security at the Namespace Level</a>
for more information.</p><h3 id="pod-security-kubernetes-io-enforce-version">pod-security.kubernetes.io/enforce-version</h3><p>Type: Label</p><p>Example: <code>pod-security.kubernetes.io/enforce-version: "1.34"</code></p><p>Used on: Namespace</p><p>Value <strong>must</strong> be <code>latest</code> or a valid Kubernetes version in the format <code>v&lt;major&gt;.&lt;minor&gt;</code>.
This determines the version of the
<a href="/docs/concepts/security/pod-security-standards/">Pod Security Standard</a>
policies to apply when validating a Pod.</p><p>See <a href="/docs/concepts/security/pod-security-admission/">Enforcing Pod Security at the Namespace Level</a>
for more information.</p><h3 id="pod-security-kubernetes-io-audit">pod-security.kubernetes.io/audit</h3><p>Type: Label</p><p>Example: <code>pod-security.kubernetes.io/audit: "baseline"</code></p><p>Used on: Namespace</p><p>Value <strong>must</strong> be one of <code>privileged</code>, <code>baseline</code>, or <code>restricted</code> which correspond to
<a href="/docs/concepts/security/pod-security-standards/">Pod Security Standard</a> levels.
Specifically, the <code>audit</code> label does not prevent the creation of a Pod in the labeled
Namespace which does not meet the requirements outlined in the indicated level,
but adds an this annotation to the Pod.</p><p>See <a href="/docs/concepts/security/pod-security-admission/">Enforcing Pod Security at the Namespace Level</a>
for more information.</p><h3 id="pod-security-kubernetes-io-audit-version">pod-security.kubernetes.io/audit-version</h3><p>Type: Label</p><p>Example: <code>pod-security.kubernetes.io/audit-version: "1.34"</code></p><p>Used on: Namespace</p><p>Value <strong>must</strong> be <code>latest</code> or a valid Kubernetes version in the format <code>v&lt;major&gt;.&lt;minor&gt;</code>.
This determines the version of the
<a href="/docs/concepts/security/pod-security-standards/">Pod Security Standard</a>
policies to apply when validating a Pod.</p><p>See <a href="/docs/concepts/security/pod-security-admission/">Enforcing Pod Security at the Namespace Level</a>
for more information.</p><h3 id="pod-security-kubernetes-io-warn">pod-security.kubernetes.io/warn</h3><p>Type: Label</p><p>Example: <code>pod-security.kubernetes.io/warn: "baseline"</code></p><p>Used on: Namespace</p><p>Value <strong>must</strong> be one of <code>privileged</code>, <code>baseline</code>, or <code>restricted</code> which correspond to
<a href="/docs/concepts/security/pod-security-standards/">Pod Security Standard</a> levels.
Specifically, the <code>warn</code> label does not prevent the creation of a Pod in the labeled
Namespace which does not meet the requirements outlined in the indicated level,
but returns a warning to the user after doing so.
Note that warnings are also displayed when creating or updating objects that contain
Pod templates, such as Deployments, Jobs, StatefulSets, etc.</p><p>See <a href="/docs/concepts/security/pod-security-admission/">Enforcing Pod Security at the Namespace Level</a>
for more information.</p><h3 id="pod-security-kubernetes-io-warn-version">pod-security.kubernetes.io/warn-version</h3><p>Type: Label</p><p>Example: <code>pod-security.kubernetes.io/warn-version: "1.34"</code></p><p>Used on: Namespace</p><p>Value <strong>must</strong> be <code>latest</code> or a valid Kubernetes version in the format <code>v&lt;major&gt;.&lt;minor&gt;</code>.
This determines the version of the <a href="/docs/concepts/security/pod-security-standards/">Pod Security Standard</a>
policies to apply when validating a submitted Pod.
Note that warnings are also displayed when creating or updating objects that contain
Pod templates, such as Deployments, Jobs, StatefulSets, etc.</p><p>See <a href="/docs/concepts/security/pod-security-admission/">Enforcing Pod Security at the Namespace Level</a>
for more information.</p><h3 id="rbac-authorization-kubernetes-io-autoupdate">rbac.authorization.kubernetes.io/autoupdate</h3><p>Type: Annotation</p><p>Example: <code>rbac.authorization.kubernetes.io/autoupdate: "false"</code></p><p>Used on: ClusterRole, ClusterRoleBinding, Role, RoleBinding</p><p>When this annotation is set to <code>"true"</code> on default RBAC objects created by the API server,
they are automatically updated at server start to add missing permissions and subjects
(extra permissions and subjects are left in place).
To prevent autoupdating a particular role or rolebinding, set this annotation to <code>"false"</code>.
If you create your own RBAC objects and set this annotation to <code>"false"</code>, <code>kubectl auth reconcile</code>
(which allows reconciling arbitrary RBAC objects in a <a class="glossary-tooltip" title="A serialized specification of one or more Kubernetes API objects." data-toggle="tooltip" data-placement="top" href="/docs/reference/glossary/?all=true#term-manifest" target="_blank" aria-label="manifest">manifest</a>)
respects this annotation and does not automatically add missing permissions and subjects.</p><h3 id="kubernetes-io-psp">kubernetes.io/psp (deprecated)</h3><p>Type: Annotation</p><p>Example: <code>kubernetes.io/psp: restricted</code></p><p>Used on: Pod</p><p>This annotation was only relevant if you were using
<a href="/docs/concepts/security/pod-security-policy/">PodSecurityPolicy</a> objects.
Kubernetes v1.34 does not support the PodSecurityPolicy API.</p><p>When the PodSecurityPolicy admission controller admitted a Pod, the admission controller
modified the Pod to have this annotation.
The value of the annotation was the name of the PodSecurityPolicy that was used for validation.</p><h3 id="seccomp-security-alpha-kubernetes-io-pod">seccomp.security.alpha.kubernetes.io/pod (non-functional)</h3><p>Type: Annotation</p><p>Used on: Pod</p><p>Kubernetes before v1.25 allowed you to configure seccomp behavior using this annotation.
See <a href="/docs/tutorials/security/seccomp/">Restrict a Container's Syscalls with seccomp</a> to
learn the supported way to specify seccomp restrictions for a Pod.</p><h3 id="container-seccomp-security-alpha-kubernetes-io">container.seccomp.security.alpha.kubernetes.io/[NAME] (non-functional)</h3><p>Type: Annotation</p><p>Used on: Pod</p><p>Kubernetes before v1.25 allowed you to configure seccomp behavior using this annotation.
See <a href="/docs/tutorials/security/seccomp/">Restrict a Container's Syscalls with seccomp</a> to
learn the supported way to specify seccomp restrictions for a Pod.</p><h3 id="snapshot-storage-kubernetes-io-allow-volume-mode-change">snapshot.storage.kubernetes.io/allow-volume-mode-change</h3><p>Type: Annotation</p><p>Example: <code>snapshot.storage.kubernetes.io/allow-volume-mode-change: "true"</code></p><p>Used on: VolumeSnapshotContent</p><p>Value can either be <code>true</code> or <code>false</code>. This determines whether a user can modify
the mode of the source volume when a PersistentVolumeClaim is being created from
a VolumeSnapshot.</p><p>Refer to <a href="/docs/concepts/storage/volume-snapshots/#convert-volume-mode">Converting the volume mode of a Snapshot</a>
and the <a href="https://kubernetes-csi.github.io/docs/">Kubernetes CSI Developer Documentation</a>
for more information.</p><h3 id="scheduler-alpha-kubernetes-io-critical-pod-deprecated">scheduler.alpha.kubernetes.io/critical-pod (deprecated)</h3><p>Type: Annotation</p><p>Example: <code>scheduler.alpha.kubernetes.io/critical-pod: ""</code></p><p>Used on: Pod</p><p>This annotation lets Kubernetes control plane know about a Pod being a critical Pod
so that the descheduler will not remove this Pod.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>Starting in v1.16, this annotation was removed in favor of
<a href="/docs/concepts/scheduling-eviction/pod-priority-preemption/">Pod Priority</a>.</div><h3 id="jobset-sigs-k8s-io-jobset-name">jobset.sigs.k8s.io/jobset-name</h3><p>Type: Label, Annotation</p><p>Example: <code>jobset.sigs.k8s.io/jobset-name: "my-jobset"</code></p><p>Used on: Jobs, Pods</p><p>This label/annotation is used to store the name of the JobSet that a Job or Pod belongs to.
<a href="https://jobset.sigs.k8s.io">JobSet</a> is an extension API that you can deploy into your Kubernetes cluster.</p><h3 id="jobset-sigs-k8s-io-replicatedjob-replicas">jobset.sigs.k8s.io/replicatedjob-replicas</h3><p>Type: Label, Annotation</p><p>Example: <code>jobset.sigs.k8s.io/replicatedjob-replicas: "5"</code></p><p>Used on: Jobs, Pods</p><p>This label/annotation specifies the number of replicas for a ReplicatedJob.</p><h3 id="jobset-sigs-k8s-io-replicatedjob-name">jobset.sigs.k8s.io/replicatedjob-name</h3><p>Type: Label, Annotation</p><p>Example: <code>jobset.sigs.k8s.io/replicatedjob-name: "my-replicatedjob"</code></p><p>Used on: Jobs, Pods</p><p>This label or annotation stores the name of the replicated job that this Job or Pod is part of.</p><h3 id="jobset-sigs-k8s-io-job-index">jobset.sigs.k8s.io/job-index</h3><p>Type: Label, Annotation</p><p>Example: <code>jobset.sigs.k8s.io/job-index: "0"</code></p><p>Used on: Jobs, Pods</p><p>This label/annotation is set by the JobSet controller on child Jobs and Pods. It contains the index of the Job replica within its parent ReplicatedJob.</p><h3 id="jobset-sigs-k8s-io-job-key">jobset.sigs.k8s.io/job-key</h3><p>Type: Label, Annotation</p><p>Example: <code>jobset.sigs.k8s.io/job-key: "0f1e93893c4cb372080804ddb9153093cb0d20cefdd37f653e739c232d363feb"</code></p><p>Used on: Jobs, Pods</p><p>The JobSet controller sets this label (and also an annotation with the same key) on child Jobs and
Pods of a JobSet. The value is the SHA256 hash of the namespaced Job name.</p><h3 id="alpha-jobset-sigs-k8s-io-exclusive-topology">alpha.jobset.sigs.k8s.io/exclusive-topology</h3><p>Type: Annotation</p><p>Example: <code>alpha.jobset.sigs.k8s.io/exclusive-topology: "zone"</code></p><p>Used on: JobSets, Jobs</p><p>You can set this label/annotation on a <a href="https://jobset.sigs.k8s.io">JobSet</a> to ensure exclusive Job
placement per topology group. You can also define this label or annotation on a replicated job
template. Read the documentation for JobSet to learn more.</p><h3 id="alpha-jobset-sigs-k8s-io-node-selector">alpha.jobset.sigs.k8s.io/node-selector</h3><p>Type: Annotation</p><p>Example: <code>alpha.jobset.sigs.k8s.io/node-selector: "true"</code></p><p>Used on: Jobs, Pods</p><p>This label/annotation can be applied to a JobSet. When it's set, the JobSet controller modifies the Jobs and their corresponding Pods by adding node selectors and tolerations. This ensures exclusive job placement per topology domain, restricting the scheduling of these Pods to specific nodes based on the strategy.</p><h3 id="alpha-jobset-sigs-k8s-io-namespaced-job">alpha.jobset.sigs.k8s.io/namespaced-job</h3><p>Type: Label</p><p>Example: <code>alpha.jobset.sigs.k8s.io/namespaced-job: "default_myjobset-replicatedjob-0"</code></p><p>Used on: Nodes</p><p>This label is either set manually or automatically (for example, a cluster autoscaler) on the nodes. When <code>alpha.jobset.sigs.k8s.io/node-selector</code> is set to <code>"true"</code>, the JobSet controller adds a nodeSelector to this node label (along with the toleration to the taint <code>alpha.jobset.sigs.k8s.io/no-schedule</code> discussed next).</p><h3 id="alpha-jobset-sigs-k8s-io-no-schedule">alpha.jobset.sigs.k8s.io/no-schedule</h3><p>Type: Taint</p><p>Example: <code>alpha.jobset.sigs.k8s.io/no-schedule: "NoSchedule"</code></p><p>Used on: Nodes</p><p>This taint is either set manually or automatically (for example, a cluster autoscaler) on the nodes. When <code>alpha.jobset.sigs.k8s.io/node-selector</code> is set to <code>"true"</code>, the JobSet controller adds a toleration to this node taint (along with the node selector to the label <code>alpha.jobset.sigs.k8s.io/namespaced-job</code> discussed previously).</p><h3 id="jobset-sigs-k8s-io-coordinator">jobset.sigs.k8s.io/coordinator</h3><p>Type: Annotation, Label</p><p>Example: <code>jobset.sigs.k8s.io/coordinator: "myjobset-workers-0-0.headless-svc"</code></p><p>Used on: Jobs, Pods</p><p>This annotation/label is used on Jobs and Pods to store a stable network endpoint where the coordinator
pod can be reached if the <a href="https://jobset.sigs.k8s.io">JobSet</a> spec defines the <code>.spec.coordinator</code> field.</p><h2 id="annotations-used-for-audit">Annotations used for audit</h2><ul><li><a href="/docs/reference/labels-annotations-taints/audit-annotations/#authorization-k8s-io-decision"><code>authorization.k8s.io/decision</code></a></li><li><a href="/docs/reference/labels-annotations-taints/audit-annotations/#authorization-k8s-io-reason"><code>authorization.k8s.io/reason</code></a></li><li><a href="/docs/reference/labels-annotations-taints/audit-annotations/#insecure-sha1-invalid-cert-kubernetes-io-hostname"><code>insecure-sha1.invalid-cert.kubernetes.io/$hostname</code></a></li><li><a href="/docs/reference/labels-annotations-taints/audit-annotations/#missing-san-invalid-cert-kubernetes-io-hostname"><code>missing-san.invalid-cert.kubernetes.io/$hostname</code></a></li><li><a href="/docs/reference/labels-annotations-taints/audit-annotations/#pod-security-kubernetes-io-audit-violations"><code>pod-security.kubernetes.io/audit-violations</code></a></li><li><a href="/docs/reference/labels-annotations-taints/audit-annotations/#pod-security-kubernetes-io-enforce-policy"><code>pod-security.kubernetes.io/enforce-policy</code></a></li><li><a href="/docs/reference/labels-annotations-taints/audit-annotations/#pod-security-kubernetes-io-exempt"><code>pod-security.kubernetes.io/exempt</code></a></li><li><a href="/docs/reference/labels-annotations-taints/audit-annotations/#validation-policy-admission-k8s-io-validation-failure"><code>validation.policy.admission.k8s.io/validation_failure</code></a></li></ul><p>See more details on <a href="/docs/reference/labels-annotations-taints/audit-annotations/">Audit Annotations</a>.</p><h2 id="kubeadm">kubeadm</h2><h3 id="kubeadm-alpha-kubernetes-io-cri-socket">kubeadm.alpha.kubernetes.io/cri-socket (deprecated)</h3><p>Type: Annotation</p><p>Example: <code>kubeadm.alpha.kubernetes.io/cri-socket: unix:///run/containerd/container.sock</code></p><p>Used on: Node</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>Starting from v1.34, this annotation is deprecated, kubeadm will no longer actively set and use it.</div><h3 id="kubeadm-kubernetes-io-etcd-advertise-client-urls">kubeadm.kubernetes.io/etcd.advertise-client-urls</h3><p>Type: Annotation</p><p>Example: <code>kubeadm.kubernetes.io/etcd.advertise-client-urls: https://172.17.0.18:2379</code></p><p>Used on: Pod</p><p>Annotation that kubeadm places on locally managed etcd Pods to keep track of
a list of URLs where etcd clients should connect to.
This is used mainly for etcd cluster health check purposes.</p><h3 id="kubeadm-kubernetes-io-kube-apiserver-advertise-address-endpoint">kubeadm.kubernetes.io/kube-apiserver.advertise-address.endpoint</h3><p>Type: Annotation</p><p>Example: <code>kubeadm.kubernetes.io/kube-apiserver.advertise-address.endpoint: https://172.17.0.18:6443</code></p><p>Used on: Pod</p><p>Annotation that kubeadm places on locally managed <code>kube-apiserver</code> Pods to keep track
of the exposed advertise address/port endpoint for that API server instance.</p><h3 id="kubeadm-kubernetes-io-component-config-hash">kubeadm.kubernetes.io/component-config.hash</h3><p>Type: Annotation</p><p>Example: <code>kubeadm.kubernetes.io/component-config.hash: 2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae</code></p><p>Used on: ConfigMap</p><p>Annotation that kubeadm places on ConfigMaps that it manages for configuring components.
It contains a hash (SHA-256) used to determine if the user has applied settings different
from the kubeadm defaults for a particular component.</p><h3 id="node-role-kubernetes-io-control-plane">node-role.kubernetes.io/control-plane</h3><p>Type: Label</p><p>Used on: Node</p><p>A marker label to indicate that the node is used to run control plane components.
The kubeadm tool applies this label to the control plane nodes that it manages.
Other cluster management tools typically also set this taint.</p><p>You can label control plane nodes with this label to make it easier to schedule Pods
only onto these nodes, or to avoid running Pods on the control plane.
If this label is set, the <a href="/docs/concepts/services-networking/topology-aware-routing/#implementation-control-plane">EndpointSlice controller</a>
ignores that node while calculating Topology Aware Hints.</p><h3 id="node-role-kubernetes-io">node-role.kubernetes.io/*</h3><p>Type: Label</p><p>Example: <code>node-role.kubernetes.io/gpu: gpu</code></p><p>Used on: Node</p><p>This optional label is applied to a node when you want to mark a node role.
The node role (text following <code>/</code> in the label key) can be set, as long as the overall key follows the
<a href="/docs/concepts/overview/working-with-objects/labels/#syntax-and-character-set">syntax</a> rules for
object labels.</p><p>Kubernetes defines one specific node role, <strong>control-plane</strong>. A label you can use to mark that node
role is <a href="#node-role-kubernetes-io-control-plane"><code>node-role.kubernetes.io/control-plane</code></a>.</p><h3 id="node-role-kubernetes-io-control-plane-taint">node-role.kubernetes.io/control-plane</h3><p>Type: Taint</p><p>Example: <code>node-role.kubernetes.io/control-plane:NoSchedule</code></p><p>Used on: Node</p><p>Taint that kubeadm applies on control plane nodes to restrict placing Pods and
allow only specific pods to schedule on them.</p><p>If this Taint is applied, control plane nodes allow only critical workloads to
be scheduled onto them. You can manually remove this taint with the following
command on a specific node.</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl taint nodes &lt;node-name&gt; node-role.kubernetes.io/control-plane:NoSchedule-
</span></span></code></pre></div><h3 id="node-role-kubernetes-io-master-taint">node-role.kubernetes.io/master (deprecated)</h3><p>Type: Taint</p><p>Used on: Node</p><p>Example: <code>node-role.kubernetes.io/master:NoSchedule</code></p><p>Taint that kubeadm previously applied on control plane nodes to allow only critical
workloads to schedule on them. Replaced by the
<a href="#node-role-kubernetes-io-control-plane-taint"><code>node-role.kubernetes.io/control-plane</code></a>
taint. kubeadm no longer sets or uses this deprecated taint.</p><h3 id="resource-kubernetes-io-admin-access-resource-kubernetes-io-admin-access">resource.kubernetes.io/admin-access {resource-kubernetes-io-admin-access}</h3><p>Type: Label</p><p>Example: <code>resource.kubernetes.io/admin-access: "true"</code></p><p>Used on: Namespace</p><p>Used to grant administrative access to certain resource.k8s.io API types within
a namespace. When this label is set on a namespace with the value <code>"true"</code>
(case-sensitive), it allows the use of <code>adminAccess: true</code> in any namespaced
<code>resource.k8s.io</code> API types. Currently, this permission applies to
<code>ResourceClaim</code> and <code>ResourceClaimTemplate</code> objects.</p><p>See <a href="/docs/concepts/scheduling-eviction/dynamic-resource-allocation/#enabling-admin-access">Dynamic Resource Allocation Admin access</a>
for more information.</p><div class="section-index"/></div>