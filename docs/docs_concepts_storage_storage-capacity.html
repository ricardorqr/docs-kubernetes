<div class="td-content"><h1 data-pagefind-weight="10">Storage Capacity</h1><p>Storage capacity is limited and may vary depending on the node on
which a pod runs: network-attached storage might not be accessible by
all nodes, or storage is local to a node to begin with.</p><div class="feature-state-notice feature-stable"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.24 [stable]</code></div><p>This page describes how Kubernetes keeps track of storage capacity and
how the scheduler uses that information to <a href="/docs/concepts/scheduling-eviction/">schedule Pods</a> onto nodes
that have access to enough storage capacity for the remaining missing
volumes. Without storage capacity tracking, the scheduler may choose a
node that doesn't have enough capacity to provision a volume and
multiple scheduling retries will be needed.</p><h2 id="before-you-begin">Before you begin</h2><p>Kubernetes v1.34 includes cluster-level API support for
storage capacity tracking. To use this you must also be using a CSI driver that
supports capacity tracking. Consult the documentation for the CSI drivers that
you use to find out whether this support is available and, if so, how to use
it. If you are not running Kubernetes v1.34, check the
documentation for that version of Kubernetes.</p><h2 id="api">API</h2><p>There are two API extensions for this feature:</p><ul><li><a href="/docs/reference/kubernetes-api/config-and-storage-resources/csi-storage-capacity-v1/">CSIStorageCapacity</a> objects:
these get produced by a CSI driver in the namespace
where the driver is installed. Each object contains capacity
information for one storage class and defines which nodes have
access to that storage.</li><li><a href="/docs/reference/kubernetes-api/config-and-storage-resources/csi-driver-v1/#CSIDriverSpec">The <code>CSIDriverSpec.StorageCapacity</code> field</a>:
when set to <code>true</code>, the Kubernetes scheduler will consider storage
capacity for volumes that use the CSI driver.</li></ul><h2 id="scheduling">Scheduling</h2><p>Storage capacity information is used by the Kubernetes scheduler if:</p><ul><li>a Pod uses a volume that has not been created yet,</li><li>that volume uses a <a class="glossary-tooltip" title="A StorageClass provides a way for administrators to describe different available storage types." data-toggle="tooltip" data-placement="top" href="/docs/concepts/storage/storage-classes" target="_blank" aria-label="StorageClass">StorageClass</a> which references a CSI driver and
uses <code>WaitForFirstConsumer</code> <a href="/docs/concepts/storage/storage-classes/#volume-binding-mode">volume binding
mode</a>,
and</li><li>the <code>CSIDriver</code> object for the driver has <code>StorageCapacity</code> set to
true.</li></ul><p>In that case, the scheduler only considers nodes for the Pod which
have enough storage available to them. This check is very
simplistic and only compares the size of the volume against the
capacity listed in <code>CSIStorageCapacity</code> objects with a topology that
includes the node.</p><p>For volumes with <code>Immediate</code> volume binding mode, the storage driver
decides where to create the volume, independently of Pods that will
use the volume. The scheduler then schedules Pods onto nodes where the
volume is available after the volume has been created.</p><p>For <a href="/docs/concepts/storage/ephemeral-volumes/#csi-ephemeral-volumes">CSI ephemeral volumes</a>,
scheduling always happens without considering storage capacity. This
is based on the assumption that this volume type is only used by
special CSI drivers which are local to a node and do not need
significant resources there.</p><h2 id="rescheduling">Rescheduling</h2><p>When a node has been selected for a Pod with <code>WaitForFirstConsumer</code>
volumes, that decision is still tentative. The next step is that the
CSI storage driver gets asked to create the volume with a hint that the
volume is supposed to be available on the selected node.</p><p>Because Kubernetes might have chosen a node based on out-dated
capacity information, it is possible that the volume cannot really be
created. The node selection is then reset and the Kubernetes scheduler
tries again to find a node for the Pod.</p><h2 id="limitations">Limitations</h2><p>Storage capacity tracking increases the chance that scheduling works
on the first try, but cannot guarantee this because the scheduler has
to decide based on potentially out-dated information. Usually, the
same retry mechanism as for scheduling without any storage capacity
information handles scheduling failures.</p><p>One situation where scheduling can fail permanently is when a Pod uses
multiple volumes: one volume might have been created already in a
topology segment which then does not have enough capacity left for
another volume. Manual intervention is necessary to recover from this,
for example by increasing capacity or deleting the volume that was
already created.</p><h2 id="what-s-next">What's next</h2><ul><li>For more information on the design, see the
<a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-storage/1472-storage-capacity-tracking/README.md">Storage Capacity Constraints for Pod Scheduling KEP</a>.</li></ul></div>