<div class="td-content"><h1 data-pagefind-weight="10">Certificate Management with kubeadm</h1><div class="feature-state-notice feature-stable"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.15 [stable]</code></div><p>Client certificates generated by <a href="/docs/reference/setup-tools/kubeadm/">kubeadm</a> expire after 1 year.
This page explains how to manage certificate renewals with kubeadm. It also covers other tasks related
to kubeadm certificate management.</p><p>The Kubernetes project recommends upgrading to the latest patch releases promptly, and
to ensure that you are running a supported minor release of Kubernetes.
Following this recommendation helps you to stay secure.</p><h2 id="before-you-begin">Before you begin</h2><p>You should be familiar with <a href="/docs/setup/best-practices/certificates/">PKI certificates and requirements in Kubernetes</a>.</p><p>You should be familiar with how to pass a <a href="/docs/reference/config-api/kubeadm-config.v1beta4/">configuration</a> file to the kubeadm commands.</p><p>This guide covers the usage of the <code>openssl</code> command (used for manual certificate signing,
if you choose that approach), but you can use your preferred tools.</p><p>Some of the steps here use <code>sudo</code> for administrator access. You can use any equivalent tool.</p><h2 id="custom-certificates">Using custom certificates</h2><p>By default, kubeadm generates all the certificates needed for a cluster to run.
You can override this behavior by providing your own certificates.</p><p>To do so, you must place them in whatever directory is specified by the
<code>--cert-dir</code> flag or the <code>certificatesDir</code> field of kubeadm's <code>ClusterConfiguration</code>.
By default this is <code>/etc/kubernetes/pki</code>.</p><p>If a given certificate and private key pair exists before running <code>kubeadm init</code>,
kubeadm does not overwrite them. This means you can, for example, copy an existing
CA into <code>/etc/kubernetes/pki/ca.crt</code> and <code>/etc/kubernetes/pki/ca.key</code>,
and kubeadm will use this CA for signing the rest of the certificates.</p><h2 id="choosing-encryption-algorithm">Choosing an encryption algorithm</h2><p>kubeadm allows you to choose an encryption algorithm that is used for creating
public and private keys. That can be done by using the <code>encryptionAlgorithm</code> field of the
kubeadm configuration:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>kubeadm.k8s.io/v1beta4<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>ClusterConfiguration<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">encryptionAlgorithm</span>:<span style="color:#bbb"> </span>&lt;ALGORITHM&gt;<span style="color:#bbb">
</span></span></span></code></pre></div><p><code>&lt;ALGORITHM&gt;</code> can be one of <code>RSA-2048</code> (default), <code>RSA-3072</code>, <code>RSA-4096</code> or <code>ECDSA-P256</code>.</p><h2 id="choosing-cert-validity-period">Choosing certificate validity period</h2><p>kubeadm allows you to choose the validity period of CA and leaf certificates.
That can be done by using the <code>certificateValidityPeriod</code> and <code>caCertificateValidityPeriod</code>
fields of the kubeadm configuration:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>kubeadm.k8s.io/v1beta4<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>ClusterConfiguration<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">certificateValidityPeriod: 8760h # Default</span>:<span style="color:#bbb"> </span><span style="color:#666">365</span><span style="color:#bbb"> </span>days × 24 hours = 1 year<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">caCertificateValidityPeriod: 87600h # Default</span>:<span style="color:#bbb"> </span><span style="color:#666">365</span><span style="color:#bbb"> </span>days × 24 hours * 10 = 10 years<span style="color:#bbb">
</span></span></span></code></pre></div><p>The values of the fields follow the accepted format for
<a href="https://pkg.go.dev/time#ParseDuration">Go's <code>time.Duration</code> values</a>, with the longest supported
unit being <code>h</code> (hours).</p><h2 id="external-ca-mode">External CA mode</h2><p>It is also possible to provide only the <code>ca.crt</code> file and not the
<code>ca.key</code> file (this is only available for the root CA file, not other cert pairs).
If all other certificates and kubeconfig files are in place, kubeadm recognizes
this condition and activates the "External CA" mode. kubeadm will proceed without the
CA key on disk.</p><p>Instead, run the controller-manager standalone with <code>--controllers=csrsigner</code> and
point to the CA certificate and key.</p><p>There are various ways to prepare the component credentials when using external CA mode.</p><h3 id="manual-preparation-of-component-credentials">Manual preparation of component credentials</h3><p><a href="/docs/setup/best-practices/certificates/">PKI certificates and requirements</a> includes information
on how to prepare all the required by kubeadm component credentials manually.</p><p>This guide covers the usage of the <code>openssl</code> command (used for manual certificate signing,
if you choose that approach), but you can use your preferred tools.</p><h3 id="preparation-of-credentials-by-signing-csrs-generated-by-kubeadm">Preparation of credentials by signing CSRs generated by kubeadm</h3><p>kubeadm can <a href="#signing-csr">generate CSR files</a> that you can sign manually with tools like
<code>openssl</code> and your external CA. These CSR files will include all the specification for credentials
that components deployed by kubeadm require.</p><h3 id="automated-preparation-of-component-credentials-by-using-kubeadm-phases">Automated preparation of component credentials by using kubeadm phases</h3><p>Alternatively, it is possible to use kubeadm phase commands to automate this process.</p><ul><li>Go to a host that you want to prepare as a kubeadm control plane node with external CA.</li><li>Copy the external CA files <code>ca.crt</code> and <code>ca.key</code> that you have into <code>/etc/kubernetes/pki</code> on the node.</li><li>Prepare a temporary <a href="/docs/reference/setup-tools/kubeadm/kubeadm-init/#config-file">kubeadm configuration file</a>
called <code>config.yaml</code> that can be used with <code>kubeadm init</code>. Make sure that this file includes
any relevant cluster wide or host-specific information that could be included in certificates, such as,
<code>ClusterConfiguration.controlPlaneEndpoint</code>, <code>ClusterConfiguration.certSANs</code> and <code>InitConfiguration.APIEndpoint</code>.</li><li>On the same host execute the commands <code>kubeadm init phase kubeconfig all --config config.yaml</code> and
<code>kubeadm init phase certs all --config config.yaml</code>. This will generate all required kubeconfig
files and certificates under <code>/etc/kubernetes/</code> and its <code>pki</code> sub directory.</li><li>Inspect the generated files. Delete <code>/etc/kubernetes/pki/ca.key</code>, delete or move to a safe location
the file <code>/etc/kubernetes/super-admin.conf</code>.</li><li>On nodes where <code>kubeadm join</code> will be called also delete <code>/etc/kubernetes/kubelet.conf</code>.
This file is only required on the first node where <code>kubeadm init</code> will be called.</li><li>Note that some files such <code>pki/sa.*</code>, <code>pki/front-proxy-ca.*</code> and <code>pki/etc/ca.*</code> are
shared between control plane nodes, You can generate them once and
<a href="/docs/setup/production-environment/tools/kubeadm/high-availability/#manual-certs">distribute them manually</a>
to nodes where <code>kubeadm join</code> will be called, or you can use the
<a href="/docs/setup/production-environment/tools/kubeadm/high-availability/#stacked-control-plane-and-etcd-nodes"><code>--upload-certs</code></a>
functionality of <code>kubeadm init</code> and <code>--certificate-key</code> of <code>kubeadm join</code> to automate this distribution.</li></ul><p>Once the credentials are prepared on all nodes, call <code>kubeadm init</code> and <code>kubeadm join</code> for these nodes to
join the cluster. kubeadm will use the existing kubeconfig and certificate files under <code>/etc/kubernetes/</code>
and its <code>pki</code> sub directory.</p><h2 id="check-certificate-expiration">Certificate expiry and management</h2><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4><code>kubeadm</code> cannot manage certificates signed by an external CA.</div><p>You can use the <code>check-expiration</code> subcommand to check when certificates expire:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubeadm certs check-expiration
</span></span></code></pre></div><p>The output is similar to this:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-console" data-lang="console"><span style="display:flex"><span><span style="color:#888">CERTIFICATE                EXPIRES                  RESIDUAL TIME   CERTIFICATE AUTHORITY   EXTERNALLY MANAGED
</span></span></span><span style="display:flex"><span><span style="color:#888">admin.conf                 Dec 30, 2020 23:36 UTC   364d                                    no
</span></span></span><span style="display:flex"><span><span style="color:#888">apiserver                  Dec 30, 2020 23:36 UTC   364d            ca                      no
</span></span></span><span style="display:flex"><span><span style="color:#888">apiserver-etcd-client      Dec 30, 2020 23:36 UTC   364d            etcd-ca                 no
</span></span></span><span style="display:flex"><span><span style="color:#888">apiserver-kubelet-client   Dec 30, 2020 23:36 UTC   364d            ca                      no
</span></span></span><span style="display:flex"><span><span style="color:#888">controller-manager.conf    Dec 30, 2020 23:36 UTC   364d                                    no
</span></span></span><span style="display:flex"><span><span style="color:#888">etcd-healthcheck-client    Dec 30, 2020 23:36 UTC   364d            etcd-ca                 no
</span></span></span><span style="display:flex"><span><span style="color:#888">etcd-peer                  Dec 30, 2020 23:36 UTC   364d            etcd-ca                 no
</span></span></span><span style="display:flex"><span><span style="color:#888">etcd-server                Dec 30, 2020 23:36 UTC   364d            etcd-ca                 no
</span></span></span><span style="display:flex"><span><span style="color:#888">front-proxy-client         Dec 30, 2020 23:36 UTC   364d            front-proxy-ca          no
</span></span></span><span style="display:flex"><span><span style="color:#888">scheduler.conf             Dec 30, 2020 23:36 UTC   364d                                    no
</span></span></span><span style="display:flex"><span><span style="color:#888"/><span>
</span></span></span><span style="display:flex"><span><span/><span style="color:#888">CERTIFICATE AUTHORITY   EXPIRES                  RESIDUAL TIME   EXTERNALLY MANAGED
</span></span></span><span style="display:flex"><span><span style="color:#888">ca                      Dec 28, 2029 23:36 UTC   9y              no
</span></span></span><span style="display:flex"><span><span style="color:#888">etcd-ca                 Dec 28, 2029 23:36 UTC   9y              no
</span></span></span><span style="display:flex"><span><span style="color:#888">front-proxy-ca          Dec 28, 2029 23:36 UTC   9y              no
</span></span></span></code></pre></div><p>The command shows expiration/residual time for the client certificates in the
<code>/etc/kubernetes/pki</code> folder and for the client certificate embedded in the kubeconfig files used
by kubeadm (<code>admin.conf</code>, <code>controller-manager.conf</code> and <code>scheduler.conf</code>).</p><p>Additionally, kubeadm informs the user if the certificate is externally managed; in this case, the
user should take care of managing certificate renewal manually/using other tools.</p><p>The <code>kubelet.conf</code> configuration file is not included in the list above because kubeadm
configures kubelet
for <a href="/docs/tasks/tls/certificate-rotation/">automatic certificate renewal</a>
with rotatable certificates under <code>/var/lib/kubelet/pki</code>.
To repair an expired kubelet client certificate see
<a href="/docs/setup/production-environment/tools/kubeadm/troubleshooting-kubeadm/#kubelet-client-cert">Kubelet client certificate rotation fails</a>.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4><p>On nodes created with <code>kubeadm init</code> from versions prior to kubeadm version 1.17, there is a
<a href="https://github.com/kubernetes/kubeadm/issues/1753">bug</a> where you manually have to modify the
contents of <code>kubelet.conf</code>. After <code>kubeadm init</code> finishes, you should update <code>kubelet.conf</code> to
point to the rotated kubelet client certificates, by replacing <code>client-certificate-data</code> and
<code>client-key-data</code> with:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">client-certificate</span>:<span style="color:#bbb"> </span>/var/lib/kubelet/pki/kubelet-client-current.pem<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">client-key</span>:<span style="color:#bbb"> </span>/var/lib/kubelet/pki/kubelet-client-current.pem<span style="color:#bbb">
</span></span></span></code></pre></div></div><h2 id="automatic-certificate-renewal">Automatic certificate renewal</h2><p>kubeadm renews all the certificates during control plane
<a href="/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/">upgrade</a>.</p><p>This feature is designed for addressing the simplest use cases;
if you don't have specific requirements on certificate renewal and perform Kubernetes version
upgrades regularly (less than 1 year in between each upgrade), kubeadm will take care of keeping
your cluster up to date and reasonably secure.</p><p>If you have more complex requirements for certificate renewal, you can opt out from the default
behavior by passing <code>--certificate-renewal=false</code> to <code>kubeadm upgrade apply</code> or to <code>kubeadm upgrade node</code>.</p><h2 id="manual-certificate-renewal">Manual certificate renewal</h2><p>You can renew your certificates manually at any time with the <code>kubeadm certs renew</code> command,
with the appropriate command line options. If you are running cluster with a replicated control
plane, this command needs to be executed on all the control-plane nodes.</p><p>This command performs the renewal using CA (or front-proxy-CA) certificate and key stored in <code>/etc/kubernetes/pki</code>.</p><p><code>kubeadm certs renew</code> uses the existing certificates as the authoritative source for attributes
(Common Name, Organization, subject alternative name) and does not rely on the <code>kubeadm-config</code>
ConfigMap.
Even so, the Kubernetes project recommends keeping the served certificate and the associated
values in that ConfigMap synchronized, to avoid any risk of confusion.</p><p>After running the command you should restart the control plane Pods. This is required since
dynamic certificate reload is currently not supported for all components and certificates.
<a href="/docs/tasks/configure-pod-container/static-pod/">Static Pods</a> are managed by the local kubelet
and not by the API Server, thus kubectl cannot be used to delete and restart them.
To restart a static Pod you can temporarily remove its manifest file from <code>/etc/kubernetes/manifests/</code>
and wait for 20 seconds (see the <code>fileCheckFrequency</code> value in <a href="/docs/reference/config-api/kubelet-config.v1beta1/">KubeletConfiguration struct</a>).
The kubelet will terminate the Pod if it's no longer in the manifest directory.
You can then move the file back and after another <code>fileCheckFrequency</code> period, the kubelet will recreate
the Pod and the certificate renewal for the component can complete.</p><p><code>kubeadm certs renew</code> can renew any specific certificate or, with the subcommand <code>all</code>, it can renew all of them:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span><span style="color:#080;font-style:italic"># If you are running cluster with a replicated control plane, this command</span>
</span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"># needs to be executed on all the control-plane nodes.</span>
</span></span><span style="display:flex"><span>kubeadm certs renew all
</span></span></code></pre></div><h3 id="admin-certificate-copy">Copying the administrator certificate (optional)</h3><p>Clusters built with kubeadm often copy the <code>admin.conf</code> certificate into
<code>$HOME/.kube/config</code>, as instructed in <a href="/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/">Creating a cluster with kubeadm</a>.
On such a system, to update the contents of <code>$HOME/.kube/config</code>
after renewing the <code>admin.conf</code>, you could run the following commands:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>sudo cp -i /etc/kubernetes/admin.conf <span style="color:#b8860b">$HOME</span>/.kube/config
</span></span><span style="display:flex"><span>sudo chown <span style="color:#a2f;font-weight:700">$(</span>id -u<span style="color:#a2f;font-weight:700">)</span>:<span style="color:#a2f;font-weight:700">$(</span>id -g<span style="color:#a2f;font-weight:700">)</span> <span style="color:#b8860b">$HOME</span>/.kube/config
</span></span></code></pre></div><h2 id="renew-certificates-with-the-kubernetes-certificates-api">Renew certificates with the Kubernetes certificates API</h2><p>This section provides more details about how to execute manual certificate renewal using the Kubernetes certificates API.</p><div class="alert alert-caution" role="alert"><h4 class="alert-heading">Caution:</h4>These are advanced topics for users who need to integrate their organization's certificate
infrastructure into a kubeadm-built cluster. If the default kubeadm configuration satisfies your
needs, you should let kubeadm manage certificates instead.</div><h3 id="set-up-a-signer">Set up a signer</h3><p>The Kubernetes Certificate Authority does not work out of the box.
You can configure an external signer such as <a href="https://cert-manager.io/docs/configuration/ca/">cert-manager</a>,
or you can use the built-in signer.</p><p>The built-in signer is part of <a href="/docs/reference/command-line-tools-reference/kube-controller-manager/"><code>kube-controller-manager</code></a>.</p><p>To activate the built-in signer, you must pass the <code>--cluster-signing-cert-file</code> and
<code>--cluster-signing-key-file</code> flags.</p><p>If you're creating a new cluster, you can use a kubeadm
<a href="/docs/reference/config-api/kubeadm-config.v1beta4/">configuration file</a>:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>kubeadm.k8s.io/v1beta4<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>ClusterConfiguration<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">controllerManager</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">extraArgs</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span><span style="color:#b44">"cluster-signing-cert-file"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">value</span>:<span style="color:#bbb"> </span><span style="color:#b44">"/etc/kubernetes/pki/ca.crt"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span><span style="color:#b44">"cluster-signing-key-file"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">value</span>:<span style="color:#bbb"> </span><span style="color:#b44">"/etc/kubernetes/pki/ca.key"</span><span style="color:#bbb">
</span></span></span></code></pre></div><h3 id="create-certificate-signing-requests-csr">Create certificate signing requests (CSR)</h3><p>See <a href="/docs/reference/access-authn-authz/certificate-signing-requests/#create-certificatessigningrequest">Create CertificateSigningRequest</a>
for creating CSRs with the Kubernetes API.</p><h2 id="renew-certificates-with-external-ca">Renew certificates with external CA</h2><p>This section provide more details about how to execute manual certificate renewal using an external CA.</p><p>To better integrate with external CAs, kubeadm can also produce certificate signing requests (CSRs).
A CSR represents a request to a CA for a signed certificate for a client.
In kubeadm terms, any certificate that would normally be signed by an on-disk CA can be produced
as a CSR instead. A CA, however, cannot be produced as a CSR.</p><h3 id="renewal-by-using-certificate-signing-requests-csr">Renewal by using certificate signing requests (CSR)</h3><p>Renewal of ceritficates is possible by generating new CSRs and signing them with the external CA.
For more details about working with CSRs generated by kubeadm see the section
<a href="#signing-csr">Signing certificate signing requests (CSR) generated by kubeadm</a>.</p><h2 id="certificate-authority-rotation">Certificate authority (CA) rotation</h2><p>Kubeadm does not support rotation or replacement of CA certificates out of the box.</p><p>For more information about manual rotation or replacement of CA, see <a href="/docs/tasks/tls/manual-rotation-of-ca-certificates/">manual rotation of CA certificates</a>.</p><h2 id="kubelet-serving-certs">Enabling signed kubelet serving certificates</h2><p>By default the kubelet serving certificate deployed by kubeadm is self-signed.
This means a connection from external services like the
<a href="https://github.com/kubernetes-sigs/metrics-server">metrics-server</a> to a
kubelet cannot be secured with TLS.</p><p>To configure the kubelets in a new kubeadm cluster to obtain properly signed serving
certificates you must pass the following minimal configuration to <code>kubeadm init</code>:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>kubeadm.k8s.io/v1beta4<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>ClusterConfiguration<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:#00f;font-weight:700">---</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>kubelet.config.k8s.io/v1beta1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>KubeletConfiguration<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">serverTLSBootstrap</span>:<span style="color:#bbb"> </span><span style="color:#a2f;font-weight:700">true</span><span style="color:#bbb">
</span></span></span></code></pre></div><p>If you have already created the cluster you must adapt it by doing the following:</p><ul><li>Find and edit the <code>kubelet-config</code> ConfigMap in the <code>kube-system</code> namespace.
In that ConfigMap, the <code>kubelet</code> key has a
<a href="/docs/reference/config-api/kubelet-config.v1beta1/">KubeletConfiguration</a>
document as its value. Edit the KubeletConfiguration document to set <code>serverTLSBootstrap: true</code>.</li><li>On each node, add the <code>serverTLSBootstrap: true</code> field in <code>/var/lib/kubelet/config.yaml</code>
and restart the kubelet with <code>systemctl restart kubelet</code></li></ul><p>The field <code>serverTLSBootstrap: true</code> will enable the bootstrap of kubelet serving
certificates by requesting them from the <code>certificates.k8s.io</code> API. One known limitation
is that the CSRs (Certificate Signing Requests) for these certificates cannot be automatically
approved by the default signer in the kube-controller-manager -
<a href="/docs/reference/access-authn-authz/certificate-signing-requests/#kubernetes-signers"><code>kubernetes.io/kubelet-serving</code></a>.
This will require action from the user or a third party controller.</p><p>These CSRs can be viewed using:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl get csr
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-console" data-lang="console"><span style="display:flex"><span><span style="color:#888">NAME        AGE     SIGNERNAME                        REQUESTOR                      CONDITION
</span></span></span><span style="display:flex"><span><span style="color:#888">csr-9wvgt   112s    kubernetes.io/kubelet-serving     system:node:worker-1           Pending
</span></span></span><span style="display:flex"><span><span style="color:#888">csr-lz97v   1m58s   kubernetes.io/kubelet-serving     system:node:control-plane-1    Pending
</span></span></span></code></pre></div><p>To approve them you can do the following:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl certificate approve &lt;CSR-name&gt;
</span></span></code></pre></div><p>By default, these serving certificate will expire after one year. Kubeadm sets the
<code>KubeletConfiguration</code> field <code>rotateCertificates</code> to <code>true</code>, which means that close
to expiration a new set of CSRs for the serving certificates will be created and must
be approved to complete the rotation. To understand more see
<a href="/docs/reference/access-authn-authz/kubelet-tls-bootstrapping/#certificate-rotation">Certificate Rotation</a>.</p><p>If you are looking for a solution for automatic approval of these CSRs it is recommended
that you contact your cloud provider and ask if they have a CSR signer that verifies
the node identity with an out of band mechanism.</p><div class="alert alert-secondary callout third-party-content" role="alert"><strong>Note:</strong> This section links to third party projects that provide functionality required by Kubernetes. The Kubernetes project authors aren't responsible for these projects, which are listed alphabetically. To add a project to this list, read the <a href="/docs/contribute/style/content-guide/#third-party-content">content guide</a> before submitting a change. <a href="#third-party-content-disclaimer">More information.</a></div><p>Third party custom controllers can be used:</p><ul><li><a href="https://github.com/postfinance/kubelet-csr-approver">kubelet-csr-approver</a></li></ul><p>Such a controller is not a secure mechanism unless it not only verifies the CommonName
in the CSR but also verifies the requested IPs and domain names. This would prevent
a malicious actor that has access to a kubelet client certificate to create
CSRs requesting serving certificates for any IP or domain name.</p><h2 id="kubeconfig-additional-users">Generating kubeconfig files for additional users</h2><p>During cluster creation, <code>kubeadm init</code> signs the certificate in the <code>super-admin.conf</code>
to have <code>Subject: O = system:masters, CN = kubernetes-super-admin</code>.
<a href="/docs/reference/access-authn-authz/rbac/#user-facing-roles"><code>system:masters</code></a>
is a break-glass, super user group that bypasses the authorization layer (for example,
<a href="/docs/reference/access-authn-authz/rbac/">RBAC</a>). The file <code>admin.conf</code> is also created
by kubeadm on control plane nodes and it contains a certificate with
<code>Subject: O = kubeadm:cluster-admins, CN = kubernetes-admin</code>. <code>kubeadm:cluster-admins</code>
is a group logically belonging to kubeadm. If your cluster uses RBAC
(the kubeadm default), the <code>kubeadm:cluster-admins</code> group is bound to the
<a href="/docs/reference/access-authn-authz/rbac/#user-facing-roles"><code>cluster-admin</code></a> ClusterRole.</p><div class="alert alert-danger" role="alert"><h4 class="alert-heading">Warning:</h4>Avoid sharing the <code>super-admin.conf</code> or <code>admin.conf</code> files. Instead, create least
privileged access even for people who work as administrators and use that least
privilege alternative for anything other than break-glass (emergency) access.</div><p>You can use the <a href="/docs/reference/setup-tools/kubeadm/kubeadm-kubeconfig/"><code>kubeadm kubeconfig user</code></a>
command to generate kubeconfig files for additional users.
The command accepts a mixture of command line flags and
<a href="/docs/reference/config-api/kubeadm-config.v1beta4/">kubeadm configuration</a> options.
The generated kubeconfig will be written to stdout and can be piped to a file using
<code>kubeadm kubeconfig user ... &gt; somefile.conf</code>.</p><p>Example configuration file that can be used with <code>--config</code>:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:#080;font-style:italic"># example.yaml</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>kubeadm.k8s.io/v1beta4<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>ClusterConfiguration<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:#080;font-style:italic"># Will be used as the target "cluster" in the kubeconfig</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">clusterName</span>:<span style="color:#bbb"> </span><span style="color:#b44">"kubernetes"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:#080;font-style:italic"># Will be used as the "server" (IP or DNS name) of this cluster in the kubeconfig</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">controlPlaneEndpoint</span>:<span style="color:#bbb"> </span><span style="color:#b44">"some-dns-address:6443"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:#080;font-style:italic"># The cluster CA key and certificate will be loaded from this local directory</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">certificatesDir</span>:<span style="color:#bbb"> </span><span style="color:#b44">"/etc/kubernetes/pki"</span><span style="color:#bbb">
</span></span></span></code></pre></div><p>Make sure that these settings match the desired target cluster settings.
To see the settings of an existing cluster use:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl get cm kubeadm-config -n kube-system -o<span style="color:#666">=</span><span style="color:#b8860b">jsonpath</span><span style="color:#666">=</span><span style="color:#b44">"{.data.ClusterConfiguration}"</span>
</span></span></code></pre></div><p>The following example will generate a kubeconfig file with credentials valid for 24 hours
for a new user <code>johndoe</code> that is part of the <code>appdevs</code> group:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubeadm kubeconfig user --config example.yaml --org appdevs --client-name johndoe --validity-period 24h
</span></span></code></pre></div><p>The following example will generate a kubeconfig file with administrator credentials valid for 1 week:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubeadm kubeconfig user --config example.yaml --client-name admin --validity-period 168h
</span></span></code></pre></div><h2 id="signing-csr">Signing certificate signing requests (CSR) generated by kubeadm</h2><p>You can create certificate signing requests with <code>kubeadm certs generate-csr</code>.
Calling this command will generate <code>.csr</code> / <code>.key</code> file pairs for regular
certificates. For certificates embedded in kubeconfig files, the command will
generate a <code>.csr</code> / <code>.conf</code> pair where the key is already embedded in the <code>.conf</code> file.</p><p>A CSR file contains all relevant information for a CA to sign a certificate.
kubeadm uses a
<a href="/docs/setup/best-practices/certificates/#all-certificates">well defined specification</a>
for all its certificates and CSRs.</p><p>The default certificate directory is <code>/etc/kubernetes/pki</code>, while the default
directory for kubeconfig files is <code>/etc/kubernetes</code>. These defaults can be
overridden with the flags <code>--cert-dir</code> and <code>--kubeconfig-dir</code>, respectively.</p><p>To pass custom options to <code>kubeadm certs generate-csr</code> use the <code>--config</code> flag,
which accepts a <a href="/docs/reference/config-api/kubeadm-config.v1beta4/">kubeadm configuration</a>
file, similarly to commands such as <code>kubeadm init</code>. Any specification such
as extra SANs and custom IP addresses must be stored in the same configuration
file and used for all relevant kubeadm commands by passing it as <code>--config</code>.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4><p>This guide uses the default Kubernetes directory <code>/etc/kubernetes</code>, which requires
a super user. If you are following this guide and are using directories that you can
write to (typically, this means running <code>kubeadm</code> with <code>--cert-dir</code> and <code>--kubeconfig-dir</code>)
then you can omit the <code>sudo</code> command.</p><p>You must then copy the files that you produced over to within the <code>/etc/kubernetes</code>
directory so that <code>kubeadm init</code> or <code>kubeadm join</code> will find them.</p></div><h3 id="preparing-ca-and-service-account-files">Preparing CA and service account files</h3><p>On the primary control plane node, where <code>kubeadm init</code> will be executed, call the following
commands:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>sudo kubeadm init phase certs ca
</span></span><span style="display:flex"><span>sudo kubeadm init phase certs etcd-ca
</span></span><span style="display:flex"><span>sudo kubeadm init phase certs front-proxy-ca
</span></span><span style="display:flex"><span>sudo kubeadm init phase certs sa
</span></span></code></pre></div><p>This will populate the folders <code>/etc/kubernetes/pki</code> and <code>/etc/kubernetes/pki/etcd</code>
with all self-signed CA files (certificates and keys) and service account (public and
private keys) that kubeadm needs for a control plane node.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4><p>If you are using an external CA, you must generate the same files out of band and manually
copy them to the primary control plane node in <code>/etc/kubernetes</code>.</p><p>Once all CSRs are signed, you can delete the root CA key (<code>ca.key</code>) as noted in the
<a href="#external-ca-mode">External CA mode</a> section.</p></div><p>For secondary control plane nodes (<code>kubeadm join --control-plane</code>) there is no need to call
the above commands. Depending on how you setup the
<a href="/docs/setup/production-environment/tools/kubeadm/high-availability/">High Availability</a>
cluster, you either have to manually copy the same files from the primary
control plane node, or use the automated <code>--upload-certs</code> functionality of <code>kubeadm init</code>.</p><h3 id="generate-csrs">Generate CSRs</h3><p>The <code>kubeadm certs generate-csr</code> command generates CSRs for all known certificates
managed by kubeadm. Once the command is done you must manually delete <code>.csr</code>, <code>.conf</code>
or <code>.key</code> files that you don't need.</p><h4 id="considerations-kubelet-conf">Considerations for kubelet.conf</h4><p>This section applies to both control plane and worker nodes.</p><p>If you have deleted the <code>ca.key</code> file from control plane nodes
(<a href="#external-ca-mode">External CA mode</a>), the active kube-controller-manager in
this cluster will not be able to sign kubelet client certificates. If no external
method for signing these certificates exists in your setup (such as an
<a href="#set-up-a-signer">external signer</a>), you could manually sign the <code>kubelet.conf.csr</code>
as explained in this guide.</p><p>Note that this also means that the automatic
<a href="/docs/tasks/tls/certificate-rotation/#enabling-client-certificate-rotation">kubelet client certificate rotation</a>
will be disabled. If so, close to certificate expiration, you must generate
a new <code>kubelet.conf.csr</code>, sign the certificate, embed it in <code>kubelet.conf</code>
and restart the kubelet.</p><p>If this does not apply to your setup, you can skip processing the <code>kubelet.conf.csr</code>
on secondary control plane and on workers nodes (all nodes that call <code>kubeadm join ...</code>).
That is because the active kube-controller-manager will be responsible
for signing new kubelet client certificates.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>You must process the <code>kubelet.conf.csr</code> file on the primary control plane node
(the host where you originally ran <code>kubeadm init</code>). This is because <code>kubeadm</code>
considers that as the node that bootstraps the cluster, and a pre-populated
<code>kubelet.conf</code> is needed.</div><h4 id="control-plane-nodes">Control plane nodes</h4><p>Execute the following command on primary (<code>kubeadm init</code>) and secondary
(<code>kubeadm join --control-plane</code>) control plane nodes to generate all CSR files:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>sudo kubeadm certs generate-csr
</span></span></code></pre></div><p>If external etcd is to be used, follow the
<a href="/docs/setup/production-environment/tools/kubeadm/high-availability/#external-etcd-nodes">External etcd with kubeadm</a>
guide to understand what CSR files are needed on the kubeadm and etcd nodes. Other
<code>.csr</code> and <code>.key</code> files under <code>/etc/kubernetes/pki/etcd</code> can be removed.</p><p>Based on the explanation in
<a href="#considerations-kubelet-conf">Considerations for kubelet.conf</a> keep or delete
the <code>kubelet.conf</code> and <code>kubelet.conf.csr</code> files.</p><h4 id="worker-nodes">Worker nodes</h4><p>Based on the explanation in
<a href="#considerations-kubelet-conf">Considerations for kubelet.conf</a>, optionally call:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>sudo kubeadm certs generate-csr
</span></span></code></pre></div><p>and keep only the <code>kubelet.conf</code> and <code>kubelet.conf.csr</code> files. Alternatively skip
the steps for worker nodes entirely.</p><h3 id="signing-csrs-for-all-certificates">Signing CSRs for all certificates</h3><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4><p>If you are using external CA and already have CA serial number files (<code>.srl</code>) for
<code>openssl</code>, you can copy such files to a kubeadm node where CSRs will be processed.
The <code>.srl</code> files to copy are <code>/etc/kubernetes/pki/ca.srl</code>,
<code>/etc/kubernetes/pki/front-proxy-ca.srl</code> and <code>/etc/kubernetes/pki/etcd/ca.srl</code>.
The files can be then moved to a new node where CSR files will be processed.</p><p>If a <code>.srl</code> file is missing for a CA on a node, the script below will generate a new SRL file
with a random starting serial number.</p><p>To read more about <code>.srl</code> files see the
<a href="https://www.openssl.org/docs/man3.0/man1/openssl-x509.html"><code>openssl</code></a>
documentation for the <code>--CAserial</code> flag.</p></div><p>Repeat this step for all nodes that have CSR files.</p><p>Write the following script in the <code>/etc/kubernetes</code> directory, navigate to the directory
and execute the script. The script will generate certificates for all CSR files that are
present in the <code>/etc/kubernetes</code> tree.</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="display:flex"><span><span style="color:#080">#!/bin/bash
</span></span></span><span style="display:flex"><span><span style="color:#080"/>
</span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"># Set certificate expiration time in days</span>
</span></span><span style="display:flex"><span><span style="color:#b8860b">DAYS</span><span style="color:#666">=</span><span style="color:#666">365</span>
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"># Process all CSR files except those for front-proxy and etcd</span>
</span></span><span style="display:flex"><span>find ./ -name <span style="color:#b44">"*.csr"</span> | grep -v <span style="color:#b44">"pki/etcd"</span> | grep -v <span style="color:#b44">"front-proxy"</span> | <span style="color:#a2f;font-weight:700">while</span> <span style="color:#a2f">read</span> -r FILE;
</span></span><span style="display:flex"><span><span style="color:#a2f;font-weight:700">do</span>
</span></span><span style="display:flex"><span>    <span style="color:#a2f">echo</span> <span style="color:#b44">"* Processing </span><span style="color:#b68;font-weight:700">${</span><span style="color:#b8860b">FILE</span><span style="color:#b68;font-weight:700">}</span><span style="color:#b44"> ..."</span>
</span></span><span style="display:flex"><span>    <span style="color:#b8860b">FILE</span><span style="color:#666">=</span><span style="color:#b68;font-weight:700">${</span><span style="color:#b8860b">FILE</span>%.*<span style="color:#b68;font-weight:700">}</span> <span style="color:#080;font-style:italic"># Trim the extension</span>
</span></span><span style="display:flex"><span>    <span style="color:#a2f;font-weight:700">if</span> <span style="color:#666">[</span> -f <span style="color:#b44">"./pki/ca.srl"</span> <span style="color:#666">]</span>; <span style="color:#a2f;font-weight:700">then</span>
</span></span><span style="display:flex"><span>        <span style="color:#b8860b">SERIAL_FLAG</span><span style="color:#666">=</span><span style="color:#b44">"-CAserial ./pki/ca.srl"</span>
</span></span><span style="display:flex"><span>    <span style="color:#a2f;font-weight:700">else</span>
</span></span><span style="display:flex"><span>        <span style="color:#b8860b">SERIAL_FLAG</span><span style="color:#666">=</span><span style="color:#b44">"-CAcreateserial"</span>
</span></span><span style="display:flex"><span>    <span style="color:#a2f;font-weight:700">fi</span>
</span></span><span style="display:flex"><span>    openssl x509 -req -days <span style="color:#b44">"</span><span style="color:#b68;font-weight:700">${</span><span style="color:#b8860b">DAYS</span><span style="color:#b68;font-weight:700">}</span><span style="color:#b44">"</span> -CA ./pki/ca.crt -CAkey ./pki/ca.key <span style="color:#b68;font-weight:700">${</span><span style="color:#b8860b">SERIAL_FLAG</span><span style="color:#b68;font-weight:700">}</span> <span style="color:#b62;font-weight:700">\
</span></span></span><span style="display:flex"><span><span style="color:#b62;font-weight:700"/>        -in <span style="color:#b44">"</span><span style="color:#b68;font-weight:700">${</span><span style="color:#b8860b">FILE</span><span style="color:#b68;font-weight:700">}</span><span style="color:#b44">.csr"</span> -out <span style="color:#b44">"</span><span style="color:#b68;font-weight:700">${</span><span style="color:#b8860b">FILE</span><span style="color:#b68;font-weight:700">}</span><span style="color:#b44">.crt"</span>
</span></span><span style="display:flex"><span>    sleep <span style="color:#666">2</span>
</span></span><span style="display:flex"><span><span style="color:#a2f;font-weight:700">done</span>
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"># Process all etcd CSRs</span>
</span></span><span style="display:flex"><span>find ./pki/etcd -name <span style="color:#b44">"*.csr"</span> | <span style="color:#a2f;font-weight:700">while</span> <span style="color:#a2f">read</span> -r FILE;
</span></span><span style="display:flex"><span><span style="color:#a2f;font-weight:700">do</span>
</span></span><span style="display:flex"><span>    <span style="color:#a2f">echo</span> <span style="color:#b44">"* Processing </span><span style="color:#b68;font-weight:700">${</span><span style="color:#b8860b">FILE</span><span style="color:#b68;font-weight:700">}</span><span style="color:#b44"> ..."</span>
</span></span><span style="display:flex"><span>    <span style="color:#b8860b">FILE</span><span style="color:#666">=</span><span style="color:#b68;font-weight:700">${</span><span style="color:#b8860b">FILE</span>%.*<span style="color:#b68;font-weight:700">}</span> <span style="color:#080;font-style:italic"># Trim the extension</span>
</span></span><span style="display:flex"><span>    <span style="color:#a2f;font-weight:700">if</span> <span style="color:#666">[</span> -f <span style="color:#b44">"./pki/etcd/ca.srl"</span> <span style="color:#666">]</span>; <span style="color:#a2f;font-weight:700">then</span>
</span></span><span style="display:flex"><span>        <span style="color:#b8860b">SERIAL_FLAG</span><span style="color:#666">=</span>-CAserial ./pki/etcd/ca.srl
</span></span><span style="display:flex"><span>    <span style="color:#a2f;font-weight:700">else</span>
</span></span><span style="display:flex"><span>        <span style="color:#b8860b">SERIAL_FLAG</span><span style="color:#666">=</span>-CAcreateserial
</span></span><span style="display:flex"><span>    <span style="color:#a2f;font-weight:700">fi</span>
</span></span><span style="display:flex"><span>    openssl x509 -req -days <span style="color:#b44">"</span><span style="color:#b68;font-weight:700">${</span><span style="color:#b8860b">DAYS</span><span style="color:#b68;font-weight:700">}</span><span style="color:#b44">"</span> -CA ./pki/etcd/ca.crt -CAkey ./pki/etcd/ca.key <span style="color:#b68;font-weight:700">${</span><span style="color:#b8860b">SERIAL_FLAG</span><span style="color:#b68;font-weight:700">}</span> <span style="color:#b62;font-weight:700">\
</span></span></span><span style="display:flex"><span><span style="color:#b62;font-weight:700"/>        -in <span style="color:#b44">"</span><span style="color:#b68;font-weight:700">${</span><span style="color:#b8860b">FILE</span><span style="color:#b68;font-weight:700">}</span><span style="color:#b44">.csr"</span> -out <span style="color:#b44">"</span><span style="color:#b68;font-weight:700">${</span><span style="color:#b8860b">FILE</span><span style="color:#b68;font-weight:700">}</span><span style="color:#b44">.crt"</span>
</span></span><span style="display:flex"><span><span style="color:#a2f;font-weight:700">done</span>
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"># Process front-proxy CSRs</span>
</span></span><span style="display:flex"><span><span style="color:#a2f">echo</span> <span style="color:#b44">"* Processing ./pki/front-proxy-client.csr ..."</span>
</span></span><span style="display:flex"><span>openssl x509 -req -days <span style="color:#b44">"</span><span style="color:#b68;font-weight:700">${</span><span style="color:#b8860b">DAYS</span><span style="color:#b68;font-weight:700">}</span><span style="color:#b44">"</span> -CA ./pki/front-proxy-ca.crt -CAkey ./pki/front-proxy-ca.key -CAcreateserial <span style="color:#b62;font-weight:700">\
</span></span></span><span style="display:flex"><span><span style="color:#b62;font-weight:700"/>    -in ./pki/front-proxy-client.csr -out ./pki/front-proxy-client.crt
</span></span></code></pre></div><h3 id="embedding-certificates-in-kubeconfig-files">Embedding certificates in kubeconfig files</h3><p>Repeat this step for all nodes that have CSR files.</p><p>Write the following script in the <code>/etc/kubernetes</code> directory, navigate to the directory
and execute the script. The script will take the <code>.crt</code> files that were signed for
kubeconfig files from CSRs in the previous step and will embed them in the kubeconfig files.</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="display:flex"><span><span style="color:#080">#!/bin/bash
</span></span></span><span style="display:flex"><span><span style="color:#080"/>
</span></span><span style="display:flex"><span><span style="color:#b8860b">CLUSTER</span><span style="color:#666">=</span>kubernetes
</span></span><span style="display:flex"><span>find ./ -name <span style="color:#b44">"*.conf"</span> | <span style="color:#a2f;font-weight:700">while</span> <span style="color:#a2f">read</span> -r FILE;
</span></span><span style="display:flex"><span><span style="color:#a2f;font-weight:700">do</span>
</span></span><span style="display:flex"><span>    <span style="color:#a2f">echo</span> <span style="color:#b44">"* Processing </span><span style="color:#b68;font-weight:700">${</span><span style="color:#b8860b">FILE</span><span style="color:#b68;font-weight:700">}</span><span style="color:#b44"> ..."</span>
</span></span><span style="display:flex"><span>    <span style="color:#b8860b">KUBECONFIG</span><span style="color:#666">=</span><span style="color:#b44">"</span><span style="color:#b68;font-weight:700">${</span><span style="color:#b8860b">FILE</span><span style="color:#b68;font-weight:700">}</span><span style="color:#b44">"</span> kubectl config set-cluster <span style="color:#b44">"</span><span style="color:#b68;font-weight:700">${</span><span style="color:#b8860b">CLUSTER</span><span style="color:#b68;font-weight:700">}</span><span style="color:#b44">"</span> --certificate-authority ./pki/ca.crt --embed-certs
</span></span><span style="display:flex"><span>    <span style="color:#b8860b">USER</span><span style="color:#666">=</span><span style="color:#a2f;font-weight:700">$(</span><span style="color:#b8860b">KUBECONFIG</span><span style="color:#666">=</span><span style="color:#b44">"</span><span style="color:#b68;font-weight:700">${</span><span style="color:#b8860b">FILE</span><span style="color:#b68;font-weight:700">}</span><span style="color:#b44">"</span> kubectl config view -o <span style="color:#b8860b">jsonpath</span><span style="color:#666">=</span><span style="color:#b44">'{.users[0].name}'</span><span style="color:#a2f;font-weight:700">)</span>
</span></span><span style="display:flex"><span>    <span style="color:#b8860b">KUBECONFIG</span><span style="color:#666">=</span><span style="color:#b44">"</span><span style="color:#b68;font-weight:700">${</span><span style="color:#b8860b">FILE</span><span style="color:#b68;font-weight:700">}</span><span style="color:#b44">"</span> kubectl config set-credentials <span style="color:#b44">"</span><span style="color:#b68;font-weight:700">${</span><span style="color:#b8860b">USER</span><span style="color:#b68;font-weight:700">}</span><span style="color:#b44">"</span> --client-certificate <span style="color:#b44">"</span><span style="color:#b68;font-weight:700">${</span><span style="color:#b8860b">FILE</span><span style="color:#b68;font-weight:700">}</span><span style="color:#b44">.crt"</span> --embed-certs
</span></span><span style="display:flex"><span><span style="color:#a2f;font-weight:700">done</span>
</span></span></code></pre></div><h3 id="post-csr-cleanup">Performing cleanup</h3><p>Perform this step on all nodes that have CSR files.</p><p>Write the following script in the <code>/etc/kubernetes</code> directory, navigate to the directory
and execute the script.</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="display:flex"><span><span style="color:#080">#!/bin/bash
</span></span></span><span style="display:flex"><span><span style="color:#080"/>
</span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"># Cleanup CSR files</span>
</span></span><span style="display:flex"><span>rm -f ./*.csr ./pki/*.csr ./pki/etcd/*.csr <span style="color:#080;font-style:italic"># Clean all CSR files</span>
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"># Cleanup CRT files that were already embedded in kubeconfig files</span>
</span></span><span style="display:flex"><span>rm -f ./*.crt
</span></span></code></pre></div><p>Optionally, move <code>.srl</code> files to the next node to be processed.</p><p>Optionally, if using external CA remove the <code>/etc/kubernetes/pki/ca.key</code> file,
as explained in the <a href="#external-ca-mode">External CA node</a> section.</p><h3 id="kubeadm-node-initialization">kubeadm node initialization</h3><p>Once CSR files have been signed and required certificates are in place on the hosts
you want to use as nodes, you can use the commands <code>kubeadm init</code> and <code>kubeadm join</code>
to create a Kubernetes cluster from these nodes. During <code>init</code> and <code>join</code>, kubeadm
uses existing certificates, encryption keys and kubeconfig files that it finds in the
<code>/etc/kubernetes</code> tree on the host's local filesystem.</p></div>