<div class="td-content"><h1 data-pagefind-weight="10">Managing Service Accounts</h1><p>A <em>ServiceAccount</em> provides an identity for processes that run in a Pod.</p><p>A process inside a Pod can use the identity of its associated service account to
authenticate to the cluster's API server.</p><p>For an introduction to service accounts, read <a href="/docs/tasks/configure-pod-container/configure-service-account/">configure service accounts</a>.</p><p>This task guide explains some of the concepts behind ServiceAccounts. The
guide also explains how to obtain or revoke tokens that represent
ServiceAccounts, and how to (optionally) bind a ServiceAccount's validity to
the lifetime of an API object.</p><h2 id="before-you-begin">Before you begin</h2><p>You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. It is recommended to run this tutorial on a cluster with at least two nodes that are not acting as control plane hosts. If you do not already have a
cluster, you can create one by using
<a href="https://minikube.sigs.k8s.io/docs/tutorials/multi_node/">minikube</a>
or you can use one of these Kubernetes playgrounds:</p><ul><li><a href="https://labs.iximiuz.com/playgrounds?category=kubernetes&amp;filter=all">iximiuz Labs</a></li><li><a href="https://killercoda.com/playgrounds/scenario/kubernetes">Killercoda</a></li><li><a href="https://kodekloud.com/public-playgrounds">KodeKloud</a></li><li><a href="https://labs.play-with-k8s.com/">Play with Kubernetes</a></li></ul><p>To be able to follow these steps exactly, ensure you have a namespace named
<code>examplens</code>.
If you don't, create one by running:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl create namespace examplens
</span></span></code></pre></div><h2 id="user-accounts-versus-service-accounts">User accounts versus service accounts</h2><p>Kubernetes distinguishes between the concept of a user account and a service account
for a number of reasons:</p><ul><li>User accounts are for humans. Service accounts are for application processes,
which (for Kubernetes) run in containers that are part of pods.</li><li>User accounts are intended to be global: names must be unique across all
namespaces of a cluster. No matter what namespace you look at, a particular
username that represents a user represents the same user.
In Kubernetes, service accounts are namespaced: two different namespaces can
contain ServiceAccounts that have identical names.</li><li>Typically, a cluster's user accounts might be synchronised from a corporate
database, where new user account creation requires special privileges and is
tied to complex business processes. By contrast, service account creation is
intended to be more lightweight, allowing cluster users to create service accounts
for specific tasks on demand. Separating ServiceAccount creation from the steps to
onboard human users makes it easier for workloads to follow the principle of
least privilege.</li><li>Auditing considerations for humans and service accounts may differ; the separation
makes that easier to achieve.</li><li>A configuration bundle for a complex system may include definition of various service
accounts for components of that system. Because service accounts can be created
without many constraints and have namespaced names, such configuration is
usually portable.</li></ul><h2 id="bound-service-account-tokens">Bound service account tokens</h2><p>ServiceAccount tokens can be bound to API objects that exist in the kube-apiserver.
This can be used to tie the validity of a token to the existence of another API object.
Supported object types are as follows:</p><ul><li>Pod (used for projected volume mounts, see below)</li><li>Secret (can be used to allow revoking a token by deleting the Secret)</li><li>Node (can be used to auto-revoke a token when its Node is deleted; creating new node-bound tokens is GA in v1.33+)</li></ul><p>When a token is bound to an object, the object's <code>metadata.name</code> and <code>metadata.uid</code> are
stored as extra 'private claims' in the issued JWT.</p><p>When a bound token is presented to the kube-apiserver, the service account authenticator
will extract and verify these claims.
If the referenced object or the ServiceAccount is pending deletion (for example, due to finalizers),
then for any instant that is 60 seconds (or more) after the <code>.metadata.deletionTimestamp</code> date,
authentication with that token would fail.
If the referenced object no longer exists (or its <code>metadata.uid</code> does not match),
the request will not be authenticated.</p><h3 id="additional-metadata-in-pod-bound-tokens">Additional metadata in Pod bound tokens</h3><div class="feature-state-notice feature-stable" title="Feature Gate: ServiceAccountTokenPodNodeInfo"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.32 [stable]</code> (enabled by default: true)</div><p>When a service account token is bound to a Pod object, additional metadata is also
embedded into the token that indicates the value of the bound pod's <code>spec.nodeName</code> field,
and the uid of that Node, if available.</p><p>This node information is <strong>not</strong> verified by the kube-apiserver when the token is used for authentication.
It is included so integrators do not have to fetch Pod or Node API objects to check the associated Node name
and uid when inspecting a JWT.</p><h3 id="verifying-and-inspecting-private-claims">Verifying and inspecting private claims</h3><p>The TokenReview API can be used to verify and extract private claims from a token:</p><ol><li><p>First, assume you have a pod named <code>test-pod</code> and a service account named <code>my-sa</code>.</p></li><li><p>Create a token that is bound to this Pod:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl create token my-sa --bound-object-kind<span style="color:#666">=</span><span style="color:#b44">"Pod"</span> --bound-object-name<span style="color:#666">=</span><span style="color:#b44">"test-pod"</span>
</span></span></code></pre></div></li><li><p>Copy this token into a new file named <code>tokenreview.yaml</code>:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>authentication.k8s.io/v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>TokenReview<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">spec</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">token</span>:<span style="color:#bbb"> </span>&lt;token from step 2&gt;<span style="color:#bbb">
</span></span></span></code></pre></div></li><li><p>Submit this resource to the apiserver for review:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span><span style="color:#080;font-style:italic"># use '-o yaml' to inspect the output</span>
</span></span><span style="display:flex"><span>kubectl create -o yaml -f tokenreview.yaml
</span></span></code></pre></div><p>You should see an output like below:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>authentication.k8s.io/v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>TokenReview<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">metadata</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">creationTimestamp</span>:<span style="color:#bbb"> </span><span style="color:#a2f;font-weight:700">null</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">spec</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">token</span>:<span style="color:#bbb"> </span>&lt;token&gt;<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">status</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">audiences</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span>- https://kubernetes.default.svc.cluster.local<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">authenticated</span>:<span style="color:#bbb"> </span><span style="color:#a2f;font-weight:700">true</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">user</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">extra</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">authentication.kubernetes.io/credential-id</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span>- JTI=7ee52be0-9045-4653-aa5e-0da57b8dccdc<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">authentication.kubernetes.io/node-name</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span>- kind-control-plane<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">authentication.kubernetes.io/node-uid</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span>- 497e9d9a-47aa-4930-b0f6-9f2fb574c8c6<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">authentication.kubernetes.io/pod-name</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span>- test-pod<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">authentication.kubernetes.io/pod-uid</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span>- e87dbbd6-3d7e-45db-aafb-72b24627dff5<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">groups</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span>- system:serviceaccounts<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span>- system:serviceaccounts:default<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span>- system:authenticated<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">uid</span>:<span style="color:#bbb"> </span>f8b4161b-2e2b-11e9-86b7-2afc33b31a7e<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">username</span>:<span style="color:#bbb"> </span>system:serviceaccount:default:my-sa<span style="color:#bbb">
</span></span></span></code></pre></div><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>Despite using <code>kubectl create -f</code> to create this resource, and defining it similar to
other resource types in Kubernetes, TokenReview is a special type and the kube-apiserver
does not actually persist the TokenReview object into etcd.
Hence <code>kubectl get tokenreview</code> is not a valid command.</div></li></ol><h4 id="schema-for-service-account-private-claims">Schema for service account private claims</h4><p>The schema for the Kubernetes-specific claims within JWT tokens is not currently documented,
however the relevant code area can be found in
<a href="https://github.com/kubernetes/kubernetes/blob/d8919343526597e0788a1efe133c70d9a0c07f69/pkg/serviceaccount/claims.go#L56-L68">the serviceaccount package</a>
in the Kubernetes codebase.</p><p>You can inspect a JWT using standard JWT decoding tool. Below is an example of a JWT for the
<code>my-serviceaccount</code> ServiceAccount, bound to a Pod object named <code>my-pod</code> which is scheduled
to the Node <code>my-node</code>, in the <code>my-namespace</code> namespace:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json"><span style="display:flex"><span>{
</span></span><span style="display:flex"><span>  <span style="color:green;font-weight:700">"aud"</span>: [
</span></span><span style="display:flex"><span>    <span style="color:#b44">"https://my-audience.example.com"</span>
</span></span><span style="display:flex"><span>  ],
</span></span><span style="display:flex"><span>  <span style="color:green;font-weight:700">"exp"</span>: <span style="color:#666">1729605240</span>,
</span></span><span style="display:flex"><span>  <span style="color:green;font-weight:700">"iat"</span>: <span style="color:#666">1729601640</span>,
</span></span><span style="display:flex"><span>  <span style="color:green;font-weight:700">"iss"</span>: <span style="color:#b44">"https://my-cluster.example.com"</span>,
</span></span><span style="display:flex"><span>  <span style="color:green;font-weight:700">"jti"</span>: <span style="color:#b44">"aed34954-b33a-4142-b1ec-389d6bbb4936"</span>,
</span></span><span style="display:flex"><span>  <span style="color:green;font-weight:700">"kubernetes.io"</span>: {
</span></span><span style="display:flex"><span>    <span style="color:green;font-weight:700">"namespace"</span>: <span style="color:#b44">"my-namespace"</span>,
</span></span><span style="display:flex"><span>    <span style="color:green;font-weight:700">"node"</span>: {
</span></span><span style="display:flex"><span>      <span style="color:green;font-weight:700">"name"</span>: <span style="color:#b44">"my-node"</span>,
</span></span><span style="display:flex"><span>      <span style="color:green;font-weight:700">"uid"</span>: <span style="color:#b44">"646e7c5e-32d6-4d42-9dbd-e504e6cbe6b1"</span>
</span></span><span style="display:flex"><span>    },
</span></span><span style="display:flex"><span>    <span style="color:green;font-weight:700">"pod"</span>: {
</span></span><span style="display:flex"><span>      <span style="color:green;font-weight:700">"name"</span>: <span style="color:#b44">"my-pod"</span>,
</span></span><span style="display:flex"><span>      <span style="color:green;font-weight:700">"uid"</span>: <span style="color:#b44">"5e0bd49b-f040-43b0-99b7-22765a53f7f3"</span>
</span></span><span style="display:flex"><span>    },
</span></span><span style="display:flex"><span>    <span style="color:green;font-weight:700">"serviceaccount"</span>: {
</span></span><span style="display:flex"><span>      <span style="color:green;font-weight:700">"name"</span>: <span style="color:#b44">"my-serviceaccount"</span>,
</span></span><span style="display:flex"><span>      <span style="color:green;font-weight:700">"uid"</span>: <span style="color:#b44">"14ee3fa4-a7e2-420f-9f9a-dbc4507c3798"</span>
</span></span><span style="display:flex"><span>    }
</span></span><span style="display:flex"><span>  },
</span></span><span style="display:flex"><span>  <span style="color:green;font-weight:700">"nbf"</span>: <span style="color:#666">1729601640</span>,
</span></span><span style="display:flex"><span>  <span style="color:green;font-weight:700">"sub"</span>: <span style="color:#b44">"system:serviceaccount:my-namespace:my-serviceaccount"</span>
</span></span><span style="display:flex"><span>}
</span></span></code></pre></div><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4><p>The <code>aud</code> and <code>iss</code> fields in this JWT may differ between different Kubernetes clusters depending
on your configuration.</p><p>The presence of both the <code>pod</code> and <code>node</code> claim implies that this token is bound
to a <em>Pod</em> object. When verifying Pod bound ServiceAccount tokens, the API server <strong>does not</strong>
verify the existence of the referenced Node object.</p></div><p>Services that run outside of Kubernetes and want to perform offline validation of JWTs may
use this schema, along with a compliant JWT validator configured with OpenID Discovery information
from the API server, to verify presented JWTs without requiring use of the TokenReview API.</p><p>Services that verify JWTs in this way <strong>do not verify</strong> the claims embedded in the JWT token to be
current and still valid.
This means if the token is bound to an object, and that object no longer exists, the token will still
be considered valid (until the configured token expires).</p><p>Clients that require assurance that a token's bound claims are still valid <strong>MUST</strong> use the TokenReview
API to present the token to the <code>kube-apiserver</code> for it to verify and expand the embedded claims, using
similar steps to the <a href="#verifying-and-inspecting-private-claims">Verifying and inspecting private claims</a>
section above, but with a <a href="/docs/reference/using-api/client-libraries/">supported client library</a>.
For more information on JWTs and their structure, see the <a href="https://datatracker.ietf.org/doc/html/rfc7519">JSON Web Token RFC</a>.</p><h2 id="bound-service-account-token-volume">Bound service account token volume mechanism</h2><div class="feature-state-notice feature-stable" title="Feature Gate: BoundServiceAccountTokenVolume"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.22 [stable]</code> (enabled by default: true)</div><p>By default, the Kubernetes control plane (specifically, the
<a href="#serviceaccount-admission-controller">ServiceAccount admission controller</a>)
adds a <a href="/docs/concepts/storage/projected-volumes/">projected volume</a> to Pods,
and this volume includes a token for Kubernetes API access.</p><p>Here's an example of how that looks for a launched Pod:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:#00f;font-weight:700">...</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>kube-api-access-&lt;random-suffix&gt;<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">projected</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">sources</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span>- <span style="color:green;font-weight:700">serviceAccountToken</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">            </span><span style="color:green;font-weight:700">path</span>:<span style="color:#bbb"> </span>token<span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># must match the path the app expects</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span>- <span style="color:green;font-weight:700">configMap</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">            </span><span style="color:green;font-weight:700">items</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">              </span>- <span style="color:green;font-weight:700">key</span>:<span style="color:#bbb"> </span>ca.crt<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">                </span><span style="color:green;font-weight:700">path</span>:<span style="color:#bbb"> </span>ca.crt<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">            </span><span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>kube-root-ca.crt<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span>- <span style="color:green;font-weight:700">downwardAPI</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">            </span><span style="color:green;font-weight:700">items</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">              </span>- <span style="color:green;font-weight:700">fieldRef</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">                  </span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">                  </span><span style="color:green;font-weight:700">fieldPath</span>:<span style="color:#bbb"> </span>metadata.namespace<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">                </span><span style="color:green;font-weight:700">path</span>:<span style="color:#bbb"> </span>namespace<span style="color:#bbb">
</span></span></span></code></pre></div><p>That manifest snippet defines a projected volume that consists of three sources. In this case,
each source also represents a single path within that volume. The three sources are:</p><ol><li>A <code>serviceAccountToken</code> source, that contains a token that the kubelet acquires from kube-apiserver.
The kubelet fetches time-bound tokens using the TokenRequest API. A token served for a TokenRequest expires
either when the pod is deleted or after a defined lifespan (by default, that is 1 hour).
The kubelet also refreshes that token before the token expires.
The token is bound to the specific Pod and has the kube-apiserver as its audience.
This mechanism superseded an earlier mechanism that added a volume based on a Secret,
where the Secret represented the ServiceAccount for the Pod, but did not expire.</li><li>A <code>configMap</code> source. The ConfigMap contains a bundle of certificate authority data. Pods can use these
certificates to make sure that they are connecting to your cluster's kube-apiserver (and not to middlebox
or an accidentally misconfigured peer).</li><li>A <code>downwardAPI</code> source that looks up the name of the namespace containing the Pod, and makes
that name information available to application code running inside the Pod.</li></ol><p>Any container within the Pod that mounts this particular volume can access the above information.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>There is no specific mechanism to invalidate a token issued via TokenRequest. If you no longer
trust a bound service account token for a Pod, you can delete that Pod. Deleting a Pod expires
its bound service account tokens.</div><h2 id="manual-secret-management-for-serviceaccounts">Manual Secret management for ServiceAccounts</h2><p>Versions of Kubernetes before v1.22 automatically created credentials for accessing
the Kubernetes API. This older mechanism was based on creating token Secrets that
could then be mounted into running Pods.</p><p>In more recent versions, including Kubernetes v1.34, API credentials
are <a href="#bound-service-account-token-volume">obtained directly</a> using the
<a href="/docs/reference/kubernetes-api/authentication-resources/token-request-v1/">TokenRequest</a> API,
and are mounted into Pods using a projected volume.
The tokens obtained using this method have bounded lifetimes, and are automatically
invalidated when the Pod they are mounted into is deleted.</p><p>You can still <a href="/docs/tasks/configure-pod-container/configure-service-account/#manually-create-an-api-token-for-a-serviceaccount">manually create</a>
a Secret to hold a service account token; for example, if you need a token that never expires.</p><p>Once you manually create a Secret and link it to a ServiceAccount,
the Kubernetes control plane automatically populates the token into that Secret.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>Although the manual mechanism for creating a long-lived ServiceAccount token exists,
using <a href="/docs/reference/kubernetes-api/authentication-resources/token-request-v1/">TokenRequest</a>
to obtain short-lived API access tokens is recommended instead.</div><h2 id="auto-generated-legacy-serviceaccount-token-clean-up">Auto-generated legacy ServiceAccount token clean up</h2><p>Before version 1.24, Kubernetes automatically generated Secret-based tokens for
ServiceAccounts. To distinguish between automatically generated tokens and
manually created ones, Kubernetes checks for a reference from the
ServiceAccount's secrets field. If the Secret is referenced in the <code>secrets</code>
field, it is considered an auto-generated legacy token. Otherwise, it is
considered a manually created legacy token. For example:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>ServiceAccount<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">metadata</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>build-robot<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">namespace</span>:<span style="color:#bbb"> </span>default<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">secrets</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>build-robot-secret<span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># usually NOT present for a manually generated token</span><span style="color:#bbb">
</span></span></span></code></pre></div><p>Beginning from version 1.29, legacy ServiceAccount tokens that were generated
automatically will be marked as invalid if they remain unused for a certain
period of time (set to default at one year). Tokens that continue to be unused
for this defined period (again, by default, one year) will subsequently be
purged by the control plane.</p><p>If users use an invalidated auto-generated token, the token validator will</p><ol><li>add an audit annotation for the key-value pair
<code>authentication.k8s.io/legacy-token-invalidated: &lt;secret name&gt;/&lt;namespace&gt;</code>,</li><li>increment the <code>invalid_legacy_auto_token_uses_total</code> metric count,</li><li>update the Secret label <code>kubernetes.io/legacy-token-last-used</code> with the new
date,</li><li>return an error indicating that the token has been invalidated.</li></ol><p>When receiving this validation error, users can update the Secret to remove the
<code>kubernetes.io/legacy-token-invalid-since</code> label to temporarily allow use of
this token.</p><p>Here's an example of an auto-generated legacy token that has been marked with the
<code>kubernetes.io/legacy-token-last-used</code> and <code>kubernetes.io/legacy-token-invalid-since</code>
labels:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>Secret<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">metadata</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>build-robot-secret<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">namespace</span>:<span style="color:#bbb"> </span>default<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">labels</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">kubernetes.io/legacy-token-last-used</span>:<span style="color:#bbb"> </span>2022-10-24<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">kubernetes.io/legacy-token-invalid-since</span>:<span style="color:#bbb"> </span>2023-10-25<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">annotations</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">kubernetes.io/service-account.name</span>:<span style="color:#bbb"> </span>build-robot<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">type</span>:<span style="color:#bbb"> </span>kubernetes.io/service-account-token<span style="color:#bbb">
</span></span></span></code></pre></div><h2 id="control-plane-details">Control plane details</h2><h3 id="serviceaccount-controller">ServiceAccount controller</h3><p>A ServiceAccount controller manages the ServiceAccounts inside namespaces, and
ensures a ServiceAccount named "default" exists in every active namespace.</p><h3 id="token-controller">Token controller</h3><p>The service account token controller runs as part of <code>kube-controller-manager</code>.
This controller acts asynchronously. It:</p><ul><li>watches for ServiceAccount deletion and deletes all corresponding ServiceAccount
token Secrets.</li><li>watches for ServiceAccount token Secret addition, and ensures the referenced
ServiceAccount exists, and adds a token to the Secret if needed.</li><li>watches for Secret deletion and removes a reference from the corresponding
ServiceAccount if needed.</li></ul><p>You must pass a service account private key file to the token controller in
the <code>kube-controller-manager</code> using the <code>--service-account-private-key-file</code>
flag. The private key is used to sign generated service account tokens.
Similarly, you must pass the corresponding public key to the <code>kube-apiserver</code>
using the <code>--service-account-key-file</code> flag. The public key will be used to
verify the tokens during authentication.</p><div class="feature-state-notice feature-beta" title="Feature Gate: ExternalServiceAccountTokenSigner"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.34 [beta]</code> (enabled by default: true)</div><p>An alternate setup to setting <code>--service-account-private-key-file</code> and <code>--service-account-key-file</code> flags is
to configure an external JWT signer for <a href="#external-serviceaccount-token-signing-and-key-management">external ServiceAccount token signing and key management</a>.
Note that these setups are mutually exclusive and cannot be configured together.</p><h3 id="serviceaccount-admission-controller">ServiceAccount admission controller</h3><p>The modification of pods is implemented via a plugin
called an <a href="/docs/reference/access-authn-authz/admission-controllers/">Admission Controller</a>.
It is part of the API server.
This admission controller acts synchronously to modify pods as they are created.
When this plugin is active (and it is by default on most distributions), then
it does the following when a Pod is created:</p><ol><li>If the pod does not have a <code>.spec.serviceAccountName</code> set, the admission controller sets the name of the
ServiceAccount for this incoming Pod to <code>default</code>.</li><li>The admission controller ensures that the ServiceAccount referenced by the incoming Pod exists. If there
is no ServiceAccount with a matching name, the admission controller rejects the incoming Pod. That check
applies even for the <code>default</code> ServiceAccount.</li><li>Provided that neither the ServiceAccount's <code>automountServiceAccountToken</code> field nor the
Pod's <code>automountServiceAccountToken</code> field is set to <code>false</code>:<ul><li>the admission controller mutates the incoming Pod, adding an extra
<a class="glossary-tooltip" title="A directory containing data, accessible to the containers in a pod." data-toggle="tooltip" data-placement="top" href="/docs/concepts/storage/volumes/" target="_blank" aria-label="volume">volume</a> that contains
a token for API access.</li><li>the admission controller adds a <code>volumeMount</code> to each container in the Pod,
skipping any containers that already have a volume mount defined for the path
<code>/var/run/secrets/kubernetes.io/serviceaccount</code>.
For Linux containers, that volume is mounted at <code>/var/run/secrets/kubernetes.io/serviceaccount</code>;
on Windows nodes, the mount is at the equivalent path.</li></ul></li><li>If the spec of the incoming Pod doesn't already contain any <code>imagePullSecrets</code>, then the
admission controller adds <code>imagePullSecrets</code>, copying them from the <code>ServiceAccount</code>.</li></ol><h3 id="legacy-serviceaccount-token-tracking-controller">Legacy ServiceAccount token tracking controller</h3><div class="feature-state-notice feature-stable" title="Feature Gate: LegacyServiceAccountTokenTracking"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.28 [stable]</code> (enabled by default: true)</div><p>This controller generates a ConfigMap called
<code>kube-system/kube-apiserver-legacy-service-account-token-tracking</code> in the
<code>kube-system</code> namespace. The ConfigMap records the timestamp when legacy service
account tokens began to be monitored by the system.</p><h3 id="legacy-serviceaccount-token-cleaner">Legacy ServiceAccount token cleaner</h3><div class="feature-state-notice feature-stable" title="Feature Gate: LegacyServiceAccountTokenCleanUp"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.30 [stable]</code> (enabled by default: true)</div><p>The legacy ServiceAccount token cleaner runs as part of the
<code>kube-controller-manager</code> and checks every 24 hours to see if any auto-generated
legacy ServiceAccount token has not been used in a <em>specified amount of time</em>.
If so, the cleaner marks those tokens as invalid.</p><p>The cleaner works by first checking the ConfigMap created by the control plane
(provided that <code>LegacyServiceAccountTokenTracking</code> is enabled). If the current
time is a <em>specified amount of time</em> after the date in the ConfigMap, the
cleaner then loops through the list of Secrets in the cluster and evaluates each
Secret that has the type <code>kubernetes.io/service-account-token</code>.</p><p>If a Secret meets all of the following conditions, the cleaner marks it as
invalid:</p><ul><li>The Secret is auto-generated, meaning that it is bi-directionally referenced
by a ServiceAccount.</li><li>The Secret is not currently mounted by any pods.</li><li>The Secret has not been used in a <em>specified amount of time</em> since it was
created or since it was last used.</li></ul><p>The cleaner marks a Secret invalid by adding a label called
<code>kubernetes.io/legacy-token-invalid-since</code> to the Secret, with the current date
as the value. If an invalid Secret is not used in a <em>specified amount of time</em>,
the cleaner will delete it.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>All the <em>specified amount of time</em> above defaults to one year. The cluster
administrator can configure this value through the
<code>--legacy-service-account-token-clean-up-period</code> command line argument for the
<code>kube-controller-manager</code> component.</div><h3 id="tokenrequest-api">TokenRequest API</h3><div class="feature-state-notice feature-stable"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.22 [stable]</code></div><p>You use the <a href="/docs/reference/kubernetes-api/authentication-resources/token-request-v1/">TokenRequest</a>
subresource of a ServiceAccount to obtain a time-bound token for that ServiceAccount.
You don't need to call this to obtain an API token for use within a container, since
the kubelet sets this up for you using a <em>projected volume</em>.</p><p>If you want to use the TokenRequest API from <code>kubectl</code>, see
<a href="/docs/tasks/configure-pod-container/configure-service-account/#manually-create-an-api-token-for-a-serviceaccount">Manually create an API token for a ServiceAccount</a>.</p><p>The Kubernetes control plane (specifically, the ServiceAccount admission controller)
adds a projected volume to Pods, and the kubelet ensures that this volume contains a token
that lets containers authenticate as the right ServiceAccount.</p><p>(This mechanism superseded an earlier mechanism that added a volume based on a Secret,
where the Secret represented the ServiceAccount for the Pod but did not expire.)</p><p>Here's an example of how that looks for a launched Pod:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:#00f;font-weight:700">...</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>kube-api-access-&lt;random-suffix&gt;<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">projected</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">defaultMode</span>:<span style="color:#bbb"> </span><span style="color:#666">420</span><span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># decimal equivalent of octal 0644</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">sources</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span>- <span style="color:green;font-weight:700">serviceAccountToken</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">            </span><span style="color:green;font-weight:700">expirationSeconds</span>:<span style="color:#bbb"> </span><span style="color:#666">3607</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">            </span><span style="color:green;font-weight:700">path</span>:<span style="color:#bbb"> </span>token<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span>- <span style="color:green;font-weight:700">configMap</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">            </span><span style="color:green;font-weight:700">items</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">              </span>- <span style="color:green;font-weight:700">key</span>:<span style="color:#bbb"> </span>ca.crt<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">                </span><span style="color:green;font-weight:700">path</span>:<span style="color:#bbb"> </span>ca.crt<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">            </span><span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>kube-root-ca.crt<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span>- <span style="color:green;font-weight:700">downwardAPI</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">            </span><span style="color:green;font-weight:700">items</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">              </span>- <span style="color:green;font-weight:700">fieldRef</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">                  </span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">                  </span><span style="color:green;font-weight:700">fieldPath</span>:<span style="color:#bbb"> </span>metadata.namespace<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">                </span><span style="color:green;font-weight:700">path</span>:<span style="color:#bbb"> </span>namespace<span style="color:#bbb">
</span></span></span></code></pre></div><p>That manifest snippet defines a projected volume that combines information from three sources:</p><ol><li>A <code>serviceAccountToken</code> source, that contains a token that the kubelet acquires from kube-apiserver.
The kubelet fetches time-bound tokens using the TokenRequest API. A token served for a TokenRequest expires
either when the pod is deleted or after a defined lifespan (by default, that is 1 hour).
The token is bound to the specific Pod and has the kube-apiserver as its audience.</li><li>A <code>configMap</code> source. The ConfigMap contains a bundle of certificate authority data. Pods can use these
certificates to make sure that they are connecting to your cluster's kube-apiserver (and not to a middlebox
or an accidentally misconfigured peer).</li><li>A <code>downwardAPI</code> source. This <code>downwardAPI</code> volume makes the name of the namespace containing the Pod available
to application code running inside the Pod.</li></ol><p>Any container within the Pod that mounts this volume can access the above information.</p><h2 id="create-token">Create additional API tokens</h2><div class="alert alert-caution" role="alert"><h4 class="alert-heading">Caution:</h4>Only create long-lived API tokens if the <a href="#tokenrequest-api">token request</a> mechanism
is not suitable. The token request mechanism provides time-limited tokens; because these
expire, they represent a lower risk to information security.</div><p>To create a non-expiring, persisted API token for a ServiceAccount, create a
Secret of type <code>kubernetes.io/service-account-token</code> with an annotation
referencing the ServiceAccount. The control plane then generates a long-lived token and
updates that Secret with that generated token data.</p><p>Here is a sample manifest for such a Secret:</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/secret/serviceaccount/mysecretname.yaml" download="secret/serviceaccount/mysecretname.yaml"><code>secret/serviceaccount/mysecretname.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" onclick="copyCode(&quot;secret-serviceaccount-mysecretname-yaml&quot;)" title="Copy secret/serviceaccount/mysecretname.yaml to clipboard"/></div><div class="includecode" id="secret-serviceaccount-mysecretname-yaml"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>Secret<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">type</span>:<span style="color:#bbb"> </span>kubernetes.io/service-account-token<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">metadata</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>mysecretname<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">annotations</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">kubernetes.io/service-account.name</span>:<span style="color:#bbb"> </span>myserviceaccount<span style="color:#bbb">
</span></span></span></code></pre></div></div></div><p>To create a Secret based on this example, run:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl -n examplens create -f https://k8s.io/examples/secret/serviceaccount/mysecretname.yaml
</span></span></code></pre></div><p>To see the details for that Secret, run:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl -n examplens describe secret mysecretname
</span></span></code></pre></div><p>The output is similar to:</p><pre tabindex="0"><code>Name:           mysecretname
Namespace:      examplens
Labels:         &lt;none&gt;
Annotations:    kubernetes.io/service-account.name=myserviceaccount
                kubernetes.io/service-account.uid=8a85c4c4-8483-11e9-bc42-526af7764f64

Type:   kubernetes.io/service-account-token

Data
====
ca.crt:         1362 bytes
namespace:      9 bytes
token:          ...
</code></pre><p>If you launch a new Pod into the <code>examplens</code> namespace, it can use the <code>myserviceaccount</code>
service-account-token Secret that you just created.</p><div class="alert alert-caution" role="alert"><h4 class="alert-heading">Caution:</h4>Do not reference manually created Secrets in the <code>secrets</code> field of a
ServiceAccount. Or the manually created Secrets will be cleaned if it is not used for a long
time. Please refer to <a href="#auto-generated-legacy-serviceaccount-token-clean-up">auto-generated legacy ServiceAccount token clean up</a>.</div><h2 id="delete-token">Delete/invalidate a ServiceAccount token</h2><h3 id="delete-legacy-token">Delete/invalidate a long-lived/legacy ServiceAccount token</h3><p>If you know the name of the Secret that contains the token you want to remove:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl delete secret name-of-secret
</span></span></code></pre></div><p>Otherwise, first find the Secret for the ServiceAccount.</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span><span style="color:#080;font-style:italic"># This assumes that you already have a namespace named 'examplens'</span>
</span></span><span style="display:flex"><span>kubectl -n examplens get serviceaccount/example-automated-thing -o yaml
</span></span></code></pre></div><p>The output is similar to:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>ServiceAccount<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">metadata</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">annotations</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">kubectl.kubernetes.io/last-applied-configuration</span>:<span style="color:#bbb"> </span>|<span style="color:#b44;font-style:italic">
</span></span></span><span style="display:flex"><span><span style="color:#b44;font-style:italic">      {"apiVersion":"v1","kind":"ServiceAccount","metadata":{"annotations":{},"name":"example-automated-thing","namespace":"examplens"}}</span><span style="color:#bbb">      
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">creationTimestamp</span>:<span style="color:#bbb"> </span><span style="color:#b44">"2019-07-21T07:07:07Z"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>example-automated-thing<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">namespace</span>:<span style="color:#bbb"> </span>examplens<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">resourceVersion</span>:<span style="color:#bbb"> </span><span style="color:#b44">"777"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">selfLink</span>:<span style="color:#bbb"> </span>/api/v1/namespaces/examplens/serviceaccounts/example-automated-thing<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">uid</span>:<span style="color:#bbb"> </span>f23fd170-66f2-4697-b049-e1e266b7f835<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">secrets</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>example-automated-thing-token-zyxwv<span style="color:#bbb">
</span></span></span></code></pre></div><p>Then, delete the Secret you now know the name of:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl -n examplens delete secret/example-automated-thing-token-zyxwv
</span></span></code></pre></div><h3 id="delete-short-lived">Delete/invalidate a short-lived ServiceAccount token</h3><p>Short lived ServiceAccount tokens automatically expire after the time-limit
specified during their creation. There is no central record of tokens issued,
so there is no way to revoke individual tokens.</p><p>If you have to revoke a short-lived token before its expiration, you
can delete and re-create the ServiceAccount it is associated to. This will
change its UID and hence invalidate <strong>all</strong> ServiceAccount tokens that were
created for it.</p><h2 id="external-serviceaccount-token-signing-and-key-management">External ServiceAccount token signing and key management</h2><div class="feature-state-notice feature-beta" title="Feature Gate: ExternalServiceAccountTokenSigner"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.34 [beta]</code> (enabled by default: true)</div><p>The kube-apiserver can be configured to use external signer for token signing and token verifying key management.
This feature enables kubernetes distributions to integrate with key management solutions of their choice
(for example, HSMs, cloud KMSes) for service account credential signing and verification.
To configure kube-apiserver to use external-jwt-signer set the <code>--service-account-signing-endpoint</code> flag
to the location of a Unix domain socket (UDS) on a filesystem, or be prefixed with an @ symbol and name
a UDS in the abstract socket namespace. At the configured UDS shall be an RPC server which implements
an <code>ExternalJWTSigner</code> gRPC service.</p><p>The external-jwt-signer must be healthy and be ready to serve supported service account keys for the kube-apiserver to start.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>The kube-apiserver flags <code>--service-account-key-file</code> and <code>--service-account-signing-key-file</code> will continue
to be used for reading from files unless <code>--service-account-signing-endpoint</code> is set; they are mutually
exclusive ways of supporting JWT signing and authentication.</div><p>An external signer provides a <code>v1.ExternalJWTSigner</code> gRPC service that implements 3 methods:</p><h3 id="metadata">Metadata</h3><p>Metadata is meant to be called once by <code>kube-apiserver</code> on startup.
This enables the external signer to share metadata with kube-apiserver, like the max token lifetime that signer supports.</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-proto" data-lang="proto"><span style="display:flex"><span><span style="color:#a2f;font-weight:700">rpc</span> Metadata(MetadataRequest) <span style="color:#a2f;font-weight:700">returns</span> (MetadataResponse) {}<span>
</span></span></span><span style="display:flex"><span><span>
</span></span></span><span style="display:flex"><span><span/><span style="color:#a2f;font-weight:700">message</span> <span style="color:#00f">MetadataRequest</span> {}<span>
</span></span></span><span style="display:flex"><span><span>
</span></span></span><span style="display:flex"><span><span/><span style="color:#a2f;font-weight:700">message</span> <span style="color:#00f">MetadataResponse</span> {<span>
</span></span></span><span style="display:flex"><span><span/>  <span style="color:#080;font-style:italic">// used by kube-apiserver for defaulting/validation of JWT lifetime while accounting for configuration flag values:
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>  <span style="color:#080;font-style:italic">// 1. `--service-account-max-token-expiration`
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>  <span style="color:#080;font-style:italic">// 2. `--service-account-extend-token-expiration`
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>  <span style="color:#080;font-style:italic">//
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>  <span style="color:#080;font-style:italic">// * If `--service-account-max-token-expiration` is greater than `max_token_expiration_seconds`, kube-apiserver treats that as misconfiguration and exits.
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>  <span style="color:#080;font-style:italic">// * If `--service-account-max-token-expiration` is not explicitly set, kube-apiserver defaults to `max_token_expiration_seconds`.
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>  <span style="color:#080;font-style:italic">// * If `--service-account-extend-token-expiration` is true, the extended expiration is `min(1 year, max_token_expiration_seconds)`.
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>  <span style="color:#080;font-style:italic">//
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>  <span style="color:#080;font-style:italic">// `max_token_expiration_seconds` must be at least 600s.
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>  <span style="color:#0b0;font-weight:700">int64</span> max_token_expiration_seconds <span style="color:#666">=</span> <span style="color:#666">1</span>;<span>
</span></span></span><span style="display:flex"><span><span/>}<span>
</span></span></span></code></pre></div><h3 id="fetchkeys">FetchKeys</h3><p>FetchKeys returns the set of public keys that are trusted to sign
Kubernetes service account tokens. Kube-apiserver will call this RPC:</p><ul><li>Every time it tries to validate a JWT from the service account issuer with an unknown key ID, and</li><li>Periodically, so it can serve reasonably-up-to-date keys from the OIDC JWKs endpoint.</li></ul><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-proto" data-lang="proto"><span style="display:flex"><span><span style="color:#a2f;font-weight:700">rpc</span> FetchKeys(FetchKeysRequest) <span style="color:#a2f;font-weight:700">returns</span> (FetchKeysResponse) {}<span>
</span></span></span><span style="display:flex"><span><span>
</span></span></span><span style="display:flex"><span><span/><span style="color:#a2f;font-weight:700">message</span> <span style="color:#00f">FetchKeysRequest</span> {}<span>
</span></span></span><span style="display:flex"><span><span>
</span></span></span><span style="display:flex"><span><span/><span style="color:#a2f;font-weight:700">message</span> <span style="color:#00f">FetchKeysResponse</span> {<span>
</span></span></span><span style="display:flex"><span><span/>  <span style="color:#a2f;font-weight:700">repeated</span> Key keys <span style="color:#666">=</span> <span style="color:#666">1</span>;<span>
</span></span></span><span style="display:flex"><span><span>
</span></span></span><span style="display:flex"><span><span/>  <span style="color:#080;font-style:italic">// The timestamp when this data was pulled from the authoritative source of
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>  <span style="color:#080;font-style:italic">// truth for verification keys.
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>  <span style="color:#080;font-style:italic">// kube-apiserver can export this from metrics, to enable end-to-end SLOs.
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>  google.protobuf.Timestamp data_timestamp <span style="color:#666">=</span> <span style="color:#666">2</span>;<span>
</span></span></span><span style="display:flex"><span><span>
</span></span></span><span style="display:flex"><span><span/>  <span style="color:#080;font-style:italic">// refresh interval for verification keys to pick changes if any.
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>  <span style="color:#080;font-style:italic">// any value &lt;= 0 is considered a misconfiguration.
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>  <span style="color:#0b0;font-weight:700">int64</span> refresh_hint_seconds <span style="color:#666">=</span> <span style="color:#666">3</span>;<span>
</span></span></span><span style="display:flex"><span><span/>}<span>
</span></span></span><span style="display:flex"><span><span>
</span></span></span><span style="display:flex"><span><span/><span style="color:#a2f;font-weight:700">message</span> <span style="color:#00f">Key</span> {<span>
</span></span></span><span style="display:flex"><span><span/>  <span style="color:#080;font-style:italic">// A unique identifier for this key.
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>  <span style="color:#080;font-style:italic">// Length must be &lt;=1024.
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>  <span style="color:#0b0;font-weight:700">string</span> key_id <span style="color:#666">=</span> <span style="color:#666">1</span>;<span>
</span></span></span><span style="display:flex"><span><span>
</span></span></span><span style="display:flex"><span><span/>  <span style="color:#080;font-style:italic">// The public key, PKIX-serialized.
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>  <span style="color:#080;font-style:italic">// must be a public key supported by kube-apiserver (currently RSA 256 or ECDSA 256/384/521)
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>  <span style="color:#0b0;font-weight:700">bytes</span> key <span style="color:#666">=</span> <span style="color:#666">2</span>;<span>
</span></span></span><span style="display:flex"><span><span>
</span></span></span><span style="display:flex"><span><span/>  <span style="color:#080;font-style:italic">// Set only for keys that are not used to sign bound tokens.
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>  <span style="color:#080;font-style:italic">// eg: supported keys for legacy tokens.
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>  <span style="color:#080;font-style:italic">// If set, key is used for verification but excluded from OIDC discovery docs.
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>  <span style="color:#080;font-style:italic">// if set, external signer should not use this key to sign a JWT.
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>  <span style="color:#0b0;font-weight:700">bool</span> exclude_from_oidc_discovery <span style="color:#666">=</span> <span style="color:#666">3</span>;<span>
</span></span></span><span style="display:flex"><span><span/>}<span>
</span></span></span></code></pre></div><h3 id="sign">Sign</h3><p>Sign takes a serialized JWT payload, and returns the serialized header and
signature. <code>kube-apiserver</code> then assembles the JWT from the header, payload,
and signature.</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-proto" data-lang="proto"><span style="display:flex"><span><span style="color:#a2f;font-weight:700">rpc</span> Sign(SignJWTRequest) <span style="color:#a2f;font-weight:700">returns</span> (SignJWTResponse) {}<span>
</span></span></span><span style="display:flex"><span><span>
</span></span></span><span style="display:flex"><span><span/><span style="color:#a2f;font-weight:700">message</span> <span style="color:#00f">SignJWTRequest</span> {<span>
</span></span></span><span style="display:flex"><span><span/>  <span style="color:#080;font-style:italic">// URL-safe base64 wrapped payload to be signed.
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>  <span style="color:#080;font-style:italic">// Exactly as it appears in the second segment of the JWT
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>  <span style="color:#0b0;font-weight:700">string</span> claims <span style="color:#666">=</span> <span style="color:#666">1</span>;<span>
</span></span></span><span style="display:flex"><span><span/>}<span>
</span></span></span><span style="display:flex"><span><span>
</span></span></span><span style="display:flex"><span><span/><span style="color:#a2f;font-weight:700">message</span> <span style="color:#00f">SignJWTResponse</span> {<span>
</span></span></span><span style="display:flex"><span><span/>  <span style="color:#080;font-style:italic">// header must contain only alg, kid, typ claims.
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>  <span style="color:#080;font-style:italic">// typ must be JWT.
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>  <span style="color:#080;font-style:italic">// kid must be non-empty, &lt;=1024 characters, and its corresponding public key should not be excluded from OIDC discovery.
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>  <span style="color:#080;font-style:italic">// alg must be one of the algorithms supported by kube-apiserver (currently RS256, ES256, ES384, ES512).
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>  <span style="color:#080;font-style:italic">// header cannot have any additional data that kube-apiserver does not recognize.
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>  <span style="color:#080;font-style:italic">// Already wrapped in URL-safe base64, exactly as it appears in the first segment of the JWT.
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>  <span style="color:#0b0;font-weight:700">string</span> header <span style="color:#666">=</span> <span style="color:#666">1</span>;<span>
</span></span></span><span style="display:flex"><span><span>
</span></span></span><span style="display:flex"><span><span/>  <span style="color:#080;font-style:italic">// The signature for the JWT.
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>  <span style="color:#080;font-style:italic">// Already wrapped in URL-safe base64, exactly as it appears in the final segment of the JWT.
</span></span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"/>  <span style="color:#0b0;font-weight:700">string</span> signature <span style="color:#666">=</span> <span style="color:#666">2</span>;<span>
</span></span></span><span style="display:flex"><span><span/>}<span>
</span></span></span></code></pre></div><h2 id="clean-up">Clean up</h2><p>If you created a namespace <code>examplens</code> to experiment with, you can remove it:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl delete namespace examplens
</span></span></code></pre></div><h2 id="what-s-next">What's next</h2><ul><li>Read more details about <a href="/docs/concepts/storage/projected-volumes/">projected volumes</a>.</li></ul></div>