<div class="td-content"><h1 data-pagefind-weight="10">Set up an Extension API Server</h1><p>Setting up an extension API server to work with the aggregation layer allows the Kubernetes apiserver to be extended with additional APIs, which are not part of the core Kubernetes APIs.</p><h2 id="before-you-begin">Before you begin</h2><p><p>You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. It is recommended to run this tutorial on a cluster with at least two nodes that are not acting as control plane hosts. If you do not already have a
cluster, you can create one by using
<a href="https://minikube.sigs.k8s.io/docs/tutorials/multi_node/">minikube</a>
or you can use one of these Kubernetes playgrounds:</p><ul><li><a href="https://labs.iximiuz.com/playgrounds?category=kubernetes&amp;filter=all">iximiuz Labs</a></li><li><a href="https://killercoda.com/playgrounds/scenario/kubernetes">Killercoda</a></li><li><a href="https://kodekloud.com/public-playgrounds">KodeKloud</a></li><li><a href="https://labs.play-with-k8s.com/">Play with Kubernetes</a></li></ul><p>To check the version, enter <code>kubectl version</code>.</p></p><ul><li>You must <a href="/docs/tasks/extend-kubernetes/configure-aggregation-layer/">configure the aggregation layer</a> and enable the apiserver flags.</li></ul><h2 id="set-up-an-extension-api-server-to-work-with-the-aggregation-layer">Set up an extension api-server to work with the aggregation layer</h2><p>The following steps describe how to set up an extension-apiserver <em>at a high level</em>. These steps apply regardless if you're using YAML configs or using APIs. An attempt is made to specifically identify any differences between the two. For a concrete example of how they can be implemented using YAML configs, you can look at the <a href="https://github.com/kubernetes/sample-apiserver/blob/master/README.md">sample-apiserver</a> in the Kubernetes repo.</p><p>Alternatively, you can use an existing 3rd party solution, such as <a href="https://github.com/kubernetes-sigs/apiserver-builder-alpha/blob/master/README.md">apiserver-builder</a>, which should generate a skeleton and automate all of the following steps for you.</p><ol><li>Make sure the APIService API is enabled (check <code>--runtime-config</code>). It should be on by default, unless it's been deliberately turned off in your cluster.</li><li>You may need to make an RBAC rule allowing you to add APIService objects, or get your cluster administrator to make one. (Since API extensions affect the entire cluster, it is not recommended to do testing/development/debug of an API extension in a live cluster.)</li><li>Create the Kubernetes namespace you want to run your extension api-service in.</li><li>Create/get a CA cert to be used to sign the server cert the extension api-server uses for HTTPS.</li><li>Create a server cert/key for the api-server to use for HTTPS. This cert should be signed by the above CA. It should also have a CN of the Kube DNS name. This is derived from the Kubernetes service and be of the form <code>&lt;service name&gt;.&lt;service name namespace&gt;.svc</code></li><li>Create a Kubernetes secret with the server cert/key in your namespace.</li><li>Create a Kubernetes deployment for the extension api-server and make sure you are loading the secret as a volume. It should contain a reference to a working image of your extension api-server. The deployment should also be in your namespace.</li><li>Make sure that your extension-apiserver loads those certs from that volume and that they are used in the HTTPS handshake.</li><li>Create a Kubernetes service account in your namespace.</li><li>Create a Kubernetes cluster role for the operations you want to allow on your resources.</li><li>Create a Kubernetes cluster role binding from the service account in your namespace to the cluster role you created.</li><li>Create a Kubernetes cluster role binding from the service account in your namespace to the <code>system:auth-delegator</code> cluster role to delegate auth decisions to the Kubernetes core API server.</li><li>Create a Kubernetes role binding from the service account in your namespace to the <code>extension-apiserver-authentication-reader</code> role. This allows your extension api-server to access the <code>extension-apiserver-authentication</code> configmap.</li><li>Create a Kubernetes apiservice. The CA cert above should be base64 encoded, stripped of new lines and used as the spec.caBundle in the apiservice. This should not be namespaced. If using the <a href="https://github.com/kubernetes/kube-aggregator/">kube-aggregator API</a>, only pass in the PEM encoded CA bundle because the base 64 encoding is done for you.</li><li>Use kubectl to get your resource. When run, kubectl should return "No resources found.". This message
indicates that everything worked but you currently have no objects of that resource type created.</li></ol><h2 id="what-s-next">What's next</h2><ul><li>Walk through the steps to <a href="/docs/tasks/extend-kubernetes/configure-aggregation-layer/">configure the API aggregation layer</a> and enable the apiserver flags.</li><li>For a high level overview, see <a href="/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/">Extending the Kubernetes API with the aggregation layer</a>.</li><li>Learn how to <a href="/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/">Extend the Kubernetes API using Custom Resource Definitions</a>.</li></ul></div>