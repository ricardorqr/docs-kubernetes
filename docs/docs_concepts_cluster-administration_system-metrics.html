<div class="td-content"><h1 data-pagefind-weight="10">Metrics For Kubernetes System Components</h1><p>System component metrics can give a better look into what is happening inside them. Metrics are
particularly useful for building dashboards and alerts.</p><p>Kubernetes components emit metrics in <a href="https://prometheus.io/docs/instrumenting/exposition_formats/">Prometheus format</a>.
This format is structured plain text, designed so that people and machines can both read it.</p><h2 id="metrics-in-kubernetes">Metrics in Kubernetes</h2><p>In most cases metrics are available on <code>/metrics</code> endpoint of the HTTP server. For components that
don't expose endpoint by default, it can be enabled using <code>--bind-address</code> flag.</p><p>Examples of those components:</p><ul><li><a class="glossary-tooltip" title="Control Plane component that runs controller processes." data-toggle="tooltip" data-placement="top" href="/docs/reference/command-line-tools-reference/kube-controller-manager/" target="_blank" aria-label="kube-controller-manager">kube-controller-manager</a></li><li><a class="glossary-tooltip" title="kube-proxy is a network proxy that runs on each node in the cluster." data-toggle="tooltip" data-placement="top" href="/docs/reference/command-line-tools-reference/kube-proxy/" target="_blank" aria-label="kube-proxy">kube-proxy</a></li><li><a class="glossary-tooltip" title="Control plane component that serves the Kubernetes API." data-toggle="tooltip" data-placement="top" href="/docs/concepts/architecture/#kube-apiserver" target="_blank" aria-label="kube-apiserver">kube-apiserver</a></li><li><a class="glossary-tooltip" title="Control plane component that watches for newly created pods with no assigned node, and selects a node for them to run on." data-toggle="tooltip" data-placement="top" href="/docs/reference/command-line-tools-reference/kube-scheduler/" target="_blank" aria-label="kube-scheduler">kube-scheduler</a></li><li><a class="glossary-tooltip" title="An agent that runs on each node in the cluster. It makes sure that containers are running in a pod." data-toggle="tooltip" data-placement="top" href="/docs/reference/command-line-tools-reference/kubelet" target="_blank" aria-label="kubelet">kubelet</a></li></ul><p>In a production environment you may want to configure <a href="https://prometheus.io/">Prometheus Server</a>
or some other metrics scraper to periodically gather these metrics and make them available in some
kind of time series database.</p><p>Note that <a class="glossary-tooltip" title="An agent that runs on each node in the cluster. It makes sure that containers are running in a pod." data-toggle="tooltip" data-placement="top" href="/docs/reference/command-line-tools-reference/kubelet" target="_blank" aria-label="kubelet">kubelet</a> also exposes metrics in
<code>/metrics/cadvisor</code>, <code>/metrics/resource</code> and <code>/metrics/probes</code> endpoints. Those metrics do not
have the same lifecycle.</p><p>If your cluster uses <a class="glossary-tooltip" title="Manages authorization decisions, allowing admins to dynamically configure access policies through the Kubernetes API." data-toggle="tooltip" data-placement="top" href="/docs/reference/access-authn-authz/rbac/" target="_blank" aria-label="RBAC">RBAC</a>, reading metrics requires
authorization via a user, group or ServiceAccount with a ClusterRole that allows accessing
<code>/metrics</code>. For example:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io/v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>ClusterRole<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">metadata</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>prometheus<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">rules</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span>- <span style="color:green;font-weight:700">nonResourceURLs</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span>- <span style="color:#b44">"/metrics"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">verbs</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span>- get<span style="color:#bbb">
</span></span></span></code></pre></div><h2 id="metric-lifecycle">Metric lifecycle</h2><p>Alpha metric → Beta metric → Stable metric → Deprecated metric → Hidden metric → Deleted metric</p><p>Alpha metrics have no stability guarantees. These metrics can be modified or deleted at any time.</p><p>Beta metrics observe a looser API contract than its stable counterparts. No labels can be removed from beta metrics during their lifetime, however, labels can be added while the metric is in the beta stage.</p><p>Stable metrics are guaranteed to not change. This means:</p><ul><li>A stable metric without a deprecated signature will not be deleted or renamed</li><li>A stable metric's type will not be modified</li></ul><p>Deprecated metrics are slated for deletion, but are still available for use.
These metrics include an annotation about the version in which they became deprecated.</p><p>For example:</p><ul><li><p>Before deprecation</p><pre tabindex="0"><code># HELP some_counter this counts things
# TYPE some_counter counter
some_counter 0
</code></pre></li><li><p>After deprecation</p><pre tabindex="0"><code># HELP some_counter (Deprecated since 1.15.0) this counts things
# TYPE some_counter counter
some_counter 0
</code></pre></li></ul><p>Hidden metrics are no longer published for scraping, but are still available for use.
A deprecated metric becomes a hidden metric after a period of time, based on its stability level:</p><ul><li><strong>STABLE</strong> metrics become hidden after a minimum of 3 releases or 9 months, whichever is longer.</li><li><strong>BETA</strong> metrics become hidden after a minimum of 1 release or 4 months, whichever is longer.</li><li><strong>ALPHA</strong> metrics can be hidden or removed in the same release in which they are deprecated.</li></ul><p>To use a hidden metric, you must enable it. For more details, refer to the <a href="#show-hidden-metrics">Show hidden metrics</a> section.</p><p>Deleted metrics are no longer published and cannot be used.</p><h2 id="show-hidden-metrics">Show hidden metrics</h2><p>As described above, admins can enable hidden metrics through a command-line flag on a specific
binary. This intends to be used as an escape hatch for admins if they missed the migration of the
metrics deprecated in the last release.</p><p>The flag <code>show-hidden-metrics-for-version</code> takes a version for which you want to show metrics
deprecated in that release. The version is expressed as x.y, where x is the major version, y is
the minor version. The patch version is not needed even though a metrics can be deprecated in a
patch release, the reason for that is the metrics deprecation policy runs against the minor release.</p><p>The flag can only take the previous minor version as its value. If you want to show all metrics hidden in the previous release, you can set the <code>show-hidden-metrics-for-version</code> flag to the previous version. Using a version that is too old is not allowed because it violates the metrics deprecation policy.</p><p>For example, let's assume metric <code>A</code> is deprecated in <code>1.29</code>. The version in which metric <code>A</code> becomes hidden depends on its stability level:</p><ul><li>If metric <code>A</code> is <strong>ALPHA</strong>, it could be hidden in <code>1.29</code>.</li><li>If metric <code>A</code> is <strong>BETA</strong>, it will be hidden in <code>1.30</code> at the earliest. If you are upgrading to <code>1.30</code> and still need <code>A</code>, you must use the command-line flag <code>--show-hidden-metrics-for-version=1.29</code>.</li><li>If metric <code>A</code> is <strong>STABLE</strong>, it will be hidden in <code>1.32</code> at the earliest. If you are upgrading to <code>1.32</code> and still need <code>A</code>, you must use the command-line flag <code>--show-hidden-metrics-for-version=1.31</code>.</li></ul><h2 id="component-metrics">Component metrics</h2><h3 id="kube-controller-manager-metrics">kube-controller-manager metrics</h3><p>Controller manager metrics provide important insight into the performance and health of the
controller manager. These metrics include common Go language runtime metrics such as go_routine
count and controller specific metrics such as etcd request latencies or Cloudprovider (AWS, GCE,
OpenStack) API latencies that can be used to gauge the health of a cluster.</p><p>Starting from Kubernetes 1.7, detailed Cloudprovider metrics are available for storage operations
for GCE, AWS, Vsphere and OpenStack.
These metrics can be used to monitor health of persistent volume operations.</p><p>For example, for GCE these metrics are called:</p><pre tabindex="0"><code>cloudprovider_gce_api_request_duration_seconds { request = "instance_list"}
cloudprovider_gce_api_request_duration_seconds { request = "disk_insert"}
cloudprovider_gce_api_request_duration_seconds { request = "disk_delete"}
cloudprovider_gce_api_request_duration_seconds { request = "attach_disk"}
cloudprovider_gce_api_request_duration_seconds { request = "detach_disk"}
cloudprovider_gce_api_request_duration_seconds { request = "list_disk"}
</code></pre><h3 id="kube-scheduler-metrics">kube-scheduler metrics</h3><div class="feature-state-notice feature-beta"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.21 [beta]</code></div><p>The scheduler exposes optional metrics that reports the requested resources and the desired limits
of all running pods. These metrics can be used to build capacity planning dashboards, assess
current or historical scheduling limits, quickly identify workloads that cannot schedule due to
lack of resources, and compare actual usage to the pod's request.</p><p>The kube-scheduler identifies the resource <a href="/docs/concepts/configuration/manage-resources-containers/">requests and limits</a>
configured for each Pod; when either a request or limit is non-zero, the kube-scheduler reports a
metrics timeseries. The time series is labelled by:</p><ul><li>namespace</li><li>pod name</li><li>the node where the pod is scheduled or an empty string if not yet scheduled</li><li>priority</li><li>the assigned scheduler for that pod</li><li>the name of the resource (for example, <code>cpu</code>)</li><li>the unit of the resource if known (for example, <code>cores</code>)</li></ul><p>Once a pod reaches completion (has a <code>restartPolicy</code> of <code>Never</code> or <code>OnFailure</code> and is in the
<code>Succeeded</code> or <code>Failed</code> pod phase, or has been deleted and all containers have a terminated state)
the series is no longer reported since the scheduler is now free to schedule other pods to run.
The two metrics are called <code>kube_pod_resource_request</code> and <code>kube_pod_resource_limit</code>.</p><p>The metrics are exposed at the HTTP endpoint <code>/metrics/resources</code>. They require
authorization for the <code>/metrics/resources</code> endpoint, usually granted by a
ClusterRole with the <code>get</code> verb for the <code>/metrics/resources</code> non-resource URL.</p><p>On Kubernetes 1.21 you must use the <code>--show-hidden-metrics-for-version=1.20</code>
flag to expose these alpha stability metrics.</p><h3 id="kubelet-pressure-stall-information-psi-metrics">kubelet Pressure Stall Information (PSI) metrics</h3><div class="feature-state-notice feature-beta"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.34 [beta]</code></div><p>As a beta feature, Kubernetes lets you configure kubelet to collect Linux kernel
<a href="https://docs.kernel.org/accounting/psi.html">Pressure Stall Information</a>
(PSI) for CPU, memory and I/O usage.
The information is collected at node, pod and container level.
The metrics are exposed at the <code>/metrics/cadvisor</code> endpoint with the following names:</p><pre tabindex="0"><code>container_pressure_cpu_stalled_seconds_total
container_pressure_cpu_waiting_seconds_total
container_pressure_memory_stalled_seconds_total
container_pressure_memory_waiting_seconds_total
container_pressure_io_stalled_seconds_total
container_pressure_io_waiting_seconds_total
</code></pre><p>This feature is enabled by default, by setting the <code>KubeletPSI</code> <a href="/docs/reference/command-line-tools-reference/feature-gates/">feature gate</a>. The information is also exposed in the
<a href="/docs/reference/instrumentation/node-metrics/#psi">Summary API</a>.</p><p>You can learn how to interpret the PSI metrics in <a href="/docs/reference/instrumentation/understand-psi-metrics/">Understand PSI Metrics</a>.</p><h4 id="requirements">Requirements</h4><p>Pressure Stall Information requires:</p><ul><li><a href="/docs/reference/node/kernel-version-requirements/#requirements-psi">Linux kernel versions 4.20 or later</a>.</li><li><a href="/docs/concepts/architecture/cgroups/">cgroup v2</a></li></ul><h2 id="disabling-metrics">Disabling metrics</h2><p>You can explicitly turn off metrics via command line flag <code>--disabled-metrics</code>. This may be
desired if, for example, a metric is causing a performance problem. The input is a list of
disabled metrics (i.e. <code>--disabled-metrics=metric1,metric2</code>).</p><h2 id="metric-cardinality-enforcement">Metric cardinality enforcement</h2><p>Metrics with unbounded dimensions could cause memory issues in the components they instrument. To
limit resource use, you can use the <code>--allow-metric-labels</code> command line option to dynamically
configure an allow-list of label values for a metric.</p><p>In alpha stage, the flag can only take in a series of mappings as metric label allow-list.
Each mapping is of the format <code>&lt;metric_name&gt;,&lt;label_name&gt;=&lt;allowed_labels&gt;</code> where
<code>&lt;allowed_labels&gt;</code> is a comma-separated list of acceptable label names.</p><p>The overall format looks like:</p><pre tabindex="0"><code>--allow-metric-labels &lt;metric_name&gt;,&lt;label_name&gt;='&lt;allow_value1&gt;, &lt;allow_value2&gt;...', &lt;metric_name2&gt;,&lt;label_name&gt;='&lt;allow_value1&gt;, &lt;allow_value2&gt;...', ...
</code></pre><p>Here is an example:</p><pre tabindex="0"><code class="language-none" data-lang="none">--allow-metric-labels number_count_metric,odd_number='1,3,5', number_count_metric,even_number='2,4,6', date_gauge_metric,weekend='Saturday,Sunday'
</code></pre><p>In addition to specifying this from the CLI, this can also be done within a configuration file. You
can specify the path to that configuration file using the <code>--allow-metric-labels-manifest</code> command
line argument to a component. Here's an example of the contents of that configuration file:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">"metric1,label2": </span><span style="color:#b44">"v1,v2,v3"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">"metric2,label1": </span><span style="color:#b44">"v1,v2,v3"</span><span style="color:#bbb">
</span></span></span></code></pre></div><p>Additionally, the <code>cardinality_enforcement_unexpected_categorizations_total</code> meta-metric records the
count of unexpected categorizations during cardinality enforcement, that is, whenever a label value
is encountered that is not allowed with respect to the allow-list constraints.</p><h2 id="what-s-next">What's next</h2><ul><li>Read about the <a href="https://github.com/prometheus/docs/blob/main/docs/instrumenting/exposition_formats.md#text-based-format">Prometheus text format</a>
for metrics</li><li>See the list of <a href="https://github.com/kubernetes/kubernetes/blob/master/test/instrumentation/testdata/stable-metrics-list.yaml">stable Kubernetes metrics</a></li><li>Read about the <a href="/docs/reference/using-api/deprecation-policy/#deprecating-a-feature-or-behavior">Kubernetes deprecation policy</a></li></ul></div>