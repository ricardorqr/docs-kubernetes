<div class="td-content"><h1 data-pagefind-weight="10">Networking on Windows</h1><p>Kubernetes supports running nodes on either Linux or Windows. You can mix both kinds of node
within a single cluster.
This page provides an overview to networking specific to the Windows operating system.</p><h2 id="networking">Container networking on Windows</h2><p>Networking for Windows containers is exposed through
<a href="/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/">CNI plugins</a>.
Windows containers function similarly to virtual machines in regards to
networking. Each container has a virtual network adapter (vNIC) which is connected
to a Hyper-V virtual switch (vSwitch). The Host Networking Service (HNS) and the
Host Compute Service (HCS) work together to create containers and attach container
vNICs to networks. HCS is responsible for the management of containers whereas HNS
is responsible for the management of networking resources such as:</p><ul><li>Virtual networks (including creation of vSwitches)</li><li>Endpoints / vNICs</li><li>Namespaces</li><li>Policies including packet encapsulations, load-balancing rules, ACLs, and NAT rules.</li></ul><p>The Windows HNS and vSwitch implement namespacing and can
create virtual NICs as needed for a pod or container. However, many configurations such
as DNS, routes, and metrics are stored in the Windows registry database rather than as
files inside <code>/etc</code>, which is how Linux stores those configurations. The Windows registry for the container
is separate from that of the host, so concepts like mapping <code>/etc/resolv.conf</code> from
the host into a container don't have the same effect they would on Linux. These must
be configured using Windows APIs run in the context of that container. Therefore
CNI implementations need to call the HNS instead of relying on file mappings to pass
network details into the pod or container.</p><h2 id="network-modes">Network modes</h2><p>Windows supports five different networking drivers/modes: L2bridge, L2tunnel,
Overlay (Beta), Transparent, and NAT. In a heterogeneous cluster with Windows and Linux
worker nodes, you need to select a networking solution that is compatible on both
Windows and Linux. The following table lists the out-of-tree plugins are supported on Windows,
with recommendations on when to use each CNI:</p><table><thead><tr><th>Network Driver</th><th>Description</th><th>Container Packet Modifications</th><th>Network Plugins</th><th>Network Plugin Characteristics</th></tr></thead><tbody><tr><td>L2bridge</td><td>Containers are attached to an external vSwitch. Containers are attached to the underlay network, although the physical network doesn't need to learn the container MACs because they are rewritten on ingress/egress.</td><td>MAC is rewritten to host MAC, IP may be rewritten to host IP using HNS OutboundNAT policy.</td><td><a href="https://www.cni.dev/plugins/current/main/win-bridge/">win-bridge</a>, <a href="https://github.com/Azure/azure-container-networking/blob/master/docs/cni.md">Azure-CNI</a>, <a href="https://github.com/flannel-io/flannel/blob/master/Documentation/backends.md#host-gw">Flannel host-gateway</a> uses win-bridge</td><td>win-bridge uses L2bridge network mode, connects containers to the underlay of hosts, offering best performance. Requires user-defined routes (UDR) for inter-node connectivity.</td></tr><tr><td>L2Tunnel</td><td>This is a special case of l2bridge, but only used on Azure. All packets are sent to the virtualization host where SDN policy is applied.</td><td>MAC rewritten, IP visible on the underlay network</td><td><a href="https://github.com/Azure/azure-container-networking/blob/master/docs/cni.md">Azure-CNI</a></td><td>Azure-CNI allows integration of containers with Azure vNET, and allows them to leverage the set of capabilities that <a href="https://azure.microsoft.com/en-us/services/virtual-network/">Azure Virtual Network provides</a>. For example, securely connect to Azure services or use Azure NSGs. See <a href="https://docs.microsoft.com/azure/aks/concepts-network#azure-cni-advanced-networking">azure-cni for some examples</a></td></tr><tr><td>Overlay</td><td>Containers are given a vNIC connected to an external vSwitch. Each overlay network gets its own IP subnet, defined by a custom IP prefix.The overlay network driver uses VXLAN encapsulation.</td><td>Encapsulated with an outer header.</td><td><a href="https://www.cni.dev/plugins/current/main/win-overlay/">win-overlay</a>, <a href="https://github.com/flannel-io/flannel/blob/master/Documentation/backends.md#vxlan">Flannel VXLAN</a> (uses win-overlay)</td><td>win-overlay should be used when virtual container networks are desired to be isolated from underlay of hosts (e.g. for security reasons). Allows for IPs to be re-used for different overlay networks (which have different VNID tags) if you are restricted on IPs in your datacenter. This option requires <a href="https://support.microsoft.com/help/4489899">KB4489899</a> on Windows Server 2019.</td></tr><tr><td>Transparent (special use case for <a href="https://github.com/openvswitch/ovn-kubernetes">ovn-kubernetes</a>)</td><td>Requires an external vSwitch. Containers are attached to an external vSwitch which enables intra-pod communication via logical networks (logical switches and routers).</td><td>Packet is encapsulated either via <a href="https://datatracker.ietf.org/doc/draft-gross-geneve/">GENEVE</a> or <a href="https://datatracker.ietf.org/doc/draft-davie-stt/">STT</a> tunneling to reach pods which are not on the same host.<br/>Packets are forwarded or dropped via the tunnel metadata information supplied by the ovn network controller.<br/>NAT is done for north-south communication.</td><td><a href="https://github.com/openvswitch/ovn-kubernetes">ovn-kubernetes</a></td><td><a href="https://github.com/openvswitch/ovn-kubernetes/tree/master/contrib">Deploy via ansible</a>. Distributed ACLs can be applied via Kubernetes policies. IPAM support. Load-balancing can be achieved without kube-proxy. NATing is done without using iptables/netsh.</td></tr><tr><td>NAT (<em>not used in Kubernetes</em>)</td><td>Containers are given a vNIC connected to an internal vSwitch. DNS/DHCP is provided using an internal component called <a href="https://techcommunity.microsoft.com/t5/virtualization/windows-nat-winnat-capabilities-and-limitations/ba-p/382303">WinNAT</a></td><td>MAC and IP is rewritten to host MAC/IP.</td><td><a href="https://github.com/Microsoft/windows-container-networking/tree/master/plugins/nat">nat</a></td><td>Included here for completeness</td></tr></tbody></table><p>As outlined above, the <a href="https://github.com/coreos/flannel">Flannel</a>
<a href="https://github.com/flannel-io/cni-plugin">CNI plugin</a>
is also <a href="https://github.com/flannel-io/cni-plugin#windows-support-experimental">supported</a> on Windows via the
<a href="https://github.com/coreos/flannel/blob/master/Documentation/backends.md#vxlan">VXLAN network backend</a> (<strong>Beta support</strong> ; delegates to win-overlay)
and <a href="https://github.com/coreos/flannel/blob/master/Documentation/backends.md#host-gw">host-gateway network backend</a> (stable support; delegates to win-bridge).</p><p>This plugin supports delegating to one of the reference CNI plugins (win-overlay,
win-bridge), to work in conjunction with Flannel daemon on Windows (Flanneld) for
automatic node subnet lease assignment and HNS network creation. This plugin reads
in its own configuration file (cni.conf), and aggregates it with the environment
variables from the FlannelD generated subnet.env file. It then delegates to one of
the reference CNI plugins for network plumbing, and sends the correct configuration
containing the node-assigned subnet to the IPAM plugin (for example: <code>host-local</code>).</p><p>For Node, Pod, and Service objects, the following network flows are supported for
TCP/UDP traffic:</p><ul><li>Pod → Pod (IP)</li><li>Pod → Pod (Name)</li><li>Pod → Service (Cluster IP)</li><li>Pod → Service (PQDN, but only if there are no ".")</li><li>Pod → Service (FQDN)</li><li>Pod → external (IP)</li><li>Pod → external (DNS)</li><li>Node → Pod</li><li>Pod → Node</li></ul><h2 id="ipam">IP address management (IPAM)</h2><p>The following IPAM options are supported on Windows:</p><ul><li><a href="https://github.com/containernetworking/plugins/tree/master/plugins/ipam/host-local">host-local</a></li><li><a href="https://github.com/Azure/azure-container-networking/blob/master/docs/ipam.md">azure-vnet-ipam</a> (for azure-cni only)</li><li><a href="https://docs.microsoft.com/windows-server/networking/technologies/ipam/ipam-top">Windows Server IPAM</a> (fallback option if no IPAM is set)</li></ul><h2 id="dsr">Direct Server Return (DSR)</h2><div class="feature-state-notice feature-stable" title="Feature Gate: WinDSR"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.34 [stable]</code> (enabled by default: true)</div><p>Load balancing mode where the IP address fixups and the LBNAT occurs at the container vSwitch port directly;
service traffic arrives with the source IP set as the originating pod IP.
This provides performance optimizations by allowing the return traffic routed through load balancers
to bypass the load balancer and respond directly to the client;
reducing load on the load balancer and also reducing overall latency.
For more information, read
<a href="https://techcommunity.microsoft.com/blog/networkingblog/direct-server-return-dsr-in-a-nutshell/693710">Direct Server Return (DSR) in a nutshell</a>.</p><h2 id="load-balancing-and-services">Load balancing and Services</h2><p>A Kubernetes <a class="glossary-tooltip" title="A way to expose an application running on a set of Pods as a network service." data-toggle="tooltip" data-placement="top" href="/docs/concepts/services-networking/service/" target="_blank" aria-label="Service">Service</a> is an abstraction
that defines a logical set of Pods and a means to access them over a network.
In a cluster that includes Windows nodes, you can use the following types of Service:</p><ul><li><code>NodePort</code></li><li><code>ClusterIP</code></li><li><code>LoadBalancer</code></li><li><code>ExternalName</code></li></ul><p>Windows container networking differs in some important ways from Linux networking.
The <a href="https://docs.microsoft.com/en-us/virtualization/windowscontainers/container-networking/architecture">Microsoft documentation for Windows Container Networking</a>
provides additional details and background.</p><p>On Windows, you can use the following settings to configure Services and load
balancing behavior:</p><table><caption style="display:none">Windows Service Settings</caption><thead><tr><th>Feature</th><th>Description</th><th>Minimum Supported Windows OS build</th><th>How to enable</th></tr></thead><tbody><tr><td>Session affinity</td><td>Ensures that connections from a particular client are passed to the same Pod each time.</td><td>Windows Server 2022</td><td>Set <code>service.spec.sessionAffinity</code> to "ClientIP"</td></tr><tr><td>Direct Server Return (DSR)</td><td>See <a href="#dsr">DSR</a> notes above.</td><td>Windows Server 2019</td><td>Set the following command line argument (assuming version 1.34): <code>--enable-dsr=true</code></td></tr><tr><td>Preserve-Destination</td><td>Skips DNAT of service traffic, thereby preserving the virtual IP of the target service in packets reaching the backend Pod. Also disables node-node forwarding.</td><td>Windows Server, version 1903</td><td>Set <code>"preserve-destination": "true"</code> in service annotations and enable DSR in kube-proxy.</td></tr><tr><td>IPv4/IPv6 dual-stack networking</td><td>Native IPv4-to-IPv4 in parallel with IPv6-to-IPv6 communications to, from, and within a cluster</td><td>Windows Server 2019</td><td>See <a href="/docs/concepts/services-networking/dual-stack/#windows-support">IPv4/IPv6 dual-stack</a></td></tr><tr><td>Client IP preservation</td><td>Ensures that source IP of incoming ingress traffic gets preserved. Also disables node-node forwarding.</td><td>Windows Server 2019</td><td>Set <code>service.spec.externalTrafficPolicy</code> to "Local" and enable DSR in kube-proxy</td></tr></tbody></table><h2 id="limitations">Limitations</h2><p>The following networking functionality is <em>not</em> supported on Windows nodes:</p><ul><li>Host networking mode</li><li>Local NodePort access from the node itself (works for other nodes or external clients)</li><li>More than 64 backend pods (or unique destination addresses) for a single Service</li><li>IPv6 communication between Windows pods connected to overlay networks</li><li>Local Traffic Policy in non-DSR mode</li><li>Outbound communication using the ICMP protocol via the <code>win-overlay</code>, <code>win-bridge</code>, or using the Azure-CNI plugin.
Specifically, the Windows data plane (<a href="https://www.microsoft.com/research/project/azure-virtual-filtering-platform/">VFP</a>)
doesn't support ICMP packet transpositions, and this means:<ul><li>ICMP packets directed to destinations within the same network (such as pod to pod communication via ping)
work as expected;</li><li>TCP/UDP packets work as expected;</li><li>ICMP packets directed to pass through a remote network (e.g. pod to external internet communication via ping)
cannot be transposed and thus will not be routed back to their source;</li><li>Since TCP/UDP packets can still be transposed, you can substitute <code>ping &lt;destination&gt;</code> with
<code>curl &lt;destination&gt;</code> when debugging connectivity with the outside world.</li></ul></li></ul><p>Other limitations:</p><ul><li>Windows reference network plugins win-bridge and win-overlay do not implement
<a href="https://github.com/containernetworking/cni/blob/master/SPEC.md">CNI spec</a> v0.4.0,
due to a missing <code>CHECK</code> implementation.</li><li>The Flannel VXLAN CNI plugin has the following limitations on Windows:<ul><li>Node-pod connectivity is only possible for local pods with Flannel v0.12.0 (or higher).</li><li>Flannel is restricted to using VNI 4096 and UDP port 4789. See the official
<a href="https://github.com/coreos/flannel/blob/master/Documentation/backends.md#vxlan">Flannel VXLAN</a>
backend docs for more details on these parameters.</li></ul></li></ul></div>