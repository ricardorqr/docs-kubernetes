<div class="td-content"><h1 data-pagefind-weight="10">Kubernetes Component SLI Metrics</h1><div class="lead">High-level indicators for measuring the reliability and performance of Kubernetes components.</div><div class="feature-state-notice feature-stable" title="Feature Gate: ComponentSLIs"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.32 [stable]</code> (enabled by default: true)</div><p>By default, Kubernetes 1.34 publishes Service Level Indicator (SLI) metrics
for each Kubernetes component binary. This metric endpoint is exposed on the serving
HTTPS port of each component, at the path <code>/metrics/slis</code>. The
<code>ComponentSLIs</code> <a href="/docs/reference/command-line-tools-reference/feature-gates/">feature gate</a>
defaults to enabled for each Kubernetes component as of v1.27.</p><h2 id="sli-metrics">SLI Metrics</h2><p>With SLI metrics enabled, each Kubernetes component exposes two metrics,
labeled per healthcheck:</p><ul><li>a gauge (which represents the current state of the healthcheck)</li><li>a counter (which records the cumulative counts observed for each healthcheck state)</li></ul><p>You can use the metric information to calculate per-component availability statistics.
For example, the API server checks the health of etcd. You can work out and report how
available or unavailable etcd has been - as reported by its client, the API server.</p><p>The prometheus gauge data looks like this:</p><pre tabindex="0"><code># HELP kubernetes_healthcheck [ALPHA] This metric records the result of a single healthcheck.
# TYPE kubernetes_healthcheck gauge
kubernetes_healthcheck{name="autoregister-completion",type="healthz"} 1
kubernetes_healthcheck{name="autoregister-completion",type="readyz"} 1
kubernetes_healthcheck{name="etcd",type="healthz"} 1
kubernetes_healthcheck{name="etcd",type="readyz"} 1
kubernetes_healthcheck{name="etcd-readiness",type="readyz"} 1
kubernetes_healthcheck{name="informer-sync",type="readyz"} 1
kubernetes_healthcheck{name="log",type="healthz"} 1
kubernetes_healthcheck{name="log",type="readyz"} 1
kubernetes_healthcheck{name="ping",type="healthz"} 1
kubernetes_healthcheck{name="ping",type="readyz"} 1
</code></pre><p>While the counter data looks like this:</p><pre tabindex="0"><code># HELP kubernetes_healthchecks_total [ALPHA] This metric records the results of all healthcheck.
# TYPE kubernetes_healthchecks_total counter
kubernetes_healthchecks_total{name="autoregister-completion",status="error",type="readyz"} 1
kubernetes_healthchecks_total{name="autoregister-completion",status="success",type="healthz"} 15
kubernetes_healthchecks_total{name="autoregister-completion",status="success",type="readyz"} 14
kubernetes_healthchecks_total{name="etcd",status="success",type="healthz"} 15
kubernetes_healthchecks_total{name="etcd",status="success",type="readyz"} 15
kubernetes_healthchecks_total{name="etcd-readiness",status="success",type="readyz"} 15
kubernetes_healthchecks_total{name="informer-sync",status="error",type="readyz"} 1
kubernetes_healthchecks_total{name="informer-sync",status="success",type="readyz"} 14
kubernetes_healthchecks_total{name="log",status="success",type="healthz"} 15
kubernetes_healthchecks_total{name="log",status="success",type="readyz"} 15
kubernetes_healthchecks_total{name="ping",status="success",type="healthz"} 15
kubernetes_healthchecks_total{name="ping",status="success",type="readyz"} 15
</code></pre><h2 id="using-this-data">Using this data</h2><p>The component SLIs metrics endpoint is intended to be scraped at a high frequency. Scraping
at a high frequency means that you end up with greater granularity of the gauge's signal, which
can be then used to calculate SLOs. The <code>/metrics/slis</code> endpoint provides the raw data necessary
to calculate an availability SLO for the respective Kubernetes component.</p></div>