<div class="td-content"><h1 data-pagefind-weight="10">Role Based Access Control Good Practices</h1><div class="lead">Principles and practices for good RBAC design for cluster operators.</div><p>Kubernetes <a class="glossary-tooltip" title="Manages authorization decisions, allowing admins to dynamically configure access policies through the Kubernetes API." data-toggle="tooltip" data-placement="top" href="/docs/reference/access-authn-authz/rbac/" target="_blank" aria-label="RBAC">RBAC</a> is a key security control
to ensure that cluster users and workloads have only the access to resources required to
execute their roles. It is important to ensure that, when designing permissions for cluster
users, the cluster administrator understands the areas where privilege escalation could occur,
to reduce the risk of excessive access leading to security incidents.</p><p>The good practices laid out here should be read in conjunction with the general
<a href="/docs/reference/access-authn-authz/rbac/#restrictions-on-role-creation-or-update">RBAC documentation</a>.</p><h2 id="general-good-practice">General good practice</h2><h3 id="least-privilege">Least privilege</h3><p>Ideally, minimal RBAC rights should be assigned to users and service accounts. Only permissions
explicitly required for their operation should be used. While each cluster will be different,
some general rules that can be applied are :</p><ul><li>Assign permissions at the namespace level where possible. Use RoleBindings as opposed to
ClusterRoleBindings to give users rights only within a specific namespace.</li><li>Avoid providing wildcard permissions when possible, especially to all resources.
As Kubernetes is an extensible system, providing wildcard access gives rights
not just to all object types that currently exist in the cluster, but also to all object types
which are created in the future.</li><li>Administrators should not use <code>cluster-admin</code> accounts except where specifically needed.
Providing a low privileged account with
<a href="/docs/reference/access-authn-authz/authentication/#user-impersonation">impersonation rights</a>
can avoid accidental modification of cluster resources.</li><li>Avoid adding users to the <code>system:masters</code> group. Any user who is a member of this group
bypasses all RBAC rights checks and will always have unrestricted superuser access, which cannot be
revoked by removing RoleBindings or ClusterRoleBindings. As an aside, if a cluster is
using an authorization webhook, membership of this group also bypasses that webhook (requests
from users who are members of that group are never sent to the webhook)</li></ul><h3 id="minimize-distribution-of-privileged-tokens">Minimize distribution of privileged tokens</h3><p>Ideally, pods shouldn't be assigned service accounts that have been granted powerful permissions
(for example, any of the rights listed under <a href="#privilege-escalation-risks">privilege escalation risks</a>).
In cases where a workload requires powerful permissions, consider the following practices:</p><ul><li>Limit the number of nodes running powerful pods. Ensure that any DaemonSets you run
are necessary and are run with least privilege to limit the blast radius of container escapes.</li><li>Avoid running powerful pods alongside untrusted or publicly-exposed ones. Consider using
<a href="/docs/concepts/scheduling-eviction/taint-and-toleration/">Taints and Toleration</a>,
<a href="/docs/concepts/scheduling-eviction/assign-pod-node/#node-affinity">NodeAffinity</a>, or
<a href="/docs/concepts/scheduling-eviction/assign-pod-node/#inter-pod-affinity-and-anti-affinity">PodAntiAffinity</a>
to ensure pods don't run alongside untrusted or less-trusted Pods. Pay special attention to
situations where less-trustworthy Pods are not meeting the <strong>Restricted</strong> Pod Security Standard.</li></ul><h3 id="hardening">Hardening</h3><p>Kubernetes defaults to providing access which may not be required in every cluster. Reviewing
the RBAC rights provided by default can provide opportunities for security hardening.
In general, changes should not be made to rights provided to <code>system:</code> accounts some options
to harden cluster rights exist:</p><ul><li>Review bindings for the <code>system:unauthenticated</code> group and remove them where possible, as this gives
access to anyone who can contact the API server at a network level.</li><li>Avoid the default auto-mounting of service account tokens by setting
<code>automountServiceAccountToken: false</code>. For more details, see
<a href="/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server">using default service account token</a>.
Setting this value for a Pod will overwrite the service account setting, workloads
which require service account tokens can still mount them.</li></ul><h3 id="periodic-review">Periodic review</h3><p>It is vital to periodically review the Kubernetes RBAC settings for redundant entries and
possible privilege escalations.
If an attacker is able to create a user account with the same name as a deleted user,
they can automatically inherit all the rights of the deleted user, especially the
rights assigned to that user.</p><h2 id="privilege-escalation-risks">Kubernetes RBAC - privilege escalation risks</h2><p>Within Kubernetes RBAC there are a number of privileges which, if granted, can allow a user or a service account
to escalate their privileges in the cluster or affect systems outside the cluster.</p><p>This section is intended to provide visibility of the areas where cluster operators
should take care, to ensure that they do not inadvertently allow for more access to clusters than intended.</p><h3 id="listing-secrets">Listing secrets</h3><p>It is generally clear that allowing <code>get</code> access on Secrets will allow a user to read their contents.
It is also important to note that <code>list</code> and <code>watch</code> access also effectively allow for users to reveal the Secret contents.
For example, when a List response is returned (for example, via <code>kubectl get secrets -A -o yaml</code>), the response
includes the contents of all Secrets.</p><h3 id="workload-creation">Workload creation</h3><p>Permission to create workloads (either Pods, or
<a href="/docs/concepts/workloads/controllers/">workload resources</a> that manage Pods) in a namespace
implicitly grants access to many other resources in that namespace, such as Secrets, ConfigMaps, and
PersistentVolumes that can be mounted in Pods. Additionally, since Pods can run as any
<a href="/docs/reference/access-authn-authz/service-accounts-admin/">ServiceAccount</a>, granting permission
to create workloads also implicitly grants the API access levels of any service account in that
namespace.</p><p>Users who can run privileged Pods can use that access to gain node access and potentially to
further elevate their privileges. Where you do not fully trust a user or other principal
with the ability to create suitably secure and isolated Pods, you should enforce either the
<strong>Baseline</strong> or <strong>Restricted</strong> Pod Security Standard.
You can use <a href="/docs/concepts/security/pod-security-admission/">Pod Security admission</a>
or other (third party) mechanisms to implement that enforcement.</p><p>For these reasons, namespaces should be used to separate resources requiring different levels of
trust or tenancy. It is still considered best practice to follow <a href="#least-privilege">least privilege</a>
principles and assign the minimum set of permissions, but boundaries within a namespace should be
considered weak.</p><h3 id="persistent-volume-creation">Persistent volume creation</h3><p>If someone - or some application - is allowed to create arbitrary PersistentVolumes, that access
includes the creation of <code>hostPath</code> volumes, which then means that a Pod would get access
to the underlying host filesystem(s) on the associated node. Granting that ability is a security risk.</p><p>There are many ways a container with unrestricted access to the host filesystem can escalate privileges, including
reading data from other containers, and abusing the credentials of system services, such as Kubelet.</p><p>You should only allow access to create PersistentVolume objects for:</p><ul><li>Users (cluster operators) that need this access for their work, and who you trust.</li><li>The Kubernetes control plane components which creates PersistentVolumes based on PersistentVolumeClaims
that are configured for automatic provisioning.
This is usually setup by the Kubernetes provider or by the operator when installing a CSI driver.</li></ul><p>Where access to persistent storage is required trusted administrators should create
PersistentVolumes, and constrained users should use PersistentVolumeClaims to access that storage.</p><h3 id="access-to-proxy-subresource-of-nodes">Access to <code>proxy</code> subresource of Nodes</h3><p>Users with access to the proxy sub-resource of node objects have rights to the Kubelet API,
which allows for command execution on every pod on the node(s) to which they have rights.
This access bypasses audit logging and admission control, so care should be taken before
granting rights to this resource.</p><h3 id="escalate-verb">Escalate verb</h3><p>Generally, the RBAC system prevents users from creating clusterroles with more rights than the user possesses.
The exception to this is the <code>escalate</code> verb. As noted in the <a href="/docs/reference/access-authn-authz/rbac/#restrictions-on-role-creation-or-update">RBAC documentation</a>,
users with this right can effectively escalate their privileges.</p><h3 id="bind-verb">Bind verb</h3><p>Similar to the <code>escalate</code> verb, granting users this right allows for the bypass of Kubernetes
in-built protections against privilege escalation, allowing users to create bindings to
roles with rights they do not already have.</p><h3 id="impersonate-verb">Impersonate verb</h3><p>This verb allows users to impersonate and gain the rights of other users in the cluster.
Care should be taken when granting it, to ensure that excessive permissions cannot be gained
via one of the impersonated accounts.</p><h3 id="csrs-and-certificate-issuing">CSRs and certificate issuing</h3><p>The CSR API allows for users with <code>create</code> rights to CSRs and <code>update</code> rights on <code>certificatesigningrequests/approval</code>
where the signer is <code>kubernetes.io/kube-apiserver-client</code> to create new client certificates
which allow users to authenticate to the cluster. Those client certificates can have arbitrary
names including duplicates of Kubernetes system components. This will effectively allow for privilege escalation.</p><h3 id="token-request">Token request</h3><p>Users with <code>create</code> rights on <code>serviceaccounts/token</code> can create TokenRequests to issue
tokens for existing service accounts.</p><h3 id="control-admission-webhooks">Control admission webhooks</h3><p>Users with control over <code>validatingwebhookconfigurations</code> or <code>mutatingwebhookconfigurations</code>
can control webhooks that can read any object admitted to the cluster, and in the case of
mutating webhooks, also mutate admitted objects.</p><h3 id="namespace-modification">Namespace modification</h3><p>Users who can perform <strong>patch</strong> operations on Namespace objects (through a namespaced RoleBinding to a Role with that access) can modify
labels on that namespace. In clusters where Pod Security Admission is used, this may allow a user to configure the namespace
for a more permissive policy than intended by the administrators.
For clusters where NetworkPolicy is used, users may be set labels that indirectly allow
access to services that an administrator did not intend to allow.</p><h2 id="denial-of-service-risks">Kubernetes RBAC - denial of service risks</h2><h3 id="object-creation-dos">Object creation denial-of-service</h3><p>Users who have rights to create objects in a cluster may be able to create sufficient large
objects to create a denial of service condition either based on the size or number of objects, as discussed in
<a href="https://github.com/kubernetes/kubernetes/issues/107325">etcd used by Kubernetes is vulnerable to OOM attack</a>. This may be
specifically relevant in multi-tenant clusters if semi-trusted or untrusted users
are allowed limited access to a system.</p><p>One option for mitigation of this issue would be to use
<a href="/docs/concepts/policy/resource-quotas/#object-count-quota">resource quotas</a>
to limit the quantity of objects which can be created.</p><h2 id="what-s-next">What's next</h2><ul><li>To learn more about RBAC, see the <a href="/docs/reference/access-authn-authz/rbac/">RBAC documentation</a>.</li></ul></div>