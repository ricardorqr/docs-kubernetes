<div class="td-content"><h1 data-pagefind-weight="10">Windows containers in Kubernetes</h1><p>Windows applications constitute a large portion of the services and applications that
run in many organizations. <a href="https://aka.ms/windowscontainers">Windows containers</a>
provide a way to encapsulate processes and package dependencies, making it easier
to use DevOps practices and follow cloud native patterns for Windows applications.</p><p>Organizations with investments in Windows-based applications and Linux-based
applications don't have to look for separate orchestrators to manage their workloads,
leading to increased operational efficiencies across their deployments, regardless
of operating system.</p><h2 id="windows-nodes-in-kubernetes">Windows nodes in Kubernetes</h2><p>To enable the orchestration of Windows containers in Kubernetes, include Windows nodes
in your existing Linux cluster. Scheduling Windows containers in
<a class="glossary-tooltip" title="A Pod represents a set of running containers in your cluster." data-toggle="tooltip" data-placement="top" href="/docs/concepts/workloads/pods/" target="_blank" aria-label="Pods">Pods</a> on Kubernetes is similar to
scheduling Linux-based containers.</p><p>In order to run Windows containers, your Kubernetes cluster must include
multiple operating systems.
While you can only run the <a class="glossary-tooltip" title="The container orchestration layer that exposes the API and interfaces to define, deploy, and manage the lifecycle of containers." data-toggle="tooltip" data-placement="top" href="/docs/reference/glossary/?all=true#term-control-plane" target="_blank" aria-label="control plane">control plane</a> on Linux,
you can deploy worker nodes running either Windows or Linux.</p><p>Windows <a class="glossary-tooltip" title="A node is a worker machine in Kubernetes." data-toggle="tooltip" data-placement="top" href="/docs/concepts/architecture/nodes/" target="_blank" aria-label="nodes">nodes</a> are
<a href="#windows-os-version-support">supported</a> provided that the operating system is
Windows Server 2019 or Windows Server 2022.</p><p>This document uses the term <em>Windows containers</em> to mean Windows containers with
process isolation. Kubernetes does not support running Windows containers with
<a href="https://docs.microsoft.com/en-us/virtualization/windowscontainers/manage-containers/hyperv-container">Hyper-V isolation</a>.</p><h2 id="limitations">Compatibility and limitations</h2><p>Some node features are only available if you use a specific
<a href="#container-runtime">container runtime</a>; others are not available on Windows nodes,
including:</p><ul><li>HugePages: not supported for Windows containers</li><li>Privileged containers: not supported for Windows containers.
<a href="/docs/tasks/configure-pod-container/create-hostprocess-pod/">HostProcess Containers</a> offer similar functionality.</li><li>TerminationGracePeriod: requires containerD</li></ul><p>Not all features of shared namespaces are supported. See <a href="#api">API compatibility</a>
for more details.</p><p>See <a href="#windows-os-version-support">Windows OS version compatibility</a> for details on
the Windows versions that Kubernetes is tested against.</p><p>From an API and kubectl perspective, Windows containers behave in much the same
way as Linux-based containers. However, there are some notable differences in key
functionality which are outlined in this section.</p><h3 id="compatibility-linux-similarities">Comparison with Linux</h3><p>Key Kubernetes elements work the same way in Windows as they do in Linux. This
section refers to several key workload abstractions and how they map to Windows.</p><ul><li><p><a href="/docs/concepts/workloads/pods/">Pods</a></p><p>A Pod is the basic building block of Kubernetes–the smallest and simplest unit in
the Kubernetes object model that you create or deploy. You may not deploy Windows and
Linux containers in the same Pod. All containers in a Pod are scheduled onto a single
Node where each Node represents a specific platform and architecture. The following
Pod capabilities, properties and events are supported with Windows containers:</p><ul><li><p>Single or multiple containers per Pod with process isolation and volume sharing</p></li><li><p>Pod <code>status</code> fields</p></li><li><p>Readiness, liveness, and startup probes</p></li><li><p>postStart &amp; preStop container lifecycle hooks</p></li><li><p>ConfigMap, Secrets: as environment variables or volumes</p></li><li><p><code>emptyDir</code> volumes</p></li><li><p>Named pipe host mounts</p></li><li><p>Resource limits</p></li><li><p>OS field:</p><p>The <code>.spec.os.name</code> field should be set to <code>windows</code> to indicate that the current Pod uses Windows containers.</p><p>If you set the <code>.spec.os.name</code> field to <code>windows</code>,
you must not set the following fields in the <code>.spec</code> of that Pod:</p><ul><li><code>spec.hostPID</code></li><li><code>spec.hostIPC</code></li><li><code>spec.securityContext.seLinuxOptions</code></li><li><code>spec.securityContext.seccompProfile</code></li><li><code>spec.securityContext.fsGroup</code></li><li><code>spec.securityContext.fsGroupChangePolicy</code></li><li><code>spec.securityContext.sysctls</code></li><li><code>spec.shareProcessNamespace</code></li><li><code>spec.securityContext.runAsUser</code></li><li><code>spec.securityContext.runAsGroup</code></li><li><code>spec.securityContext.supplementalGroups</code></li><li><code>spec.containers[*].securityContext.seLinuxOptions</code></li><li><code>spec.containers[*].securityContext.seccompProfile</code></li><li><code>spec.containers[*].securityContext.capabilities</code></li><li><code>spec.containers[*].securityContext.readOnlyRootFilesystem</code></li><li><code>spec.containers[*].securityContext.privileged</code></li><li><code>spec.containers[*].securityContext.allowPrivilegeEscalation</code></li><li><code>spec.containers[*].securityContext.procMount</code></li><li><code>spec.containers[*].securityContext.runAsUser</code></li><li><code>spec.containers[*].securityContext.runAsGroup</code></li></ul><p>In the above list, wildcards (<code>*</code>) indicate all elements in a list.
For example, <code>spec.containers[*].securityContext</code> refers to the SecurityContext object
for all containers. If any of these fields is specified, the Pod will
not be admitted by the API server.</p></li></ul></li><li><p><a href="/docs/concepts/workloads/controllers/">Workload resources</a> including:</p><ul><li>ReplicaSet</li><li>Deployment</li><li>StatefulSet</li><li>DaemonSet</li><li>Job</li><li>CronJob</li><li>ReplicationController</li></ul></li><li><p><a class="glossary-tooltip" title="A way to expose an application running on a set of Pods as a network service." data-toggle="tooltip" data-placement="top" href="/docs/concepts/services-networking/service/" target="_blank" aria-label="Services">Services</a>
See <a href="/docs/concepts/services-networking/windows-networking/#load-balancing-and-services">Load balancing and Services</a> for more details.</p></li></ul><p>Pods, workload resources, and Services are critical elements to managing Windows
workloads on Kubernetes. However, on their own they are not enough to enable
the proper lifecycle management of Windows workloads in a dynamic cloud native
environment.</p><ul><li><code>kubectl exec</code></li><li>Pod and container metrics</li><li><a class="glossary-tooltip" title="Object that automatically scales the number of pod replicas based on targeted resource utilization or custom metric targets." data-toggle="tooltip" data-placement="top" href="/docs/tasks/run-application/horizontal-pod-autoscale/" target="_blank" aria-label="Horizontal pod autoscaling">Horizontal pod autoscaling</a></li><li><a class="glossary-tooltip" title="Provides constraints that limit aggregate resource consumption per namespace." data-toggle="tooltip" data-placement="top" href="/docs/concepts/policy/resource-quotas/" target="_blank" aria-label="Resource quotas">Resource quotas</a></li><li>Scheduler preemption</li></ul><h3 id="kubelet-compatibility">Command line options for the kubelet</h3><p>Some kubelet command line options behave differently on Windows, as described below:</p><ul><li>The <code>--windows-priorityclass</code> lets you set the scheduling priority of the kubelet process
(see <a href="/docs/concepts/configuration/windows-resource-management/#resource-management-cpu">CPU resource management</a>)</li><li>The <code>--kube-reserved</code>, <code>--system-reserved</code> , and <code>--eviction-hard</code> flags update
<a href="/docs/tasks/administer-cluster/reserve-compute-resources/#node-allocatable">NodeAllocatable</a></li><li>Eviction by using <code>--enforce-node-allocable</code> is not implemented</li><li>When running on a Windows node the kubelet does not have memory or CPU
restrictions. <code>--kube-reserved</code> and <code>--system-reserved</code> only subtract from <code>NodeAllocatable</code>
and do not guarantee resource provided for workloads.
See <a href="/docs/concepts/configuration/windows-resource-management/#resource-reservation">Resource Management for Windows nodes</a>
for more information.</li><li>The <code>PIDPressure</code> Condition is not implemented</li><li>The kubelet does not take OOM eviction actions</li></ul><h3 id="api">API compatibility</h3><p>There are subtle differences in the way the Kubernetes APIs work for Windows due to the OS
and container runtime. Some workload properties were designed for Linux, and fail to run on Windows.</p><p>At a high level, these OS concepts are different:</p><ul><li>Identity - Linux uses userID (UID) and groupID (GID) which
are represented as integer types. User and group names
are not canonical - they are just an alias in <code>/etc/groups</code>
or <code>/etc/passwd</code> back to UID+GID. Windows uses a larger binary
<a href="https://docs.microsoft.com/en-us/windows/security/identity-protection/access-control/security-identifiers">security identifier</a> (SID)
which is stored in the Windows Security Access Manager (SAM) database. This
database is not shared between the host and containers, or between containers.</li><li>File permissions - Windows uses an access control list based on (SIDs), whereas
POSIX systems such as Linux use a bitmask based on object permissions and UID+GID,
plus <em>optional</em> access control lists.</li><li>File paths - the convention on Windows is to use <code>\</code> instead of <code>/</code>. The Go IO
libraries typically accept both and just make it work, but when you're setting a
path or command line that's interpreted inside a container, <code>\</code> may be needed.</li><li>Signals - Windows interactive apps handle termination differently, and can
implement one or more of these:<ul><li>A UI thread handles well-defined messages including <code>WM_CLOSE</code>.</li><li>Console apps handle Ctrl-C or Ctrl-break using a Control Handler.</li><li>Services register a Service Control Handler function that can accept
<code>SERVICE_CONTROL_STOP</code> control codes.</li></ul></li></ul><p>Container exit codes follow the same convention where 0 is success, and nonzero is failure.
The specific error codes may differ across Windows and Linux. However, exit codes
passed from the Kubernetes components (kubelet, kube-proxy) are unchanged.</p><h4 id="compatibility-v1-pod-spec-containers">Field compatibility for container specifications</h4><p>The following list documents differences between how Pod container specifications
work between Windows and Linux:</p><ul><li>Huge pages are not implemented in the Windows container
runtime, and are not available. They require <a href="https://docs.microsoft.com/en-us/windows/desktop/Memory/large-page-support">asserting a user
privilege</a>
that's not configurable for containers.</li><li><code>requests.cpu</code> and <code>requests.memory</code> - requests are subtracted
from node available resources, so they can be used to avoid overprovisioning a
node. However, they cannot be used to guarantee resources in an overprovisioned
node. They should be applied to all containers as a best practice if the operator
wants to avoid overprovisioning entirely.</li><li><code>securityContext.allowPrivilegeEscalation</code> -
not possible on Windows; none of the capabilities are hooked up</li><li><code>securityContext.capabilities</code> -
POSIX capabilities are not implemented on Windows</li><li><code>securityContext.privileged</code> -
Windows doesn't support privileged containers, use <a href="/docs/tasks/configure-pod-container/create-hostprocess-pod/">HostProcess Containers</a> instead</li><li><code>securityContext.procMount</code> -
Windows doesn't have a <code>/proc</code> filesystem</li><li><code>securityContext.readOnlyRootFilesystem</code> -
not possible on Windows; write access is required for registry &amp; system
processes to run inside the container</li><li><code>securityContext.runAsGroup</code> -
not possible on Windows as there is no GID support</li><li><code>securityContext.runAsNonRoot</code> -
this setting will prevent containers from running as <code>ContainerAdministrator</code>
which is the closest equivalent to a root user on Windows.</li><li><code>securityContext.runAsUser</code> -
use <a href="/docs/tasks/configure-pod-container/configure-runasusername/"><code>runAsUserName</code></a>
instead</li><li><code>securityContext.seLinuxOptions</code> -
not possible on Windows as SELinux is Linux-specific</li><li><code>terminationMessagePath</code> -
this has some limitations in that Windows doesn't support mapping single files. The
default value is <code>/dev/termination-log</code>, which does work because it does not
exist on Windows by default.</li></ul><h4 id="compatibility-v1-pod">Field compatibility for Pod specifications</h4><p>The following list documents differences between how Pod specifications work between Windows and Linux:</p><ul><li><code>hostIPC</code> and <code>hostpid</code> - host namespace sharing is not possible on Windows</li><li><code>hostNetwork</code> - host networking is not possible on Windows</li><li><code>dnsPolicy</code> - setting the Pod <code>dnsPolicy</code> to <code>ClusterFirstWithHostNet</code> is
not supported on Windows because host networking is not provided. Pods always
run with a container network.</li><li><code>podSecurityContext</code> <a href="#compatibility-v1-pod-spec-containers-securitycontext">see below</a></li><li><code>shareProcessNamespace</code> - this is a beta feature, and depends on Linux namespaces
which are not implemented on Windows. Windows cannot share process namespaces or
the container's root filesystem. Only the network can be shared.</li><li><code>terminationGracePeriodSeconds</code> - this is not fully implemented in Docker on Windows,
see the <a href="https://github.com/moby/moby/issues/25982">GitHub issue</a>.
The behavior today is that the ENTRYPOINT process is sent CTRL_SHUTDOWN_EVENT,
then Windows waits 5 seconds by default, and finally shuts down
all processes using the normal Windows shutdown behavior. The 5
second default is actually in the Windows registry
<a href="https://github.com/moby/moby/issues/25982#issuecomment-426441183">inside the container</a>,
so it can be overridden when the container is built.</li><li><code>volumeDevices</code> - this is a beta feature, and is not implemented on Windows.
Windows cannot attach raw block devices to pods.</li><li><code>volumes</code><ul><li>If you define an <code>emptyDir</code> volume, you cannot set its volume source to <code>memory</code>.</li></ul></li><li>You cannot enable <code>mountPropagation</code> for volume mounts as this is not
supported on Windows.</li></ul><h4 id="compatibility-v1-pod-sec-containers-hostnetwork">Host network access</h4><p>Kubernetes v1.26 to v1.32 included alpha support for running Windows Pods in the host's network namespace.</p><p>Kubernetes v1.34 does <strong>not</strong> include the <code>WindowsHostNetwork</code> feature gate
or support for running Windows Pods in the host's network namespace.</p><h4 id="compatibility-v1-pod-spec-containers-securitycontext">Field compatibility for Pod security context</h4><p>Only the <code>securityContext.runAsNonRoot</code> and <code>securityContext.windowsOptions</code> from the Pod
<a href="/docs/reference/kubernetes-api/workload-resources/pod-v1/#security-context"><code>securityContext</code></a> fields work on Windows.</p><h2 id="node-problem-detector">Node problem detector</h2><p>The node problem detector (see
<a href="/docs/tasks/debug/debug-cluster/monitor-node-health/">Monitor Node Health</a>)
has preliminary support for Windows.
For more information, visit the project's <a href="https://github.com/kubernetes/node-problem-detector#windows">GitHub page</a>.</p><h2 id="pause-container">Pause container</h2><p>In a Kubernetes Pod, an infrastructure or “pause” container is first created
to host the container. In Linux, the cgroups and namespaces that make up a pod
need a process to maintain their continued existence; the pause process provides
this. Containers that belong to the same pod, including infrastructure and worker
containers, share a common network endpoint (same IPv4 and / or IPv6 address, same
network port spaces). Kubernetes uses pause containers to allow for worker containers
crashing or restarting without losing any of the networking configuration.</p><p>Kubernetes maintains a multi-architecture image that includes support for Windows.
For Kubernetes v1.34.0 the recommended pause image is <code>registry.k8s.io/pause:3.6</code>.
The <a href="https://github.com/kubernetes/kubernetes/tree/master/build/pause">source code</a>
is available on GitHub.</p><p>Microsoft maintains a different multi-architecture image, with Linux and Windows
amd64 support, that you can find as <code>mcr.microsoft.com/oss/kubernetes/pause:3.6</code>.
This image is built from the same source as the Kubernetes maintained image but
all of the Windows binaries are <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/install/authenticode">authenticode signed</a> by Microsoft.
The Kubernetes project recommends using the Microsoft maintained image if you are
deploying to a production or production-like environment that requires signed
binaries.</p><h2 id="container-runtime">Container runtimes</h2><p>You need to install a
<a class="glossary-tooltip" title="The container runtime is the software that is responsible for running containers." data-toggle="tooltip" data-placement="top" href="/docs/setup/production-environment/container-runtimes" target="_blank" aria-label="container runtime">container runtime</a>
into each node in the cluster so that Pods can run there.</p><p>The following container runtimes work with Windows:</p><div class="alert alert-secondary callout third-party-content" role="alert"><strong>Note:</strong> This section links to third party projects that provide functionality required by Kubernetes. The Kubernetes project authors aren't responsible for these projects, which are listed alphabetically. To add a project to this list, read the <a href="/docs/contribute/style/content-guide/#third-party-content">content guide</a> before submitting a change. <a href="#third-party-content-disclaimer">More information.</a></div><h3 id="containerd">ContainerD</h3><div class="feature-state-notice feature-stable"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.20 [stable]</code></div><p>You can use <a class="glossary-tooltip" title="A container runtime with an emphasis on simplicity, robustness and portability" data-toggle="tooltip" data-placement="top" href="https://containerd.io/docs/" target="_blank" aria-label="ContainerD">ContainerD</a> 1.4.0+
as the container runtime for Kubernetes nodes that run Windows.</p><p>Learn how to <a href="/docs/setup/production-environment/container-runtimes/#containerd">install ContainerD on a Windows node</a>.<div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>There is a <a href="/docs/tasks/configure-pod-container/configure-gmsa/#gmsa-limitations">known limitation</a>
when using GMSA with containerd to access Windows network shares, which requires a
kernel patch.</div></p><h3 id="mcr">Mirantis Container Runtime</h3><p><a href="https://docs.mirantis.com/mcr/25.0/overview.html">Mirantis Container Runtime</a> (MCR)
is available as a container runtime for all Windows Server 2019 and later versions.</p><p>See <a href="https://docs.mirantis.com/mcr/25.0/install/mcr-windows.html">Install MCR on Windows Servers</a> for more information.</p><h2 id="windows-os-version-support">Windows OS version compatibility</h2><p>On Windows nodes, strict compatibility rules apply where the host OS version must
match the container base image OS version. Only Windows containers with a container
operating system of Windows Server 2019 are fully supported.</p><p>For Kubernetes v1.34, operating system compatibility for Windows nodes (and Pods)
is as follows:</p><dl><dt>Windows Server LTSC release</dt><dd>Windows Server 2019</dd><dd>Windows Server 2022</dd><dt>Windows Server SAC release</dt><dd>Windows Server version 20H2</dd></dl><p>The Kubernetes <a href="/docs/setup/release/version-skew-policy/">version-skew policy</a> also applies.</p><h2 id="windows-hardware-recommendations">Hardware recommendations and considerations</h2><div class="alert alert-secondary callout third-party-content" role="alert"><strong>Note:</strong> This section links to third party projects that provide functionality required by Kubernetes. The Kubernetes project authors aren't responsible for these projects, which are listed alphabetically. To add a project to this list, read the <a href="/docs/contribute/style/content-guide/#third-party-content">content guide</a> before submitting a change. <a href="#third-party-content-disclaimer">More information.</a></div><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>The following hardware specifications outlined here should be regarded as sensible default values.
They are not intended to represent minimum requirements or specific recommendations for production environments.
Depending on the requirements for your workload these values may need to be adjusted.</div><ul><li>64-bit processor 4 CPU cores or more, capable of supporting virtualization</li><li>8GB or more of RAM</li><li>50GB or more of free disk space</li></ul><p>Refer to
<a href="https://learn.microsoft.com/en-us/windows-server/get-started/hardware-requirements">Hardware requirements for Windows Server Microsoft documentation</a>
for the most up-to-date information on minimum hardware requirements. For guidance on deciding on resources for
production worker nodes refer to <a href="/docs/setup/production-environment/#production-worker-nodes">Production worker nodes Kubernetes documentation</a>.</p><p>To optimize system resources, if a graphical user interface is not required,
it may be preferable to use a Windows Server OS installation that excludes
the <a href="https://learn.microsoft.com/en-us/windows-server/get-started/install-options-server-core-desktop-experience">Windows Desktop Experience</a>
installation option, as this configuration typically frees up more system
resources.</p><p>In assessing disk space for Windows worker nodes, take note that Windows container images are typically larger than
Linux container images, with container image sizes ranging
from <a href="https://techcommunity.microsoft.com/t5/containers/nano-server-x-server-core-x-server-which-base-image-is-the-right/ba-p/2835785">300MB to over 10GB</a>
for a single image. Additionally, take note that the <code>C:</code> drive in Windows containers represents a virtual free size of
20GB by default, which is not the actual consumed space, but rather the disk size for which a single container can grow
to occupy when using local storage on the host.
See <a href="https://learn.microsoft.com/en-us/virtualization/windowscontainers/manage-containers/container-storage#storage-limits">Containers on Windows - Container Storage Documentation</a>
for more detail.</p><h2 id="troubleshooting">Getting help and troubleshooting</h2><p>Your main source of help for troubleshooting your Kubernetes cluster should start
with the <a href="/docs/tasks/debug/">Troubleshooting</a>
page.</p><p>Some additional, Windows-specific troubleshooting help is included
in this section. Logs are an important element of troubleshooting
issues in Kubernetes. Make sure to include them any time you seek
troubleshooting assistance from other contributors. Follow the
instructions in the
SIG Windows <a href="https://github.com/kubernetes/community/blob/master/sig-windows/CONTRIBUTING.md#gathering-logs">contributing guide on gathering logs</a>.</p><h3 id="reporting-issues-and-feature-requests">Reporting issues and feature requests</h3><p>If you have what looks like a bug, or you would like to
make a feature request, please follow the <a href="https://github.com/kubernetes/community/blob/master/sig-windows/CONTRIBUTING.md#reporting-issues-and-feature-requests">SIG Windows contributing guide</a> to create a new issue.
You should first search the list of issues in case it was
reported previously and comment with your experience on the issue and add additional
logs. SIG Windows channel on the Kubernetes Slack is also a great avenue to get some initial support and
troubleshooting ideas prior to creating a ticket.</p><h3 id="validating-the-windows-cluster-operability">Validating the Windows cluster operability</h3><p>The Kubernetes project provides a <em>Windows Operational Readiness</em> specification,
accompanied by a structured test suite. This suite is split into two sets of tests,
core and extended, each containing categories aimed at testing specific areas.
It can be used to validate all the functionalities of a Windows and hybrid system
(mixed with Linux nodes) with full coverage.</p><p>To set up the project on a newly created cluster, refer to the instructions in the
<a href="https://github.com/kubernetes-sigs/windows-operational-readiness/blob/main/README.md">project guide</a>.</p><h2 id="deployment-tools">Deployment tools</h2><p>The kubeadm tool helps you to deploy a Kubernetes cluster, providing the control
plane to manage the cluster it, and nodes to run your workloads.</p><p>The Kubernetes <a href="https://cluster-api.sigs.k8s.io/">cluster API</a> project also provides means to automate deployment of Windows nodes.</p><h2 id="windows-distribution-channels">Windows distribution channels</h2><p>For a detailed explanation of Windows distribution channels see the
<a href="https://docs.microsoft.com/en-us/windows-server/get-started-19/servicing-channels-19">Microsoft documentation</a>.</p><p>Information on the different Windows Server servicing channels
including their support models can be found at
<a href="https://docs.microsoft.com/en-us/windows-server/get-started/servicing-channels-comparison">Windows Server servicing channels</a>.</p></div>