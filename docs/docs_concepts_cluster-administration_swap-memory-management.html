<div class="td-content"><h1 data-pagefind-weight="10">Swap memory management</h1><p>Kubernetes can be configured to use swap memory on a <a class="glossary-tooltip" title="A node is a worker machine in Kubernetes." data-toggle="tooltip" data-placement="top" href="/docs/concepts/architecture/nodes/" target="_blank" aria-label="node">node</a>,
allowing the kernel to free up physical memory by swapping out pages to backing storage.
This is useful for multiple use-cases.
For example, nodes running workloads that can benefit from using swap,
such as those that have large memory footprints but only access a portion of that memory at any given time.
It also helps prevent Pods from being terminated during memory pressure spikes,
shields nodes from system-level memory spikes that might compromise its stability,
allows for more flexible memory management on the node, and much more.</p><p>To learn about configuring swap in your cluster, read
<a href="/docs/tutorials/cluster-management/provision-swap-memory/">Configuring swap memory on Kubernetes nodes</a>.</p><h2 id="operating-system-support">Operating system support</h2><ul><li>Linux nodes support swap; you need to configure each node to enable it.
By default, the kubelet will <strong>not</strong> start on a Linux node that has swap enabled.</li><li>Windows nodes require swap space.
By default, the kubelet does <strong>not</strong> start on a Windows node that has swap disabled.</li></ul><h2 id="how-does-it-work">How does it work?</h2><p>There are a number of possible ways that one could envision swap use on a node.
If kubelet is already running on a node, it would need to be restarted after swap is provisioned in order to identify it.</p><p>When kubelet starts on a node in which swap is provisioned and available
(with the <code>failSwapOn: false</code> configuration), kubelet will:</p><ul><li>Be able to start on this swap-enabled node.</li><li>Direct the Container Runtime Interface (CRI) implementation, often referred to as the container runtime,
to allocate zero swap memory to Kubernetes workloads by default.</li></ul><p>Swap configuration on a node is exposed to a cluster admin via the
<a href="/docs/reference/config-api/kubelet-config.v1/"><code>memorySwap</code> in the KubeletConfiguration</a>.
As a cluster administrator, you can specify the node's behaviour in the
presence of swap memory by setting <code>memorySwap.swapBehavior</code>.</p><h3 id="swap-behaviors">Swap behaviors</h3><p>You need to pick a <a href="/docs/reference/node/swap-behavior/">swap behavior</a> to
use. Different nodes in your cluster can use different swap behaviors.</p><p>The swap behaviors you can choose for Linux nodes are:</p><dl><dt><code>NoSwap</code> (default)</dt><dd>Workloads running as Pods on this node do not and cannot use swap.</dd><dt><code>LimitedSwap</code></dt><dd>Kubernetes workloads can utilize swap memory.</dd></dl><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4><p>If you choose the NoSwap behavior, and you configure the kubelet to tolerate
swap space (<code>failSwapOn: false</code>), then your workloads don't use any swap.</p><p>However, processes outside of Kubernetes-managed containers, such as systemi
services (and even the kubelet itself!) <strong>can</strong> utilize swap.</p></div><p>You can read <a href="/docs/tutorials/cluster-management/provision-swap-memory/">configuring swap memory on Kubernetes nodes</a> to learn about enabling swap for your cluster.</p><h3 id="container-runtime-integration">Container runtime integration</h3><p>The kubelet uses the container runtime API, and directs the container runtime to
apply specific configuration (for example, in the cgroup v2 case, <code>memory.swap.max</code>) in a manner that will
enable the desired swap configuration for a container. For runtimes that use control groups, or cgroups,
the container runtime is then responsible for writing these settings to the container-level cgroup.</p><h2 id="observability-for-swap-use">Observability for swap use</h2><h3 id="node-and-container-level-metric-statistics">Node and container level metric statistics</h3><p>Kubelet now collects node and container level metric statistics,
which can be accessed at the <code>/metrics/resource</code> (which is used mainly by monitoring
tools like Prometheus) and <code>/stats/summary</code> (which is used mainly by Autoscalers) kubelet HTTP endpoints.
This allows clients who can directly request the kubelet to
monitor swap usage and remaining swap memory when using <code>LimitedSwap</code>.
Additionally, a <code>machine_swap_bytes</code> metric has been added to cadvisor to show
the total physical swap capacity of the machine.
See <a href="/docs/reference/instrumentation/node-metrics/">this page</a> for more info.</p><p>For example, these <code>/metrics/resource</code> are supported:</p><ul><li><code>node_swap_usage_bytes</code>: Current swap usage of the node in bytes.</li><li><code>container_swap_usage_bytes</code>: Current amount of the container swap usage in bytes.</li><li><code>container_swap_limit_bytes</code>: Current amount of the container swap limit in bytes.</li></ul><h3 id="using-kubectl-top-show-swap">Using <code>kubectl top --show-swap</code></h3><p>Querying metrics is valuable, but somewhat cumbersome, as these metrics
are designed to be used by software rather than humans.
In order to consume this data in a more user-friendly way,
the <code>kubectl top</code> command has been extended to support swap metrics, using the <code>--show-swap</code> flag.</p><p>In order to receive information about swap usage on nodes, <code>kubectl top nodes --show-swap</code> can be used:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl top nodes --show-swap
</span></span></code></pre></div><p>This will result in an output similar to:</p><pre tabindex="0"><code>NAME    CPU(cores)   CPU(%)   MEMORY(bytes)   MEMORY(%)   SWAP(bytes)    SWAP(%)       
node1   1m           10%      2Mi             10%         1Mi            0%   
node2   5m           10%      6Mi             10%         2Mi            0%   
node3   3m           10%      4Mi             10%         &lt;unknown&gt;      &lt;unknown&gt;   
</code></pre><p>In order to receive information about swap usage by pods, <code>kubectl top nodes --show-swap</code> can be used:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl top pod -n kube-system --show-swap
</span></span></code></pre></div><p>This will result in an output similar to:</p><pre tabindex="0"><code>NAME                                      CPU(cores)   MEMORY(bytes)   SWAP(bytes)
coredns-58d5bc5cdb-5nbk4                  2m           19Mi            0Mi
coredns-58d5bc5cdb-jsh26                  3m           37Mi            0Mi
etcd-node01                               51m          143Mi           5Mi
kube-apiserver-node01                     98m          824Mi           16Mi
kube-controller-manager-node01            20m          135Mi           9Mi
kube-proxy-ffgs2                          1m           24Mi            0Mi
kube-proxy-fhvwx                          1m           39Mi            0Mi
kube-scheduler-node01                     13m          69Mi            0Mi
metrics-server-8598789fdb-d2kcj           5m           26Mi            0Mi   
</code></pre><h3 id="nodes-to-report-swap-capacity-as-part-of-node-status">Nodes to report swap capacity as part of node status</h3><p>A new node status field is now added, <code>node.status.nodeInfo.swap.capacity</code>, to report the swap capacity of a node.</p><p>As an example, the following command can be used to retrieve the swap capacity of the nodes in a cluster:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl get nodes -o go-template<span style="color:#666">=</span><span style="color:#b44">'{{range .items}}{{.metadata.name}}: {{if .status.nodeInfo.swap.capacity}}{{.status.nodeInfo.swap.capacity}}{{else}}&lt;unknown&gt;{{end}}{{"\n"}}{{end}}'</span>
</span></span></code></pre></div><p>This will result in an output similar to:</p><pre tabindex="0"><code>node1: 21474836480
node2: 42949664768
node3: &lt;unknown&gt;
</code></pre><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>The <code>&lt;unknown&gt;</code> value indicates that the <code>.status.nodeInfo.swap.capacity</code> field is not set for that Node.
This probably means that the node does not have swap provisioned, or less likely,
that the kubelet is not able to determine the swap capacity of the node.</div><h3 id="node-feature-discovery">Swap discovery using Node Feature Discovery (NFD)</h3><p><a href="https://github.com/kubernetes-sigs/node-feature-discovery">Node Feature Discovery</a>
is a Kubernetes addon for detecting hardware features and configuration.
It can be utilized to discover which nodes are provisioned with swap.</p><p>As an example, to figure out which nodes are provisioned with swap,
use the following command:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl get nodes -o <span style="color:#b8860b">jsonpath</span><span style="color:#666">=</span><span style="color:#b44">'{range .items[?(@.metadata.labels.feature\.node\.kubernetes\.io/memory-swap)]}{.metadata.name}{"\t"}{.metadata.labels.feature\.node\.kubernetes\.io/memory-swap}{"\n"}{end}'</span>
</span></span></code></pre></div><p>This will result in an output similar to:</p><pre tabindex="0"><code>k8s-worker1: true
k8s-worker2: true
k8s-worker3: false
</code></pre><p>In this example, swap is provisioned on nodes <code>k8s-worker1</code> and <code>k8s-worker2</code>, but not on <code>k8s-worker3</code>.</p><h2 id="risks-and-caveats">Risks and caveats</h2><div class="alert alert-caution" role="alert"><h4 class="alert-heading">Caution:</h4>It is deeply encouraged to encrypt the swap space.
See Memory-backed volumes <a href="#memory-backed-volumes">memory-backed volumes</a> for more info.</div><p>Having swap available on a system reduces predictability.
While swap can enhance performance by making more RAM available, swapping data
back to memory is a heavy operation, sometimes slower by many orders of magnitude,
which can cause unexpected performance regressions.
Furthermore, swap changes a system's behaviour under memory pressure.
Enabling swap increases the risk of noisy neighbors,
where Pods that frequently use their RAM may cause other Pods to swap.
In addition, since swap allows for greater memory usage for workloads in Kubernetes that cannot be predictably accounted for,
and due to unexpected packing configurations,
the scheduler currently does not account for swap memory usage.
This heightens the risk of noisy neighbors.</p><p>The performance of a node with swap memory enabled depends on the underlying physical storage.
When swap memory is in use, performance will be significantly worse in an I/O
operations per second (IOPS) constrained environment, such as a cloud VM with
I/O throttling, when compared to faster storage mediums like solid-state drives
or NVMe.
As swap might cause IO pressure, it is recommended to give a higher IO latency
priority to system critical daemons. See the relevant section in the
<a href="#good-practice-for-using-swap-in-a-kubernetes-cluster">recommended practices</a> section below.</p><h3 id="memory-backed-volumes">Memory-backed volumes</h3><p>On Linux nodes, memory-backed volumes (such as <a href="/docs/concepts/configuration/secret/"><code>secret</code></a>
volume mounts, or <a href="/docs/concepts/storage/volumes/#emptydir"><code>emptyDir</code></a> with <code>medium: Memory</code>)
are implemented with a <code>tmpfs</code> filesystem.
The contents of such volumes should remain in memory at all times, hence should
not be swapped to disk.
To ensure the contents of such volumes remain in memory, the <code>noswap</code> tmpfs option
is being used.</p><p>The Linux kernel officially supports the <code>noswap</code> option from version 6.3 (more info
can be found in <a href="/docs/reference/node/kernel-version-requirements/#requirements-other">Linux Kernel Version Requirements</a>).
However, the different distributions often choose to backport this mount option to older
Linux versions as well.</p><p>In order to verify whether the node supports the <code>noswap</code> option, the kubelet will do the following:</p><ul><li>If the kernel's version is above 6.3 then the <code>noswap</code> option will be assumed to be supported.</li><li>Otherwise, kubelet would try to mount a dummy tmpfs with the <code>noswap</code> option at startup.
If kubelet fails with an error indicating of an unknown option, <code>noswap</code> will be assumed
to not be supported, hence will not be used.
A kubelet log entry will be emitted to warn the user about memory-backed volumes might swap to disk.
If kubelet succeeds, the dummy tmpfs will be deleted and the <code>noswap</code> option will be used.<ul><li>If the <code>noswap</code> option is not supported, kubelet will emit a warning log entry,
then continue its execution.</li></ul></li></ul><p>See the <a href="#setting-up-encrypted-swap">section above</a> with an example for setting unencrypted swap.
However, handling encrypted swap is not within the scope of kubelet;
rather, it is a general OS configuration concern and should be addressed at that level.
It is the administrator's responsibility to provision encrypted swap to mitigate this risk.</p><h3 id="evictions">Evictions</h3><p>Configuring memory eviction thresholds for swap-enabled nodes can be tricky.</p><p>With swap being disabled, it is reasonable to configure kubelet's eviction thresholds
to be a bit lower than the node's memory capacity.
The rationale is that we want Kubernetes to start evicting Pods before the node runs out of memory
and invokes the Out Of Memory (OOM) killer, since the OOM killer is not Kubernetes-aware,
therefore does not consider things like QoS, pod priority, or other Kubernetes-specific factors.</p><p>With swap enabled, the situation is more complex.
In Linux, the <code>vm.min_free_kbytes</code> parameter defines the memory threshold for the kernel
to start aggressively reclaiming memory, which includes swapping out pages.
If the kubelet's eviction thresholds are set in a way that eviction would take place
before the kernel starts reclaiming memory, it could lead to workloads never
being able to swap out during node memory pressure.
However, setting the eviction thresholds too high could result in the node running out of memory
and invoking the OOM killer, which is not ideal either.</p><p>To address this, it is recommended to set the kubelet's eviction thresholds
to be slightly lower than the <code>vm.min_free_kbytes</code> value.
This way, the node can start swapping before kubelet would start evicting Pods,
allowing workloads to swap out unused data and preventing evictions from happening.
On the other hand, since it is just slightly lower, kubelet is likely to start evicting Pods
before the node runs out of memory, thus avoiding the OOM killer.</p><p>The value of <code>vm.min_free_kbytes</code> can be determined by running the following command on the node:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>cat /proc/sys/vm/min_free_kbytes
</span></span></code></pre></div><h3 id="unutilized-swap-space">Unutilized swap space</h3><p>Under the <code>LimitedSwap</code> behavior, the amount of swap available to a Pod is determined automatically,
based on the proportion of the memory requested relative to the node's total memory
(For more details, see the <a href="#how-is-the-swap-limit-being-determined-with-limitedswap">section below</a>).</p><p>This design means that usually there would be some portion of swap that will remain
restricted for Kubernetes workloads.
For example, since Kubernetes 1.34 does not permit swap use for
Pods in the Guaranteed <a class="glossary-tooltip" title="QoS Class (Quality of Service Class) provides a way for Kubernetes to classify pods within the cluster into several classes and make decisions about scheduling and eviction." data-toggle="tooltip" data-placement="top" href="/docs/concepts/workloads/pods/pod-qos/" target="_blank" aria-label="QoS class">QoS class</a>,
the amount of swap that's proportional to the memory request for Guaranteed pods would
remain unused by Kubernetes workloads.</p><p>This behavior carries some risk in a situation where many pods are not eligible for swapping.
On the other hand, it effectively keeps some system-reserved amount of swap memory that can be used by processes
outside of Kubernetes' scope, such as system daemons and even kubelet itself.</p><h2 id="good-practice-for-using-swap-in-a-kubernetes-cluster">Good practice for using swap in a Kubernetes cluster</h2><h3 id="disable-swap-for-system-critical-daemons">Disable swap for system-critical daemons</h3><p>During the testing phase and based on user feedback, it was observed that the performance
of system-critical daemons and services might degrade.
This implies that system daemons, including the kubelet, could operate slower than usual.
If this issue is encountered, it is advisable to configure the cgroup of the system slice
to prevent swapping (i.e., set <code>memory.swap.max=0</code>).</p><h3 id="protect-system-critical-daemons-for-i-o-latency">Protect system-critical daemons for I/O latency</h3><p>Swap can increase the I/O load on a node.
When memory pressure causes the kernel to rapidly swap pages in and out,
system-critical daemons and services that rely on I/O operations may
experience performance degradation.</p><p>To mitigate this, it is recommended for systemd users to prioritize the system slice in terms of I/O latency.
For non-systemd users,
setting up a dedicated cgroup for system daemons and processes and prioritizing I/O latency in the same way is advised.
This can be achieved by setting <code>io.latency</code> for the system slice,
thereby granting it higher I/O priority.
See <a href="https://www.kernel.org/doc/Documentation/admin-guide/cgroup-v2.rst">cgroup's documentation</a> for more info.</p><h3 id="swap-and-control-plane-nodes">Swap and control plane nodes</h3><p>The Kubernetes project recommends running control plane nodes without any swap space configured.
The control plane primarily hosts Guaranteed QoS Pods, so swap can generally be disabled.
The main concern is that swapping critical services on the control plane could negatively impact performance.</p><h3 id="use-of-a-dedicated-disk-for-swap">Use of a dedicated disk for swap</h3><p>The Kubernetes project recommends using encrypted swap, whenever you run nodes with swap enabled.
If swap resides on a partition or the root filesystem, workloads may interfere
with system processes that need to write to disk.
When they share the same disk, processes can overwhelm swap,
disrupting the I/O of kubelet, container runtime, and systemd, which would impact other workloads.
Since swap space is located on a disk, it is crucial to ensure the disk is fast enough for the intended use cases.
Alternatively, one can configure I/O priorities between different mapped areas of a single backing device.</p><h3 id="swap-aware-scheduling">Swap-aware scheduling</h3><p>Kubernetes 1.34 does not support allocating Pods to nodes in a way that accounts
for swap memory usage. The scheduler typically uses <em>requests</em> for infrastructure resources
to guide Pod placement, and Pods do not request swap space; they just request <code>memory</code>.
This means that the scheduler does not consider swap memory when making scheduling decisions.
While this is something we are actively working on, it is not yet implemented.</p><p>In order for administrators to ensure that Pods are not scheduled on nodes
with swap memory unless they are specifically intended to use it,
Administrators can taint nodes with swap available to protect against this problem.
Taints will ensure that workloads which tolerate swap will not spill onto nodes without swap under load.</p><h3 id="selecting-storage-for-optimal-performance">Selecting storage for optimal performance</h3><p>The storage device designated for swap space is critical to maintaining system responsiveness
during high memory usage.
Rotational hard disk drives (HDDs) are ill-suited for this task as their mechanical nature introduces significant latency,
leading to severe performance degradation and system thrashing.
For modern performance needs, a device such as a Solid State Drive (SSD) is probably the appropriate choice for swap,
as its low-latency electronic access minimizes the slowdown.</p><h2 id="swap-behavior-details">Swap behavior details</h2><h3 id="how-is-the-swap-limit-being-determined-with-limitedswap">How is the swap limit being determined with LimitedSwap?</h3><p>The configuration of swap memory, including its limitations, presents a significant
challenge. Not only is it prone to misconfiguration, but as a system-level property, any
misconfiguration could potentially compromise the entire node rather than just a specific
workload. To mitigate this risk and ensure the health of the node, we have implemented
Swap with automatic configuration of limitations.</p><p>With <code>LimitedSwap</code>, Pods that do not fall under the Burstable QoS classification (i.e.
<code>BestEffort</code>/<code>Guaranteed</code> QoS Pods) are prohibited from utilizing swap memory.
<code>BestEffort</code> QoS Pods exhibit unpredictable memory consumption patterns and lack
information regarding their memory usage, making it difficult to determine a safe
allocation of swap memory.
Conversely, <code>Guaranteed</code> QoS Pods are typically employed for applications that rely on the
precise allocation of resources specified by the workload, with memory being immediately available.
To maintain the aforementioned security and node health guarantees,
these Pods are not permitted to use swap memory when <code>LimitedSwap</code> is in effect.
In addition, high-priority pods are not permitted to use swap in order to ensure the memory
they consume always residents on disk, hence ready to use.</p><p>Prior to detailing the calculation of the swap limit, it is necessary to define the following terms:</p><ul><li><code>nodeTotalMemory</code>: The total amount of physical memory available on the node.</li><li><code>totalPodsSwapAvailable</code>: The total amount of swap memory on the node that is available for use by Pods (some swap memory may be reserved for system use).</li><li><code>containerMemoryRequest</code>: The container's memory request.</li></ul><p>Swap limitation is configured as:<br/>( <code>containerMemoryRequest</code> / <code>nodeTotalMemory</code> ) Ã— <code>totalPodsSwapAvailable</code></p><p>In other words, the amount of swap that a container is able to use is proportionate to its
memory request, the node's total physical memory and the total amount of swap memory on
the node that is available for use by Pods.</p><p>It is important to note that, for containers within Burstable QoS Pods, it is possible to
opt-out of swap usage by specifying memory requests that are equal to memory limits.
Containers configured in this manner will not have access to swap memory.</p><h2 id="what-s-next">What's next</h2><ul><li>To learn about managing swap on Linux nodes, read
<a href="/docs/tutorials/cluster-management/provision-swap-memory/">configuring swap memory on Kubernetes nodes</a>.</li><li>You can check out a <a href="/blog/2025/03/25/swap-linux-improvements/">blog post about Kubernetes and swap</a></li><li>For background information, please see the original KEP, <a href="https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/2400-node-swap">KEP-2400</a>,
and its <a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/2400-node-swap/README.md">design</a>.</li></ul></div>