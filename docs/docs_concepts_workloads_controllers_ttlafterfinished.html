<div class="td-content"><h1 data-pagefind-weight="10">Automatic Cleanup for Finished Jobs</h1><div class="lead">A time-to-live mechanism to clean up old Jobs that have finished execution.</div><div class="feature-state-notice feature-stable"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.23 [stable]</code></div><p>When your Job has finished, it's useful to keep that Job in the API (and not immediately delete the Job)
so that you can tell whether the Job succeeded or failed.</p><p>Kubernetes' TTL-after-finished <a class="glossary-tooltip" title="A control loop that watches the shared state of the cluster through the apiserver and makes changes attempting to move the current state towards the desired state." data-toggle="tooltip" data-placement="top" href="/docs/concepts/architecture/controller/" target="_blank" aria-label="controller">controller</a> provides a
TTL (time to live) mechanism to limit the lifetime of Job objects that
have finished execution.</p><h2 id="cleanup-for-finished-jobs">Cleanup for finished Jobs</h2><p>The TTL-after-finished controller is only supported for Jobs. You can use this mechanism to clean
up finished Jobs (either <code>Complete</code> or <code>Failed</code>) automatically by specifying the
<code>.spec.ttlSecondsAfterFinished</code> field of a Job, as in this
<a href="/docs/concepts/workloads/controllers/job/#clean-up-finished-jobs-automatically">example</a>.</p><p>The TTL-after-finished controller assumes that a Job is eligible to be cleaned up
TTL seconds after the Job has finished. The timer starts once the
status condition of the Job changes to show that the Job is either <code>Complete</code> or <code>Failed</code>; once the TTL has
expired, that Job becomes eligible for
<a href="/docs/concepts/architecture/garbage-collection/#cascading-deletion">cascading</a> removal. When the
TTL-after-finished controller cleans up a job, it will delete it cascadingly, that is to say it will delete
its dependent objects together with it.</p><p>Kubernetes honors object lifecycle guarantees on the Job, such as waiting for
<a href="/docs/concepts/overview/working-with-objects/finalizers/">finalizers</a>.</p><p>You can set the TTL seconds at any time. Here are some examples for setting the
<code>.spec.ttlSecondsAfterFinished</code> field of a Job:</p><ul><li>Specify this field in the Job manifest, so that a Job can be cleaned up
automatically some time after it finishes.</li><li>Manually set this field of existing, already finished Jobs, so that they become eligible
for cleanup.</li><li>Use a
<a href="/docs/reference/access-authn-authz/admission-controllers/#mutatingadmissionwebhook">mutating admission webhook</a>
to set this field dynamically at Job creation time. Cluster administrators can
use this to enforce a TTL policy for finished jobs.</li><li>Use a
<a href="/docs/reference/access-authn-authz/admission-controllers/#mutatingadmissionwebhook">mutating admission webhook</a>
to set this field dynamically after the Job has finished, and choose
different TTL values based on job status, labels. For this case, the webhook needs
to detect changes to the <code>.status</code> of the Job and only set a TTL when the Job
is being marked as completed.</li><li>Write your own controller to manage the cleanup TTL for Jobs that match a particular
<a class="glossary-tooltip" title="Allows users to filter a list of resources based on labels." data-toggle="tooltip" data-placement="top" href="/docs/concepts/overview/working-with-objects/labels/" target="_blank" aria-label="selector">selector</a>.</li></ul><h2 id="caveats">Caveats</h2><h3 id="updating-ttl-for-finished-jobs">Updating TTL for finished Jobs</h3><p>You can modify the TTL period, e.g. <code>.spec.ttlSecondsAfterFinished</code> field of Jobs,
after the job is created or has finished. If you extend the TTL period after the
existing <code>ttlSecondsAfterFinished</code> period has expired, Kubernetes doesn't guarantee
to retain that Job, even if an update to extend the TTL returns a successful API
response.</p><h3 id="time-skew">Time skew</h3><p>Because the TTL-after-finished controller uses timestamps stored in the Kubernetes jobs to
determine whether the TTL has expired or not, this feature is sensitive to time
skew in your cluster, which may cause the control plane to clean up Job objects
at the wrong time.</p><p>Clocks aren't always correct, but the difference should be
very small. Please be aware of this risk when setting a non-zero TTL.</p><h2 id="what-s-next">What's next</h2><ul><li><p>Read <a href="/docs/concepts/workloads/controllers/job/#clean-up-finished-jobs-automatically">Clean up Jobs automatically</a></p></li><li><p>Refer to the <a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-apps/592-ttl-after-finish/README.md">Kubernetes Enhancement Proposal</a>
(KEP) for adding this mechanism.</p></li></ul></div>