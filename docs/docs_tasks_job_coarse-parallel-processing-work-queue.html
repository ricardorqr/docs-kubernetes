<div class="td-content"><h1 data-pagefind-weight="10">Coarse Parallel Processing Using a Work Queue</h1><p>In this example, you will run a Kubernetes Job with multiple parallel
worker processes.</p><p>In this example, as each pod is created, it picks up one unit of work
from a task queue, completes it, deletes it from the queue, and exits.</p><p>Here is an overview of the steps in this example:</p><ol><li><strong>Start a message queue service.</strong> In this example, you use RabbitMQ, but you could use another
one. In practice you would set up a message queue service once and reuse it for many jobs.</li><li><strong>Create a queue, and fill it with messages.</strong> Each message represents one task to be done. In
this example, a message is an integer that we will do a lengthy computation on.</li><li><strong>Start a Job that works on tasks from the queue</strong>. The Job starts several pods. Each pod takes
one task from the message queue, processes it, and exits.</li></ol><h2 id="before-you-begin">Before you begin</h2><p>You should already be familiar with the basic,
non-parallel, use of <a href="/docs/concepts/workloads/controllers/job/">Job</a>.</p><p>You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. It is recommended to run this tutorial on a cluster with at least two nodes that are not acting as control plane hosts. If you do not already have a
cluster, you can create one by using
<a href="https://minikube.sigs.k8s.io/docs/tutorials/multi_node/">minikube</a>
or you can use one of these Kubernetes playgrounds:</p><ul><li><a href="https://labs.iximiuz.com/playgrounds?category=kubernetes&amp;filter=all">iximiuz Labs</a></li><li><a href="https://killercoda.com/playgrounds/scenario/kubernetes">Killercoda</a></li><li><a href="https://kodekloud.com/public-playgrounds">KodeKloud</a></li><li><a href="https://labs.play-with-k8s.com/">Play with Kubernetes</a></li></ul><p>You will need a container image registry where you can upload images to run in your cluster.</p><p>This task example also assumes that you have Docker installed locally.</p><h2 id="starting-a-message-queue-service">Starting a message queue service</h2><p>This example uses RabbitMQ, however, you can adapt the example to use another AMQP-type message service.</p><p>In practice you could set up a message queue service once in a
cluster and reuse it for many jobs, as well as for long-running services.</p><p>Start RabbitMQ as follows:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span><span style="color:#080;font-style:italic"># make a Service for the StatefulSet to use</span>
</span></span><span style="display:flex"><span>kubectl create -f https://kubernetes.io/examples/application/job/rabbitmq/rabbitmq-service.yaml
</span></span></code></pre></div><pre tabindex="0"><code>service "rabbitmq-service" created
</code></pre><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl create -f https://kubernetes.io/examples/application/job/rabbitmq/rabbitmq-statefulset.yaml
</span></span></code></pre></div><pre tabindex="0"><code>statefulset "rabbitmq" created
</code></pre><h2 id="testing-the-message-queue-service">Testing the message queue service</h2><p>Now, we can experiment with accessing the message queue. We will
create a temporary interactive pod, install some tools on it,
and experiment with queues.</p><p>First create a temporary interactive Pod.</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span><span style="color:#080;font-style:italic"># Create a temporary interactive container</span>
</span></span><span style="display:flex"><span>kubectl run -i --tty temp --image ubuntu:22.04
</span></span></code></pre></div><pre tabindex="0"><code>Waiting for pod default/temp-loe07 to be running, status is Pending, pod ready: false
... [ previous line repeats several times .. hit return when it stops ] ...
</code></pre><p>Note that your pod name and command prompt will be different.</p><p>Next install the <code>amqp-tools</code> so you can work with message queues.
The next commands show what you need to run inside the interactive shell in that Pod:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>apt-get update <span style="color:#666">&amp;&amp;</span> apt-get install -y curl ca-certificates amqp-tools python3 dnsutils
</span></span></code></pre></div><p>Later, you will make a container image that includes these packages.</p><p>Next, you will check that you can discover the Service for RabbitMQ:</p><pre tabindex="0"><code># Run these commands inside the Pod
# Note the rabbitmq-service has a DNS name, provided by Kubernetes:
nslookup rabbitmq-service
</code></pre><pre tabindex="0"><code>Server:        10.0.0.10
Address:    10.0.0.10#53

Name:    rabbitmq-service.default.svc.cluster.local
Address: 10.0.147.152
</code></pre><p>(the IP addresses will vary)</p><p>If the kube-dns addon is not set up correctly, the previous step may not work for you.
You can also find the IP address for that Service in an environment variable:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span><span style="color:#080;font-style:italic"># run this check inside the Pod</span>
</span></span><span style="display:flex"><span>env | grep RABBITMQ_SERVICE | grep HOST
</span></span></code></pre></div><pre tabindex="0"><code>RABBITMQ_SERVICE_SERVICE_HOST=10.0.147.152
</code></pre><p>(the IP address will vary)</p><p>Next you will verify that you can create a queue, and publish and consume messages.</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span><span style="color:#080;font-style:italic"># Run these commands inside the Pod</span>
</span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"># In the next line, rabbitmq-service is the hostname where the rabbitmq-service</span>
</span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"># can be reached.  5672 is the standard port for rabbitmq.</span>
</span></span><span style="display:flex"><span><span style="color:#a2f">export</span> <span style="color:#b8860b">BROKER_URL</span><span style="color:#666">=</span>amqp://guest:guest@rabbitmq-service:5672
</span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"># If you could not resolve "rabbitmq-service" in the previous step,</span>
</span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"># then use this command instead:</span>
</span></span><span style="display:flex"><span><span style="color:#b8860b">BROKER_URL</span><span style="color:#666">=</span>amqp://guest:guest@<span style="color:#b8860b">$RABBITMQ_SERVICE_SERVICE_HOST</span>:5672
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"># Now create a queue:</span>
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span>/usr/bin/amqp-declare-queue --url<span style="color:#666">=</span><span style="color:#b8860b">$BROKER_URL</span> -q foo -d
</span></span></code></pre></div><pre tabindex="0"><code>foo
</code></pre><p>Publish one message to the queue:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>/usr/bin/amqp-publish --url<span style="color:#666">=</span><span style="color:#b8860b">$BROKER_URL</span> -r foo -p -b Hello
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"># And get it back.</span>
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span>/usr/bin/amqp-consume --url<span style="color:#666">=</span><span style="color:#b8860b">$BROKER_URL</span> -q foo -c <span style="color:#666">1</span> cat <span style="color:#666">&amp;&amp;</span> <span style="color:#a2f">echo</span> 1&gt;&amp;<span style="color:#666">2</span>
</span></span></code></pre></div><pre tabindex="0"><code>Hello
</code></pre><p>In the last command, the <code>amqp-consume</code> tool took one message (<code>-c 1</code>)
from the queue, and passes that message to the standard input of an arbitrary command.
In this case, the program <code>cat</code> prints out the characters read from standard input, and
the echo adds a carriage return so the example is readable.</p><h2 id="fill-the-queue-with-tasks">Fill the queue with tasks</h2><p>Now, fill the queue with some simulated tasks. In this example, the tasks are strings to be
printed.</p><p>In a practice, the content of the messages might be:</p><ul><li>names of files to that need to be processed</li><li>extra flags to the program</li><li>ranges of keys in a database table</li><li>configuration parameters to a simulation</li><li>frame numbers of a scene to be rendered</li></ul><p>If there is large data that is needed in a read-only mode by all pods
of the Job, you typically put that in a shared file system like NFS and mount
that readonly on all the pods, or write the program in the pod so that it can natively read
data from a cluster file system (for example: HDFS).</p><p>For this example, you will create the queue and fill it using the AMQP command line tools.
In practice, you might write a program to fill the queue using an AMQP client library.</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span><span style="color:#080;font-style:italic"># Run this on your computer, not in the Pod</span>
</span></span><span style="display:flex"><span>/usr/bin/amqp-declare-queue --url<span style="color:#666">=</span><span style="color:#b8860b">$BROKER_URL</span> -q job1  -d
</span></span></code></pre></div><pre tabindex="0"><code>job1
</code></pre><p>Add items to the queue:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span><span style="color:#a2f;font-weight:700">for</span> f in apple banana cherry date fig grape lemon melon
</span></span><span style="display:flex"><span><span style="color:#a2f;font-weight:700">do</span>
</span></span><span style="display:flex"><span>  /usr/bin/amqp-publish --url<span style="color:#666">=</span><span style="color:#b8860b">$BROKER_URL</span> -r job1 -p -b <span style="color:#b8860b">$f</span>
</span></span><span style="display:flex"><span><span style="color:#a2f;font-weight:700">done</span>
</span></span></code></pre></div><p>You added 8 messages to the queue.</p><h2 id="create-a-container-image">Create a container image</h2><p>Now you are ready to create an image that you will run as a Job.</p><p>The job will use the <code>amqp-consume</code> utility to read the message
from the queue and run the actual work. Here is a very simple
example program:</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/application/job/rabbitmq/worker.py" download="application/job/rabbitmq/worker.py"><code>application/job/rabbitmq/worker.py</code>
</a><img src="/images/copycode.svg" class="icon-copycode" onclick="copyCode(&quot;application-job-rabbitmq-worker-py&quot;)" title="Copy application/job/rabbitmq/worker.py to clipboard"/></div><div class="includecode" id="application-job-rabbitmq-worker-py"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="display:flex"><span><span style="color:#080;font-style:italic">#!/usr/bin/env python</span>
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span><span style="color:#080;font-style:italic"># Just prints standard out and sleeps for 10 seconds.</span>
</span></span><span style="display:flex"><span><span style="color:#a2f;font-weight:700">import</span> <span style="color:#00f;font-weight:700">sys</span>
</span></span><span style="display:flex"><span><span style="color:#a2f;font-weight:700">import</span> <span style="color:#00f;font-weight:700">time</span>
</span></span><span style="display:flex"><span><span style="color:#a2f">print</span>(<span style="color:#b44">"Processing "</span> <span style="color:#666">+</span> sys<span style="color:#666">.</span>stdin<span style="color:#666">.</span>readlines()[<span style="color:#666">0</span>])
</span></span><span style="display:flex"><span>time<span style="color:#666">.</span>sleep(<span style="color:#666">10</span>)
</span></span></code></pre></div></div></div><p>Give the script execution permission:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>chmod +x worker.py
</span></span></code></pre></div><p>Now, build an image. Make a temporary directory, change to it,
download the <a href="/examples/application/job/rabbitmq/Dockerfile">Dockerfile</a>,
and <a href="/examples/application/job/rabbitmq/worker.py">worker.py</a>. In either case,
build the image with this command:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>docker build -t job-wq-1 .
</span></span></code></pre></div><p>For the <a href="https://hub.docker.com/">Docker Hub</a>, tag your app image with
your username and push to the Hub with the below commands. Replace
<code>&lt;username&gt;</code> with your Hub username.</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>docker tag job-wq-1 &lt;username&gt;/job-wq-1
</span></span><span style="display:flex"><span>docker push &lt;username&gt;/job-wq-1
</span></span></code></pre></div><p>If you are using an alternative container image registry, tag the
image and push it there instead.</p><h2 id="defining-a-job">Defining a Job</h2><p>Here is a manifest for a Job. You'll need to make a copy of the Job manifest
(call it <code>./job.yaml</code>),
and edit the name of the container image to match the name you used.</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/application/job/rabbitmq/job.yaml" download="application/job/rabbitmq/job.yaml"><code>application/job/rabbitmq/job.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" onclick="copyCode(&quot;application-job-rabbitmq-job-yaml&quot;)" title="Copy application/job/rabbitmq/job.yaml to clipboard"/></div><div class="includecode" id="application-job-rabbitmq-job-yaml"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>batch/v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>Job<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">metadata</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>job-wq-1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">spec</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">completions</span>:<span style="color:#bbb"> </span><span style="color:#666">8</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">parallelism</span>:<span style="color:#bbb"> </span><span style="color:#666">2</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">template</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">metadata</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>job-wq-1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">spec</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">containers</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>c<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">image</span>:<span style="color:#bbb"> </span>gcr.io/&lt;project&gt;/job-wq-1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">env</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>BROKER_URL<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">          </span><span style="color:green;font-weight:700">value</span>:<span style="color:#bbb"> </span>amqp://guest:guest@rabbitmq-service:5672<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>QUEUE<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">          </span><span style="color:green;font-weight:700">value</span>:<span style="color:#bbb"> </span>job1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">restartPolicy</span>:<span style="color:#bbb"> </span>OnFailure<span style="color:#bbb">
</span></span></span></code></pre></div></div></div><p>In this example, each pod works on one item from the queue and then exits.
So, the completion count of the Job corresponds to the number of work items
done. That is why the example manifest has <code>.spec.completions</code> set to <code>8</code>.</p><h2 id="running-the-job">Running the Job</h2><p>Now, run the Job:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span><span style="color:#080;font-style:italic"># this assumes you downloaded and then edited the manifest already</span>
</span></span><span style="display:flex"><span>kubectl apply -f ./job.yaml
</span></span></code></pre></div><p>You can wait for the Job to succeed, with a timeout:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span><span style="color:#080;font-style:italic"># The check for condition name is case insensitive</span>
</span></span><span style="display:flex"><span>kubectl <span style="color:#a2f">wait</span> --for<span style="color:#666">=</span><span style="color:#b8860b">condition</span><span style="color:#666">=</span><span style="color:#a2f">complete</span> --timeout<span style="color:#666">=</span>300s job/job-wq-1
</span></span></code></pre></div><p>Next, check on the Job:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl describe jobs/job-wq-1
</span></span></code></pre></div><pre tabindex="0"><code>Name:             job-wq-1
Namespace:        default
Selector:         controller-uid=41d75705-92df-11e7-b85e-fa163ee3c11f
Labels:           controller-uid=41d75705-92df-11e7-b85e-fa163ee3c11f
                  job-name=job-wq-1
Annotations:      &lt;none&gt;
Parallelism:      2
Completions:      8
Start Time:       Wed, 06 Sep 2022 16:42:02 +0000
Pods Statuses:    0 Running / 8 Succeeded / 0 Failed
Pod Template:
  Labels:       controller-uid=41d75705-92df-11e7-b85e-fa163ee3c11f
                job-name=job-wq-1
  Containers:
   c:
    Image:      container-registry.example/causal-jigsaw-637/job-wq-1
    Port:
    Environment:
      BROKER_URL:       amqp://guest:guest@rabbitmq-service:5672
      QUEUE:            job1
    Mounts:             &lt;none&gt;
  Volumes:              &lt;none&gt;
Events:
  FirstSeen  LastSeen   Count    From    SubobjectPath    Type      Reason              Message
  ─────────  ────────   ─────    ────    ─────────────    ──────    ──────              ───────
  27s        27s        1        {job }                   Normal    SuccessfulCreate    Created pod: job-wq-1-hcobb
  27s        27s        1        {job }                   Normal    SuccessfulCreate    Created pod: job-wq-1-weytj
  27s        27s        1        {job }                   Normal    SuccessfulCreate    Created pod: job-wq-1-qaam5
  27s        27s        1        {job }                   Normal    SuccessfulCreate    Created pod: job-wq-1-b67sr
  26s        26s        1        {job }                   Normal    SuccessfulCreate    Created pod: job-wq-1-xe5hj
  15s        15s        1        {job }                   Normal    SuccessfulCreate    Created pod: job-wq-1-w2zqe
  14s        14s        1        {job }                   Normal    SuccessfulCreate    Created pod: job-wq-1-d6ppa
  14s        14s        1        {job }                   Normal    SuccessfulCreate    Created pod: job-wq-1-p17e0
</code></pre><p>All the pods for that Job succeeded! You're done.</p><h2 id="alternatives">Alternatives</h2><p>This approach has the advantage that you do not need to modify your "worker" program to be
aware that there is a work queue. You can include the worker program unmodified in your container
image.</p><p>Using this approach does require that you run a message queue service.
If running a queue service is inconvenient, you may
want to consider one of the other <a href="/docs/concepts/workloads/controllers/job/#job-patterns">job patterns</a>.</p><p>This approach creates a pod for every work item. If your work items only take a few seconds,
though, creating a Pod for every work item may add a lot of overhead. Consider another
design, such as in the <a href="/docs/tasks/job/fine-parallel-processing-work-queue/">fine parallel work queue example</a>,
that executes multiple work items per Pod.</p><p>In this example, you used the <code>amqp-consume</code> utility to read the message
from the queue and run the actual program. This has the advantage that you
do not need to modify your program to be aware of the queue.
The <a href="/docs/tasks/job/fine-parallel-processing-work-queue/">fine parallel work queue example</a>
shows how to communicate with the work queue using a client library.</p><h2 id="caveats">Caveats</h2><p>If the number of completions is set to less than the number of items in the queue, then
not all items will be processed.</p><p>If the number of completions is set to more than the number of items in the queue,
then the Job will not appear to be completed, even though all items in the queue
have been processed. It will start additional pods which will block waiting
for a message.
You would need to make your own mechanism to spot when there is work
to do and measure the size of the queue, setting the number of completions to match.</p><p>There is an unlikely race with this pattern. If the container is killed in between the time
that the message is acknowledged by the <code>amqp-consume</code> command and the time that the container
exits with success, or if the node crashes before the kubelet is able to post the success of the pod
back to the API server, then the Job will not appear to be complete, even though all items
in the queue have been processed.</p></div>