<div class="td-content"><h1 data-pagefind-weight="10">Secrets</h1><p>A Secret is an object that contains a small amount of sensitive data such as
a password, a token, or a key. Such information might otherwise be put in a
<a class="glossary-tooltip" title="A Pod represents a set of running containers in your cluster." data-toggle="tooltip" data-placement="top" href="/docs/concepts/workloads/pods/" target="_blank" aria-label="Pod">Pod</a> specification or in a
<a class="glossary-tooltip" title="Stored instance of a container that holds a set of software needed to run an application." data-toggle="tooltip" data-placement="top" href="/docs/reference/glossary/?all=true#term-image" target="_blank" aria-label="container image">container image</a>. Using a
Secret means that you don't need to include confidential data in your
application code.</p><p>Because Secrets can be created independently of the Pods that use them, there
is less risk of the Secret (and its data) being exposed during the workflow of
creating, viewing, and editing Pods. Kubernetes, and applications that run in
your cluster, can also take additional precautions with Secrets, such as avoiding
writing sensitive data to nonvolatile storage.</p><p>Secrets are similar to <a class="glossary-tooltip" title="An API object used to store non-confidential data in key-value pairs. Can be consumed as environment variables, command-line arguments, or configuration files in a volume." data-toggle="tooltip" data-placement="top" href="/docs/concepts/configuration/configmap/" target="_blank" aria-label="ConfigMaps">ConfigMaps</a>
but are specifically intended to hold confidential data.</p><div class="alert alert-caution" role="alert"><h4 class="alert-heading">Caution:</h4><p>Kubernetes Secrets are, by default, stored unencrypted in the API server's underlying data store
(etcd). Anyone with API access can retrieve or modify a Secret, and so can anyone with access to etcd.
Additionally, anyone who is authorized to create a Pod in a namespace can use that access to read
any Secret in that namespace; this includes indirect access such as the ability to create a
Deployment.</p><p>In order to safely use Secrets, take at least the following steps:</p><ol><li><a href="/docs/tasks/administer-cluster/encrypt-data/">Enable Encryption at Rest</a> for Secrets.</li><li><a href="/docs/reference/access-authn-authz/authorization/">Enable or configure RBAC rules</a> with
least-privilege access to Secrets.</li><li>Restrict Secret access to specific containers.</li><li><a href="https://secrets-store-csi-driver.sigs.k8s.io/concepts.html#provider-for-the-secrets-store-csi-driver">Consider using external Secret store providers</a>.</li></ol><p>For more guidelines to manage and improve the security of your Secrets, refer to
<a href="/docs/concepts/security/secrets-good-practices/">Good practices for Kubernetes Secrets</a>.</p></div><p>See <a href="#information-security-for-secrets">Information security for Secrets</a> for more details.</p><h2 id="uses-for-secrets">Uses for Secrets</h2><p>You can use Secrets for purposes such as the following:</p><ul><li><a href="/docs/tasks/inject-data-application/distribute-credentials-secure/#define-container-environment-variables-using-secret-data">Set environment variables for a container</a>.</li><li><a href="/docs/tasks/inject-data-application/distribute-credentials-secure/#provide-prod-test-creds">Provide credentials such as SSH keys or passwords to Pods</a>.</li><li><a href="/docs/tasks/configure-pod-container/pull-image-private-registry/">Allow the kubelet to pull container images from private registries</a>.</li></ul><p>The Kubernetes control plane also uses Secrets; for example,
<a href="#bootstrap-token-secrets">bootstrap token Secrets</a> are a mechanism to
help automate node registration.</p><h3 id="use-case-dotfiles-in-a-secret-volume">Use case: dotfiles in a secret volume</h3><p>You can make your data "hidden" by defining a key that begins with a dot.
This key represents a dotfile or "hidden" file. For example, when the following Secret
is mounted into a volume, <code>secret-volume</code>, the volume will contain a single file,
called <code>.secret-file</code>, and the <code>dotfile-test-container</code> will have this file
present at the path <code>/etc/secret-volume/.secret-file</code>.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>Files beginning with dot characters are hidden from the output of <code>ls -l</code>;
you must use <code>ls -la</code> to see them when listing directory contents.</div><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/secret/dotfile-secret.yaml" download="secret/dotfile-secret.yaml"><code>secret/dotfile-secret.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" onclick="copyCode(&quot;secret-dotfile-secret-yaml&quot;)" title="Copy secret/dotfile-secret.yaml to clipboard"/></div><div class="includecode" id="secret-dotfile-secret-yaml"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>Secret<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">metadata</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>dotfile-secret<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">data</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">.secret-file</span>:<span style="color:#bbb"> </span>dmFsdWUtMg0KDQo=<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:#00f;font-weight:700">---</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>Pod<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">metadata</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>secret-dotfiles-pod<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">spec</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">volumes</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>secret-volume<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">secret</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">secretName</span>:<span style="color:#bbb"> </span>dotfile-secret<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">containers</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>dotfile-test-container<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">image</span>:<span style="color:#bbb"> </span>registry.k8s.io/busybox<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">command</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span>- ls<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span>- <span style="color:#b44">"-l"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span>- <span style="color:#b44">"/etc/secret-volume"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">volumeMounts</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>secret-volume<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">          </span><span style="color:green;font-weight:700">readOnly</span>:<span style="color:#bbb"> </span><span style="color:#a2f;font-weight:700">true</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">          </span><span style="color:green;font-weight:700">mountPath</span>:<span style="color:#bbb"> </span><span style="color:#b44">"/etc/secret-volume"</span></span></span></code></pre></div></div></div><h3 id="use-case-secret-visible-to-one-container-in-a-pod">Use case: Secret visible to one container in a Pod</h3><p>Consider a program that needs to handle HTTP requests, do some complex business
logic, and then sign some messages with an HMAC. Because it has complex
application logic, there might be an unnoticed remote file reading exploit in
the server, which could expose the private key to an attacker.</p><p>This could be divided into two processes in two containers: a frontend container
which handles user interaction and business logic, but which cannot see the
private key; and a signer container that can see the private key, and responds
to simple signing requests from the frontend (for example, over localhost networking).</p><p>With this partitioned approach, an attacker now has to trick the application
server into doing something rather arbitrary, which may be harder than getting
it to read a file.</p><h3 id="alternatives-to-secrets">Alternatives to Secrets</h3><p>Rather than using a Secret to protect confidential data, you can pick from alternatives.</p><p>Here are some of your options:</p><ul><li>If your cloud-native component needs to authenticate to another application that you
know is running within the same Kubernetes cluster, you can use a
<a href="/docs/reference/access-authn-authz/authentication/#service-account-tokens">ServiceAccount</a>
and its tokens to identify your client.</li><li>There are third-party tools that you can run, either within or outside your cluster,
that manage sensitive data. For example, a service that Pods access over HTTPS,
that reveals a Secret if the client correctly authenticates (for example, with a ServiceAccount
token).</li><li>For authentication, you can implement a custom signer for X.509 certificates, and use
<a href="/docs/reference/access-authn-authz/certificate-signing-requests/">CertificateSigningRequests</a>
to let that custom signer issue certificates to Pods that need them.</li><li>You can use a <a href="/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/">device plugin</a>
to expose node-local encryption hardware to a specific Pod. For example, you can schedule
trusted Pods onto nodes that provide a Trusted Platform Module, configured out-of-band.</li></ul><p>You can also combine two or more of those options, including the option to use Secret objects themselves.</p><p>For example: implement (or deploy) an <a class="glossary-tooltip" title="A specialized controller used to manage a custom resource" data-toggle="tooltip" data-placement="top" href="/docs/concepts/extend-kubernetes/operator/" target="_blank" aria-label="operator">operator</a>
that fetches short-lived session tokens from an external service, and then creates Secrets based
on those short-lived session tokens. Pods running in your cluster can make use of the session tokens,
and operator ensures they are valid. This separation means that you can run Pods that are unaware of
the exact mechanisms for issuing and refreshing those session tokens.</p><h2 id="secret-types">Types of Secret</h2><p>When creating a Secret, you can specify its type using the <code>type</code> field of
the <a href="/docs/reference/kubernetes-api/config-and-storage-resources/secret-v1/">Secret</a>
resource, or certain equivalent <code>kubectl</code> command line flags (if available).
The Secret type is used to facilitate programmatic handling of the Secret data.</p><p>Kubernetes provides several built-in types for some common usage scenarios.
These types vary in terms of the validations performed and the constraints
Kubernetes imposes on them.</p><table><thead><tr><th>Built-in Type</th><th>Usage</th></tr></thead><tbody><tr><td><code>Opaque</code></td><td>arbitrary user-defined data</td></tr><tr><td><code>kubernetes.io/service-account-token</code></td><td>ServiceAccount token</td></tr><tr><td><code>kubernetes.io/dockercfg</code></td><td>serialized <code>~/.dockercfg</code> file</td></tr><tr><td><code>kubernetes.io/dockerconfigjson</code></td><td>serialized <code>~/.docker/config.json</code> file</td></tr><tr><td><code>kubernetes.io/basic-auth</code></td><td>credentials for basic authentication</td></tr><tr><td><code>kubernetes.io/ssh-auth</code></td><td>credentials for SSH authentication</td></tr><tr><td><code>kubernetes.io/tls</code></td><td>data for a TLS client or server</td></tr><tr><td><code>bootstrap.kubernetes.io/token</code></td><td>bootstrap token data</td></tr></tbody></table><p>You can define and use your own Secret type by assigning a non-empty string as the
<code>type</code> value for a Secret object (an empty string is treated as an <code>Opaque</code> type).</p><p>Kubernetes doesn't impose any constraints on the type name. However, if you
are using one of the built-in types, you must meet all the requirements defined
for that type.</p><p>If you are defining a type of Secret that's for public use, follow the convention
and structure the Secret type to have your domain name before the name, separated
by a <code>/</code>. For example: <code>cloud-hosting.example.net/cloud-api-credentials</code>.</p><h3 id="opaque-secrets">Opaque Secrets</h3><p><code>Opaque</code> is the default Secret type if you don't explicitly specify a type in
a Secret manifest. When you create a Secret using <code>kubectl</code>, you must use the
<code>generic</code> subcommand to indicate an <code>Opaque</code> Secret type. For example, the
following command creates an empty Secret of type <code>Opaque</code>:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl create secret generic empty-secret
</span></span><span style="display:flex"><span>kubectl get secret empty-secret
</span></span></code></pre></div><p>The output looks like:</p><pre tabindex="0"><code>NAME           TYPE     DATA   AGE
empty-secret   Opaque   0      2m6s
</code></pre><p>The <code>DATA</code> column shows the number of data items stored in the Secret.
In this case, <code>0</code> means you have created an empty Secret.</p><h3 id="serviceaccount-token-secrets">ServiceAccount token Secrets</h3><p>A <code>kubernetes.io/service-account-token</code> type of Secret is used to store a
token credential that identifies a
<a class="glossary-tooltip" title="Provides an identity for processes that run in a Pod." data-toggle="tooltip" data-placement="top" href="/docs/tasks/configure-pod-container/configure-service-account/" target="_blank" aria-label="ServiceAccount">ServiceAccount</a>. This
is a legacy mechanism that provides long-lived ServiceAccount credentials to
Pods.</p><p>In Kubernetes v1.22 and later, the recommended approach is to obtain a
short-lived, automatically rotating ServiceAccount token by using the
<a href="/docs/reference/kubernetes-api/authentication-resources/token-request-v1/"><code>TokenRequest</code></a>
API instead. You can get these short-lived tokens using the following methods:</p><ul><li>Call the <code>TokenRequest</code> API either directly or by using an API client like
<code>kubectl</code>. For example, you can use the
<a href="/docs/reference/generated/kubectl/kubectl-commands#-em-token-em-"><code>kubectl create token</code></a>
command.</li><li>Request a mounted token in a
<a href="/docs/reference/access-authn-authz/service-accounts-admin/#bound-service-account-token-volume">projected volume</a>
in your Pod manifest. Kubernetes creates the token and mounts it in the Pod.
The token is automatically invalidated when the Pod that it's mounted in is
deleted. For details, see
<a href="/docs/tasks/configure-pod-container/configure-service-account/#launch-a-pod-using-service-account-token-projection">Launch a Pod using service account token projection</a>.</li></ul><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>You should only create a ServiceAccount token Secret
if you can't use the <code>TokenRequest</code> API to obtain a token,
and the security exposure of persisting a non-expiring token credential
in a readable API object is acceptable to you. For instructions, see
<a href="/docs/tasks/configure-pod-container/configure-service-account/#manually-create-an-api-token-for-a-serviceaccount">Manually create a long-lived API token for a ServiceAccount</a>.</div><p>When using this Secret type, you need to ensure that the
<code>kubernetes.io/service-account.name</code> annotation is set to an existing
ServiceAccount name. If you are creating both the ServiceAccount and
the Secret objects, you should create the ServiceAccount object first.</p><p>After the Secret is created, a Kubernetes <a class="glossary-tooltip" title="A control loop that watches the shared state of the cluster through the apiserver and makes changes attempting to move the current state towards the desired state." data-toggle="tooltip" data-placement="top" href="/docs/concepts/architecture/controller/" target="_blank" aria-label="controller">controller</a>
fills in some other fields such as the <code>kubernetes.io/service-account.uid</code> annotation, and the
<code>token</code> key in the <code>data</code> field, which is populated with an authentication token.</p><p>The following example configuration declares a ServiceAccount token Secret:</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/secret/serviceaccount-token-secret.yaml" download="secret/serviceaccount-token-secret.yaml"><code>secret/serviceaccount-token-secret.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" onclick="copyCode(&quot;secret-serviceaccount-token-secret-yaml&quot;)" title="Copy secret/serviceaccount-token-secret.yaml to clipboard"/></div><div class="includecode" id="secret-serviceaccount-token-secret-yaml"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>Secret<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">metadata</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>secret-sa-sample<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">annotations</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">kubernetes.io/service-account.name</span>:<span style="color:#bbb"> </span><span style="color:#b44">"sa-name"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">type</span>:<span style="color:#bbb"> </span>kubernetes.io/service-account-token<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">data</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">extra</span>:<span style="color:#bbb"> </span>YmFyCg==</span></span></code></pre></div></div></div><p>After creating the Secret, wait for Kubernetes to populate the <code>token</code> key in the <code>data</code> field.</p><p>See the <a href="/docs/concepts/security/service-accounts/">ServiceAccount</a>
documentation for more information on how ServiceAccounts work.
You can also check the <code>automountServiceAccountToken</code> field and the
<code>serviceAccountName</code> field of the
<a href="/docs/reference/generated/kubernetes-api/v1.34/#pod-v1-core"><code>Pod</code></a>
for information on referencing ServiceAccount credentials from within Pods.</p><h3 id="docker-config-secrets">Docker config Secrets</h3><p>If you are creating a Secret to store credentials for accessing a container image registry,
you must use one of the following <code>type</code> values for that Secret:</p><ul><li><code>kubernetes.io/dockercfg</code>: store a serialized <code>~/.dockercfg</code> which is the
legacy format for configuring Docker command line. The Secret
<code>data</code> field contains a <code>.dockercfg</code> key whose value is the content of a
base64 encoded <code>~/.dockercfg</code> file.</li><li><code>kubernetes.io/dockerconfigjson</code>: store a serialized JSON that follows the
same format rules as the <code>~/.docker/config.json</code> file, which is a new format
for <code>~/.dockercfg</code>. The Secret <code>data</code> field must contain a
<code>.dockerconfigjson</code> key for which the value is the content of a base64
encoded <code>~/.docker/config.json</code> file.</li></ul><p>Below is an example for a <code>kubernetes.io/dockercfg</code> type of Secret:</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/secret/dockercfg-secret.yaml" download="secret/dockercfg-secret.yaml"><code>secret/dockercfg-secret.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" onclick="copyCode(&quot;secret-dockercfg-secret-yaml&quot;)" title="Copy secret/dockercfg-secret.yaml to clipboard"/></div><div class="includecode" id="secret-dockercfg-secret-yaml"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>Secret<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">metadata</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>secret-dockercfg<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">type</span>:<span style="color:#bbb"> </span>kubernetes.io/dockercfg<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">data</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">.dockercfg</span>:<span style="color:#bbb"> </span>|<span style="color:#b44;font-style:italic">
</span></span></span><span style="display:flex"><span><span style="color:#b44;font-style:italic">    eyJhdXRocyI6eyJodHRwczovL2V4YW1wbGUvdjEvIjp7ImF1dGgiOiJvcGVuc2VzYW1lIn19fQo=</span><span style="color:#bbb">    </span></span></span></code></pre></div></div></div><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>If you do not want to perform the base64 encoding, you can choose to use the
<code>stringData</code> field instead.</div><p>When you create Docker config Secrets using a manifest, the API
server checks whether the expected key exists in the <code>data</code> field, and
it verifies if the value provided can be parsed as a valid JSON. The API
server doesn't validate if the JSON actually is a Docker config file.</p><p>You can also use <code>kubectl</code> to create a Secret for accessing a container
registry, such as when you don't have a Docker configuration file:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl create secret docker-registry secret-tiger-docker <span>\</span>
</span></span><span style="display:flex"><span>  --docker-email<span style="color:#666">=</span>tiger@acme.example <span style="color:#b62;font-weight:700">\
</span></span></span><span style="display:flex"><span><span style="color:#b62;font-weight:700"/>  --docker-username<span style="color:#666">=</span>tiger <span style="color:#b62;font-weight:700">\
</span></span></span><span style="display:flex"><span><span style="color:#b62;font-weight:700"/>  --docker-password<span style="color:#666">=</span>pass1234 <span style="color:#b62;font-weight:700">\
</span></span></span><span style="display:flex"><span><span style="color:#b62;font-weight:700"/>  --docker-server<span style="color:#666">=</span>my-registry.example:5000
</span></span></code></pre></div><p>This command creates a Secret of type <code>kubernetes.io/dockerconfigjson</code>.</p><p>Retrieve the <code>.data.dockerconfigjson</code> field from that new Secret and decode the
data:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl get secret secret-tiger-docker -o <span style="color:#b8860b">jsonpath</span><span style="color:#666">=</span><span style="color:#b44">'{.data.*}'</span> | base64 -d
</span></span></code></pre></div><p>The output is equivalent to the following JSON document (which is also a valid
Docker configuration file):</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json"><span style="display:flex"><span>{
</span></span><span style="display:flex"><span>  <span style="color:green;font-weight:700">"auths"</span>: {
</span></span><span style="display:flex"><span>    <span style="color:green;font-weight:700">"my-registry.example:5000"</span>: {
</span></span><span style="display:flex"><span>      <span style="color:green;font-weight:700">"username"</span>: <span style="color:#b44">"tiger"</span>,
</span></span><span style="display:flex"><span>      <span style="color:green;font-weight:700">"password"</span>: <span style="color:#b44">"pass1234"</span>,
</span></span><span style="display:flex"><span>      <span style="color:green;font-weight:700">"email"</span>: <span style="color:#b44">"tiger@acme.example"</span>,
</span></span><span style="display:flex"><span>      <span style="color:green;font-weight:700">"auth"</span>: <span style="color:#b44">"dGlnZXI6cGFzczEyMzQ="</span>
</span></span><span style="display:flex"><span>    }
</span></span><span style="display:flex"><span>  }
</span></span><span style="display:flex"><span>}
</span></span></code></pre></div><div class="alert alert-caution" role="alert"><h4 class="alert-heading">Caution:</h4><p>The <code>auth</code> value there is base64 encoded; it is obscured but not secret.
Anyone who can read that Secret can learn the registry access bearer token.</p><p>It is suggested to use <a href="/docs/tasks/administer-cluster/kubelet-credential-provider/">credential providers</a> to dynamically and securely provide pull secrets on-demand.</p></div><h3 id="basic-authentication-secret">Basic authentication Secret</h3><p>The <code>kubernetes.io/basic-auth</code> type is provided for storing credentials needed
for basic authentication. When using this Secret type, the <code>data</code> field of the
Secret must contain one of the following two keys:</p><ul><li><code>username</code>: the user name for authentication</li><li><code>password</code>: the password or token for authentication</li></ul><p>Both values for the above two keys are base64 encoded strings. You can
alternatively provide the clear text content using the <code>stringData</code> field in the
Secret manifest.</p><p>The following manifest is an example of a basic authentication Secret:</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/secret/basicauth-secret.yaml" download="secret/basicauth-secret.yaml"><code>secret/basicauth-secret.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" onclick="copyCode(&quot;secret-basicauth-secret-yaml&quot;)" title="Copy secret/basicauth-secret.yaml to clipboard"/></div><div class="includecode" id="secret-basicauth-secret-yaml"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>Secret<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">metadata</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>secret-basic-auth<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">type</span>:<span style="color:#bbb"> </span>kubernetes.io/basic-auth<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">stringData</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">username</span>:<span style="color:#bbb"> </span>admin<span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># required field for kubernetes.io/basic-auth</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">password</span>:<span style="color:#bbb"> </span>t0p-Secret<span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># required field for kubernetes.io/basic-auth</span></span></span></code></pre></div></div></div><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>The <code>stringData</code> field for a Secret does not work well with server-side apply.</div><p>The basic authentication Secret type is provided only for convenience.
You can create an <code>Opaque</code> type for credentials used for basic authentication.
However, using the defined and public Secret type (<code>kubernetes.io/basic-auth</code>) helps other
people to understand the purpose of your Secret, and sets a convention for what key names
to expect.</p><h3 id="ssh-authentication-secrets">SSH authentication Secrets</h3><p>The builtin type <code>kubernetes.io/ssh-auth</code> is provided for storing data used in
SSH authentication. When using this Secret type, you will have to specify a
<code>ssh-privatekey</code> key-value pair in the <code>data</code> (or <code>stringData</code>) field
as the SSH credential to use.</p><p>The following manifest is an example of a Secret used for SSH public/private
key authentication:</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/secret/ssh-auth-secret.yaml" download="secret/ssh-auth-secret.yaml"><code>secret/ssh-auth-secret.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" onclick="copyCode(&quot;secret-ssh-auth-secret-yaml&quot;)" title="Copy secret/ssh-auth-secret.yaml to clipboard"/></div><div class="includecode" id="secret-ssh-auth-secret-yaml"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>Secret<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">metadata</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>secret-ssh-auth<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">type</span>:<span style="color:#bbb"> </span>kubernetes.io/ssh-auth<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">data</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:#080;font-style:italic"># the data is abbreviated in this example</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">ssh-privatekey</span>:<span style="color:#bbb"> </span>|<span style="color:#b44;font-style:italic">
</span></span></span><span style="display:flex"><span><span style="color:#b44;font-style:italic">    UG91cmluZzYlRW1vdGljb24lU2N1YmE=</span><span style="color:#bbb">    </span></span></span></code></pre></div></div></div><p>The SSH authentication Secret type is provided only for convenience.
You can create an <code>Opaque</code> type for credentials used for SSH authentication.
However, using the defined and public Secret type (<code>kubernetes.io/ssh-auth</code>) helps other
people to understand the purpose of your Secret, and sets a convention for what key names
to expect.
The Kubernetes API verifies that the required keys are set for a Secret of this type.</p><div class="alert alert-caution" role="alert"><h4 class="alert-heading">Caution:</h4>SSH private keys do not establish trusted communication between an SSH client and
host server on their own. A secondary means of establishing trust is needed to
mitigate "man in the middle" attacks, such as a <code>known_hosts</code> file added to a ConfigMap.</div><h3 id="tls-secrets">TLS Secrets</h3><p>The <code>kubernetes.io/tls</code> Secret type is for storing
a certificate and its associated key that are typically used for TLS.</p><p>One common use for TLS Secrets is to configure encryption in transit for
an <a href="/docs/concepts/services-networking/ingress/">Ingress</a>, but you can also use it
with other resources or directly in your workload.
When using this type of Secret, the <code>tls.key</code> and the <code>tls.crt</code> key must be provided
in the <code>data</code> (or <code>stringData</code>) field of the Secret configuration, although the API
server doesn't actually validate the values for each key.</p><p>As an alternative to using <code>stringData</code>, you can use the <code>data</code> field to provide
the base64 encoded certificate and private key. For details, see
<a href="#restriction-names-data">Constraints on Secret names and data</a>.</p><p>The following YAML contains an example config for a TLS Secret:</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/secret/tls-auth-secret.yaml" download="secret/tls-auth-secret.yaml"><code>secret/tls-auth-secret.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" onclick="copyCode(&quot;secret-tls-auth-secret-yaml&quot;)" title="Copy secret/tls-auth-secret.yaml to clipboard"/></div><div class="includecode" id="secret-tls-auth-secret-yaml"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>Secret<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">metadata</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>secret-tls<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">type</span>:<span style="color:#bbb"> </span>kubernetes.io/tls<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">data</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:#080;font-style:italic"># values are base64 encoded, which obscures them but does NOT provide</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:#080;font-style:italic"># any useful level of confidentiality</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:#080;font-style:italic"># Replace the following values with your own base64-encoded certificate and key.</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">tls.crt</span>:<span style="color:#bbb"> </span><span style="color:#b44">"REPLACE_WITH_BASE64_CERT"</span><span style="color:#bbb"> 
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">tls.key</span>:<span style="color:#bbb"> </span><span style="color:#b44">"REPLACE_WITH_BASE64_KEY"</span></span></span></code></pre></div></div></div><p>The TLS Secret type is provided only for convenience.
You can create an <code>Opaque</code> type for credentials used for TLS authentication.
However, using the defined and public Secret type (<code>kubernetes.io/tls</code>)
helps ensure the consistency of Secret format in your project. The API server
verifies if the required keys are set for a Secret of this type.</p><p>To create a TLS Secret using <code>kubectl</code>, use the <code>tls</code> subcommand:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl create secret tls my-tls-secret <span style="color:#b62;font-weight:700">\
</span></span></span><span style="display:flex"><span><span style="color:#b62;font-weight:700"/>  --cert<span style="color:#666">=</span>path/to/cert/file <span style="color:#b62;font-weight:700">\
</span></span></span><span style="display:flex"><span><span style="color:#b62;font-weight:700"/>  --key<span style="color:#666">=</span>path/to/key/file
</span></span></code></pre></div><p>The public/private key pair must exist before hand. The public key certificate for <code>--cert</code> must be .PEM encoded
and must match the given private key for <code>--key</code>.</p><h3 id="bootstrap-token-secrets">Bootstrap token Secrets</h3><p>The <code>bootstrap.kubernetes.io/token</code> Secret type is for
tokens used during the node bootstrap process. It stores tokens used to sign
well-known ConfigMaps.</p><p>A bootstrap token Secret is usually created in the <code>kube-system</code> namespace and
named in the form <code>bootstrap-token-&lt;token-id&gt;</code> where <code>&lt;token-id&gt;</code> is a 6 character
string of the token ID.</p><p>As a Kubernetes manifest, a bootstrap token Secret might look like the
following:</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/secret/bootstrap-token-secret-base64.yaml" download="secret/bootstrap-token-secret-base64.yaml"><code>secret/bootstrap-token-secret-base64.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" onclick="copyCode(&quot;secret-bootstrap-token-secret-base64-yaml&quot;)" title="Copy secret/bootstrap-token-secret-base64.yaml to clipboard"/></div><div class="includecode" id="secret-bootstrap-token-secret-base64-yaml"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>Secret<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">metadata</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>bootstrap-token-5emitj<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">namespace</span>:<span style="color:#bbb"> </span>kube-system<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">type</span>:<span style="color:#bbb"> </span>bootstrap.kubernetes.io/token<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">data</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">auth-extra-groups</span>:<span style="color:#bbb"> </span>c3lzdGVtOmJvb3RzdHJhcHBlcnM6a3ViZWFkbTpkZWZhdWx0LW5vZGUtdG9rZW4=<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">expiration</span>:<span style="color:#bbb"> </span>MjAyMC0wOS0xM1QwNDozOToxMFo=<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">token-id</span>:<span style="color:#bbb"> </span>NWVtaXRq<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">token-secret</span>:<span style="color:#bbb"> </span>a3E0Z2lodnN6emduMXAwcg==<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">usage-bootstrap-authentication</span>:<span style="color:#bbb"> </span>dHJ1ZQ==<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">usage-bootstrap-signing</span>:<span style="color:#bbb"> </span>dHJ1ZQ==</span></span></code></pre></div></div></div><p>A bootstrap token Secret has the following keys specified under <code>data</code>:</p><ul><li><code>token-id</code>: A random 6 character string as the token identifier. Required.</li><li><code>token-secret</code>: A random 16 character string as the actual token Secret. Required.</li><li><code>description</code>: A human-readable string that describes what the token is
used for. Optional.</li><li><code>expiration</code>: An absolute UTC time using <a href="https://datatracker.ietf.org/doc/html/rfc3339">RFC3339</a> specifying when the token
should be expired. Optional.</li><li><code>usage-bootstrap-&lt;usage&gt;</code>: A boolean flag indicating additional usage for
the bootstrap token.</li><li><code>auth-extra-groups</code>: A comma-separated list of group names that will be
authenticated as in addition to the <code>system:bootstrappers</code> group.</li></ul><p>You can alternatively provide the values in the <code>stringData</code> field of the Secret
without base64 encoding them:</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/secret/bootstrap-token-secret-literal.yaml" download="secret/bootstrap-token-secret-literal.yaml"><code>secret/bootstrap-token-secret-literal.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" onclick="copyCode(&quot;secret-bootstrap-token-secret-literal-yaml&quot;)" title="Copy secret/bootstrap-token-secret-literal.yaml to clipboard"/></div><div class="includecode" id="secret-bootstrap-token-secret-literal-yaml"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>Secret<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">metadata</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:#080;font-style:italic"># Note how the Secret is named</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>bootstrap-token-5emitj<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:#080;font-style:italic"># A bootstrap token Secret usually resides in the kube-system namespace</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">namespace</span>:<span style="color:#bbb"> </span>kube-system<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">type</span>:<span style="color:#bbb"> </span>bootstrap.kubernetes.io/token<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">stringData</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">auth-extra-groups</span>:<span style="color:#bbb"> </span><span style="color:#b44">"system:bootstrappers:kubeadm:default-node-token"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">expiration</span>:<span style="color:#bbb"> </span><span style="color:#b44">"2020-09-13T04:39:10Z"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:#080;font-style:italic"># This token ID is used in the name</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">token-id</span>:<span style="color:#bbb"> </span><span style="color:#b44">"5emitj"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">token-secret</span>:<span style="color:#bbb"> </span><span style="color:#b44">"kq4gihvszzgn1p0r"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:#080;font-style:italic"># This token can be used for authentication</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">usage-bootstrap-authentication</span>:<span style="color:#bbb"> </span><span style="color:#b44">"true"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:#080;font-style:italic"># and it can be used for signing</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">usage-bootstrap-signing</span>:<span style="color:#bbb"> </span><span style="color:#b44">"true"</span></span></span></code></pre></div></div></div><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>The <code>stringData</code> field for a Secret does not work well with server-side apply.</div><h2 id="working-with-secrets">Working with Secrets</h2><h3 id="creating-a-secret">Creating a Secret</h3><p>There are several options to create a Secret:</p><ul><li><a href="/docs/tasks/configmap-secret/managing-secret-using-kubectl/">Use <code>kubectl</code></a></li><li><a href="/docs/tasks/configmap-secret/managing-secret-using-config-file/">Use a configuration file</a></li><li><a href="/docs/tasks/configmap-secret/managing-secret-using-kustomize/">Use the Kustomize tool</a></li></ul><h4 id="restriction-names-data">Constraints on Secret names and data</h4><p>The name of a Secret object must be a valid
<a href="/docs/concepts/overview/working-with-objects/names/#dns-subdomain-names">DNS subdomain name</a>.</p><p>You can specify the <code>data</code> and/or the <code>stringData</code> field when creating a
configuration file for a Secret. The <code>data</code> and the <code>stringData</code> fields are optional.
The values for all keys in the <code>data</code> field have to be base64-encoded strings.
If the conversion to base64 string is not desirable, you can choose to specify
the <code>stringData</code> field instead, which accepts arbitrary strings as values.</p><p>The keys of <code>data</code> and <code>stringData</code> must consist of alphanumeric characters,
<code>-</code>, <code>_</code> or <code>.</code>. All key-value pairs in the <code>stringData</code> field are internally
merged into the <code>data</code> field. If a key appears in both the <code>data</code> and the
<code>stringData</code> field, the value specified in the <code>stringData</code> field takes
precedence.</p><h4 id="restriction-data-size">Size limit</h4><p>Individual Secrets are limited to 1MiB in size. This is to discourage creation
of very large Secrets that could exhaust the API server and kubelet memory.
However, creation of many smaller Secrets could also exhaust memory. You can
use a <a href="/docs/concepts/policy/resource-quotas/">resource quota</a> to limit the
number of Secrets (or other resources) in a namespace.</p><h3 id="editing-a-secret">Editing a Secret</h3><p>You can edit an existing Secret unless it is <a href="#secret-immutable">immutable</a>. To
edit a Secret, use one of the following methods:</p><ul><li><a href="/docs/tasks/configmap-secret/managing-secret-using-kubectl/#edit-secret">Use <code>kubectl</code></a></li><li><a href="/docs/tasks/configmap-secret/managing-secret-using-config-file/#edit-secret">Use a configuration file</a></li></ul><p>You can also edit the data in a Secret using the <a href="/docs/tasks/configmap-secret/managing-secret-using-kustomize/#edit-secret">Kustomize tool</a>. However, this
method creates a new <code>Secret</code> object with the edited data.</p><p>Depending on how you created the Secret, as well as how the Secret is used in
your Pods, updates to existing <code>Secret</code> objects are propagated automatically to
Pods that use the data. For more information, refer to <a href="#using-secrets-as-files-from-a-pod">Using Secrets as files from a Pod</a> section.</p><h3 id="using-a-secret">Using a Secret</h3><p>Secrets can be mounted as data volumes or exposed as
<a class="glossary-tooltip" title="Container environment variables are name=value pairs that provide useful information into containers running in a Pod." data-toggle="tooltip" data-placement="top" href="/docs/concepts/containers/container-environment/" target="_blank" aria-label="environment variables">environment variables</a>
to be used by a container in a Pod. Secrets can also be used by other parts of the
system, without being directly exposed to the Pod. For example, Secrets can hold
credentials that other parts of the system should use to interact with external
systems on your behalf.</p><p>Secret volume sources are validated to ensure that the specified object
reference actually points to an object of type Secret. Therefore, a Secret
needs to be created before any Pods that depend on it.</p><p>If the Secret cannot be fetched (perhaps because it does not exist, or
due to a temporary lack of connection to the API server) the kubelet
periodically retries running that Pod. The kubelet also reports an Event
for that Pod, including details of the problem fetching the Secret.</p><h4 id="restriction-secret-must-exist">Optional Secrets</h4><p>When you reference a Secret in a Pod, you can mark the Secret as <em>optional</em>,
such as in the following example. If an optional Secret doesn't exist,
Kubernetes ignores it.</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/secret/optional-secret.yaml" download="secret/optional-secret.yaml"><code>secret/optional-secret.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" onclick="copyCode(&quot;secret-optional-secret-yaml&quot;)" title="Copy secret/optional-secret.yaml to clipboard"/></div><div class="includecode" id="secret-optional-secret-yaml"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>Pod<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">metadata</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>mypod<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">spec</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">containers</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>mypod<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">image</span>:<span style="color:#bbb"> </span>redis<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">volumeMounts</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>foo<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">mountPath</span>:<span style="color:#bbb"> </span><span style="color:#b44">"/etc/foo"</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">readOnly</span>:<span style="color:#bbb"> </span><span style="color:#a2f;font-weight:700">true</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">volumes</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>foo<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">secret</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">secretName</span>:<span style="color:#bbb"> </span>mysecret<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">optional</span>:<span style="color:#bbb"> </span><span style="color:#a2f;font-weight:700">true</span></span></span></code></pre></div></div></div><p>By default, Secrets are required. None of a Pod's containers will start until
all non-optional Secrets are available.</p><p>If a Pod references a specific key in a non-optional Secret and that Secret
does exist, but is missing the named key, the Pod fails during startup.</p><h3 id="using-secrets-as-files-from-a-pod">Using Secrets as files from a Pod</h3><p>If you want to access data from a Secret in a Pod, one way to do that is to
have Kubernetes make the value of that Secret be available as a file inside
the filesystem of one or more of the Pod's containers.</p><p>For instructions, refer to
<a href="/docs/tasks/inject-data-application/distribute-credentials-secure/#create-a-pod-that-has-access-to-the-secret-data-through-a-volume">Create a Pod that has access to the secret data through a Volume</a>.</p><p>When a volume contains data from a Secret, and that Secret is updated, Kubernetes tracks
this and updates the data in the volume, using an eventually-consistent approach.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>A container using a Secret as a
<a href="/docs/concepts/storage/volumes/#using-subpath">subPath</a> volume mount does not receive
automated Secret updates.</div><p>The kubelet keeps a cache of the current keys and values for the Secrets that are used in
volumes for pods on that node.
You can configure the way that the kubelet detects changes from the cached values. The
<code>configMapAndSecretChangeDetectionStrategy</code> field in the
<a href="/docs/reference/config-api/kubelet-config.v1beta1/">kubelet configuration</a> controls
which strategy the kubelet uses. The default strategy is <code>Watch</code>.</p><p>Updates to Secrets can be either propagated by an API watch mechanism (the default), based on
a cache with a defined time-to-live, or polled from the cluster API server on each kubelet
synchronisation loop.</p><p>As a result, the total delay from the moment when the Secret is updated to the moment
when new keys are projected to the Pod can be as long as the kubelet sync period + cache
propagation delay, where the cache propagation delay depends on the chosen cache type
(following the same order listed in the previous paragraph, these are:
watch propagation delay, the configured cache TTL, or zero for direct polling).</p><h3 id="using-secrets-as-environment-variables">Using Secrets as environment variables</h3><p>To use a Secret in an <a class="glossary-tooltip" title="Container environment variables are name=value pairs that provide useful information into containers running in a Pod." data-toggle="tooltip" data-placement="top" href="/docs/concepts/containers/container-environment/" target="_blank" aria-label="environment variable">environment variable</a>
in a Pod:</p><ol><li>For each container in your Pod specification, add an environment variable
for each Secret key that you want to use to the
<code>env[].valueFrom.secretKeyRef</code> field.</li><li>Modify your image and/or command line so that the program looks for values
in the specified environment variables.</li></ol><p>For instructions, refer to
<a href="/docs/tasks/inject-data-application/distribute-credentials-secure/#define-container-environment-variables-using-secret-data">Define container environment variables using Secret data</a>.</p><p>It's important to note that the range of characters allowed for environment variable
names in pods is <a href="/docs/tasks/inject-data-application/define-environment-variable-container/#using-environment-variables-inside-of-your-config">restricted</a>.
If any keys do not meet the rules, those keys are not made available to your container, though
the Pod is allowed to start.</p><h3 id="using-imagepullsecrets">Container image pull Secrets</h3><p>If you want to fetch container images from a private repository, you need a way for
the kubelet on each node to authenticate to that repository. You can configure
<em>image pull Secrets</em> to make this possible. These Secrets are configured at the Pod
level.</p><h4 id="using-imagepullsecrets-1">Using imagePullSecrets</h4><p>The <code>imagePullSecrets</code> field is a list of references to Secrets in the same namespace.
You can use an <code>imagePullSecrets</code> to pass a Secret that contains a Docker (or other) image registry
password to the kubelet. The kubelet uses this information to pull a private image on behalf of your Pod.
See the <a href="/docs/reference/generated/kubernetes-api/v1.34/#podspec-v1-core">PodSpec API</a>
for more information about the <code>imagePullSecrets</code> field.</p><h5 id="manually-specifying-an-imagepullsecret">Manually specifying an imagePullSecret</h5><p>You can learn how to specify <code>imagePullSecrets</code> from the
<a href="/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod">container images</a>
documentation.</p><h5 id="arranging-for-imagepullsecrets-to-be-automatically-attached">Arranging for imagePullSecrets to be automatically attached</h5><p>You can manually create <code>imagePullSecrets</code>, and reference these from a ServiceAccount. Any Pods
created with that ServiceAccount or created with that ServiceAccount by default, will get their
<code>imagePullSecrets</code> field set to that of the service account.
See <a href="/docs/tasks/configure-pod-container/configure-service-account/#add-imagepullsecrets-to-a-service-account">Add ImagePullSecrets to a service account</a>
for a detailed explanation of that process.</p><h3 id="restriction-static-pod">Using Secrets with static Pods</h3><p>You cannot use ConfigMaps or Secrets with <a class="glossary-tooltip" title="A pod managed directly by the kubelet daemon on a specific node." data-toggle="tooltip" data-placement="top" href="/docs/tasks/configure-pod-container/static-pod/" target="_blank" aria-label="static Pods">static Pods</a>.</p><h2 id="secret-immutable">Immutable Secrets</h2><div class="feature-state-notice feature-stable"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.21 [stable]</code></div><p>Kubernetes lets you mark specific Secrets (and ConfigMaps) as <em>immutable</em>.
Preventing changes to the data of an existing Secret has the following benefits:</p><ul><li>protects you from accidental (or unwanted) updates that could cause applications outages</li><li>(for clusters that extensively use Secrets - at least tens of thousands of unique Secret
to Pod mounts), switching to immutable Secrets improves the performance of your cluster
by significantly reducing load on kube-apiserver. The kubelet does not need to maintain
a [watch] on any Secrets that are marked as immutable.</li></ul><h3 id="secret-immutable-create">Marking a Secret as immutable</h3><p>You can create an immutable Secret by setting the <code>immutable</code> field to <code>true</code>. For example,</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>Secret<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">metadata</span>:<span style="color:#bbb"> </span>...<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">data</span>:<span style="color:#bbb"> </span>...<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">immutable</span>:<span style="color:#bbb"> </span><span style="color:#a2f;font-weight:700">true</span><span style="color:#bbb">
</span></span></span></code></pre></div><p>You can also update any existing mutable Secret to make it immutable.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>Once a Secret or ConfigMap is marked as immutable, it is <em>not</em> possible to revert this change
nor to mutate the contents of the <code>data</code> field. You can only delete and recreate the Secret.
Existing Pods maintain a mount point to the deleted Secret - it is recommended to recreate
these pods.</div><h2 id="information-security-for-secrets">Information security for Secrets</h2><p>Although ConfigMap and Secret work similarly, Kubernetes applies some additional
protection for Secret objects.</p><p>Secrets often hold values that span a spectrum of importance, many of which can
cause escalations within Kubernetes (e.g. service account tokens) and to
external systems. Even if an individual app can reason about the power of the
Secrets it expects to interact with, other apps within the same namespace can
render those assumptions invalid.</p><p>A Secret is only sent to a node if a Pod on that node requires it.
For mounting Secrets into Pods, the kubelet stores a copy of the data into a <code>tmpfs</code>
so that the confidential data is not written to durable storage.
Once the Pod that depends on the Secret is deleted, the kubelet deletes its local copy
of the confidential data from the Secret.</p><p>There may be several containers in a Pod. By default, containers you define
only have access to the default ServiceAccount and its related Secret.
You must explicitly define environment variables or map a volume into a
container in order to provide access to any other Secret.</p><p>There may be Secrets for several Pods on the same node. However, only the
Secrets that a Pod requests are potentially visible within its containers.
Therefore, one Pod does not have access to the Secrets of another Pod.</p><h3 id="configure-least-privilege-access-to-secrets">Configure least-privilege access to Secrets</h3><p>To enhance the security measures around Secrets, use separate namespaces to isolate access to mounted secrets.</p><div class="alert alert-danger" role="alert"><h4 class="alert-heading">Warning:</h4>Any containers that run with <code>privileged: true</code> on a node can access all
Secrets used on that node.</div><h2 id="what-s-next">What's next</h2><ul><li>For guidelines to manage and improve the security of your Secrets, refer to
<a href="/docs/concepts/security/secrets-good-practices/">Good practices for Kubernetes Secrets</a>.</li><li>Learn how to <a href="/docs/tasks/configmap-secret/managing-secret-using-kubectl/">manage Secrets using <code>kubectl</code></a></li><li>Learn how to <a href="/docs/tasks/configmap-secret/managing-secret-using-config-file/">manage Secrets using config file</a></li><li>Learn how to <a href="/docs/tasks/configmap-secret/managing-secret-using-kustomize/">manage Secrets using kustomize</a></li><li>Read the <a href="/docs/reference/kubernetes-api/config-and-storage-resources/secret-v1/">API reference</a> for <code>Secret</code></li></ul></div>