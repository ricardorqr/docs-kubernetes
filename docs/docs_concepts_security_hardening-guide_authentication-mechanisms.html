<div class="td-content"><h1 data-pagefind-weight="10">Hardening Guide - Authentication Mechanisms</h1><div class="lead">Information on authentication options in Kubernetes and their security properties.</div><p>Selecting the appropriate authentication mechanism(s) is a crucial aspect of securing your cluster.
Kubernetes provides several built-in mechanisms, each with its own strengths and weaknesses that
should be carefully considered when choosing the best authentication mechanism for your cluster.</p><p>In general, it is recommended to enable as few authentication mechanisms as possible to simplify
user management and prevent cases where users retain access to a cluster that is no longer required.</p><p>It is important to note that Kubernetes does not have an in-built user database within the cluster.
Instead, it takes user information from the configured authentication system and uses that to make
authorization decisions. Therefore, to audit user access, you need to review credentials from every
configured authentication source.</p><p>For production clusters with multiple users directly accessing the Kubernetes API, it is
recommended to use external authentication sources such as OIDC. The internal authentication
mechanisms, such as client certificates and service account tokens, described below, are not
suitable for this use case.</p><h2 id="x509-client-certificate-authentication">X.509 client certificate authentication</h2><p>Kubernetes leverages <a href="/docs/reference/access-authn-authz/authentication/#x509-client-certificates">X.509 client certificate</a>
authentication for system components, such as when the kubelet authenticates to the API Server.
While this mechanism can also be used for user authentication, it might not be suitable for
production use due to several restrictions:</p><ul><li>Client certificates cannot be individually revoked. Once compromised, a certificate can be used
by an attacker until it expires. To mitigate this risk, it is recommended to configure short
lifetimes for user authentication credentials created using client certificates.</li><li>If a certificate needs to be invalidated, the certificate authority must be re-keyed, which
can introduce availability risks to the cluster.</li><li>There is no permanent record of client certificates created in the cluster. Therefore, all
issued certificates must be recorded if you need to keep track of them.</li><li>Private keys used for client certificate authentication cannot be password-protected. Anyone
who can read the file containing the key will be able to make use of it.</li><li>Using client certificate authentication requires a direct connection from the client to the
API server without any intervening TLS termination points, which can complicate network architectures.</li><li>Group data is embedded in the <code>O</code> value of the client certificate, which means the user's group
memberships cannot be changed for the lifetime of the certificate.</li></ul><h2 id="static-token-file">Static token file</h2><p>Although Kubernetes allows you to load credentials from a
<a href="/docs/reference/access-authn-authz/authentication/#static-token-file">static token file</a> located
on the control plane node disks, this approach is not recommended for production servers due to
several reasons:</p><ul><li>Credentials are stored in clear text on control plane node disks, which can be a security risk.</li><li>Changing any credential requires a restart of the API server process to take effect, which can
impact availability.</li><li>There is no mechanism available to allow users to rotate their credentials. To rotate a
credential, a cluster administrator must modify the token on disk and distribute it to the users.</li><li>There is no lockout mechanism available to prevent brute-force attacks.</li></ul><h2 id="bootstrap-tokens">Bootstrap tokens</h2><p><a href="/docs/reference/access-authn-authz/bootstrap-tokens/">Bootstrap tokens</a> are used for joining
nodes to clusters and are not recommended for user authentication due to several reasons:</p><ul><li>They have hard-coded group memberships that are not suitable for general use, making them
unsuitable for authentication purposes.</li><li>Manually generating bootstrap tokens can lead to weak tokens that can be guessed by an attacker,
which can be a security risk.</li><li>There is no lockout mechanism available to prevent brute-force attacks, making it easier for
attackers to guess or crack the token.</li></ul><h2 id="serviceaccount-secret-tokens">ServiceAccount secret tokens</h2><p><a href="/docs/reference/access-authn-authz/service-accounts-admin/#manual-secret-management-for-serviceaccounts">Service account secrets</a>
are available as an option to allow workloads running in the cluster to authenticate to the
API server. In Kubernetes &lt; 1.23, these were the default option, however, they are being replaced
with TokenRequest API tokens. While these secrets could be used for user authentication, they are
generally unsuitable for a number of reasons:</p><ul><li>They cannot be set with an expiry and will remain valid until the associated service account is deleted.</li><li>The authentication tokens are visible to any cluster user who can read secrets in the namespace
that they are defined in.</li><li>Service accounts cannot be added to arbitrary groups complicating RBAC management where they are used.</li></ul><h2 id="tokenrequest-api-tokens">TokenRequest API tokens</h2><p>The TokenRequest API is a useful tool for generating short-lived credentials for service
authentication to the API server or third-party systems. However, it is not generally recommended
for user authentication as there is no revocation method available, and distributing credentials
to users in a secure manner can be challenging.</p><p>When using TokenRequest tokens for service authentication, it is recommended to implement a short
lifespan to reduce the impact of compromised tokens.</p><h2 id="openid-connect-token-authentication">OpenID Connect token authentication</h2><p>Kubernetes supports integrating external authentication services with the Kubernetes API using
<a href="/docs/reference/access-authn-authz/authentication/#openid-connect-tokens">OpenID Connect (OIDC)</a>.
There is a wide variety of software that can be used to integrate Kubernetes with an identity
provider. However, when using OIDC authentication in Kubernetes, it is important to consider the
following hardening measures:</p><ul><li>The software installed in the cluster to support OIDC authentication should be isolated from
general workloads as it will run with high privileges.</li><li>Some Kubernetes managed services are limited in the OIDC providers that can be used.</li><li>As with TokenRequest tokens, OIDC tokens should have a short lifespan to reduce the impact of
compromised tokens.</li></ul><h2 id="webhook-token-authentication">Webhook token authentication</h2><p><a href="/docs/reference/access-authn-authz/authentication/#webhook-token-authentication">Webhook token authentication</a>
is another option for integrating external authentication providers into Kubernetes. This mechanism
allows for an authentication service, either running inside the cluster or externally, to be
contacted for an authentication decision over a webhook. It is important to note that the suitability
of this mechanism will likely depend on the software used for the authentication service, and there
are some Kubernetes-specific considerations to take into account.</p><p>To configure Webhook authentication, access to control plane server filesystems is required. This
means that it will not be possible with Managed Kubernetes unless the provider specifically makes it
available. Additionally, any software installed in the cluster to support this access should be
isolated from general workloads, as it will run with high privileges.</p><h2 id="authenticating-proxy">Authenticating proxy</h2><p>Another option for integrating external authentication systems into Kubernetes is to use an
<a href="/docs/reference/access-authn-authz/authentication/#authenticating-proxy">authenticating proxy</a>.
With this mechanism, Kubernetes expects to receive requests from the proxy with specific header
values set, indicating the username and group memberships to assign for authorization purposes.
It is important to note that there are specific considerations to take into account when using
this mechanism.</p><p>Firstly, securely configured TLS must be used between the proxy and Kubernetes API server to
mitigate the risk of traffic interception or sniffing attacks. This ensures that the communication
between the proxy and Kubernetes API server is secure.</p><p>Secondly, it is important to be aware that an attacker who is able to modify the headers of the
request may be able to gain unauthorized access to Kubernetes resources. As such, it is important
to ensure that the headers are properly secured and cannot be tampered with.</p><h2 id="what-s-next">What's next</h2><ul><li><a href="/docs/reference/access-authn-authz/authentication/">User Authentication</a></li><li><a href="/docs/reference/access-authn-authz/bootstrap-tokens/">Authenticating with Bootstrap Tokens</a></li><li><a href="/docs/reference/access-authn-authz/kubelet-authn-authz/#kubelet-authentication">kubelet Authentication</a></li><li><a href="/docs/reference/access-authn-authz/service-accounts-admin/#bound-service-account-tokens">Authenticating with Service Account Tokens</a></li></ul></div>