<div class="td-content"><h1 data-pagefind-weight="10">Pods</h1><p><em>Pods</em> are the smallest deployable units of computing that you can create and manage in Kubernetes.</p><p>A <em>Pod</em> (as in a pod of whales or pea pod) is a group of one or more
<a class="glossary-tooltip" title="A lightweight and portable executable image that contains software and all of its dependencies." data-toggle="tooltip" data-placement="top" href="/docs/concepts/containers/" target="_blank" aria-label="containers">containers</a>, with shared storage and network resources, and a specification for how to run the containers. A Pod's contents are always co-located and
co-scheduled, and run in a shared context. A Pod models an
application-specific "logical host": it contains one or more application
containers which are relatively tightly coupled.
In non-cloud contexts, applications executed on the same physical or virtual machine are analogous to cloud applications executed on the same logical host.</p><p>As well as application containers, a Pod can contain
<a class="glossary-tooltip" title="One or more initialization containers that must run to completion before any app containers run." data-toggle="tooltip" data-placement="top" href="/docs/concepts/workloads/pods/init-containers/" target="_blank" aria-label="init containers">init containers</a> that run
during Pod startup. You can also inject
<a class="glossary-tooltip" title="A type of container type that you can temporarily run inside a Pod" data-toggle="tooltip" data-placement="top" href="/docs/concepts/workloads/pods/ephemeral-containers/" target="_blank" aria-label="ephemeral containers">ephemeral containers</a>
for debugging a running Pod.</p><h2 id="what-is-a-pod">What is a Pod?</h2><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>You need to install a <a href="/docs/setup/production-environment/container-runtimes/">container runtime</a>
into each node in the cluster so that Pods can run there.</div><p>The shared context of a Pod is a set of Linux namespaces, cgroups, and
potentially other facets of isolation - the same things that isolate a <a class="glossary-tooltip" title="A lightweight and portable executable image that contains software and all of its dependencies." data-toggle="tooltip" data-placement="top" href="/docs/concepts/containers/" target="_blank" aria-label="container">container</a>. Within a Pod's context, the individual applications may have
further sub-isolations applied.</p><p>A Pod is similar to a set of containers with shared namespaces and shared filesystem volumes.</p><p>Pods in a Kubernetes cluster are used in two main ways:</p><ul><li><p><strong>Pods that run a single container</strong>. The "one-container-per-Pod" model is the
most common Kubernetes use case; in this case, you can think of a Pod as a
wrapper around a single container; Kubernetes manages Pods rather than managing
the containers directly.</p></li><li><p><strong>Pods that run multiple containers that need to work together</strong>. A Pod can
encapsulate an application composed of
<a href="#how-pods-manage-multiple-containers">multiple co-located containers</a> that are
tightly coupled and need to share resources. These co-located containers
form a single cohesive unit.</p><p>Grouping multiple co-located and co-managed containers in a single Pod is a
relatively advanced use case. You should use this pattern only in specific
instances in which your containers are tightly coupled.</p><p>You don't need to run multiple containers to provide replication (for resilience
or capacity); if you need multiple replicas, see
<a href="/docs/concepts/workloads/controllers/">Workload management</a>.</p></li></ul><h2 id="using-pods">Using Pods</h2><p>The following is an example of a Pod which consists of a container running the image <code>nginx:1.14.2</code>.</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/pods/simple-pod.yaml" download="pods/simple-pod.yaml"><code>pods/simple-pod.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" onclick="copyCode(&quot;pods-simple-pod-yaml&quot;)" title="Copy pods/simple-pod.yaml to clipboard"/></div><div class="includecode" id="pods-simple-pod-yaml"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>Pod<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">metadata</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">spec</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">containers</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">image</span>:<span style="color:#bbb"> </span>nginx:1.14.2<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">ports</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span>- <span style="color:green;font-weight:700">containerPort</span>:<span style="color:#bbb"> </span><span style="color:#666">80</span><span style="color:#bbb">
</span></span></span></code></pre></div></div></div><p>To create the Pod shown above, run the following command:</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>kubectl apply -f https://k8s.io/examples/pods/simple-pod.yaml
</span></span></code></pre></div><p>Pods are generally not created directly and are created using workload resources.
See <a href="#working-with-pods">Working with Pods</a> for more information on how Pods are used
with workload resources.</p><h3 id="workload-resources-for-managing-pods">Workload resources for managing pods</h3><p>Usually you don't need to create Pods directly, even singleton Pods. Instead, create them using workload resources such as <a class="glossary-tooltip" title="Manages a replicated application on your cluster." data-toggle="tooltip" data-placement="top" href="/docs/concepts/workloads/controllers/deployment/" target="_blank" aria-label="Deployment">Deployment</a> or <a class="glossary-tooltip" title="A finite or batch task that runs to completion." data-toggle="tooltip" data-placement="top" href="/docs/concepts/workloads/controllers/job/" target="_blank" aria-label="Job">Job</a>.
If your Pods need to track state, consider the
<a class="glossary-tooltip" title="A StatefulSet manages deployment and scaling of a set of Pods, with durable storage and persistent identifiers for each Pod." data-toggle="tooltip" data-placement="top" href="/docs/concepts/workloads/controllers/statefulset/" target="_blank" aria-label="StatefulSet">StatefulSet</a> resource.</p><p>Each Pod is meant to run a single instance of a given application. If you want to
scale your application horizontally (to provide more overall resources by running
more instances), you should use multiple Pods, one for each instance. In
Kubernetes, this is typically referred to as <em>replication</em>.
Replicated Pods are usually created and managed as a group by a workload resource
and its <a class="glossary-tooltip" title="A control loop that watches the shared state of the cluster through the apiserver and makes changes attempting to move the current state towards the desired state." data-toggle="tooltip" data-placement="top" href="/docs/concepts/architecture/controller/" target="_blank" aria-label="controller">controller</a>.</p><p>See <a href="#pods-and-controllers">Pods and controllers</a> for more information on how
Kubernetes uses workload resources, and their controllers, to implement application
scaling and auto-healing.</p><p>Pods natively provide two kinds of shared resources for their constituent containers:
<a href="#pod-networking">networking</a> and <a href="#pod-storage">storage</a>.</p><h2 id="working-with-pods">Working with Pods</h2><p>You'll rarely create individual Pods directly in Kubernetes—even singleton Pods. This
is because Pods are designed as relatively ephemeral, disposable entities. When
a Pod gets created (directly by you, or indirectly by a
<a class="glossary-tooltip" title="A control loop that watches the shared state of the cluster through the apiserver and makes changes attempting to move the current state towards the desired state." data-toggle="tooltip" data-placement="top" href="/docs/concepts/architecture/controller/" target="_blank" aria-label="controller">controller</a>), the new Pod is
scheduled to run on a <a class="glossary-tooltip" title="A node is a worker machine in Kubernetes." data-toggle="tooltip" data-placement="top" href="/docs/concepts/architecture/nodes/" target="_blank" aria-label="Node">Node</a> in your cluster.
The Pod remains on that node until the Pod finishes execution, the Pod object is deleted,
the Pod is <em>evicted</em> for lack of resources, or the node fails.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>Restarting a container in a Pod should not be confused with restarting a Pod. A Pod
is not a process, but an environment for running container(s). A Pod persists until
it is deleted.</div><p>The name of a Pod must be a valid
<a href="/docs/concepts/overview/working-with-objects/names/#dns-subdomain-names">DNS subdomain</a>
value, but this can produce unexpected results for the Pod hostname. For best compatibility,
the name should follow the more restrictive rules for a
<a href="/docs/concepts/overview/working-with-objects/names/#dns-label-names">DNS label</a>.</p><h3 id="pod-os">Pod OS</h3><div class="feature-state-notice feature-stable"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.25 [stable]</code></div><p>You should set the <code>.spec.os.name</code> field to either <code>windows</code> or <code>linux</code> to indicate the OS on
which you want the pod to run. These two are the only operating systems supported for now by
Kubernetes. In the future, this list may be expanded.</p><p>In Kubernetes v1.34, the value of <code>.spec.os.name</code> does not affect
how the <a class="glossary-tooltip" title="Control plane component that watches for newly created pods with no assigned node, and selects a node for them to run on." data-toggle="tooltip" data-placement="top" href="/docs/reference/command-line-tools-reference/kube-scheduler/" target="_blank" aria-label="kube-scheduler">kube-scheduler</a>
picks a node for the Pod to run on. In any cluster where there is more than one operating system for
running nodes, you should set the
<a href="/docs/reference/labels-annotations-taints/#kubernetes-io-os">kubernetes.io/os</a>
label correctly on each node, and define pods with a <code>nodeSelector</code> based on the operating system
label. The kube-scheduler assigns your pod to a node based on other criteria and may or may not
succeed in picking a suitable node placement where the node OS is right for the containers in that Pod.
The <a href="/docs/concepts/security/pod-security-standards/">Pod security standards</a> also use this
field to avoid enforcing policies that aren't relevant to the operating system.</p><h3 id="pods-and-controllers">Pods and controllers</h3><p>You can use workload resources to create and manage multiple Pods for you. A controller
for the resource handles replication and rollout and automatic healing in case of
Pod failure. For example, if a Node fails, a controller notices that Pods on that
Node have stopped working and creates a replacement Pod. The scheduler places the
replacement Pod onto a healthy Node.</p><p>Here are some examples of workload resources that manage one or more Pods:</p><ul><li><a class="glossary-tooltip" title="Manages a replicated application on your cluster." data-toggle="tooltip" data-placement="top" href="/docs/concepts/workloads/controllers/deployment/" target="_blank" aria-label="Deployment">Deployment</a></li><li><a class="glossary-tooltip" title="A StatefulSet manages deployment and scaling of a set of Pods, with durable storage and persistent identifiers for each Pod." data-toggle="tooltip" data-placement="top" href="/docs/concepts/workloads/controllers/statefulset/" target="_blank" aria-label="StatefulSet">StatefulSet</a></li><li><a class="glossary-tooltip" title="Ensures a copy of a Pod is running across a set of nodes in a cluster." data-toggle="tooltip" data-placement="top" href="/docs/concepts/workloads/controllers/daemonset" target="_blank" aria-label="DaemonSet">DaemonSet</a></li></ul><h3 id="pod-templates">Pod templates</h3><p>Controllers for <a class="glossary-tooltip" title="A workload is an application running on Kubernetes." data-toggle="tooltip" data-placement="top" href="/docs/concepts/workloads/" target="_blank" aria-label="workload">workload</a> resources create Pods
from a <em>pod template</em> and manage those Pods on your behalf.</p><p>PodTemplates are specifications for creating Pods, and are included in workload resources such as
<a href="/docs/concepts/workloads/controllers/deployment/">Deployments</a>,
<a href="/docs/concepts/workloads/controllers/job/">Jobs</a>, and
<a href="/docs/concepts/workloads/controllers/daemonset/">DaemonSets</a>.</p><p>Each controller for a workload resource uses the <code>PodTemplate</code> inside the workload
object to make actual Pods. The <code>PodTemplate</code> is part of the desired state of whatever
workload resource you used to run your app.</p><p>When you create a Pod, you can include
<a href="/docs/tasks/inject-data-application/define-environment-variable-container/">environment variables</a>
in the Pod template for the containers that run in the Pod.</p><p>The sample below is a manifest for a simple Job with a <code>template</code> that starts one
container. The container in that Pod prints a message then pauses.</p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="display:flex"><span><span style="color:green;font-weight:700">apiVersion</span>:<span style="color:#bbb"> </span>batch/v1<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">kind</span>:<span style="color:#bbb"> </span>Job<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">metadata</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>hello<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb"/><span style="color:green;font-weight:700">spec</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">  </span><span style="color:green;font-weight:700">template</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># This is the pod template</span><span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:green;font-weight:700">spec</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">containers</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span>- <span style="color:green;font-weight:700">name</span>:<span style="color:#bbb"> </span>hello<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">image</span>:<span style="color:#bbb"> </span>busybox:1.28<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">        </span><span style="color:green;font-weight:700">command</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">'sh'</span>,<span style="color:#bbb"> </span><span style="color:#b44">'-c'</span>,<span style="color:#bbb"> </span><span style="color:#b44">'echo "Hello, Kubernetes!" &amp;&amp; sleep 3600'</span>]<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">      </span><span style="color:green;font-weight:700">restartPolicy</span>:<span style="color:#bbb"> </span>OnFailure<span style="color:#bbb">
</span></span></span><span style="display:flex"><span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># The pod template ends here</span><span style="color:#bbb">
</span></span></span></code></pre></div><p>Modifying the pod template or switching to a new pod template has no direct effect
on the Pods that already exist. If you change the pod template for a workload
resource, that resource needs to create replacement Pods that use the updated template.</p><p>For example, the StatefulSet controller ensures that the running Pods match the current
pod template for each StatefulSet object. If you edit the StatefulSet to change its pod
template, the StatefulSet starts to create new Pods based on the updated template.
Eventually, all of the old Pods are replaced with new Pods, and the update is complete.</p><p>Each workload resource implements its own rules for handling changes to the Pod template.
If you want to read more about StatefulSet specifically, read
<a href="/docs/tutorials/stateful-application/basic-stateful-set/#updating-statefulsets">Update strategy</a> in the StatefulSet Basics tutorial.</p><p>On Nodes, the <a class="glossary-tooltip" title="An agent that runs on each node in the cluster. It makes sure that containers are running in a pod." data-toggle="tooltip" data-placement="top" href="/docs/reference/command-line-tools-reference/kubelet" target="_blank" aria-label="kubelet">kubelet</a> does not
directly observe or manage any of the details around pod templates and updates; those
details are abstracted away. That abstraction and separation of concerns simplifies
system semantics, and makes it feasible to extend the cluster's behavior without
changing existing code.</p><h2 id="pod-update-and-replacement">Pod update and replacement</h2><p>As mentioned in the previous section, when the Pod template for a workload
resource is changed, the controller creates new Pods based on the updated
template instead of updating or patching the existing Pods.</p><p>Kubernetes doesn't prevent you from managing Pods directly. It is possible to
update some fields of a running Pod, in place. However, Pod update operations
like
<a href="/docs/reference/generated/kubernetes-api/v1.34/#patch-pod-v1-core"><code>patch</code></a>, and
<a href="/docs/reference/generated/kubernetes-api/v1.34/#replace-pod-v1-core"><code>replace</code></a>
have some limitations:</p><ul><li><p>Most of the metadata about a Pod is immutable. For example, you cannot
change the <code>namespace</code>, <code>name</code>, <code>uid</code>, or <code>creationTimestamp</code> fields.</p></li><li><p>If the <code>metadata.deletionTimestamp</code> is set, no new entry can be added to the
<code>metadata.finalizers</code> list.</p></li><li><p>Pod updates may not change fields other than <code>spec.containers[*].image</code>,
<code>spec.initContainers[*].image</code>, <code>spec.activeDeadlineSeconds</code>, <code>spec.terminationGracePeriodSeconds</code>,
<code>spec.tolerations</code> or <code>spec.schedulingGates</code>. For <code>spec.tolerations</code>, you can only add new entries.</p></li><li><p>When updating the <code>spec.activeDeadlineSeconds</code> field, two types of updates
are allowed:</p><ol><li>setting the unassigned field to a positive number;</li><li>updating the field from a positive number to a smaller, non-negative
number.</li></ol></li></ul><h3 id="pod-subresources">Pod subresources</h3><p>The above update rules apply to regular pod updates, but other pod fields can be updated through <em>subresources</em>.</p><ul><li><strong>Resize:</strong> The <code>resize</code> subresource allows container resources (<code>spec.containers[*].resources</code>) to be updated.
See <a href="/docs/tasks/configure-pod-container/resize-container-resources/">Resize Container Resources</a> for more details.</li><li><strong>Ephemeral Containers:</strong> The <code>ephemeralContainers</code> subresource allows
<a class="glossary-tooltip" title="A type of container type that you can temporarily run inside a Pod" data-toggle="tooltip" data-placement="top" href="/docs/concepts/workloads/pods/ephemeral-containers/" target="_blank" aria-label="ephemeral containers">ephemeral containers</a>
to be added to a Pod.
See <a href="/docs/concepts/workloads/pods/ephemeral-containers/">Ephemeral Containers</a> for more details.</li><li><strong>Status:</strong> The <code>status</code> subresource allows the pod status to be updated.
This is typically only used by the Kubelet and other system controllers.</li><li><strong>Binding:</strong> The <code>binding</code> subresource allows setting the pod's <code>spec.nodeName</code> via a <code>Binding</code> request.
This is typically only used by the <a class="glossary-tooltip" title="Control plane component that watches for newly created pods with no assigned node, and selects a node for them to run on." data-toggle="tooltip" data-placement="top" href="/docs/reference/command-line-tools-reference/kube-scheduler/" target="_blank" aria-label="scheduler">scheduler</a>.</li></ul><h3 id="pod-generation">Pod generation</h3><ul><li>The <code>metadata.generation</code> field is unique. It will be automatically set by the
system such that new pods have a <code>metadata.generation</code> of 1, and every update to
mutable fields in the pod's spec will increment the <code>metadata.generation</code> by 1.</li></ul><div class="feature-state-notice feature-beta" title="Feature Gate: PodObservedGenerationTracking"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.34 [beta]</code> (enabled by default: true)</div><ul><li><code>observedGeneration</code> is a field that is captured in the <code>status</code> section of the Pod
object. If the feature gate <code>PodObservedGenerationTracking</code> is set, the Kubelet will set <code>status.observedGeneration</code>
to track the pod state to the current pod status. The pod's <code>status.observedGeneration</code> will reflect the
<code>metadata.generation</code> of the pod at the point that the pod status is being reported.</li></ul><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>The <code>status.observedGeneration</code> field is managed by the kubelet and external controllers should <strong>not</strong> modify this field.</div><p>Different status fields may either be associated with the <code>metadata.generation</code> of the current sync loop, or with the
<code>metadata.generation</code> of the previous sync loop. The key distinction is whether a change in the <code>spec</code> is reflected
directly in the <code>status</code> or is an indirect result of a running process.</p><h4 id="direct-status-updates">Direct Status Updates</h4><p>For status fields where the allocated spec is directly reflected, the <code>observedGeneration</code> will
be associated with the current <code>metadata.generation</code> (Generation N).</p><p>This behavior applies to:</p><ul><li><strong>Resize Status</strong>: The status of a resource resize operation.</li><li><strong>Allocated Resources</strong>: The resources allocated to the Pod after a resize.</li><li><strong>Ephemeral Containers</strong>: When a new ephemeral container is added, and it is in <code>Waiting</code> state.</li></ul><h4 id="indirect-status-updates">Indirect Status Updates</h4><p>For status fields that are an indirect result of running the spec, the <code>observedGeneration</code> will be associated
with the <code>metadata.generation</code> of the previous sync loop (Generation N-1).</p><p>This behavior applies to:</p><ul><li><strong>Container Image</strong>: The <code>ContainerStatus.ImageID</code> reflects the image from the previous generation until the new image
is pulled and the container is updated.</li><li><strong>Actual Resources</strong>: During an in-progress resize, the actual resources in use still belong to the previous generation's
request.</li><li><strong>Container state</strong>: During an in-progress resize, with require restart policy reflects the previous generation's
request.</li><li><strong>activeDeadlineSeconds</strong> &amp; <strong>terminationGracePeriodSeconds</strong> &amp; <strong>deletionTimestamp</strong>: The effects of these fields on the
Pod's status are a result of the previously observed specification.</li></ul><h2 id="resource-sharing-and-communication">Resource sharing and communication</h2><p>Pods enable data sharing and communication among their constituent
containers.</p><h3 id="pod-storage">Storage in Pods</h3><p>A Pod can specify a set of shared storage
<a class="glossary-tooltip" title="A directory containing data, accessible to the containers in a pod." data-toggle="tooltip" data-placement="top" href="/docs/concepts/storage/volumes/" target="_blank" aria-label="volumes">volumes</a>. All containers
in the Pod can access the shared volumes, allowing those containers to
share data. Volumes also allow persistent data in a Pod to survive
in case one of the containers within needs to be restarted. See
<a href="/docs/concepts/storage/">Storage</a> for more information on how
Kubernetes implements shared storage and makes it available to Pods.</p><h3 id="pod-networking">Pod networking</h3><p>Each Pod is assigned a unique IP address for each address family. Every
container in a Pod shares the network namespace, including the IP address and
network ports. Inside a Pod (and <strong>only</strong> then), the containers that belong to the Pod
can communicate with one another using <code>localhost</code>. When containers in a Pod communicate
with entities <em>outside the Pod</em>,
they must coordinate how they use the shared network resources (such as ports).
Within a Pod, containers share an IP address and port space, and
can find each other via <code>localhost</code>. The containers in a Pod can also communicate
with each other using standard inter-process communications like SystemV semaphores
or POSIX shared memory. Containers in different Pods have distinct IP addresses
and can not communicate by OS-level IPC without special configuration.
Containers that want to interact with a container running in a different Pod can
use IP networking to communicate.</p><p>Containers within the Pod see the system hostname as being the same as the configured
<code>name</code> for the Pod. There's more about this in the <a href="/docs/concepts/cluster-administration/networking/">networking</a>
section.</p><h2 id="pod-security">Pod security settings</h2><p>To set security constraints on Pods and containers, you use the
<code>securityContext</code> field in the Pod specification. This field gives you
granular control over what a Pod or individual containers can do. For example:</p><ul><li>Drop specific Linux capabilities to avoid the impact of a CVE.</li><li>Force all processes in the Pod to run as a non-root user or as a specific
user or group ID.</li><li>Set a specific seccomp profile.</li><li>Set Windows security options, such as whether containers run as HostProcess.</li></ul><div class="alert alert-caution" role="alert"><h4 class="alert-heading">Caution:</h4>You can also use the Pod securityContext to enable
<a href="/docs/concepts/security/linux-kernel-security-constraints/#privileged-containers"><em>privileged mode</em></a>
in Linux containers. Privileged mode overrides many of the other security
settings in the securityContext. Avoid using this setting unless you can't grant
the equivalent permissions by using other fields in the securityContext.
In Kubernetes 1.26 and later, you can run Windows containers in a similarly
privileged mode by setting the <code>windowsOptions.hostProcess</code> flag on the
security context of the Pod spec. For details and instructions, see
<a href="/docs/tasks/configure-pod-container/create-hostprocess-pod/">Create a Windows HostProcess Pod</a>.</div><ul><li>To learn about kernel-level security constraints that you can use,
see <a href="/docs/concepts/security/linux-kernel-security-constraints/">Linux kernel security constraints for Pods and containers</a>.</li><li>To learn more about the Pod security context, see
<a href="/docs/tasks/configure-pod-container/security-context/">Configure a Security Context for a Pod or Container</a>.</li></ul><h2 id="static-pods">Static Pods</h2><p><em>Static Pods</em> are managed directly by the kubelet daemon on a specific node,
without the <a class="glossary-tooltip" title="Control plane component that serves the Kubernetes API." data-toggle="tooltip" data-placement="top" href="/docs/concepts/architecture/#kube-apiserver" target="_blank" aria-label="API server">API server</a>
observing them.
Whereas most Pods are managed by the control plane (for example, a
<a class="glossary-tooltip" title="Manages a replicated application on your cluster." data-toggle="tooltip" data-placement="top" href="/docs/concepts/workloads/controllers/deployment/" target="_blank" aria-label="Deployment">Deployment</a>), for static
Pods, the kubelet directly supervises each static Pod (and restarts it if it fails).</p><p>Static Pods are always bound to one <a class="glossary-tooltip" title="An agent that runs on each node in the cluster. It makes sure that containers are running in a pod." data-toggle="tooltip" data-placement="top" href="/docs/reference/command-line-tools-reference/kubelet" target="_blank" aria-label="Kubelet">Kubelet</a> on a specific node.
The main use for static Pods is to run a self-hosted control plane: in other words,
using the kubelet to supervise the individual <a href="/docs/concepts/architecture/#control-plane-components">control plane components</a>.</p><p>The kubelet automatically tries to create a <a class="glossary-tooltip" title="An object in the API server that tracks a static pod on a kubelet." data-toggle="tooltip" data-placement="top" href="/docs/reference/glossary/?all=true#term-mirror-pod" target="_blank" aria-label="mirror Pod">mirror Pod</a>
on the Kubernetes API server for each static Pod.
This means that the Pods running on a node are visible on the API server,
but cannot be controlled from there. See the guide <a href="/docs/tasks/configure-pod-container/static-pod/">Create static Pods</a>
for more information.</p><div class="alert alert-info" role="alert"><h4 class="alert-heading">Note:</h4>The <code>spec</code> of a static Pod cannot refer to other API objects
(e.g., <a class="glossary-tooltip" title="Provides an identity for processes that run in a Pod." data-toggle="tooltip" data-placement="top" href="/docs/tasks/configure-pod-container/configure-service-account/" target="_blank" aria-label="ServiceAccount">ServiceAccount</a>,
<a class="glossary-tooltip" title="An API object used to store non-confidential data in key-value pairs. Can be consumed as environment variables, command-line arguments, or configuration files in a volume." data-toggle="tooltip" data-placement="top" href="/docs/concepts/configuration/configmap/" target="_blank" aria-label="ConfigMap">ConfigMap</a>,
<a class="glossary-tooltip" title="Stores sensitive information, such as passwords, OAuth tokens, and ssh keys." data-toggle="tooltip" data-placement="top" href="/docs/concepts/configuration/secret/" target="_blank" aria-label="Secret">Secret</a>, etc).</div><h2 id="how-pods-manage-multiple-containers">Pods with multiple containers</h2><p>Pods are designed to support multiple cooperating processes (as containers) that form
a cohesive unit of service. The containers in a Pod are automatically co-located and
co-scheduled on the same physical or virtual machine in the cluster. The containers
can share resources and dependencies, communicate with one another, and coordinate
when and how they are terminated.</p><p>Pods in a Kubernetes cluster are used in two main ways:</p><ul><li><strong>Pods that run a single container</strong>. The "one-container-per-Pod" model is the
most common Kubernetes use case; in this case, you can think of a Pod as a
wrapper around a single container; Kubernetes manages Pods rather than managing
the containers directly.</li><li><strong>Pods that run multiple containers that need to work together</strong>. A Pod can
encapsulate an application composed of
multiple co-located containers that are
tightly coupled and need to share resources. These co-located containers
form a single cohesive unit of service—for example, one container serving data
stored in a shared volume to the public, while a separate
<a class="glossary-tooltip" title="An auxilliary container that stays running throughout the lifecycle of a Pod." data-toggle="tooltip" data-placement="top" href="/docs/concepts/workloads/pods/sidecar-containers/" target="_blank" aria-label="sidecar container">sidecar container</a>
refreshes or updates those files.
The Pod wraps these containers, storage resources, and an ephemeral network
identity together as a single unit.</li></ul><p>For example, you might have a container that
acts as a web server for files in a shared volume, and a separate
<a href="/docs/concepts/workloads/pods/sidecar-containers/">sidecar container</a>
that updates those files from a remote source, as in the following diagram:</p><figure class="diagram-medium"><img src="/images/docs/pod.svg" alt="Pod creation diagram"/></figure><p>Some Pods have <a class="glossary-tooltip" title="One or more initialization containers that must run to completion before any app containers run." data-toggle="tooltip" data-placement="top" href="/docs/concepts/workloads/pods/init-containers/" target="_blank" aria-label="init containers">init containers</a>
as well as <a class="glossary-tooltip" title="A container used to run part of a workload. Compare with init container." data-toggle="tooltip" data-placement="top" href="/docs/reference/glossary/?all=true#term-app-container" target="_blank" aria-label="app containers">app containers</a>.
By default, init containers run and complete before the app containers are started.</p><p>You can also have <a href="/docs/concepts/workloads/pods/sidecar-containers/">sidecar containers</a>
that provide auxiliary services to the main application Pod (for example: a service mesh).</p><div class="feature-state-notice feature-stable" title="Feature Gate: SidecarContainers"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.33 [stable]</code> (enabled by default: true)</div><p>Enabled by default, the <code>SidecarContainers</code> <a href="/docs/reference/command-line-tools-reference/feature-gates/">feature gate</a>
allows you to specify <code>restartPolicy: Always</code> for init containers.
Setting the <code>Always</code> restart policy ensures that the containers where you set it are
treated as <em>sidecars</em> that are kept running during the entire lifetime of the Pod.
Containers that you explicitly define as sidecar containers
start up before the main application Pod and remain running until the Pod is
shut down.</p><h2 id="container-probes">Container probes</h2><p>A <em>probe</em> is a diagnostic performed periodically by the kubelet on a container.
To perform a diagnostic, the kubelet can invoke different actions:</p><ul><li><code>ExecAction</code> (performed with the help of the container runtime)</li><li><code>TCPSocketAction</code> (checked directly by the kubelet)</li><li><code>HTTPGetAction</code> (checked directly by the kubelet)</li></ul><p>You can read more about <a href="/docs/concepts/workloads/pods/pod-lifecycle/#container-probes">probes</a>
in the Pod Lifecycle documentation.</p><h2 id="what-s-next">What's next</h2><ul><li>Learn about the <a href="/docs/concepts/workloads/pods/pod-lifecycle/">lifecycle of a Pod</a>.</li><li>Learn about <a href="/docs/concepts/containers/runtime-class/">RuntimeClass</a> and how you can use it to
configure different Pods with different container runtime configurations.</li><li>Read about <a href="/docs/concepts/workloads/pods/disruptions/">PodDisruptionBudget</a>
and how you can use it to manage application availability during disruptions.</li><li>Pod is a top-level resource in the Kubernetes REST API.
The
<a href="/docs/reference/kubernetes-api/workload-resources/pod-v1/">Pod</a>
object definition describes the object in detail.</li><li><a href="/blog/2015/06/the-distributed-system-toolkit-patterns/">The Distributed System Toolkit: Patterns for Composite Containers</a> explains common layouts for Pods with more than one container.</li><li>Read about <a href="/docs/concepts/scheduling-eviction/topology-spread-constraints/">Pod topology spread constraints</a></li></ul><p>To understand the context for why Kubernetes wraps a common Pod API in other resources
(such as <a class="glossary-tooltip" title="A StatefulSet manages deployment and scaling of a set of Pods, with durable storage and persistent identifiers for each Pod." data-toggle="tooltip" data-placement="top" href="/docs/concepts/workloads/controllers/statefulset/" target="_blank" aria-label="StatefulSets">StatefulSets</a> or
<a class="glossary-tooltip" title="Manages a replicated application on your cluster." data-toggle="tooltip" data-placement="top" href="/docs/concepts/workloads/controllers/deployment/" target="_blank" aria-label="Deployments">Deployments</a>),
you can read about the prior art, including:</p><ul><li><a href="https://aurora.apache.org/documentation/latest/reference/configuration/#job-schema">Aurora</a></li><li><a href="https://research.google/pubs/large-scale-cluster-management-at-google-with-borg/">Borg</a></li><li><a href="https://github.com/d2iq-archive/marathon">Marathon</a></li><li><a href="https://research.google/pubs/pub41684/">Omega</a></li><li><a href="https://engineering.fb.com/data-center-engineering/tupperware/">Tupperware</a>.</li></ul><div class="section-index"/></div>