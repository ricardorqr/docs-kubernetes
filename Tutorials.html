<meta charset='UTF-8'>
<div><div class="td-content"><p>This section of the Kubernetes documentation contains tutorials.
A tutorial shows how to accomplish a goal that is larger than a single
<a href="/docs/tasks/">task</a>. Typically a tutorial has several sections,
each of which has a sequence of steps.
Before walking through each tutorial, you may want to bookmark the
<a href="/docs/reference/glossary/">Standardized Glossary</a> page for later references.</p><h2 id="basics">Basics</h2><ul><li><a href="/docs/tutorials/kubernetes-basics/">Kubernetes Basics</a> is an in-depth interactive tutorial that helps you understand the Kubernetes system and try out some basic Kubernetes features.</li><li><a href="https://www.edx.org/course/introduction-kubernetes-linuxfoundationx-lfs158x">Introduction to Kubernetes (edX)</a></li><li><a href="/docs/tutorials/hello-minikube/">Hello Minikube</a></li></ul><h2 id="configuration">Configuration</h2><ul><li><a href="/docs/tutorials/configuration/configure-redis-using-configmap/">Configuring Redis Using a ConfigMap</a></li></ul><h2 id="authoring-pods">Authoring Pods</h2><ul><li><a href="/docs/tutorials/configuration/pod-sidecar-containers/">Adopting Sidecar Containers</a></li></ul><h2 id="stateless-applications">Stateless Applications</h2><ul><li><a href="/docs/tutorials/stateless-application/expose-external-ip-address/">Exposing an External IP Address to Access an Application in a Cluster</a></li><li><a href="/docs/tutorials/stateless-application/guestbook/">Example: Deploying PHP Guestbook application with Redis</a></li></ul><h2 id="stateful-applications">Stateful Applications</h2><ul><li><a href="/docs/tutorials/stateful-application/basic-stateful-set/">StatefulSet Basics</a></li><li><a href="/docs/tutorials/stateful-application/mysql-wordpress-persistent-volume/">Example: WordPress and MySQL with Persistent Volumes</a></li><li><a href="/docs/tutorials/stateful-application/cassandra/">Example: Deploying Cassandra with Stateful Sets</a></li><li><a href="/docs/tutorials/stateful-application/zookeeper/">Running ZooKeeper, A CP Distributed System</a></li></ul><h2 id="services">Services</h2><ul><li><a href="/docs/tutorials/services/connect-applications-service/">Connecting Applications with Services</a></li><li><a href="/docs/tutorials/services/source-ip/">Using Source IP</a></li></ul><h2 id="security">Security</h2><ul><li><a href="/docs/tutorials/security/cluster-level-pss/">Apply Pod Security Standards at Cluster level</a></li><li><a href="/docs/tutorials/security/ns-level-pss/">Apply Pod Security Standards at Namespace level</a></li><li><a href="/docs/tutorials/security/apparmor/">Restrict a Container's Access to Resources with AppArmor</a></li><li><a href="/docs/tutorials/security/seccomp/">Seccomp</a></li></ul><h2 id="cluster-management">Cluster Management</h2><ul><li><a href="/docs/tutorials/cluster-management/provision-swap-memory/">Configuring Swap Memory on Kubernetes Nodes</a></li><li><a href="/docs/tutorials/cluster-management/kubelet-standalone/">Running Kubelet in Standalone Mode</a></li><li><a href="/docs/tutorials/cluster-management/install-use-dra/">Install Drivers and Allocate Devices with DRA</a></li></ul><h2 id="what-s-next">What's next</h2><p>If you would like to write a tutorial, see
<a href="/docs/contribute/style/page-content-types/">Content Page Types</a>
for information about the tutorial page type.</p><div class="section-index"></div></div></div><div><div class="td-content"><h1>Hello Minikube</h1><p>This tutorial shows you how to run a sample app on Kubernetes using minikube.
The tutorial provides a container image that uses NGINX to echo back all the requests.</p><h2 id="objectives">Objectives</h2><ul><li>Deploy a sample application to minikube.</li><li>Run the app.</li><li>View application logs.</li></ul><h2 id="before-you-begin">Before you begin</h2><p>This tutorial assumes that you have already set up <code>minikube</code>.
See <strong>Step 1</strong> in <a href="https://minikube.sigs.k8s.io/docs/start/">minikube start</a> for installation instructions.<div class="alert alert-info"><h4 class="alert-heading">Note:</h4>Only execute the instructions in <strong>Step 1, Installation</strong>. The rest is covered on this page.</div></p><p>You also need to install <code>kubectl</code>.
See <a href="/docs/tasks/tools/#kubectl">Install tools</a> for installation instructions.</p><h2 id="create-a-minikube-cluster">Create a minikube cluster</h2><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>minikube start
</span></span></code></pre></div><h2 id="open-the-dashboard">Open the Dashboard</h2><p>Open the Kubernetes dashboard. You can do this two different ways:</p><ul class="nav nav-tabs" id="dashboard"><li class="nav-item"><a class="nav-link active" href="#dashboard-0">Launch a browser</a></li><li class="nav-item"><a class="nav-link" href="#dashboard-1">URL copy and paste</a></li></ul><div class="tab-content" id="dashboard"><div id="dashboard-0" class="tab-pane show active"><p><p>Open a <strong>new</strong> terminal, and run:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span># Start a new terminal, and leave this running.</span>
</span></span><span><span>minikube dashboard
</span></span></code></pre></div><p>Now, switch back to the terminal where you ran <code>minikube start</code>.</p><div class="alert alert-info"><h4 class="alert-heading">Note:</h4><p>The <code>dashboard</code> command enables the dashboard add-on and opens the proxy in the default web browser.
You can create Kubernetes resources on the dashboard such as Deployment and Service.</p><p>To find out how to avoid directly invoking the browser from the terminal and get a URL for the web dashboard, see the "URL copy and paste" tab.</p><p>By default, the dashboard is only accessible from within the internal Kubernetes virtual network.
The <code>dashboard</code> command creates a temporary proxy to make the dashboard accessible from outside the Kubernetes virtual network.</p><p>To stop the proxy, run <code>Ctrl+C</code> to exit the process.
After the command exits, the dashboard remains running in the Kubernetes cluster.
You can run the <code>dashboard</code> command again to create another proxy to access the dashboard.</p></div></p></div><div id="dashboard-1" class="tab-pane"><p><p>If you don't want minikube to open a web browser for you, run the <code>dashboard</code> subcommand with the
<code>--url</code> flag. <code>minikube</code> outputs a URL that you can open in the browser you prefer.</p><p>Open a <strong>new</strong> terminal, and run:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span># Start a new terminal, and leave this running.</span>
</span></span><span><span>minikube dashboard --url
</span></span></code></pre></div><p>Now, you can use this URL and switch back to the terminal where you ran <code>minikube start</code>.</p></p></div></div><h2 id="create-a-deployment">Create a Deployment</h2><p>A Kubernetes <a href="/docs/concepts/workloads/pods/"><em>Pod</em></a> is a group of one or more Containers,
tied together for the purposes of administration and networking. The Pod in this
tutorial has only one Container. A Kubernetes
<a href="/docs/concepts/workloads/controllers/deployment/"><em>Deployment</em></a> checks on the health of your
Pod and restarts the Pod's Container if it terminates. Deployments are the
recommended way to manage the creation and scaling of Pods.</p><ol><li><p>Use the <code>kubectl create</code> command to create a Deployment that manages a Pod. The
Pod runs a Container based on the provided Docker image.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span># Run a test container image that includes a webserver</span>
</span></span><span><span>kubectl create deployment hello-node --image<span>=</span>registry.k8s.io/e2e-test-images/agnhost:2.53 -- /agnhost netexec --http-port<span>=</span><span>8080</span>
</span></span></code></pre></div></li><li><p>View the Deployment:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get deployments
</span></span></code></pre></div><p>The output is similar to:</p><pre tabindex="0"><code>NAME         READY   UP-TO-DATE   AVAILABLE   AGE
hello-node   1/1     1            1           1m
</code></pre><p>(It may take some time for the pod to become available. If you see "0/1", try again in a few seconds.)</p></li><li><p>View the Pod:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pods
</span></span></code></pre></div><p>The output is similar to:</p><pre tabindex="0"><code>NAME                          READY     STATUS    RESTARTS   AGE
hello-node-5f76cf6ccf-br9b5   1/1       Running   0          1m
</code></pre></li><li><p>View cluster events:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get events
</span></span></code></pre></div></li><li><p>View the <code>kubectl</code> configuration:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl config view
</span></span></code></pre></div></li><li><p>View application logs for a container in a pod (replace pod name with the one you got from <code>kubectl get pods</code>).</p><div class="alert alert-info"><h4 class="alert-heading">Note:</h4>Replace <code>hello-node-5f76cf6ccf-br9b5</code> in the <code>kubectl logs</code> command with the name of the pod from the <code>kubectl get pods</code> command output.</div><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl logs hello-node-5f76cf6ccf-br9b5
</span></span></code></pre></div><p>The output is similar to:</p><pre tabindex="0"><code>I0911 09:19:26.677397       1 log.go:195] Started HTTP server on port 8080
I0911 09:19:26.677586       1 log.go:195] Started UDP server on port  8081
</code></pre></li></ol><div class="alert alert-info"><h4 class="alert-heading">Note:</h4>For more information about <code>kubectl</code> commands, see the <a href="/docs/reference/kubectl/">kubectl overview</a>.</div><h2 id="create-a-service">Create a Service</h2><p>By default, the Pod is only accessible by its internal IP address within the
Kubernetes cluster. To make the <code>hello-node</code> Container accessible from outside the
Kubernetes virtual network, you have to expose the Pod as a
Kubernetes <a href="/docs/concepts/services-networking/service/"><em>Service</em></a>.</p><div class="alert alert-danger"><h4 class="alert-heading">Warning:</h4>The agnhost container has a <code>/shell</code> endpoint, which is useful for
debugging, but dangerous to expose to the public internet. Do not run this on an
internet-facing cluster, or a production cluster.</div><ol><li><p>Expose the Pod to the public internet using the <code>kubectl expose</code> command:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl expose deployment hello-node --type<span>=</span>LoadBalancer --port<span>=</span><span>8080</span>
</span></span></code></pre></div><p>The <code>--type=LoadBalancer</code> flag indicates that you want to expose your Service
outside of the cluster.</p><p>The application code inside the test image only listens on TCP port 8080. If you used
<code>kubectl expose</code> to expose a different port, clients could not connect to that other port.</p></li><li><p>View the Service you created:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get services
</span></span></code></pre></div><p>The output is similar to:</p><pre tabindex="0"><code>NAME         TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE
hello-node   LoadBalancer   10.108.144.78   &lt;pending&gt;     8080:30369/TCP   21s
kubernetes   ClusterIP      10.96.0.1       &lt;none&gt;        443/TCP          23m
</code></pre><p>On cloud providers that support load balancers,
an external IP address would be provisioned to access the Service. On minikube,
the <code>LoadBalancer</code> type makes the Service accessible through the <code>minikube service</code>
command.</p></li><li><p>Run the following command:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>minikube service hello-node
</span></span></code></pre></div><p>This opens up a browser window that serves your app and shows the app's response.</p></li></ol><h2 id="enable-addons">Enable addons</h2><p>The minikube tool includes a set of built-in <a class="glossary-tooltip" title="Resources that extend the functionality of Kubernetes." href="/docs/concepts/cluster-administration/addons/" target="_blank">addons</a> that can be enabled, disabled and opened in the local Kubernetes environment.</p><ol><li><p>List the currently supported addons:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>minikube addons list
</span></span></code></pre></div><p>The output is similar to:</p><pre tabindex="0"><code>addon-manager: enabled
dashboard: enabled
default-storageclass: enabled
efk: disabled
freshpod: disabled
gvisor: disabled
helm-tiller: disabled
ingress: disabled
ingress-dns: disabled
logviewer: disabled
metrics-server: disabled
nvidia-driver-installer: disabled
nvidia-gpu-device-plugin: disabled
registry: disabled
registry-creds: disabled
storage-provisioner: enabled
storage-provisioner-gluster: disabled
</code></pre></li><li><p>Enable an addon, for example, <code>metrics-server</code>:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>minikube addons <span>enable</span> metrics-server
</span></span></code></pre></div><p>The output is similar to:</p><pre tabindex="0"><code>The 'metrics-server' addon is enabled
</code></pre></li><li><p>View the Pod and Service you created by installing that addon:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pod,svc -n kube-system
</span></span></code></pre></div><p>The output is similar to:</p><pre tabindex="0"><code>NAME                                        READY     STATUS    RESTARTS   AGE
pod/coredns-5644d7b6d9-mh9ll                1/1       Running   0          34m
pod/coredns-5644d7b6d9-pqd2t                1/1       Running   0          34m
pod/metrics-server-67fb648c5                1/1       Running   0          26s
pod/etcd-minikube                           1/1       Running   0          34m
pod/influxdb-grafana-b29w8                  2/2       Running   0          26s
pod/kube-addon-manager-minikube             1/1       Running   0          34m
pod/kube-apiserver-minikube                 1/1       Running   0          34m
pod/kube-controller-manager-minikube        1/1       Running   0          34m
pod/kube-proxy-rnlps                        1/1       Running   0          34m
pod/kube-scheduler-minikube                 1/1       Running   0          34m
pod/storage-provisioner                     1/1       Running   0          34m

NAME                           TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)             AGE
service/metrics-server         ClusterIP   10.96.241.45    &lt;none&gt;        80/TCP              26s
service/kube-dns               ClusterIP   10.96.0.10      &lt;none&gt;        53/UDP,53/TCP       34m
service/monitoring-grafana     NodePort    10.99.24.54     &lt;none&gt;        80:30002/TCP        26s
service/monitoring-influxdb    ClusterIP   10.111.169.94   &lt;none&gt;        8083/TCP,8086/TCP   26s
</code></pre></li><li><p>Check the output from <code>metrics-server</code>:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl top pods
</span></span></code></pre></div><p>The output is similar to:</p><pre tabindex="0"><code>NAME                         CPU(cores)   MEMORY(bytes)   
hello-node-ccf4b9788-4jn97   1m           6Mi             
</code></pre><p>If you see the following message, wait, and try again:</p><pre tabindex="0"><code>error: Metrics API not available
</code></pre></li><li><p>Disable <code>metrics-server</code>:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>minikube addons disable metrics-server
</span></span></code></pre></div><p>The output is similar to:</p><pre tabindex="0"><code>metrics-server was successfully disabled
</code></pre></li></ol><h2 id="clean-up">Clean up</h2><p>Now you can clean up the resources you created in your cluster:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl delete service hello-node
</span></span><span><span>kubectl delete deployment hello-node
</span></span></code></pre></div><p>Stop the Minikube cluster</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>minikube stop
</span></span></code></pre></div><p>Optionally, delete the Minikube VM:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span># Optional</span>
</span></span><span><span>minikube delete
</span></span></code></pre></div><p>If you want to use minikube again to learn more about Kubernetes, you don't need to delete it.</p><h2 id="conclusion">Conclusion</h2><p>This page covered the basic aspects to get a minikube cluster up and running. You are now ready to deploy applications.</p><h2 id="what-s-next">What's next</h2><ul><li>Tutorial to <em><a href="/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro/">deploy your first app on Kubernetes with kubectl</a></em>.</li><li>Learn more about <a href="/docs/concepts/workloads/controllers/deployment/">Deployment objects</a>.</li><li>Learn more about <a href="/docs/tasks/run-application/run-stateless-application-deployment/">Deploying applications</a>.</li><li>Learn more about <a href="/docs/concepts/services-networking/service/">Service objects</a>.</li></ul></div></div><div><div class="td-content"><h1>Learn Kubernetes Basics</h1><h2 id="objectives">Objectives</h2><p>This tutorial provides a walkthrough of the basics of the Kubernetes cluster orchestration
system. Each module contains some background information on major Kubernetes features
and concepts, and a tutorial for you to follow along.</p><p>Using the tutorials, you can learn to:</p><ul><li>Deploy a containerized application on a cluster.</li><li>Scale the deployment.</li><li>Update the containerized application with a new software version.</li><li>Debug the containerized application.</li></ul><h2 id="what-can-kubernetes-do-for-you">What can Kubernetes do for you?</h2><p>With modern web services, users expect applications to be available 24/7, and developers
expect to deploy new versions of those applications several times a day. Containerization
helps package software to serve these goals, enabling applications to be released and updated
without downtime. Kubernetes helps you make sure those containerized applications run where
and when you want, and helps them find the resources and tools they need to work. Kubernetes
is a production-ready, open source platform designed with Google's accumulated experience in
container orchestration, combined with best-of-breed ideas from the community.</p><h2 id="kubernetes-basics-modules">Kubernetes Basics Modules</h2><div class="tutorials-modules"><div class="module"><a href="/docs/tutorials/kubernetes-basics/create-cluster/cluster-intro/"><img src="/docs/tutorials/kubernetes-basics/public/images/module_01.svg?v=1469803628347" alt="Module 1"><h5>1. Create a Kubernetes cluster</h5></a></div><div class="module"><a href="/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro/"><img src="/docs/tutorials/kubernetes-basics/public/images/module_02.svg?v=1469803628347" alt="Module 2"><h5>2. Deploy an app</h5></a></div><div class="module"><a href="/docs/tutorials/kubernetes-basics/explore/explore-intro/"><img src="/docs/tutorials/kubernetes-basics/public/images/module_03.svg?v=1469803628347" alt="Module 3"><h5>3. Explore your app</h5></a></div><div class="module"><a href="/docs/tutorials/kubernetes-basics/expose/expose-intro/"><img src="/docs/tutorials/kubernetes-basics/public/images/module_04.svg?v=1469803628347" alt="Module 4"><h5>4. Expose your app publicly</h5></a></div><div class="module"><a href="/docs/tutorials/kubernetes-basics/scale/scale-intro/"><img src="/docs/tutorials/kubernetes-basics/public/images/module_05.svg?v=1469803628347" alt="Module 5"><h5>5. Scale up your app</h5></a></div><div class="module"><a href="/docs/tutorials/kubernetes-basics/update/update-intro/"><img src="/docs/tutorials/kubernetes-basics/public/images/module_06.svg?v=1469803628347" alt="Module 6"><h5>6. Update your app</h5></a></div></div><h2 id="what-s-next">What's next</h2><ul><li>Tutorial <a href="/docs/tutorials/kubernetes-basics/create-cluster/">Using Minikube to Create a Cluster</a></li></ul><div class="section-index"></div></div></div><div><div class="td-content"><h1>Create a Cluster</h1><p>Learn about Kubernetes <a class="glossary-tooltip" title="A set of worker machines, called nodes, that run containerized applications. Every cluster has at least one worker node." href="/docs/reference/glossary/?all=true#term-cluster" target="_blank">cluster</a> and create a simple cluster using Minikube.</p><div class="section-index"><hr class="panel-line"><div class="entry"><h5><a href="/docs/tutorials/kubernetes-basics/create-cluster/cluster-intro/">Using Minikube to Create a Cluster</a></h5><p></p></div></div></div></div><div><div class="td-content"><h1>Using Minikube to Create a Cluster</h1><h2 id="objectives">Objectives</h2><ul><li>Learn what a Kubernetes cluster is.</li><li>Learn what Minikube is.</li><li>Start a Kubernetes cluster on your computer.</li></ul><h2 id="kubernetes-clusters">Kubernetes Clusters</h2><div class="alert alert-primary"><em>Kubernetes is a production-grade, open-source platform that orchestrates
the placement (scheduling) and execution of application containers
within and across computer clusters.</em></div><p><strong>Kubernetes coordinates a highly available cluster of computers that are connected
to work as a single unit.</strong> The abstractions in Kubernetes allow you to deploy
containerized applications to a cluster without tying them specifically to individual
machines. To make use of this new model of deployment, applications need to be packaged
in a way that decouples them from individual hosts: they need to be containerized.
Containerized applications are more flexible and available than in past deployment models,
where applications were installed directly onto specific machines as packages deeply
integrated into the host. <strong>Kubernetes automates the distribution and scheduling of
application containers across a cluster in a more efficient way.</strong> Kubernetes is an
open-source platform and is production-ready.</p><p>A Kubernetes cluster consists of two types of resources:</p><ul><li>The <strong>Control Plane</strong> coordinates the cluster</li><li><strong>Nodes</strong> are the workers that run applications</li></ul><h3 id="cluster-diagram">Cluster Diagram</h3><figure><img src="/docs/tutorials/kubernetes-basics/public/images/module_01_cluster.svg"></figure><p><strong>The Control Plane is responsible for managing the cluster.</strong> The Control Plane
coordinates all activities in your cluster, such as scheduling applications, maintaining
applications' desired state, scaling applications, and rolling out new updates.</p><div class="alert alert-primary"><em>Control Planes manage the cluster and the nodes that are used to host the running
applications.</em></div><p><strong>A node is a VM or a physical computer that serves as a worker machine in a Kubernetes
cluster.</strong> Each node has a Kubelet, which is an agent for managing the node and
communicating with the Kubernetes control plane. The node should also have tools for
handling container operations, such as <a class="glossary-tooltip" title="A container runtime with an emphasis on simplicity, robustness and portability" href="https://containerd.io/docs/" target="_blank">containerd</a>
or <a class="glossary-tooltip" title="A lightweight container runtime specifically for Kubernetes" href="https://cri-o.io/#what-is-cri-o" target="_blank">CRI-O</a>. A Kubernetes cluster that handles production
traffic should have a minimum of three nodes because if one node goes down, both an
<a href="/docs/concepts/architecture/#etcd">etcd</a> member and a control plane instance are lost,
and redundancy is compromised. You can mitigate this risk by adding more control plane nodes.</p><p>When you deploy applications on Kubernetes, you tell the control plane to start
the application containers. The control plane schedules the containers to run on
the cluster's nodes. <strong>Node-level components, such as the kubelet, communicate
with the control plane using the <a href="/docs/concepts/overview/kubernetes-api/">Kubernetes API</a></strong>,
which the control plane exposes. End users can also use the Kubernetes API directly
to interact with the cluster.</p><p>A Kubernetes cluster can be deployed on either physical or virtual machines. To
get started with Kubernetes development, you can use Minikube. Minikube is a lightweight
Kubernetes implementation that creates a VM on your local machine and deploys a
simple cluster containing only one node. Minikube is available for Linux, macOS,
and Windows systems. The Minikube CLI provides basic bootstrapping operations for
working with your cluster, including start, stop, status, and delete.</p><h2 id="what-s-next">What's next</h2><ul><li>Tutorial <a href="/docs/tutorials/hello-minikube/">Hello Minikube</a>.</li><li>Learn more about <a href="/docs/concepts/architecture/">Cluster Architecture</a>.</li></ul></div></div><div><div class="td-content"><h1>Deploy an App</h1><div class="section-index"><hr class="panel-line"><div class="entry"><h5><a href="/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro/">Using kubectl to Create a Deployment</a></h5><p></p></div></div></div></div><div><div class="td-content"><h1>Using kubectl to Create a Deployment</h1><h2 id="objectives">Objectives</h2><ul><li>Learn about application Deployments.</li><li>Deploy your first app on Kubernetes with kubectl.</li></ul><h2 id="kubernetes-deployments">Kubernetes Deployments</h2><div class="alert alert-primary"><em>A Deployment is responsible for creating and updating instances of your application.</em></div><div class="alert alert-info"><h4 class="alert-heading">Note:</h4>This tutorial uses a container that requires the AMD64 architecture. If you are using
minikube on a computer with a different CPU architecture, you could try using minikube with
a driver that can emulate AMD64. For example, the Docker Desktop driver can do this.</div><p>Once you have a <a href="/docs/tutorials/kubernetes-basics/create-cluster/cluster-intro/">running Kubernetes cluster</a>,
you can deploy your containerized applications on top of it. To do so, you create a
Kubernetes <strong>Deployment</strong>. The Deployment instructs Kubernetes how to create and
update instances of your application. Once you've created a Deployment, the Kubernetes
control plane schedules the application instances included in that Deployment to run
on individual Nodes in the cluster.</p><p>Once the application instances are created, a Kubernetes Deployment controller continuously
monitors those instances. If the Node hosting an instance goes down or is deleted,
the Deployment controller replaces the instance with an instance on another Node
in the cluster. <strong>This provides a self-healing mechanism to address machine failure
or maintenance.</strong></p><p>In a pre-orchestration world, installation scripts would often be used to start
applications, but they did not allow recovery from machine failure. By both creating
your application instances and keeping them running across Nodes, Kubernetes Deployments
provide a fundamentally different approach to application management.</p><h2 id="deploying-your-first-app-on-kubernetes">Deploying your first app on Kubernetes</h2><div class="alert alert-primary"><em>Applications need to be packaged into one of the supported container formats in
order to be deployed on Kubernetes.</em></div><figure class="diagram-medium"><img src="/docs/tutorials/kubernetes-basics/public/images/module_02_first_app.svg"></figure><p>You can create and manage a Deployment by using the Kubernetes command line interface,
<a href="/docs/reference/kubectl/">kubectl</a>. <code>kubectl</code> uses the Kubernetes API to interact
with the cluster. In this module, you'll learn the most common <code>kubectl</code> commands
needed to create Deployments that run your applications on a Kubernetes cluster.</p><p>When you create a Deployment, you'll need to specify the container image for your
application and the number of replicas that you want to run. You can change that
information later by updating your Deployment; <a href="/docs/tutorials/kubernetes-basics/scale/scale-intro/">Module 5</a>
and <a href="/docs/tutorials/kubernetes-basics/update/update-intro/">Module 6</a> of the bootcamp
discuss how you can scale and update your Deployments.</p><p>For your first Deployment, you'll use a hello-node application packaged in a Docker
container that uses NGINX to echo back all the requests. (If you didn't already try
creating a hello-node application and deploying it using a container, you can do
that first by following the instructions from the <a href="/docs/tutorials/hello-minikube/">Hello Minikube tutorial</a>.)</p><p>You will need to have installed kubectl as well. If you need to install it, visit
<a href="/docs/tasks/tools/#kubectl">install tools</a>.</p><p>Now that you know what Deployments are, let's deploy our first app!</p><h3 id="kubectl-basics">kubectl basics</h3><p>The common format of a kubectl command is: <code>kubectl action resource</code>.</p><p>This performs the specified <em>action</em> (like <code>create</code>, <code>describe</code> or <code>delete</code>) on the
specified <em>resource</em> (like <code>node</code> or <code>deployment</code>. You can use <code>--help</code> after the
subcommand to get additional info about possible parameters (for example: <code>kubectl get nodes --help</code>).</p><p>Check that kubectl is configured to talk to your cluster, by running the <code>kubectl version</code> command.</p><p>Check that kubectl is installed and that you can see both the client and the server versions.</p><p>To view the nodes in the cluster, run the <code>kubectl get nodes</code> command.</p><p>You see the available nodes. Later, Kubernetes will choose where to deploy our
application based on Node available resources.</p><h3 id="deploy-an-app">Deploy an app</h3><p>Let&#8217;s deploy our first app on Kubernetes with the <code>kubectl create deployment</code> command.
We need to provide the deployment name and app image location (include the full
repository url for images hosted outside Docker Hub).</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl create deployment kubernetes-bootcamp --image<span>=</span>gcr.io/google-samples/kubernetes-bootcamp:v1
</span></span></code></pre></div><p>Great! You just deployed your first application by creating a deployment. This performed a few things for you:</p><ul><li>searched for a suitable node where an instance of the application could be run (we have only 1 available node)</li><li>scheduled the application to run on that Node</li><li>configured the cluster to reschedule the instance on a new Node when needed</li></ul><p>To list your deployments use the <code>kubectl get deployments</code> command:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get deployments
</span></span></code></pre></div><p>We see that there is 1 deployment running a single instance of your app. The instance
is running inside a container on your node.</p><h3 id="view-the-app">View the app</h3><p><a href="/docs/concepts/workloads/pods/">Pods</a> that are running inside Kubernetes are running
on a private, isolated network. By default they are visible from other pods and services
within the same Kubernetes cluster, but not outside that network. When we use <code>kubectl</code>,
we're interacting through an API endpoint to communicate with our application.</p><p>We will cover other options on how to expose your application outside the Kubernetes
cluster later, in <a href="/docs/tutorials/kubernetes-basics/expose/">Module 4</a>.
Also as a basic tutorial, we're not explaining what <code>Pods</code> are in any
detail here, it will be covered in later topics.</p><p>The <code>kubectl proxy</code> command can create a proxy that will forward communications
into the cluster-wide, private network. The proxy can be terminated by pressing
control-C and won't show any output while it's running.</p><p><strong>You need to open a second terminal window to run the proxy.</strong></p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl proxy
</span></span></code></pre></div><p>We now have a connection between our host (the terminal) and the Kubernetes cluster.
The proxy enables direct access to the API from these terminals.</p><p>You can see all those APIs hosted through the proxy endpoint. For example, we can
query the version directly through the API using the <code>curl</code> command:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>curl http://localhost:8001/version
</span></span></code></pre></div><div class="alert alert-info"><h4 class="alert-heading">Note:</h4>If port 8001 is not accessible, ensure that the <code>kubectl proxy</code> that you started
above is running in the second terminal.</div><p>The API server will automatically create an endpoint for each pod, based on the
pod name, that is also accessible through the proxy.</p><p>First we need to get the Pod name, and we'll store it in the environment variable <code>POD_NAME</code>.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span>export</span> <span>POD_NAME</span><span>=</span><span>$(</span>kubectl get pods -o go-template --template <span>'{{range .items}}{{.metadata.name}}{{"\n"}}{{end}}'</span><span>)</span>
</span></span><span><span><span>echo</span> Name of the Pod: <span>$POD_NAME</span>
</span></span></code></pre></div><p>You can access the Pod through the proxied API, by running:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>curl http://localhost:8001/api/v1/namespaces/default/pods/<span>$POD_NAME</span>:8080/proxy/
</span></span></code></pre></div><p>In order for the new Deployment to be accessible without using the proxy, a Service
is required which will be explained in <a href="/docs/tutorials/kubernetes-basics/expose/">Module 4</a>.</p><h2 id="what-s-next">What's next</h2><ul><li>Tutorial <a href="/docs/tutorials/kubernetes-basics/explore/explore-intro/">Viewing Pods and Nodes</a>.</li><li>Learn more about <a href="/docs/concepts/workloads/controllers/deployment/">Deployments</a>.</li></ul></div></div><div><div class="td-content"><h1>Explore Your App</h1><div class="section-index"><hr class="panel-line"><div class="entry"><h5><a href="/docs/tutorials/kubernetes-basics/explore/explore-intro/">Viewing Pods and Nodes</a></h5><p></p></div></div></div></div><div><div class="td-content"><h1>Viewing Pods and Nodes</h1><h2 id="objectives">Objectives</h2><ul><li>Learn about Kubernetes Pods.</li><li>Learn about Kubernetes Nodes.</li><li>Troubleshoot deployed applications.</li></ul><h2 id="kubernetes-pods">Kubernetes Pods</h2><div class="alert alert-primary"><em>A Pod is a group of one or more application containers (such as Docker) and includes
shared storage (volumes), IP address and information about how to run them.</em></div><p>When you created a Deployment in <a href="/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro/">Module 2</a>,
Kubernetes created a <strong>Pod</strong> to host your application instance. A Pod is a Kubernetes
abstraction that represents a group of one or more application containers (such as Docker),
and some shared resources for those containers. Those resources include:</p><ul><li>Shared storage, as Volumes</li><li>Networking, as a unique cluster IP address</li><li>Information about how to run each container, such as the container image version
or specific ports to use</li></ul><p>A Pod models an application-specific "logical host" and can contain different application
containers which are relatively tightly coupled. For example, a Pod might include
both the container with your Node.js app as well as a different container that feeds
the data to be published by the Node.js webserver. The containers in a Pod share an
IP Address and port space, are always co-located and co-scheduled, and run in a shared
context on the same Node.</p><p>Pods are the atomic unit on the Kubernetes platform. When we create a Deployment
on Kubernetes, that Deployment creates Pods with containers inside them (as opposed
to creating containers directly). Each Pod is tied to the Node where it is scheduled,
and remains there until termination (according to restart policy) or deletion. In
case of a Node failure, identical Pods are scheduled on other available Nodes in
the cluster.</p><h3 id="pods-overview">Pods overview</h3><figure class="diagram-medium"><img src="/docs/tutorials/kubernetes-basics/public/images/module_03_pods.svg"></figure><div class="alert alert-primary"><em>Containers should only be scheduled together in a single Pod if they are tightly
coupled and need to share resources such as disk.</em></div><h2 id="nodes">Nodes</h2><p>A Pod always runs on a <strong>Node</strong>. A Node is a worker machine in Kubernetes and may
be either a virtual or a physical machine, depending on the cluster. Each Node is
managed by the control plane. A Node can have multiple pods, and the Kubernetes
control plane automatically handles scheduling the pods across the Nodes in the
cluster. The control plane's automatic scheduling takes into account the available
resources on each Node.</p><p>Every Kubernetes Node runs at least:</p><ul><li><p>Kubelet, a process responsible for communication between the Kubernetes control
plane and the Node; it manages the Pods and the containers running on a machine.</p></li><li><p>A container runtime (like Docker) responsible for pulling the container image
from a registry, unpacking the container, and running the application.</p></li></ul><h3 id="nodes-overview">Nodes overview</h3><figure class="diagram-medium"><img src="/docs/tutorials/kubernetes-basics/public/images/module_03_nodes.svg"></figure><h2 id="troubleshooting-with-kubectl">Troubleshooting with kubectl</h2><p>In <a href="/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro/">Module 2</a>, you used
the kubectl command-line interface. You'll continue to use it in Module 3 to get
information about deployed applications and their environments. The most common
operations can be done with the following kubectl subcommands:</p><ul><li><code>kubectl get</code> - list resources</li><li><code>kubectl describe</code> - show detailed information about a resource</li><li><code>kubectl logs</code> - print the logs from a container in a pod</li><li><code>kubectl exec</code> - execute a command on a container in a pod</li></ul><p>You can use these commands to see when applications were deployed, what their current
statuses are, where they are running and what their configurations are.</p><p>Now that we know more about our cluster components and the command line, let's
explore our application.</p><h3 id="check-application-configuration">Check application configuration</h3><p>Let's verify that the application we deployed in the previous scenario is running.
We'll use the <code>kubectl get</code> command and look for existing Pods:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pods
</span></span></code></pre></div><p>If no pods are running, please wait a couple of seconds and list the Pods again.
You can continue once you see one Pod running.</p><p>Next, to view what containers are inside that Pod and what images are used to build
those containers we run the <code>kubectl describe pods</code> command:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl describe pods
</span></span></code></pre></div><p>We see here details about the Pod&#8217;s container: IP address, the ports used and a
list of events related to the lifecycle of the Pod.</p><p>The output of the <code>describe</code> subcommand is extensive and covers some concepts that
we didn&#8217;t explain yet, but don&#8217;t worry, they will become familiar by the end of this tutorial.</p><div class="alert alert-info"><h4 class="alert-heading">Note:</h4>The <code>describe</code> subcommand can be used to get detailed information about most of the
Kubernetes primitives, including Nodes, Pods, and Deployments. The describe output is
designed to be human readable, not to be scripted against.</div><h3 id="show-the-app-in-the-terminal">Show the app in the terminal</h3><p>Recall that Pods are running in an isolated, private network - so we need to proxy access
to them so we can debug and interact with them. To do this, we'll use the <code>kubectl proxy</code>
command to run a proxy in a <strong>second terminal</strong>. Open a new terminal window, and
in that new terminal, run:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl proxy
</span></span></code></pre></div><p>Now again, we'll get the Pod name and query that pod directly through the proxy.
To get the Pod name and store it in the <code>POD_NAME</code> environment variable:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span>export</span> <span>POD_NAME</span><span>=</span><span>"</span><span>$(</span>kubectl get pods -o go-template --template <span>'{{range .items}}{{.metadata.name}}{{"\n"}}{{end}}'</span><span>)</span><span>"</span>
</span></span><span><span><span>echo</span> Name of the Pod: <span>$POD_NAME</span>
</span></span></code></pre></div><p>To see the output of our application, run a <code>curl</code> request:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>curl http://localhost:8001/api/v1/namespaces/default/pods/<span>$POD_NAME</span>:8080/proxy/
</span></span></code></pre></div><p>The URL is the route to the API of the Pod.</p><div class="alert alert-info"><h4 class="alert-heading">Note:</h4>We don't need to specify the container name, because we only have one container inside the pod.</div><h3 id="executing-commands-on-the-container">Executing commands on the container</h3><p>We can execute commands directly on the container once the Pod is up and running.
For this, we use the <code>exec</code> subcommand and use the name of the Pod as a parameter.
Let&#8217;s list the environment variables:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl <span>exec</span> <span>"</span><span>$POD_NAME</span><span>"</span> -- env
</span></span></code></pre></div><p>Again, it's worth mentioning that the name of the container itself can be omitted
since we only have a single container in the Pod.</p><p>Next let&#8217;s start a bash session in the Pod&#8217;s container:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl <span>exec</span> -ti <span>$POD_NAME</span> -- bash
</span></span></code></pre></div><p>We have now an open console on the container where we run our NodeJS application.
The source code of the app is in the <code>server.js</code> file:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>cat server.js
</span></span></code></pre></div><p>You can check that the application is up by running a curl command:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>curl http://localhost:8080
</span></span></code></pre></div><div class="alert alert-info"><h4 class="alert-heading">Note:</h4>Here we used <code>localhost</code> because we executed the command inside the NodeJS Pod.
If you cannot connect to <code>localhost:8080</code>, check to make sure you have run the
<code>kubectl exec</code> command and are launching the command from within the Pod.</div><p>To close your container connection, type <code>exit</code>.</p><h2 id="what-s-next">What's next</h2><ul><li>Tutorial
<a href="/docs/tutorials/kubernetes-basics/expose/expose-intro/">Using A Service To Expose Your App</a>.</li><li>Learn more about <a href="/docs/concepts/workloads/pods/">Pods</a>.</li><li>Learn more about <a href="/docs/concepts/architecture/nodes/">Nodes</a>.</li></ul></div></div><div><div class="td-content"><h1>Expose Your App Publicly</h1><div class="section-index"><hr class="panel-line"><div class="entry"><h5><a href="/docs/tutorials/kubernetes-basics/expose/expose-intro/">Using a Service to Expose Your App</a></h5><p></p></div></div></div></div><div><div class="td-content"><h1>Using a Service to Expose Your App</h1><h2 id="objectives">Objectives</h2><ul><li>Learn about a Service in Kubernetes.</li><li>Understand how labels and selectors relate to a Service.</li><li>Expose an application outside a Kubernetes cluster.</li></ul><h2 id="overview-of-kubernetes-services">Overview of Kubernetes Services</h2><p>Kubernetes <a href="/docs/concepts/workloads/pods/">Pods</a> are mortal. Pods have a
<a href="/docs/concepts/workloads/pods/pod-lifecycle/">lifecycle</a>. When a worker node dies,
the Pods running on the Node are also lost. A <a href="/docs/concepts/workloads/controllers/replicaset/">Replicaset</a>
might then dynamically drive the cluster back to the desired state via the creation
of new Pods to keep your application running. As another example, consider an image-processing
backend with 3 replicas. Those replicas are exchangeable; the front-end system should
not care about backend replicas or even if a Pod is lost and recreated. That said,
each Pod in a Kubernetes cluster has a unique IP address, even Pods on the same Node,
so there needs to be a way of automatically reconciling changes among Pods so that your
applications continue to function.</p><div class="alert alert-primary"><em>A Kubernetes Service is an abstraction layer which defines a logical set of Pods and
enables external traffic exposure, load balancing and service discovery for those Pods.</em></div><p>A <a href="/docs/concepts/services-networking/service/">Service</a> in Kubernetes is an abstraction
which defines a logical set of Pods and a policy by which to access them. Services
enable a loose coupling between dependent Pods. A Service is defined using YAML or JSON,
like all Kubernetes object manifests. The set of Pods targeted by a Service is usually
determined by a <em>label selector</em> (see below for why you might want a Service without
including a <code>selector</code> in the spec).</p><p>Although each Pod has a unique IP address, those IPs are not exposed outside the
cluster without a Service. Services allow your applications to receive traffic.
Services can be exposed in different ways by specifying a <code>type</code> in the <code>spec</code> of the Service:</p><ul><li><p><em>ClusterIP</em> (default) - Exposes the Service on an internal IP in the cluster. This
type makes the Service only reachable from within the cluster.</p></li><li><p><em>NodePort</em> - Exposes the Service on the same port of each selected Node in the cluster using NAT.
Makes a Service accessible from outside the cluster using <code>NodeIP:NodePort</code>. Superset of ClusterIP.</p></li><li><p><em>LoadBalancer</em> - Creates an external load balancer in the current cloud (if supported)
and assigns a fixed, external IP to the Service. Superset of NodePort.</p></li><li><p><em>ExternalName</em> - Maps the Service to the contents of the <code>externalName</code> field
(e.g. <code>foo.bar.example.com</code>), by returning a <code>CNAME</code> record with its value.
No proxying of any kind is set up. This type requires v1.7 or higher of <code>kube-dns</code>,
or CoreDNS version 0.0.8 or higher.</p></li></ul><p>More information about the different types of Services can be found in the
<a href="/docs/tutorials/services/source-ip/">Using Source IP</a> tutorial. Also see
<a href="/docs/tutorials/services/connect-applications-service/">Connecting Applications with Services</a>.</p><p>Additionally, note that there are some use cases with Services that involve not defining
a <code>selector</code> in the spec. A Service created without <code>selector</code> will also not create
the corresponding Endpoints object. This allows users to manually map a Service to
specific endpoints. Another possibility why there may be no selector is you are strictly
using <code>type: ExternalName</code>.</p><h2 id="services-and-labels">Services and Labels</h2><p>A Service routes traffic across a set of Pods. Services are the abstraction that allows
pods to die and replicate in Kubernetes without impacting your application. Discovery
and routing among dependent Pods (such as the frontend and backend components in an application)
are handled by Kubernetes Services.</p><p>Services match a set of Pods using
<a href="/docs/concepts/overview/working-with-objects/labels/">labels and selectors</a>, a grouping
primitive that allows logical operation on objects in Kubernetes. Labels are key/value
pairs attached to objects and can be used in any number of ways:</p><ul><li>Designate objects for development, test, and production</li><li>Embed version tags</li><li>Classify an object using tags</li></ul><figure class="diagram-medium"><img src="/docs/tutorials/kubernetes-basics/public/images/module_04_labels.svg"></figure><p>Labels can be attached to objects at creation time or later on. They can be modified
at any time. Let's expose our application now using a Service and apply some labels.</p><h3 id="step-1-creating-a-new-service">Step 1: Creating a new Service</h3><p>Let&#8217;s verify that our application is running. We&#8217;ll use the <code>kubectl get</code> command
and look for existing Pods:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pods
</span></span></code></pre></div><p>If no Pods are running then it means the objects from the previous tutorials were
cleaned up. In this case, go back and recreate the deployment from the
<a href="/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro/#deploy-an-app">Using kubectl to create a Deployment</a>
tutorial. Please wait a couple of seconds and list the Pods again. You can continue
once you see the one Pod running.</p><p>Next, let&#8217;s list the current Services from our cluster:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get services
</span></span></code></pre></div><p>To expose the deployment to external traffic, we'll use the kubectl expose command with the --type=NodePort option:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl expose deployment/kubernetes-bootcamp --type<span>=</span><span>"NodePort"</span> --port <span>8080</span>
</span></span></code></pre></div><p>We have now a running Service called kubernetes-bootcamp. Here we see that the Service
received a unique cluster-IP, an internal port and an external-IP (the IP of the Node).</p><p>To find out what port was opened externally (for the <code>type: NodePort</code> Service) we&#8217;ll
run the <code>describe service</code> subcommand:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl describe services/kubernetes-bootcamp
</span></span></code></pre></div><p>Create an environment variable called <code>NODE_PORT</code> that has the value of the Node
port assigned:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span>export</span> <span>NODE_PORT</span><span>=</span><span>"</span><span>$(</span>kubectl get services/kubernetes-bootcamp -o go-template<span>=</span><span>'{{(index .spec.ports 0).nodePort}}'</span><span>)</span><span>"</span>
</span></span><span><span><span>echo</span> <span>"NODE_PORT=</span><span>$NODE_PORT</span><span>"</span>
</span></span></code></pre></div><p>Now we can test that the app is exposed outside of the cluster using <code>curl</code>, the
IP address of the Node and the externally exposed port:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>curl http://<span>"</span><span>$(</span>minikube ip<span>)</span><span>:</span><span>$NODE_PORT</span><span>"</span>
</span></span></code></pre></div><div class="alert alert-info"><h4 class="alert-heading">Note:</h4><p>If you're running minikube with Docker Desktop as the container driver, a minikube
tunnel is needed. This is because containers inside Docker Desktop are isolated
from your host computer.</p><p>In a separate terminal window, execute:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>minikube service kubernetes-bootcamp --url
</span></span></code></pre></div><p>The output looks like this:</p><pre tabindex="0"><code>http://127.0.0.1:51082
!  Because you are using a Docker driver on darwin, the terminal needs to be open to run it.
</code></pre><p>Then use the given URL to access the app:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>curl 127.0.0.1:51082
</span></span></code></pre></div></div><p>And we get a response from the server. The Service is exposed.</p><h3 id="step-2-using-labels">Step 2: Using labels</h3><p>The Deployment created automatically a label for our Pod. With the <code>describe deployment</code>
subcommand you can see the name (the <em>key</em>) of that label:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl describe deployment
</span></span></code></pre></div><p>Let&#8217;s use this label to query our list of Pods. We&#8217;ll use the <code>kubectl get pods</code>
command with <code>-l</code> as a parameter, followed by the label values:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pods -l <span>app</span><span>=</span>kubernetes-bootcamp
</span></span></code></pre></div><p>You can do the same to list the existing Services:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get services -l <span>app</span><span>=</span>kubernetes-bootcamp
</span></span></code></pre></div><p>Get the name of the Pod and store it in the POD_NAME environment variable:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span>export</span> <span>POD_NAME</span><span>=</span><span>"</span><span>$(</span>kubectl get pods -o go-template --template <span>'{{range .items}}{{.metadata.name}}{{"\n"}}{{end}}'</span><span>)</span><span>"</span>
</span></span><span><span><span>echo</span> <span>"Name of the Pod: </span><span>$POD_NAME</span><span>"</span>
</span></span></code></pre></div><p>To apply a new label we use the label subcommand followed by the object type,
object name and the new label:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl label pods <span>"</span><span>$POD_NAME</span><span>"</span> <span>version</span><span>=</span>v1
</span></span></code></pre></div><p>This will apply a new label to our Pod (we pinned the application version to the Pod),
and we can check it with the <code>describe pod</code> command:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl describe pods <span>"</span><span>$POD_NAME</span><span>"</span>
</span></span></code></pre></div><p>We see here that the label is attached now to our Pod. And we can query now the
list of pods using the new label:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pods -l <span>version</span><span>=</span>v1
</span></span></code></pre></div><p>And we see the Pod.</p><h3 id="step-3-deleting-a-service">Step 3: Deleting a service</h3><p>To delete Services you can use the <code>delete service</code> subcommand. Labels can be used
also here:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl delete service -l <span>app</span><span>=</span>kubernetes-bootcamp
</span></span></code></pre></div><p>Confirm that the Service is gone:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get services
</span></span></code></pre></div><p>This confirms that our Service was removed. To confirm that route is not exposed
anymore you can <code>curl</code> the previously exposed IP and port:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>curl http://<span>"</span><span>$(</span>minikube ip<span>)</span><span>:</span><span>$NODE_PORT</span><span>"</span>
</span></span></code></pre></div><p>This proves that the application is not reachable anymore from outside of the cluster.
You can confirm that the app is still running with a <code>curl</code> from inside the pod:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl <span>exec</span> -ti <span>$POD_NAME</span> -- curl http://localhost:8080
</span></span></code></pre></div><p>We see here that the application is up. This is because the Deployment is managing
the application. To shut down the application, you would need to delete the Deployment
as well.</p><h2 id="what-s-next">What's next</h2><ul><li>Tutorial
<a href="/docs/tutorials/kubernetes-basics/scale/scale-intro/">Running Multiple Instances of Your App</a>.</li><li>Learn more about <a href="/docs/concepts/services-networking/service/">Service</a>.</li></ul></div></div><div><div class="td-content"><h1>Scale Your App</h1><div class="section-index"><hr class="panel-line"><div class="entry"><h5><a href="/docs/tutorials/kubernetes-basics/scale/scale-intro/">Running Multiple Instances of Your App</a></h5><p></p></div></div></div></div><div><div class="td-content"><h1>Running Multiple Instances of Your App</h1><h2 id="objectives">Objectives</h2><ul><li>Scale an existing app manually using kubectl.</li></ul><h2 id="scaling-an-application">Scaling an application</h2><div class="alert alert-primary"><em>You can create from the start a Deployment with multiple instances using the --replicas
parameter for the kubectl create deployment command.</em></div><p>Previously we created a <a href="/docs/concepts/workloads/controllers/deployment/">Deployment</a>,
and then exposed it publicly via a <a href="/docs/concepts/services-networking/service/">Service</a>.
The Deployment created only one Pod for running our application. When traffic increases,
we will need to scale the application to keep up with user demand.</p><p>If you haven't worked through the earlier sections, start from
<a href="/docs/tutorials/kubernetes-basics/create-cluster/cluster-intro/">Using minikube to create a cluster</a>.</p><p><em>Scaling</em> is accomplished by changing the number of replicas in a Deployment.</p><div class="alert alert-info"><h4 class="alert-heading">Note:</h4><p>If you are trying this after the
<a href="/docs/tutorials/kubernetes-basics/expose/expose-intro/">previous section</a>, then you
may have deleted the service you created, or have created a Service of <code>type: NodePort</code>.
In this section, it is assumed that a service with <code>type: LoadBalancer</code> is created
for the kubernetes-bootcamp Deployment.</p><p>If you have <em>not</em> deleted the Service created in
<a href="/docs/tutorials/kubernetes-basics/expose/expose-intro/">the previous section</a>,
first delete that Service and then run the following command to create a new Service
with its <code>type</code> set to <code>LoadBalancer</code>:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl expose deployment/kubernetes-bootcamp --type<span>=</span><span>"LoadBalancer"</span> --port <span>8080</span>
</span></span></code></pre></div></div><h2 id="scaling-overview">Scaling overview</h2><div class="col-md-8"><div id="myCarousel" class="carousel"><div class="carousel-inner"><div class="item carousel-item active"><img src="/docs/tutorials/kubernetes-basics/public/images/module_05_scaling1.svg"></div><div class="item carousel-item"><img src="/docs/tutorials/kubernetes-basics/public/images/module_05_scaling2.svg"></div></div></div></div><div class="alert alert-primary"><em>Scaling is accomplished by changing the number of replicas in a Deployment.</em></div><p>Scaling out a Deployment will ensure new Pods are created and scheduled to Nodes
with available resources. Scaling will increase the number of Pods to the new desired
state. Kubernetes also supports <a href="/docs/tasks/run-application/horizontal-pod-autoscale/">autoscaling</a>
of Pods, but it is outside of the scope of this tutorial. Scaling to zero is also
possible, and it will terminate all Pods of the specified Deployment.</p><p>Running multiple instances of an application will require a way to distribute the
traffic to all of them. Services have an integrated load-balancer that will distribute
network traffic to all Pods of an exposed Deployment. Services will monitor continuously
the running Pods using endpoints, to ensure the traffic is sent only to available Pods.</p><p>Once you have multiple instances of an application running, you would be able to
do Rolling updates without downtime. We'll cover that in the next section of the
tutorial. Now, let's go to the terminal and scale our application.</p><h3 id="scaling-a-deployment">Scaling a Deployment</h3><p>To list your Deployments, use the <code>get deployments</code> subcommand:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get deployments
</span></span></code></pre></div><p>The output should be similar to:</p><pre tabindex="0"><code>NAME                  READY   UP-TO-DATE   AVAILABLE   AGE
kubernetes-bootcamp   1/1     1            1           11m
</code></pre><p>We should have 1 Pod. If not, run the command again. This shows:</p><ul><li><em>NAME</em> lists the names of the Deployments in the cluster.</li><li><em>READY</em> shows the ratio of CURRENT/DESIRED replicas</li><li><em>UP-TO-DATE</em> displays the number of replicas that have been updated to achieve the desired state.</li><li><em>AVAILABLE</em> displays how many replicas of the application are available to your users.</li><li><em>AGE</em> displays the amount of time that the application has been running.</li></ul><p>To see the ReplicaSet created by the Deployment, run:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get rs
</span></span></code></pre></div><p>Notice that the name of the ReplicaSet is always formatted as
[DEPLOYMENT-NAME]-[RANDOM-STRING].
The random string is randomly generated and uses the pod-template-hash as a seed.</p><p>Two important columns of this output are:</p><ul><li><em>DESIRED</em> displays the desired number of replicas of the application, which you
define when you create the Deployment. This is the desired state.</li><li><em>CURRENT</em> displays how many replicas are currently running.</li></ul><p>Next, let&#8217;s scale the Deployment to 4 replicas. We&#8217;ll use the <code>kubectl scale</code> command,
followed by the Deployment type, name and desired number of instances:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl scale deployments/kubernetes-bootcamp --replicas<span>=</span><span>4</span>
</span></span></code></pre></div><p>To list your Deployments once again, use <code>get deployments</code>:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get deployments
</span></span></code></pre></div><p>The change was applied, and we have 4 instances of the application available. Next,
let&#8217;s check if the number of Pods changed:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pods -o wide
</span></span></code></pre></div><p>There are 4 Pods now, with different IP addresses. The change was registered in
the Deployment events log. To check that, use the <code>describe</code> subcommand:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl describe deployments/kubernetes-bootcamp
</span></span></code></pre></div><p>You can also view in the output of this command that there are 4 replicas now.</p><h3 id="load-balancing">Load Balancing</h3><p>Let's check that the Service is load-balancing the traffic. To find out the exposed
IP and Port we can use <code>describe service</code> as we learned in the previous part of the tutorial:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl describe services/kubernetes-bootcamp
</span></span></code></pre></div><p>Create an environment variable called NODE_PORT that has a value as the Node port:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span>export</span> <span>NODE_PORT</span><span>=</span><span>"</span><span>$(</span>kubectl get services/kubernetes-bootcamp -o go-template<span>=</span><span>'{{(index .spec.ports 0).nodePort}}'</span><span>)</span><span>"</span>
</span></span><span><span><span>echo</span> <span>NODE_PORT</span><span>=</span><span>$NODE_PORT</span>
</span></span></code></pre></div><p>Next, we&#8217;ll do a <code>curl</code> to the exposed IP address and port. Execute the command multiple times:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>curl http://<span>"</span><span>$(</span>minikube ip<span>)</span><span>:</span><span>$NODE_PORT</span><span>"</span>
</span></span></code></pre></div><p>We hit a different Pod with every request. This demonstrates that the load-balancing is working.</p><p>The output should be similar to:</p><pre tabindex="0"><code>Hello Kubernetes bootcamp! | Running on: kubernetes-bootcamp-644c5687f4-wp67j | v=1
Hello Kubernetes bootcamp! | Running on: kubernetes-bootcamp-644c5687f4-hs9dj | v=1
Hello Kubernetes bootcamp! | Running on: kubernetes-bootcamp-644c5687f4-4hjvf | v=1
Hello Kubernetes bootcamp! | Running on: kubernetes-bootcamp-644c5687f4-wp67j | v=1
Hello Kubernetes bootcamp! | Running on: kubernetes-bootcamp-644c5687f4-4hjvf | v=1
</code></pre><div class="alert alert-info"><h4 class="alert-heading">Note:</h4><p>If you're running minikube with Docker Desktop as the container driver, a minikube
tunnel is needed. This is because containers inside Docker Desktop are isolated
from your host computer.</p><p>In a separate terminal window, execute:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>minikube service kubernetes-bootcamp --url
</span></span></code></pre></div><p>The output looks like this:</p><pre tabindex="0"><code>http://127.0.0.1:51082
!  Because you are using a Docker driver on darwin, the terminal needs to be open to run it.
</code></pre><p>Then use the given URL to access the app:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>curl 127.0.0.1:51082
</span></span></code></pre></div></div><h3 id="scale-down">Scale Down</h3><p>To scale down the Deployment to 2 replicas, run again the <code>scale</code> subcommand:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl scale deployments/kubernetes-bootcamp --replicas<span>=</span><span>2</span>
</span></span></code></pre></div><p>List the Deployments to check if the change was applied with the <code>get deployments</code> subcommand:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get deployments
</span></span></code></pre></div><p>The number of replicas decreased to 2. List the number of Pods, with <code>get pods</code>:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pods -o wide
</span></span></code></pre></div><p>This confirms that 2 Pods were terminated.</p><h2 id="what-s-next">What's next</h2><ul><li>Tutorial
<a href="/docs/tutorials/kubernetes-basics/update/update-intro/">Performing a Rolling Update</a>.</li><li>Learn more about <a href="/docs/concepts/workloads/controllers/replicaset/">ReplicaSet</a>.</li><li>Learn more about <a href="/docs/concepts/workloads/autoscaling/">Autoscaling</a>.</li></ul></div></div><div><div class="td-content"><h1>Update Your App</h1><div class="section-index"><hr class="panel-line"><div class="entry"><h5><a href="/docs/tutorials/kubernetes-basics/update/update-intro/">Performing a Rolling Update</a></h5><p></p></div></div></div></div><div><div class="td-content"><h1>Performing a Rolling Update</h1><h2 id="objectives">Objectives</h2><p>Perform a rolling update using kubectl.</p><h2 id="updating-an-application">Updating an application</h2><div class="alert alert-primary"><em>Rolling updates allow Deployments' update to take place with zero downtime by
incrementally updating Pods instances with new ones.</em></div><p>Users expect applications to be available all the time, and developers are expected
to deploy new versions of them several times a day. In Kubernetes this is done with
rolling updates. A <strong>rolling update</strong> allows a Deployment update to take place with
zero downtime. It does this by incrementally replacing the current Pods with new ones.
The new Pods are scheduled on Nodes with available resources, and Kubernetes waits
for those new Pods to start before removing the old Pods.</p><p>In the previous module we scaled our application to run multiple instances. This
is a requirement for performing updates without affecting application availability.
By default, the maximum number of Pods that can be unavailable during the update
and the maximum number of new Pods that can be created, is one. Both options can
be configured to either numbers or percentages (of Pods). In Kubernetes, updates are
versioned and any Deployment update can be reverted to a previous (stable) version.</p><h2 id="rolling-updates-overview">Rolling updates overview</h2><div class="col-md-8"><div id="myCarousel" class="carousel"><div class="carousel-inner"><div class="item carousel-item active"><img src="/docs/tutorials/kubernetes-basics/public/images/module_06_rollingupdates1.svg"></div><div class="item carousel-item"><img src="/docs/tutorials/kubernetes-basics/public/images/module_06_rollingupdates2.svg"></div><div class="item carousel-item"><img src="/docs/tutorials/kubernetes-basics/public/images/module_06_rollingupdates3.svg"></div><div class="item carousel-item"><img src="/docs/tutorials/kubernetes-basics/public/images/module_06_rollingupdates4.svg"></div></div></div></div><div class="alert alert-primary"><em>If a Deployment is exposed publicly, the Service will load-balance the traffic
only to available Pods during the update.</em></div><p>Similar to application Scaling, if a Deployment is exposed publicly, the Service
will load-balance the traffic only to available Pods during the update. An available
Pod is an instance that is available to the users of the application.</p><p>Rolling updates allow the following actions:</p><ul><li>Promote an application from one environment to another (via container image updates)</li><li>Rollback to previous versions</li><li>Continuous Integration and Continuous Delivery of applications with zero downtime</li></ul><p>In the following interactive tutorial, we'll update our application to a new version,
and also perform a rollback.</p><h3 id="update-the-version-of-the-app">Update the version of the app</h3><p>To list your Deployments, run the <code>get deployments</code> subcommand:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get deployments
</span></span></code></pre></div><p>To list the running Pods, run the <code>get pods</code> subcommand:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pods
</span></span></code></pre></div><p>To view the current image version of the app, run the <code>describe pods</code> subcommand
and look for the <code>Image</code> field:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl describe pods
</span></span></code></pre></div><p>To update the image of the application to version 2, use the <code>set image</code> subcommand,
followed by the deployment name and the new image version:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl <span>set</span> image deployments/kubernetes-bootcamp kubernetes-bootcamp<span>=</span>docker.io/jocatalin/kubernetes-bootcamp:v2
</span></span></code></pre></div><p>The command notified the Deployment to use a different image for your app and initiated
a rolling update. Check the status of the new Pods, and view the old one terminating
with the <code>get pods</code> subcommand:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pods
</span></span></code></pre></div><h3 id="verify-an-update">Verify an update</h3><p>First, check that the service is running, as you might have deleted it in previous
tutorial step, run <code>describe services/kubernetes-bootcamp</code>. If it's missing,
you can create it again with:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl expose deployment/kubernetes-bootcamp --type<span>=</span><span>"NodePort"</span> --port <span>8080</span>
</span></span></code></pre></div><p>Create an environment variable called <code>NODE_PORT</code> that has the value of the Node
port assigned:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span>export</span> <span>NODE_PORT</span><span>=</span><span>"</span><span>$(</span>kubectl get services/kubernetes-bootcamp -o go-template<span>=</span><span>'{{(index .spec.ports 0).nodePort}}'</span><span>)</span><span>"</span>
</span></span><span><span><span>echo</span> <span>"NODE_PORT=</span><span>$NODE_PORT</span><span>"</span>
</span></span></code></pre></div><p>Next, do a <code>curl</code> to the exposed IP and port:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>curl http://<span>"</span><span>$(</span>minikube ip<span>)</span><span>:</span><span>$NODE_PORT</span><span>"</span>
</span></span></code></pre></div><p>Every time you run the <code>curl</code> command, you will hit a different Pod. Notice that
all Pods are now running the latest version (<code>v2</code>).</p><p>You can also confirm the update by running the <code>rollout status</code> subcommand:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl rollout status deployments/kubernetes-bootcamp
</span></span></code></pre></div><p>To view the current image version of the app, run the describe pods subcommand:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl describe pods
</span></span></code></pre></div><p>In the <code>Image</code> field of the output, verify that you are running the latest image
version (<code>v2</code>).</p><h3 id="roll-back-an-update">Roll back an update</h3><p>Let&#8217;s perform another update, and try to deploy an image tagged with <code>v10</code>:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl <span>set</span> image deployments/kubernetes-bootcamp kubernetes-bootcamp<span>=</span>gcr.io/google-samples/kubernetes-bootcamp:v10
</span></span></code></pre></div><p>Use <code>get deployments</code> to see the status of the deployment:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get deployments
</span></span></code></pre></div><p>Notice that the output doesn't list the desired number of available Pods. Run the
<code>get pods</code> subcommand to list all Pods:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pods
</span></span></code></pre></div><p>Notice that some of the Pods have a status of <code>ImagePullBackOff</code>.</p><p>To get more insight into the problem, run the <code>describe pods</code> subcommand:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl describe pods
</span></span></code></pre></div><p>In the <code>Events</code> section of the output for the affected Pods, notice that the <code>v10</code>
image version did not exist in the repository.</p><p>To roll back the deployment to your last working version, use the <code>rollout undo</code>
subcommand:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl rollout undo deployments/kubernetes-bootcamp
</span></span></code></pre></div><p>The <code>rollout undo</code> command reverts the deployment to the previous known state
(<code>v2</code> of the image). Updates are versioned and you can revert to any previously
known state of a Deployment.</p><p>Use the <code>get pods</code> subcommand to list the Pods again:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pods
</span></span></code></pre></div><p>To check the image deployed on the running Pods, use the <code>describe pods</code> subcommand:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl describe pods
</span></span></code></pre></div><p>The Deployment is once again using a stable version of the app (<code>v2</code>). The rollback
was successful.</p><p>Remember to clean up your local cluster.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl delete deployments/kubernetes-bootcamp services/kubernetes-bootcamp
</span></span></code></pre></div><h2 id="what-s-next">What's next</h2><ul><li>Learn more about <a href="/docs/concepts/workloads/controllers/deployment/">Deployments</a>.</li></ul></div></div><div><div class="td-content"><h1>Configuration</h1><div class="section-index"><hr class="panel-line"><div class="entry"><h5><a href="/docs/tutorials/configuration/updating-configuration-via-a-configmap/">Updating Configuration via a ConfigMap</a></h5><p></p></div><div class="entry"><h5><a href="/docs/tutorials/configuration/configure-redis-using-configmap/">Configuring Redis using a ConfigMap</a></h5><p></p></div><div class="entry"><h5><a href="/docs/tutorials/configuration/pod-sidecar-containers/">Adopting Sidecar Containers</a></h5><p></p></div></div></div></div><div><div class="td-content"><h1>Updating Configuration via a ConfigMap</h1><p>This page provides a step-by-step example of updating configuration within a Pod via a ConfigMap
and builds upon the <a href="/docs/tasks/configure-pod-container/configure-pod-configmap/">Configure a Pod to Use a ConfigMap</a> task.<br>At the end of this tutorial, you will understand how to change the configuration for a running application.<br>This tutorial uses the <code>alpine</code> and <code>nginx</code> images as examples.</p><h2 id="before-you-begin">Before you begin</h2><p>You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. It is recommended to run this tutorial on a cluster with at least two nodes that are not acting as control plane hosts. If you do not already have a
cluster, you can create one by using
<a href="https://minikube.sigs.k8s.io/docs/tutorials/multi_node/">minikube</a>
or you can use one of these Kubernetes playgrounds:</p><ul><li><a href="https://labs.iximiuz.com/playgrounds?category=kubernetes&amp;filter=all">iximiuz Labs</a></li><li><a href="https://killercoda.com/playgrounds/scenario/kubernetes">Killercoda</a></li><li><a href="https://kodekloud.com/public-playgrounds">KodeKloud</a></li><li><a href="https://labs.play-with-k8s.com/">Play with Kubernetes</a></li></ul><p>You need to have the <a href="https://curl.se/">curl</a> command-line tool for making HTTP requests from
the terminal or command prompt. If you do not have <code>curl</code> available, you can install it. Check the
documentation for your local operating system.</p><h2 id="objectives">Objectives</h2><ul><li>Update configuration via a ConfigMap mounted as a Volume</li><li>Update environment variables of a Pod via a ConfigMap</li><li>Update configuration via a ConfigMap in a multi-container Pod</li><li>Update configuration via a ConfigMap in a Pod possessing a Sidecar Container</li></ul><h2 id="rollout-configmap-volume">Update configuration via a ConfigMap mounted as a Volume</h2><p>Use the <code>kubectl create configmap</code> command to create a ConfigMap from
<a href="/docs/tasks/configure-pod-container/configure-pod-configmap/#create-configmaps-from-literal-values">literal values</a>:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl create configmap sport --from-literal<span>=</span><span>sport</span><span>=</span>football
</span></span></code></pre></div><p>Below is an example of a Deployment manifest with the ConfigMap <code>sport</code> mounted as a
<a class="glossary-tooltip" title="A directory containing data, accessible to the containers in a pod." href="/docs/concepts/storage/volumes/" target="_blank">volume</a> into the Pod's only container.</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/deployments/deployment-with-configmap-as-volume.yaml"><code>deployments/deployment-with-configmap-as-volume.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" title="Copy deployments/deployment-with-configmap-as-volume.yaml to clipboard"></div><div class="includecode" id="deployments-deployment-with-configmap-as-volume-yaml"><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span>apiVersion</span>:<span> </span>apps/v1<span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>Deployment<span>
</span></span></span><span><span><span></span><span>metadata</span>:<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>configmap-volume<span>
</span></span></span><span><span><span>  </span><span>labels</span>:<span>
</span></span></span><span><span><span>    </span><span>app.kubernetes.io/name</span>:<span> </span>configmap-volume<span>
</span></span></span><span><span><span></span><span>spec</span>:<span>
</span></span></span><span><span><span>  </span><span>replicas</span>:<span> </span><span>3</span><span>
</span></span></span><span><span><span>  </span><span>selector</span>:<span>
</span></span></span><span><span><span>    </span><span>matchLabels</span>:<span>
</span></span></span><span><span><span>      </span><span>app.kubernetes.io/name</span>:<span> </span>configmap-volume<span>
</span></span></span><span><span><span>  </span><span>template</span>:<span>
</span></span></span><span><span><span>    </span><span>metadata</span>:<span>
</span></span></span><span><span><span>      </span><span>labels</span>:<span>
</span></span></span><span><span><span>        </span><span>app.kubernetes.io/name</span>:<span> </span>configmap-volume<span>
</span></span></span><span><span><span>    </span><span>spec</span>:<span>
</span></span></span><span><span><span>      </span><span>containers</span>:<span>
</span></span></span><span><span><span>        </span>- <span>name</span>:<span> </span>alpine<span>
</span></span></span><span><span><span>          </span><span>image</span>:<span> </span>alpine:3<span>
</span></span></span><span><span><span>          </span><span>command</span>:<span>
</span></span></span><span><span><span>            </span>- /bin/sh<span>
</span></span></span><span><span><span>            </span>- -c<span>
</span></span></span><span><span><span>            </span>- while true; do echo "$(date) My preferred sport is $(cat /etc/config/sport)";<span>
</span></span></span><span><span><span>              </span>sleep 10; done;<span>
</span></span></span><span><span><span>          </span><span>ports</span>:<span>
</span></span></span><span><span><span>            </span>- <span>containerPort</span>:<span> </span><span>80</span><span>
</span></span></span><span><span><span>          </span><span>volumeMounts</span>:<span>
</span></span></span><span><span><span>            </span>- <span>name</span>:<span> </span>config-volume<span>
</span></span></span><span><span><span>              </span><span>mountPath</span>:<span> </span>/etc/config<span>
</span></span></span><span><span><span>      </span><span>volumes</span>:<span>
</span></span></span><span><span><span>        </span>- <span>name</span>:<span> </span>config-volume<span>
</span></span></span><span><span><span>          </span><span>configMap</span>:<span>
</span></span></span><span><span><span>            </span><span>name</span>:<span> </span>sport</span></span></code></pre></div></div></div><p>Create the Deployment:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl apply -f https://k8s.io/examples/deployments/deployment-with-configmap-as-volume.yaml
</span></span></code></pre></div><p>Check the pods for this Deployment to ensure they are ready (matching by
<a class="glossary-tooltip" title="Allows users to filter a list of resources based on labels." href="/docs/concepts/overview/working-with-objects/labels/" target="_blank">selector</a>):</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pods --selector<span>=</span>app.kubernetes.io/name<span>=</span>configmap-volume
</span></span></code></pre></div><p>You should see an output similar to:</p><pre tabindex="0"><code>NAME                                READY   STATUS    RESTARTS   AGE
configmap-volume-6b976dfdcf-qxvbm   1/1     Running   0          72s
configmap-volume-6b976dfdcf-skpvm   1/1     Running   0          72s
configmap-volume-6b976dfdcf-tbc6r   1/1     Running   0          72s
</code></pre><p>On each node where one of these Pods is running, the kubelet fetches the data for
that ConfigMap and translates it to files in a local volume.
The kubelet then mounts that volume into the container, as specified in the Pod template.
The code running in that container loads the information from the file
and uses it to print a report to stdout.
You can check this report by viewing the logs for one of the Pods in that Deployment:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span># Pick one Pod that belongs to the Deployment, and view its logs</span>
</span></span><span><span>kubectl logs deployments/configmap-volume
</span></span></code></pre></div><p>You should see an output similar to:</p><pre tabindex="0"><code>Found 3 pods, using pod/configmap-volume-76d9c5678f-x5rgj
Thu Jan  4 14:06:46 UTC 2024 My preferred sport is football
Thu Jan  4 14:06:56 UTC 2024 My preferred sport is football
Thu Jan  4 14:07:06 UTC 2024 My preferred sport is football
Thu Jan  4 14:07:16 UTC 2024 My preferred sport is football
Thu Jan  4 14:07:26 UTC 2024 My preferred sport is football
</code></pre><p>Edit the ConfigMap:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl edit configmap sport
</span></span></code></pre></div><p>In the editor that appears, change the value of key <code>sport</code> from <code>football</code> to <code>cricket</code>. Save your changes.
The kubectl tool updates the ConfigMap accordingly (if you see an error, try again).</p><p>Here's an example of how that manifest could look after you edit it:</p><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span>apiVersion</span>:<span> </span>v1<span>
</span></span></span><span><span><span></span><span>data</span>:<span>
</span></span></span><span><span><span>  </span><span>sport</span>:<span> </span>cricket<span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>ConfigMap<span>
</span></span></span><span><span><span></span><span># You can leave the existing metadata as they are.</span><span>
</span></span></span><span><span><span></span><span># The values you'll see won't exactly match these.</span><span>
</span></span></span><span><span><span></span><span>metadata</span>:<span>
</span></span></span><span><span><span>  </span><span>creationTimestamp</span>:<span> </span><span>"2024-01-04T14:05:06Z"</span><span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>sport<span>
</span></span></span><span><span><span>  </span><span>namespace</span>:<span> </span>default<span>
</span></span></span><span><span><span>  </span><span>resourceVersion</span>:<span> </span><span>"1743935"</span><span>
</span></span></span><span><span><span>  </span><span>uid</span>:<span> </span>024ee001-fe72-487e-872e-34d6464a8a23<span>
</span></span></span></code></pre></div><p>You should see the following output:</p><pre tabindex="0"><code>configmap/sport edited
</code></pre><p>Tail (follow the latest entries in) the logs of one of the pods that belongs to this Deployment:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl logs deployments/configmap-volume --follow
</span></span></code></pre></div><p>After few seconds, you should see the log output change as follows:</p><pre tabindex="0"><code>Thu Jan  4 14:11:36 UTC 2024 My preferred sport is football
Thu Jan  4 14:11:46 UTC 2024 My preferred sport is football
Thu Jan  4 14:11:56 UTC 2024 My preferred sport is football
Thu Jan  4 14:12:06 UTC 2024 My preferred sport is cricket
Thu Jan  4 14:12:16 UTC 2024 My preferred sport is cricket
</code></pre><p>When you have a ConfigMap that is mapped into a running Pod using either a
<code>configMap</code> volume or a <code>projected</code> volume, and you update that ConfigMap,
the running Pod sees the update almost immediately.<br>However, your application only sees the change if it is written to either poll for changes,
or watch for file updates.<br>An application that loads its configuration once at startup will not notice a change.</p><div class="alert alert-info"><h4 class="alert-heading">Note:</h4>The total delay from the moment when the ConfigMap is updated to the moment when
new keys are projected to the Pod can be as long as kubelet sync period.<br>Also check <a href="/docs/tasks/configure-pod-container/configure-pod-configmap/#mounted-configmaps-are-updated-automatically">Mounted ConfigMaps are updated automatically</a>.</div><h2 id="rollout-configmap-env">Update environment variables of a Pod via a ConfigMap</h2><p>Use the <code>kubectl create configmap</code> command to create a ConfigMap from
<a href="/docs/tasks/configure-pod-container/configure-pod-configmap/#create-configmaps-from-literal-values">literal values</a>:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl create configmap fruits --from-literal<span>=</span><span>fruits</span><span>=</span>apples
</span></span></code></pre></div><p>Below is an example of a Deployment manifest with an environment variable configured via the ConfigMap <code>fruits</code>.</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/deployments/deployment-with-configmap-as-envvar.yaml"><code>deployments/deployment-with-configmap-as-envvar.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" title="Copy deployments/deployment-with-configmap-as-envvar.yaml to clipboard"></div><div class="includecode" id="deployments-deployment-with-configmap-as-envvar-yaml"><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span>apiVersion</span>:<span> </span>apps/v1<span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>Deployment<span>
</span></span></span><span><span><span></span><span>metadata</span>:<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>configmap-env-var<span>
</span></span></span><span><span><span>  </span><span>labels</span>:<span>
</span></span></span><span><span><span>    </span><span>app.kubernetes.io/name</span>:<span> </span>configmap-env-var<span>
</span></span></span><span><span><span></span><span>spec</span>:<span>
</span></span></span><span><span><span>  </span><span>replicas</span>:<span> </span><span>3</span><span>
</span></span></span><span><span><span>  </span><span>selector</span>:<span>
</span></span></span><span><span><span>    </span><span>matchLabels</span>:<span>
</span></span></span><span><span><span>      </span><span>app.kubernetes.io/name</span>:<span> </span>configmap-env-var<span>
</span></span></span><span><span><span>  </span><span>template</span>:<span>
</span></span></span><span><span><span>    </span><span>metadata</span>:<span>
</span></span></span><span><span><span>      </span><span>labels</span>:<span>
</span></span></span><span><span><span>        </span><span>app.kubernetes.io/name</span>:<span> </span>configmap-env-var<span>
</span></span></span><span><span><span>    </span><span>spec</span>:<span>
</span></span></span><span><span><span>      </span><span>containers</span>:<span>
</span></span></span><span><span><span>        </span>- <span>name</span>:<span> </span>alpine<span>
</span></span></span><span><span><span>          </span><span>image</span>:<span> </span>alpine:3<span>
</span></span></span><span><span><span>          </span><span>env</span>:<span>
</span></span></span><span><span><span>            </span>- <span>name</span>:<span> </span>FRUITS<span>
</span></span></span><span><span><span>              </span><span>valueFrom</span>:<span>
</span></span></span><span><span><span>                </span><span>configMapKeyRef</span>:<span>
</span></span></span><span><span><span>                  </span><span>key</span>:<span> </span>fruits<span>
</span></span></span><span><span><span>                  </span><span>name</span>:<span> </span>fruits<span>
</span></span></span><span><span><span>          </span><span>command</span>:<span>
</span></span></span><span><span><span>            </span>- /bin/sh<span>
</span></span></span><span><span><span>            </span>- -c<span>
</span></span></span><span><span><span>            </span>- while true; do echo "$(date) The basket is full of $FRUITS";<span>
</span></span></span><span><span><span>                </span>sleep 10; done;<span>
</span></span></span><span><span><span>          </span><span>ports</span>:<span>
</span></span></span><span><span><span>            </span>- <span>containerPort</span>:<span> </span><span>80</span></span></span></code></pre></div></div></div><p>Create the Deployment:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl apply -f https://k8s.io/examples/deployments/deployment-with-configmap-as-envvar.yaml
</span></span></code></pre></div><p>Check the pods for this Deployment to ensure they are ready (matching by
<a class="glossary-tooltip" title="Allows users to filter a list of resources based on labels." href="/docs/concepts/overview/working-with-objects/labels/" target="_blank">selector</a>):</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pods --selector<span>=</span>app.kubernetes.io/name<span>=</span>configmap-env-var
</span></span></code></pre></div><p>You should see an output similar to:</p><pre tabindex="0"><code>NAME                                 READY   STATUS    RESTARTS   AGE
configmap-env-var-59cfc64f7d-74d7z   1/1     Running   0          46s
configmap-env-var-59cfc64f7d-c4wmj   1/1     Running   0          46s
configmap-env-var-59cfc64f7d-dpr98   1/1     Running   0          46s
</code></pre><p>The key-value pair in the ConfigMap is configured as an environment variable in the container of the Pod.
Check this by viewing the logs of one Pod that belongs to the Deployment.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl logs deployment/configmap-env-var
</span></span></code></pre></div><p>You should see an output similar to:</p><pre tabindex="0"><code>Found 3 pods, using pod/configmap-env-var-7c994f7769-l74nq
Thu Jan  4 16:07:06 UTC 2024 The basket is full of apples
Thu Jan  4 16:07:16 UTC 2024 The basket is full of apples
Thu Jan  4 16:07:26 UTC 2024 The basket is full of apples
</code></pre><p>Edit the ConfigMap:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl edit configmap fruits
</span></span></code></pre></div><p>In the editor that appears, change the value of key <code>fruits</code> from <code>apples</code> to <code>mangoes</code>. Save your changes.
The kubectl tool updates the ConfigMap accordingly (if you see an error, try again).</p><p>Here's an example of how that manifest could look after you edit it:</p><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span>apiVersion</span>:<span> </span>v1<span>
</span></span></span><span><span><span></span><span>data</span>:<span>
</span></span></span><span><span><span>  </span><span>fruits</span>:<span> </span>mangoes<span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>ConfigMap<span>
</span></span></span><span><span><span></span><span># You can leave the existing metadata as they are.</span><span>
</span></span></span><span><span><span></span><span># The values you'll see won't exactly match these.</span><span>
</span></span></span><span><span><span></span><span>metadata</span>:<span>
</span></span></span><span><span><span>  </span><span>creationTimestamp</span>:<span> </span><span>"2024-01-04T16:04:19Z"</span><span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>fruits<span>
</span></span></span><span><span><span>  </span><span>namespace</span>:<span> </span>default<span>
</span></span></span><span><span><span>  </span><span>resourceVersion</span>:<span> </span><span>"1749472"</span><span>
</span></span></span></code></pre></div><p>You should see the following output:</p><pre tabindex="0"><code>configmap/fruits edited
</code></pre><p>Tail the logs of the Deployment and observe the output for few seconds:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span># As the text explains, the output does NOT change</span>
</span></span><span><span>kubectl logs deployments/configmap-env-var --follow
</span></span></code></pre></div><p>Notice that the output remains <strong>unchanged</strong>, even though you edited the ConfigMap:</p><pre tabindex="0"><code>Thu Jan  4 16:12:56 UTC 2024 The basket is full of apples
Thu Jan  4 16:13:06 UTC 2024 The basket is full of apples
Thu Jan  4 16:13:16 UTC 2024 The basket is full of apples
Thu Jan  4 16:13:26 UTC 2024 The basket is full of apples
</code></pre><div class="alert alert-info"><h4 class="alert-heading">Note:</h4>Although the value of the key inside the ConfigMap has changed, the environment variable
in the Pod still shows the earlier value. This is because environment variables for a
process running inside a Pod are <strong>not</strong> updated when the source data changes; if you
wanted to force an update, you would need to have Kubernetes replace your existing Pods.
The new Pods would then run with the updated information.</div><p>You can trigger that replacement. Perform a rollout for the Deployment, using
<a href="/docs/reference/kubectl/generated/kubectl_rollout/"><code>kubectl rollout</code></a>:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span># Trigger the rollout</span>
</span></span><span><span>kubectl rollout restart deployment configmap-env-var
</span></span><span><span>
</span></span><span><span><span># Wait for the rollout to complete</span>
</span></span><span><span>kubectl rollout status deployment configmap-env-var --watch<span>=</span><span>true</span>
</span></span></code></pre></div><p>Next, check the Deployment:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get deployment configmap-env-var
</span></span></code></pre></div><p>You should see an output similar to:</p><pre tabindex="0"><code>NAME                READY   UP-TO-DATE   AVAILABLE   AGE
configmap-env-var   3/3     3            3           12m
</code></pre><p>Check the Pods:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pods --selector<span>=</span>app.kubernetes.io/name<span>=</span>configmap-env-var
</span></span></code></pre></div><p>The rollout causes Kubernetes to make a new <a class="glossary-tooltip" title="ReplicaSet ensures that a specified number of Pod replicas are running at one time" href="/docs/concepts/workloads/controllers/replicaset/" target="_blank">ReplicaSet</a>
for the Deployment; that means the existing Pods eventually terminate, and new ones are created.
After few seconds, you should see an output similar to:</p><pre tabindex="0"><code>NAME                                 READY   STATUS        RESTARTS   AGE
configmap-env-var-6d94d89bf5-2ph2l   1/1     Running       0          13s
configmap-env-var-6d94d89bf5-74twx   1/1     Running       0          8s
configmap-env-var-6d94d89bf5-d5vx8   1/1     Running       0          11s
</code></pre><div class="alert alert-info"><h4 class="alert-heading">Note:</h4>Please wait for the older Pods to fully terminate before proceeding with the next steps.</div><p>View the logs for a Pod in this Deployment:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span># Pick one Pod that belongs to the Deployment, and view its logs</span>
</span></span><span><span>kubectl logs deployment/configmap-env-var
</span></span></code></pre></div><p>You should see an output similar to the below:</p><pre tabindex="0"><code>Found 3 pods, using pod/configmap-env-var-6d9ff89fb6-bzcf6
Thu Jan  4 16:30:35 UTC 2024 The basket is full of mangoes
Thu Jan  4 16:30:45 UTC 2024 The basket is full of mangoes
Thu Jan  4 16:30:55 UTC 2024 The basket is full of mangoes
</code></pre><p>This demonstrates the scenario of updating environment variables in a Pod that are derived
from a ConfigMap. Changes to the ConfigMap values are applied to the Pod during the subsequent
rollout. If Pods get created for another reason, such as scaling up the Deployment, then the new Pods
also use the latest configuration values; if you don't trigger a rollout, then you might find that your
app is running with a mix of old and new environment variable values.</p><h2 id="rollout-configmap-multiple-containers">Update configuration via a ConfigMap in a multi-container Pod</h2><p>Use the <code>kubectl create configmap</code> command to create a ConfigMap from
<a href="/docs/tasks/configure-pod-container/configure-pod-configmap/#create-configmaps-from-literal-values">literal values</a>:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl create configmap color --from-literal<span>=</span><span>color</span><span>=</span>red
</span></span></code></pre></div><p>Below is an example manifest for a Deployment that manages a set of Pods, each with two containers.
The two containers share an <code>emptyDir</code> volume that they use to communicate.
The first container runs a web server (<code>nginx</code>). The mount path for the shared volume in the
web server container is <code>/usr/share/nginx/html</code>. The second helper container is based on <code>alpine</code>,
and for this container the <code>emptyDir</code> volume is mounted at <code>/pod-data</code>. The helper container writes
a file in HTML that has its content based on a ConfigMap. The web server container serves the HTML via HTTP.</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/deployments/deployment-with-configmap-two-containers.yaml"><code>deployments/deployment-with-configmap-two-containers.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" title="Copy deployments/deployment-with-configmap-two-containers.yaml to clipboard"></div><div class="includecode" id="deployments-deployment-with-configmap-two-containers-yaml"><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span>apiVersion</span>:<span> </span>apps/v1<span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>Deployment<span>
</span></span></span><span><span><span></span><span>metadata</span>:<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>configmap-two-containers<span>
</span></span></span><span><span><span>  </span><span>labels</span>:<span>
</span></span></span><span><span><span>    </span><span>app.kubernetes.io/name</span>:<span> </span>configmap-two-containers<span>
</span></span></span><span><span><span></span><span>spec</span>:<span>
</span></span></span><span><span><span>  </span><span>replicas</span>:<span> </span><span>3</span><span>
</span></span></span><span><span><span>  </span><span>selector</span>:<span>
</span></span></span><span><span><span>    </span><span>matchLabels</span>:<span>
</span></span></span><span><span><span>      </span><span>app.kubernetes.io/name</span>:<span> </span>configmap-two-containers<span>
</span></span></span><span><span><span>  </span><span>template</span>:<span>
</span></span></span><span><span><span>    </span><span>metadata</span>:<span>
</span></span></span><span><span><span>      </span><span>labels</span>:<span>
</span></span></span><span><span><span>        </span><span>app.kubernetes.io/name</span>:<span> </span>configmap-two-containers<span>
</span></span></span><span><span><span>    </span><span>spec</span>:<span>
</span></span></span><span><span><span>      </span><span>volumes</span>:<span>
</span></span></span><span><span><span>        </span>- <span>name</span>:<span> </span>shared-data<span>
</span></span></span><span><span><span>          </span><span>emptyDir</span>:<span> </span>{}<span>
</span></span></span><span><span><span>        </span>- <span>name</span>:<span> </span>config-volume<span>
</span></span></span><span><span><span>          </span><span>configMap</span>:<span>
</span></span></span><span><span><span>            </span><span>name</span>:<span> </span>color<span>
</span></span></span><span><span><span>      </span><span>containers</span>:<span>
</span></span></span><span><span><span>        </span>- <span>name</span>:<span> </span>nginx<span>
</span></span></span><span><span><span>          </span><span>image</span>:<span> </span>nginx<span>
</span></span></span><span><span><span>          </span><span>volumeMounts</span>:<span>
</span></span></span><span><span><span>            </span>- <span>name</span>:<span> </span>shared-data<span>
</span></span></span><span><span><span>              </span><span>mountPath</span>:<span> </span>/usr/share/nginx/html<span>
</span></span></span><span><span><span>        </span>- <span>name</span>:<span> </span>alpine<span>
</span></span></span><span><span><span>          </span><span>image</span>:<span> </span>alpine:3<span>
</span></span></span><span><span><span>          </span><span>volumeMounts</span>:<span>
</span></span></span><span><span><span>            </span>- <span>name</span>:<span> </span>shared-data<span>
</span></span></span><span><span><span>              </span><span>mountPath</span>:<span> </span>/pod-data<span>
</span></span></span><span><span><span>            </span>- <span>name</span>:<span> </span>config-volume<span>
</span></span></span><span><span><span>              </span><span>mountPath</span>:<span> </span>/etc/config<span>
</span></span></span><span><span><span>          </span><span>command</span>:<span>
</span></span></span><span><span><span>            </span>- /bin/sh<span>
</span></span></span><span><span><span>            </span>- -c<span>
</span></span></span><span><span><span>            </span>- while true; do echo "$(date) My preferred color is $(cat /etc/config/color)" &gt; /pod-data/index.html;<span>
</span></span></span><span><span><span>              </span>sleep 10; done;<span>
</span></span></span></code></pre></div></div></div><p>Create the Deployment:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl apply -f https://k8s.io/examples/deployments/deployment-with-configmap-two-containers.yaml
</span></span></code></pre></div><p>Check the pods for this Deployment to ensure they are ready (matching by
<a class="glossary-tooltip" title="Allows users to filter a list of resources based on labels." href="/docs/concepts/overview/working-with-objects/labels/" target="_blank">selector</a>):</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pods --selector<span>=</span>app.kubernetes.io/name<span>=</span>configmap-two-containers
</span></span></code></pre></div><p>You should see an output similar to:</p><pre tabindex="0"><code>NAME                                        READY   STATUS    RESTARTS   AGE
configmap-two-containers-565fb6d4f4-2xhxf   2/2     Running   0          20s
configmap-two-containers-565fb6d4f4-g5v4j   2/2     Running   0          20s
configmap-two-containers-565fb6d4f4-mzsmf   2/2     Running   0          20s
</code></pre><p>Expose the Deployment (the <code>kubectl</code> tool creates a
<a class="glossary-tooltip" title="A way to expose an application running on a set of Pods as a network service." href="/docs/concepts/services-networking/service/" target="_blank">Service</a> for you):</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl expose deployment configmap-two-containers --name<span>=</span>configmap-service --port<span>=</span><span>8080</span> --target-port<span>=</span><span>80</span>
</span></span></code></pre></div><p>Use <code>kubectl</code> to forward the port:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span># this stays running in the background</span>
</span></span><span><span>kubectl port-forward service/configmap-service 8080:8080 &amp;
</span></span></code></pre></div><p>Access the service.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>curl http://localhost:8080
</span></span></code></pre></div><p>You should see an output similar to:</p><pre tabindex="0"><code>Fri Jan  5 08:08:22 UTC 2024 My preferred color is red
</code></pre><p>Edit the ConfigMap:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl edit configmap color
</span></span></code></pre></div><p>In the editor that appears, change the value of key <code>color</code> from <code>red</code> to <code>blue</code>. Save your changes.
The kubectl tool updates the ConfigMap accordingly (if you see an error, try again).</p><p>Here's an example of how that manifest could look after you edit it:</p><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span>apiVersion</span>:<span> </span>v1<span>
</span></span></span><span><span><span></span><span>data</span>:<span>
</span></span></span><span><span><span>  </span><span>color</span>:<span> </span>blue<span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>ConfigMap<span>
</span></span></span><span><span><span></span><span># You can leave the existing metadata as they are.</span><span>
</span></span></span><span><span><span></span><span># The values you'll see won't exactly match these.</span><span>
</span></span></span><span><span><span></span><span>metadata</span>:<span>
</span></span></span><span><span><span>  </span><span>creationTimestamp</span>:<span> </span><span>"2024-01-05T08:12:05Z"</span><span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>color<span>
</span></span></span><span><span><span>  </span><span>namespace</span>:<span> </span>configmap<span>
</span></span></span><span><span><span>  </span><span>resourceVersion</span>:<span> </span><span>"1801272"</span><span>
</span></span></span><span><span><span>  </span><span>uid</span>:<span> </span>80d33e4a-cbb4-4bc9-ba8c-544c68e425d6<span>
</span></span></span></code></pre></div><p>Loop over the service URL for few seconds.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span># Cancel this when you're happy with it (Ctrl-C)</span>
</span></span><span><span><span>while</span> true; <span>do</span> curl --connect-timeout 7.5 http://localhost:8080; sleep 10; <span>done</span>
</span></span></code></pre></div><p>You should see the output change as follows:</p><pre tabindex="0"><code>Fri Jan  5 08:14:00 UTC 2024 My preferred color is red
Fri Jan  5 08:14:02 UTC 2024 My preferred color is red
Fri Jan  5 08:14:20 UTC 2024 My preferred color is red
Fri Jan  5 08:14:22 UTC 2024 My preferred color is red
Fri Jan  5 08:14:32 UTC 2024 My preferred color is blue
Fri Jan  5 08:14:43 UTC 2024 My preferred color is blue
Fri Jan  5 08:15:00 UTC 2024 My preferred color is blue
</code></pre><h2 id="rollout-configmap-sidecar">Update configuration via a ConfigMap in a Pod possessing a sidecar container</h2><p>The above scenario can be replicated by using a <a href="/docs/concepts/workloads/pods/sidecar-containers/">Sidecar Container</a>
as a helper container to write the HTML file.<br>As a Sidecar Container is conceptually an Init Container, it is guaranteed to start before the main web server container.<br>This ensures that the HTML file is always available when the web server is ready to serve it.</p><p>If you are continuing from the previous scenario, you can reuse the ConfigMap named <code>color</code> for this scenario.<br>If you are executing this scenario independently, use the <code>kubectl create configmap</code> command to create a ConfigMap
from <a href="/docs/tasks/configure-pod-container/configure-pod-configmap/#create-configmaps-from-literal-values">literal values</a>:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl create configmap color --from-literal<span>=</span><span>color</span><span>=</span>blue
</span></span></code></pre></div><p>Below is an example manifest for a Deployment that manages a set of Pods, each with a main container and
a sidecar container. The two containers share an <code>emptyDir</code> volume that they use to communicate.
The main container runs a web server (NGINX). The mount path for the shared volume in the web server container
is <code>/usr/share/nginx/html</code>. The second container is a Sidecar Container based on Alpine Linux which acts as
a helper container. For this container the <code>emptyDir</code> volume is mounted at <code>/pod-data</code>. The Sidecar Container
writes a file in HTML that has its content based on a ConfigMap. The web server container serves the HTML via HTTP.</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/deployments/deployment-with-configmap-and-sidecar-container.yaml"><code>deployments/deployment-with-configmap-and-sidecar-container.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" title="Copy deployments/deployment-with-configmap-and-sidecar-container.yaml to clipboard"></div><div class="includecode" id="deployments-deployment-with-configmap-and-sidecar-container-yaml"><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span>apiVersion</span>:<span> </span>apps/v1<span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>Deployment<span>
</span></span></span><span><span><span></span><span>metadata</span>:<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>configmap-sidecar-container<span>
</span></span></span><span><span><span>  </span><span>labels</span>:<span>
</span></span></span><span><span><span>    </span><span>app.kubernetes.io/name</span>:<span> </span>configmap-sidecar-container<span>
</span></span></span><span><span><span></span><span>spec</span>:<span>
</span></span></span><span><span><span>  </span><span>replicas</span>:<span> </span><span>3</span><span>
</span></span></span><span><span><span>  </span><span>selector</span>:<span>
</span></span></span><span><span><span>    </span><span>matchLabels</span>:<span>
</span></span></span><span><span><span>      </span><span>app.kubernetes.io/name</span>:<span> </span>configmap-sidecar-container<span>
</span></span></span><span><span><span>  </span><span>template</span>:<span>
</span></span></span><span><span><span>    </span><span>metadata</span>:<span>
</span></span></span><span><span><span>      </span><span>labels</span>:<span>
</span></span></span><span><span><span>        </span><span>app.kubernetes.io/name</span>:<span> </span>configmap-sidecar-container<span>
</span></span></span><span><span><span>    </span><span>spec</span>:<span>
</span></span></span><span><span><span>      </span><span>volumes</span>:<span>
</span></span></span><span><span><span>        </span>- <span>name</span>:<span> </span>shared-data<span>
</span></span></span><span><span><span>          </span><span>emptyDir</span>:<span> </span>{}<span>
</span></span></span><span><span><span>        </span>- <span>name</span>:<span> </span>config-volume<span>
</span></span></span><span><span><span>          </span><span>configMap</span>:<span>
</span></span></span><span><span><span>            </span><span>name</span>:<span> </span>color<span>
</span></span></span><span><span><span>      </span><span>containers</span>:<span>
</span></span></span><span><span><span>        </span>- <span>name</span>:<span> </span>nginx<span>
</span></span></span><span><span><span>          </span><span>image</span>:<span> </span>nginx<span>
</span></span></span><span><span><span>          </span><span>volumeMounts</span>:<span>
</span></span></span><span><span><span>            </span>- <span>name</span>:<span> </span>shared-data<span>
</span></span></span><span><span><span>              </span><span>mountPath</span>:<span> </span>/usr/share/nginx/html<span>
</span></span></span><span><span><span>      </span><span>initContainers</span>:<span>
</span></span></span><span><span><span>        </span>- <span>name</span>:<span> </span>alpine<span>
</span></span></span><span><span><span>          </span><span>image</span>:<span> </span>alpine:3<span>
</span></span></span><span><span><span>          </span><span>restartPolicy</span>:<span> </span>Always<span>
</span></span></span><span><span><span>          </span><span>volumeMounts</span>:<span>
</span></span></span><span><span><span>            </span>- <span>name</span>:<span> </span>shared-data<span>
</span></span></span><span><span><span>              </span><span>mountPath</span>:<span> </span>/pod-data<span>
</span></span></span><span><span><span>            </span>- <span>name</span>:<span> </span>config-volume<span>
</span></span></span><span><span><span>              </span><span>mountPath</span>:<span> </span>/etc/config<span>
</span></span></span><span><span><span>          </span><span>command</span>:<span>
</span></span></span><span><span><span>            </span>- /bin/sh<span>
</span></span></span><span><span><span>            </span>- -c<span>
</span></span></span><span><span><span>            </span>- while true; do echo "$(date) My preferred color is $(cat /etc/config/color)" &gt; /pod-data/index.html;<span>
</span></span></span><span><span><span>              </span>sleep 10; done;<span>
</span></span></span></code></pre></div></div></div><p>Create the Deployment:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl apply -f https://k8s.io/examples/deployments/deployment-with-configmap-and-sidecar-container.yaml
</span></span></code></pre></div><p>Check the pods for this Deployment to ensure they are ready (matching by
<a class="glossary-tooltip" title="Allows users to filter a list of resources based on labels." href="/docs/concepts/overview/working-with-objects/labels/" target="_blank">selector</a>):</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pods --selector<span>=</span>app.kubernetes.io/name<span>=</span>configmap-sidecar-container
</span></span></code></pre></div><p>You should see an output similar to:</p><pre tabindex="0"><code>NAME                                           READY   STATUS    RESTARTS   AGE
configmap-sidecar-container-5fb59f558b-87rp7   2/2     Running   0          94s
configmap-sidecar-container-5fb59f558b-ccs7s   2/2     Running   0          94s
configmap-sidecar-container-5fb59f558b-wnmgk   2/2     Running   0          94s
</code></pre><p>Expose the Deployment (the <code>kubectl</code> tool creates a
<a class="glossary-tooltip" title="A way to expose an application running on a set of Pods as a network service." href="/docs/concepts/services-networking/service/" target="_blank">Service</a> for you):</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl expose deployment configmap-sidecar-container --name<span>=</span>configmap-sidecar-service --port<span>=</span><span>8081</span> --target-port<span>=</span><span>80</span>
</span></span></code></pre></div><p>Use <code>kubectl</code> to forward the port:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span># this stays running in the background</span>
</span></span><span><span>kubectl port-forward service/configmap-sidecar-service 8081:8081 &amp;
</span></span></code></pre></div><p>Access the service.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>curl http://localhost:8081
</span></span></code></pre></div><p>You should see an output similar to:</p><pre tabindex="0"><code>Sat Feb 17 13:09:05 UTC 2024 My preferred color is blue
</code></pre><p>Edit the ConfigMap:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl edit configmap color
</span></span></code></pre></div><p>In the editor that appears, change the value of key <code>color</code> from <code>blue</code> to <code>green</code>. Save your changes.
The kubectl tool updates the ConfigMap accordingly (if you see an error, try again).</p><p>Here's an example of how that manifest could look after you edit it:</p><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span>apiVersion</span>:<span> </span>v1<span>
</span></span></span><span><span><span></span><span>data</span>:<span>
</span></span></span><span><span><span>  </span><span>color</span>:<span> </span>green<span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>ConfigMap<span>
</span></span></span><span><span><span></span><span># You can leave the existing metadata as they are.</span><span>
</span></span></span><span><span><span></span><span># The values you'll see won't exactly match these.</span><span>
</span></span></span><span><span><span></span><span>metadata</span>:<span>
</span></span></span><span><span><span>  </span><span>creationTimestamp</span>:<span> </span><span>"2024-02-17T12:20:30Z"</span><span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>color<span>
</span></span></span><span><span><span>  </span><span>namespace</span>:<span> </span>default<span>
</span></span></span><span><span><span>  </span><span>resourceVersion</span>:<span> </span><span>"1054"</span><span>
</span></span></span><span><span><span>  </span><span>uid</span>:<span> </span>e40bb34c-58df-4280-8bea-6ed16edccfaa<span>
</span></span></span></code></pre></div><p>Loop over the service URL for few seconds.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span># Cancel this when you're happy with it (Ctrl-C)</span>
</span></span><span><span><span>while</span> true; <span>do</span> curl --connect-timeout 7.5 http://localhost:8081; sleep 10; <span>done</span>
</span></span></code></pre></div><p>You should see the output change as follows:</p><pre tabindex="0"><code>Sat Feb 17 13:12:35 UTC 2024 My preferred color is blue
Sat Feb 17 13:12:45 UTC 2024 My preferred color is blue
Sat Feb 17 13:12:55 UTC 2024 My preferred color is blue
Sat Feb 17 13:13:05 UTC 2024 My preferred color is blue
Sat Feb 17 13:13:15 UTC 2024 My preferred color is green
Sat Feb 17 13:13:25 UTC 2024 My preferred color is green
Sat Feb 17 13:13:35 UTC 2024 My preferred color is green
</code></pre><h2 id="rollout-configmap-immutable-volume">Update configuration via an immutable ConfigMap that is mounted as a volume</h2><div class="alert alert-info"><h4 class="alert-heading">Note:</h4><p>Immutable ConfigMaps are especially used for configuration that is constant and is <strong>not</strong> expected
to change over time. Marking a ConfigMap as immutable allows a performance improvement where the kubelet does not watch for changes.</p><p>If you do need to make a change, you should plan to either:</p><ul><li>change the name of the ConfigMap, and switch to running Pods that reference the new name</li><li>replace all the nodes in your cluster that have previously run a Pod that used the old value</li><li>restart the kubelet on any node where the kubelet previously loaded the old ConfigMap</li></ul></div><p>An example manifest for an <a href="/docs/concepts/configuration/configmap/#configmap-immutable">Immutable ConfigMap</a> is shown below.</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/configmap/immutable-configmap.yaml"><code>configmap/immutable-configmap.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" title="Copy configmap/immutable-configmap.yaml to clipboard"></div><div class="includecode" id="configmap-immutable-configmap-yaml"><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span>apiVersion</span>:<span> </span>v1<span>
</span></span></span><span><span><span></span><span>data</span>:<span>
</span></span></span><span><span><span>  </span><span>company_name</span>:<span> </span><span>"ACME, Inc."</span><span> </span><span># existing fictional company name</span><span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>ConfigMap<span>
</span></span></span><span><span><span></span><span>immutable</span>:<span> </span><span>true</span><span>
</span></span></span><span><span><span></span><span>metadata</span>:<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>company-name-20150801</span></span></code></pre></div></div></div><p>Create the Immutable ConfigMap:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl apply -f https://k8s.io/examples/configmap/immutable-configmap.yaml
</span></span></code></pre></div><p>Below is an example of a Deployment manifest with the Immutable ConfigMap <code>company-name-20150801</code> mounted as a
<a class="glossary-tooltip" title="A directory containing data, accessible to the containers in a pod." href="/docs/concepts/storage/volumes/" target="_blank">volume</a> into the Pod's only container.</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/deployments/deployment-with-immutable-configmap-as-volume.yaml"><code>deployments/deployment-with-immutable-configmap-as-volume.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" title="Copy deployments/deployment-with-immutable-configmap-as-volume.yaml to clipboard"></div><div class="includecode" id="deployments-deployment-with-immutable-configmap-as-volume-yaml"><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span>apiVersion</span>:<span> </span>apps/v1<span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>Deployment<span>
</span></span></span><span><span><span></span><span>metadata</span>:<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>immutable-configmap-volume<span>
</span></span></span><span><span><span>  </span><span>labels</span>:<span>
</span></span></span><span><span><span>    </span><span>app.kubernetes.io/name</span>:<span> </span>immutable-configmap-volume<span>
</span></span></span><span><span><span></span><span>spec</span>:<span>
</span></span></span><span><span><span>  </span><span>replicas</span>:<span> </span><span>3</span><span>
</span></span></span><span><span><span>  </span><span>selector</span>:<span>
</span></span></span><span><span><span>    </span><span>matchLabels</span>:<span>
</span></span></span><span><span><span>      </span><span>app.kubernetes.io/name</span>:<span> </span>immutable-configmap-volume<span>
</span></span></span><span><span><span>  </span><span>template</span>:<span>
</span></span></span><span><span><span>    </span><span>metadata</span>:<span>
</span></span></span><span><span><span>      </span><span>labels</span>:<span>
</span></span></span><span><span><span>        </span><span>app.kubernetes.io/name</span>:<span> </span>immutable-configmap-volume<span>
</span></span></span><span><span><span>    </span><span>spec</span>:<span>
</span></span></span><span><span><span>      </span><span>containers</span>:<span>
</span></span></span><span><span><span>        </span>- <span>name</span>:<span> </span>alpine<span>
</span></span></span><span><span><span>          </span><span>image</span>:<span> </span>alpine:3<span>
</span></span></span><span><span><span>          </span><span>command</span>:<span>
</span></span></span><span><span><span>            </span>- /bin/sh<span>
</span></span></span><span><span><span>            </span>- -c<span>
</span></span></span><span><span><span>            </span>- while true; do echo "$(date) The name of the company is $(cat /etc/config/company_name)";<span>
</span></span></span><span><span><span>              </span>sleep 10; done;<span>
</span></span></span><span><span><span>          </span><span>ports</span>:<span>
</span></span></span><span><span><span>            </span>- <span>containerPort</span>:<span> </span><span>80</span><span>
</span></span></span><span><span><span>          </span><span>volumeMounts</span>:<span>
</span></span></span><span><span><span>            </span>- <span>name</span>:<span> </span>config-volume<span>
</span></span></span><span><span><span>              </span><span>mountPath</span>:<span> </span>/etc/config<span>
</span></span></span><span><span><span>      </span><span>volumes</span>:<span>
</span></span></span><span><span><span>        </span>- <span>name</span>:<span> </span>config-volume<span>
</span></span></span><span><span><span>          </span><span>configMap</span>:<span>
</span></span></span><span><span><span>            </span><span>name</span>:<span> </span>company-name-20150801</span></span></code></pre></div></div></div><p>Create the Deployment:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl apply -f https://k8s.io/examples/deployments/deployment-with-immutable-configmap-as-volume.yaml
</span></span></code></pre></div><p>Check the pods for this Deployment to ensure they are ready (matching by
<a class="glossary-tooltip" title="Allows users to filter a list of resources based on labels." href="/docs/concepts/overview/working-with-objects/labels/" target="_blank">selector</a>):</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pods --selector<span>=</span>app.kubernetes.io/name<span>=</span>immutable-configmap-volume
</span></span></code></pre></div><p>You should see an output similar to:</p><pre tabindex="0"><code>NAME                                          READY   STATUS    RESTARTS   AGE
immutable-configmap-volume-78b6fbff95-5gsfh   1/1     Running   0          62s
immutable-configmap-volume-78b6fbff95-7vcj4   1/1     Running   0          62s
immutable-configmap-volume-78b6fbff95-vdslm   1/1     Running   0          62s
</code></pre><p>The Pod's container refers to the data defined in the ConfigMap and uses it to print a report to stdout.
You can check this report by viewing the logs for one of the Pods in that Deployment:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span># Pick one Pod that belongs to the Deployment, and view its logs</span>
</span></span><span><span>kubectl logs deployments/immutable-configmap-volume
</span></span></code></pre></div><p>You should see an output similar to:</p><pre tabindex="0"><code>Found 3 pods, using pod/immutable-configmap-volume-78b6fbff95-5gsfh
Wed Mar 20 03:52:34 UTC 2024 The name of the company is ACME, Inc.
Wed Mar 20 03:52:44 UTC 2024 The name of the company is ACME, Inc.
Wed Mar 20 03:52:54 UTC 2024 The name of the company is ACME, Inc.
</code></pre><div class="alert alert-info"><h4 class="alert-heading">Note:</h4>Once a ConfigMap is marked as immutable, it is not possible to revert this change
nor to mutate the contents of the data or the binaryData field.<br>In order to modify the behavior of the Pods that use this configuration,
you will create a new immutable ConfigMap and edit the Deployment
to define a slightly different pod template, referencing the new ConfigMap.</div><p>Create a new immutable ConfigMap by using the manifest shown below:</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/configmap/new-immutable-configmap.yaml"><code>configmap/new-immutable-configmap.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" title="Copy configmap/new-immutable-configmap.yaml to clipboard"></div><div class="includecode" id="configmap-new-immutable-configmap-yaml"><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span>apiVersion</span>:<span> </span>v1<span>
</span></span></span><span><span><span></span><span>data</span>:<span>
</span></span></span><span><span><span>  </span><span>company_name</span>:<span> </span><span>"Fiktivesunternehmen GmbH"</span><span> </span><span># new fictional company name</span><span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>ConfigMap<span>
</span></span></span><span><span><span></span><span>immutable</span>:<span> </span><span>true</span><span>
</span></span></span><span><span><span></span><span>metadata</span>:<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>company-name-20240312</span></span></code></pre></div></div></div><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl apply -f https://k8s.io/examples/configmap/new-immutable-configmap.yaml
</span></span></code></pre></div><p>You should see an output similar to:</p><pre tabindex="0"><code>configmap/company-name-20240312 created
</code></pre><p>Check the newly created ConfigMap:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get configmap
</span></span></code></pre></div><p>You should see an output displaying both the old and new ConfigMaps:</p><pre tabindex="0"><code>NAME                    DATA   AGE
company-name-20150801   1      22m
company-name-20240312   1      24s
</code></pre><p>Modify the Deployment to reference the new ConfigMap.</p><p>Edit the Deployment:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl edit deployment immutable-configmap-volume
</span></span></code></pre></div><p>In the editor that appears, update the existing volume definition to use the new ConfigMap.</p><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span>volumes</span>:<span>
</span></span></span><span><span><span></span>- <span>configMap</span>:<span>
</span></span></span><span><span><span>    </span><span>defaultMode</span>:<span> </span><span>420</span><span>
</span></span></span><span><span><span>    </span><span>name</span>:<span> </span>company-name-20240312<span> </span><span># Update this field</span><span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>config-volume<span>
</span></span></span></code></pre></div><p>You should see the following output:</p><pre tabindex="0"><code>deployment.apps/immutable-configmap-volume edited
</code></pre><p>This will trigger a rollout. Wait for all the previous Pods to terminate and the new Pods to be in a ready state.</p><p>Monitor the status of the Pods:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pods --selector<span>=</span>app.kubernetes.io/name<span>=</span>immutable-configmap-volume
</span></span></code></pre></div><pre tabindex="0"><code>NAME                                          READY   STATUS        RESTARTS   AGE
immutable-configmap-volume-5fdb88fcc8-29v8n   1/1     Running       0          13s
immutable-configmap-volume-5fdb88fcc8-52ddd   1/1     Running       0          14s
immutable-configmap-volume-5fdb88fcc8-n5jx4   1/1     Running       0          15s
immutable-configmap-volume-78b6fbff95-5gsfh   1/1     Terminating   0          32m
immutable-configmap-volume-78b6fbff95-7vcj4   1/1     Terminating   0          32m
immutable-configmap-volume-78b6fbff95-vdslm   1/1     Terminating   0          32m
</code></pre><p>You should eventually see an output similar to:</p><pre tabindex="0"><code>NAME                                          READY   STATUS    RESTARTS   AGE
immutable-configmap-volume-5fdb88fcc8-29v8n   1/1     Running   0          43s
immutable-configmap-volume-5fdb88fcc8-52ddd   1/1     Running   0          44s
immutable-configmap-volume-5fdb88fcc8-n5jx4   1/1     Running   0          45s
</code></pre><p>View the logs for a Pod in this Deployment:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span># Pick one Pod that belongs to the Deployment, and view its logs</span>
</span></span><span><span>kubectl logs deployment/immutable-configmap-volume
</span></span></code></pre></div><p>You should see an output similar to the below:</p><pre tabindex="0"><code>Found 3 pods, using pod/immutable-configmap-volume-5fdb88fcc8-n5jx4
Wed Mar 20 04:24:17 UTC 2024 The name of the company is Fiktivesunternehmen GmbH
Wed Mar 20 04:24:27 UTC 2024 The name of the company is Fiktivesunternehmen GmbH
Wed Mar 20 04:24:37 UTC 2024 The name of the company is Fiktivesunternehmen GmbH
</code></pre><p>Once all the deployments have migrated to use the new immutable ConfigMap, it is advised to delete the old one.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl delete configmap company-name-20150801
</span></span></code></pre></div><h2 id="summary">Summary</h2><p>Changes to a ConfigMap mounted as a Volume on a Pod are available seamlessly after the subsequent kubelet sync.</p><p>Changes to a ConfigMap that configures environment variables for a Pod are available after the subsequent rollout for the Pod.</p><p>Once a ConfigMap is marked as immutable, it is not possible to revert this change
(you cannot make an immutable ConfigMap mutable), and you also cannot make any change
to the contents of the <code>data</code> or the <code>binaryData</code> field. You can delete and recreate
the ConfigMap, or you can make a new different ConfigMap. When you delete a ConfigMap,
running containers and their Pods maintain a mount point to any volume that referenced
that existing ConfigMap.</p><h2 id="cleaning-up">Cleaning up</h2><p>Terminate the <code>kubectl port-forward</code> commands in case they are running.</p><p>Delete the resources created during the tutorial:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl delete deployment configmap-volume configmap-env-var configmap-two-containers configmap-sidecar-container immutable-configmap-volume
</span></span><span><span>kubectl delete service configmap-service configmap-sidecar-service
</span></span><span><span>kubectl delete configmap sport fruits color company-name-20240312
</span></span><span><span>
</span></span><span><span>kubectl delete configmap company-name-20150801 <span># In case it was not handled during the task execution</span>
</span></span></code></pre></div></div></div><div><div class="td-content"><h1>Configuring Redis using a ConfigMap</h1><p>This page provides a real world example of how to configure Redis using a ConfigMap and builds upon the <a href="/docs/tasks/configure-pod-container/configure-pod-configmap/">Configure a Pod to Use a ConfigMap</a> task.</p><h2 id="objectives">Objectives</h2><ul><li>Create a ConfigMap with Redis configuration values</li><li>Create a Redis Pod that mounts and uses the created ConfigMap</li><li>Verify that the configuration was correctly applied.</li></ul><h2 id="before-you-begin">Before you begin</h2><p><p>You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. It is recommended to run this tutorial on a cluster with at least two nodes that are not acting as control plane hosts. If you do not already have a
cluster, you can create one by using
<a href="https://minikube.sigs.k8s.io/docs/tutorials/multi_node/">minikube</a>
or you can use one of these Kubernetes playgrounds:</p><ul><li><a href="https://labs.iximiuz.com/playgrounds?category=kubernetes&amp;filter=all">iximiuz Labs</a></li><li><a href="https://killercoda.com/playgrounds/scenario/kubernetes">Killercoda</a></li><li><a href="https://kodekloud.com/public-playgrounds">KodeKloud</a></li><li><a href="https://labs.play-with-k8s.com/">Play with Kubernetes</a></li></ul><p>To check the version, enter <code>kubectl version</code>.</p></p><ul><li>The example shown on this page works with <code>kubectl</code> 1.14 and above.</li><li>Understand <a href="/docs/tasks/configure-pod-container/configure-pod-configmap/">Configure a Pod to Use a ConfigMap</a>.</li></ul><h2 id="real-world-example-configuring-redis-using-a-configmap">Real World Example: Configuring Redis using a ConfigMap</h2><p>Follow the steps below to configure a Redis cache using data stored in a ConfigMap.</p><p>First create a ConfigMap with an empty configuration block:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>cat <span>&lt;&lt;EOF &gt;./example-redis-config.yaml
</span></span></span><span><span><span>apiVersion: v1
</span></span></span><span><span><span>kind: ConfigMap
</span></span></span><span><span><span>metadata:
</span></span></span><span><span><span>  name: example-redis-config
</span></span></span><span><span><span>data:
</span></span></span><span><span><span>  redis-config: ""
</span></span></span><span><span><span>EOF</span>
</span></span></code></pre></div><p>Apply the ConfigMap created above, along with a Redis pod manifest:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl apply -f example-redis-config.yaml
</span></span><span><span>kubectl apply -f https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/pods/config/redis-pod.yaml
</span></span></code></pre></div><p>Examine the contents of the Redis pod manifest and note the following:</p><ul><li>A volume named <code>config</code> is created by <code>spec.volumes[1]</code></li><li>The <code>key</code> and <code>path</code> under <code>spec.volumes[1].configMap.items[0]</code> exposes the <code>redis-config</code> key from the
<code>example-redis-config</code> ConfigMap as a file named <code>redis.conf</code> on the <code>config</code> volume.</li><li>The <code>config</code> volume is then mounted at <code>/redis-master</code> by <code>spec.containers[0].volumeMounts[1]</code>.</li></ul><p>This has the net effect of exposing the data in <code>data.redis-config</code> from the <code>example-redis-config</code>
ConfigMap above as <code>/redis-master/redis.conf</code> inside the Pod.</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/pods/config/redis-pod.yaml"><code>pods/config/redis-pod.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" title="Copy pods/config/redis-pod.yaml to clipboard"></div><div class="includecode" id="pods-config-redis-pod-yaml"><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span>apiVersion</span>:<span> </span>v1<span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>Pod<span>
</span></span></span><span><span><span></span><span>metadata</span>:<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>redis<span>
</span></span></span><span><span><span></span><span>spec</span>:<span>
</span></span></span><span><span><span>  </span><span>containers</span>:<span>
</span></span></span><span><span><span>  </span>- <span>name</span>:<span> </span>redis<span>
</span></span></span><span><span><span>    </span><span>image</span>:<span> </span>redis:8.0.2<span>
</span></span></span><span><span><span>    </span><span>command</span>:<span>
</span></span></span><span><span><span>      </span>- redis-server<span>
</span></span></span><span><span><span>      </span>- <span>"/redis-master/redis.conf"</span><span>
</span></span></span><span><span><span>    </span><span>env</span>:<span>
</span></span></span><span><span><span>    </span>- <span>name</span>:<span> </span>MASTER<span>
</span></span></span><span><span><span>      </span><span>value</span>:<span> </span><span>"true"</span><span>
</span></span></span><span><span><span>    </span><span>ports</span>:<span>
</span></span></span><span><span><span>    </span>- <span>containerPort</span>:<span> </span><span>6379</span><span>
</span></span></span><span><span><span>    </span><span>resources</span>:<span>
</span></span></span><span><span><span>      </span><span>limits</span>:<span>
</span></span></span><span><span><span>        </span><span>cpu</span>:<span> </span><span>"0.1"</span><span>
</span></span></span><span><span><span>    </span><span>volumeMounts</span>:<span>
</span></span></span><span><span><span>    </span>- <span>mountPath</span>:<span> </span>/redis-master-data<span>
</span></span></span><span><span><span>      </span><span>name</span>:<span> </span>data<span>
</span></span></span><span><span><span>    </span>- <span>mountPath</span>:<span> </span>/redis-master<span>
</span></span></span><span><span><span>      </span><span>name</span>:<span> </span>config<span>
</span></span></span><span><span><span>  </span><span>volumes</span>:<span>
</span></span></span><span><span><span>    </span>- <span>name</span>:<span> </span>data<span>
</span></span></span><span><span><span>      </span><span>emptyDir</span>:<span> </span>{}<span>
</span></span></span><span><span><span>    </span>- <span>name</span>:<span> </span>config<span>
</span></span></span><span><span><span>      </span><span>configMap</span>:<span>
</span></span></span><span><span><span>        </span><span>name</span>:<span> </span>example-redis-config<span>
</span></span></span><span><span><span>        </span><span>items</span>:<span>
</span></span></span><span><span><span>        </span>- <span>key</span>:<span> </span>redis-config<span>
</span></span></span><span><span><span>          </span><span>path</span>:<span> </span>redis.conf<span>
</span></span></span></code></pre></div></div></div><p>Examine the created objects:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pod/redis configmap/example-redis-config 
</span></span></code></pre></div><p>You should see the following output:</p><pre tabindex="0"><code>NAME        READY   STATUS    RESTARTS   AGE
pod/redis   1/1     Running   0          8s

NAME                             DATA   AGE
configmap/example-redis-config   1      14s
</code></pre><p>Recall that we left <code>redis-config</code> key in the <code>example-redis-config</code> ConfigMap blank:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl describe configmap/example-redis-config
</span></span></code></pre></div><p>You should see an empty <code>redis-config</code> key:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>Name:         example-redis-config
</span></span><span><span>Namespace:    default
</span></span><span><span>Labels:       &lt;none&gt;
</span></span><span><span>Annotations:  &lt;none&gt;
</span></span><span><span>
</span></span><span><span><span>Data</span>
</span></span><span><span><span>====</span>
</span></span><span><span>redis-config:
</span></span></code></pre></div><p>Use <code>kubectl exec</code> to enter the pod and run the <code>redis-cli</code> tool to check the current configuration:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl <span>exec</span> -it pod/redis -- redis-cli
</span></span></code></pre></div><p>Check <code>maxmemory</code>:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>127.0.0.1:6379&gt; CONFIG GET maxmemory
</span></span></code></pre></div><p>It should show the default value of 0:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>1<span>)</span> <span>"maxmemory"</span>
</span></span><span><span>2<span>)</span> <span>"0"</span>
</span></span></code></pre></div><p>Similarly, check <code>maxmemory-policy</code>:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>127.0.0.1:6379&gt; CONFIG GET maxmemory-policy
</span></span></code></pre></div><p>Which should also yield its default value of <code>noeviction</code>:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>1<span>)</span> <span>"maxmemory-policy"</span>
</span></span><span><span>2<span>)</span> <span>"noeviction"</span>
</span></span></code></pre></div><p>Now let's add some configuration values to the <code>example-redis-config</code> ConfigMap:</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/pods/config/example-redis-config.yaml"><code>pods/config/example-redis-config.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" title="Copy pods/config/example-redis-config.yaml to clipboard"></div><div class="includecode" id="pods-config-example-redis-config-yaml"><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span>apiVersion</span>:<span> </span>v1<span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>ConfigMap<span>
</span></span></span><span><span><span></span><span>metadata</span>:<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>example-redis-config<span>
</span></span></span><span><span><span></span><span>data</span>:<span>
</span></span></span><span><span><span>  </span><span>redis-config</span>:<span> </span>|<span>
</span></span></span><span><span><span>    maxmemory 2mb
</span></span></span><span><span><span>    maxmemory-policy allkeys-lru</span><span>    
</span></span></span></code></pre></div></div></div><p>Apply the updated ConfigMap:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl apply -f example-redis-config.yaml
</span></span></code></pre></div><p>Confirm that the ConfigMap was updated:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl describe configmap/example-redis-config
</span></span></code></pre></div><p>You should see the configuration values we just added:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>Name:         example-redis-config
</span></span><span><span>Namespace:    default
</span></span><span><span>Labels:       &lt;none&gt;
</span></span><span><span>Annotations:  &lt;none&gt;
</span></span><span><span>
</span></span><span><span><span>Data</span>
</span></span><span><span><span>====</span>
</span></span><span><span>redis-config:
</span></span><span><span>----
</span></span><span><span>maxmemory 2mb
</span></span><span><span>maxmemory-policy allkeys-lru
</span></span></code></pre></div><p>Check the Redis Pod again using <code>redis-cli</code> via <code>kubectl exec</code> to see if the configuration was applied:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl <span>exec</span> -it pod/redis -- redis-cli
</span></span></code></pre></div><p>Check <code>maxmemory</code>:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>127.0.0.1:6379&gt; CONFIG GET maxmemory
</span></span></code></pre></div><p>It remains at the default value of 0:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>1<span>)</span> <span>"maxmemory"</span>
</span></span><span><span>2<span>)</span> <span>"0"</span>
</span></span></code></pre></div><p>Similarly, <code>maxmemory-policy</code> remains at the <code>noeviction</code> default setting:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>127.0.0.1:6379&gt; CONFIG GET maxmemory-policy
</span></span></code></pre></div><p>Returns:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>1<span>)</span> <span>"maxmemory-policy"</span>
</span></span><span><span>2<span>)</span> <span>"noeviction"</span>
</span></span></code></pre></div><p>The configuration values have not changed because the Pod needs to be restarted to grab updated
values from associated ConfigMaps. Let's delete and recreate the Pod:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl delete pod redis
</span></span><span><span>kubectl apply -f https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/pods/config/redis-pod.yaml
</span></span></code></pre></div><p>Now re-check the configuration values one last time:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl <span>exec</span> -it pod/redis -- redis-cli
</span></span></code></pre></div><p>Check <code>maxmemory</code>:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>127.0.0.1:6379&gt; CONFIG GET maxmemory
</span></span></code></pre></div><p>It should now return the updated value of 2097152:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>1<span>)</span> <span>"maxmemory"</span>
</span></span><span><span>2<span>)</span> <span>"2097152"</span>
</span></span></code></pre></div><p>Similarly, <code>maxmemory-policy</code> has also been updated:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>127.0.0.1:6379&gt; CONFIG GET maxmemory-policy
</span></span></code></pre></div><p>It now reflects the desired value of <code>allkeys-lru</code>:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>1<span>)</span> <span>"maxmemory-policy"</span>
</span></span><span><span>2<span>)</span> <span>"allkeys-lru"</span>
</span></span></code></pre></div><p>Clean up your work by deleting the created resources:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl delete pod/redis configmap/example-redis-config
</span></span></code></pre></div><h2 id="what-s-next">What's next</h2><ul><li>Learn more about <a href="/docs/tasks/configure-pod-container/configure-pod-configmap/">ConfigMaps</a>.</li><li>Follow an example of <a href="/docs/tutorials/configuration/updating-configuration-via-a-configmap/">Updating configuration via a ConfigMap</a>.</li></ul></div></div><div><div class="td-content"><h1>Adopting Sidecar Containers</h1><p>This section is relevant for people adopting a new built-in
<a href="/docs/concepts/workloads/pods/sidecar-containers/">sidecar containers</a> feature for their workloads.</p><p>Sidecar container is not a new concept as posted in the
<a href="/blog/2015/06/the-distributed-system-toolkit-patterns/">blog post</a>.
Kubernetes allows running multiple containers in a Pod to implement this concept.
However, running a sidecar container as a regular container
has a lot of limitations being fixed with the new built-in sidecar containers support.</p><div class="feature-state-notice feature-stable" title="Feature Gate: SidecarContainers"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.33 [stable]</code> (enabled by default: true)</div><h2 id="objectives">Objectives</h2><ul><li>Understand the need for sidecar containers</li><li>Be able to troubleshoot issues with the sidecar containers</li><li>Understand options to universally "inject" sidecar containers to any workload</li></ul><h2 id="before-you-begin">Before you begin</h2><p><p>You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. It is recommended to run this tutorial on a cluster with at least two nodes that are not acting as control plane hosts. If you do not already have a
cluster, you can create one by using
<a href="https://minikube.sigs.k8s.io/docs/tutorials/multi_node/">minikube</a>
or you can use one of these Kubernetes playgrounds:</p><ul><li><a href="https://labs.iximiuz.com/playgrounds?category=kubernetes&amp;filter=all">iximiuz Labs</a></li><li><a href="https://killercoda.com/playgrounds/scenario/kubernetes">Killercoda</a></li><li><a href="https://kodekloud.com/public-playgrounds">KodeKloud</a></li><li><a href="https://labs.play-with-k8s.com/">Play with Kubernetes</a></li></ul>Your Kubernetes server must be at or later than version 1.29.<p>To check the version, enter <code>kubectl version</code>.</p></p><h2 id="sidecar-containers-overview">Sidecar containers overview</h2><p>Sidecar containers are secondary containers that run along with the main
application container within the same <a class="glossary-tooltip" title="A Pod represents a set of running containers in your cluster." href="/docs/concepts/workloads/pods/" target="_blank">Pod</a>.
These containers are used to enhance or to extend the functionality of the primary <em>app
container</em> by providing additional services, or functionalities such as logging, monitoring,
security, or data synchronization, without directly altering the primary application code.
You can read more in the <a href="/docs/concepts/workloads/pods/sidecar-containers/">Sidecar containers</a>
concept page.</p><p>The concept of sidecar containers is not new and there are multiple implementations of this concept.
As well as sidecar containers that you, the person defining the Pod, want to run, you can also find
that some <a class="glossary-tooltip" title="Resources that extend the functionality of Kubernetes." href="/docs/concepts/cluster-administration/addons/" target="_blank">addons</a> modify Pods - before the Pods
start running - so that there are extra sidecar containers. The mechanisms to <em>inject</em> those extra
sidecars are often <a href="/docs/reference/access-authn-authz/admission-controllers/#mutatingadmissionwebhook">mutating webhooks</a>.
For example, a service mesh addon might inject a sidecar that configures mutual TLS and encryption
in transit between different Pods.</p><p>While the concept of sidecar containers is not new,
the native implementation of this feature in Kubernetes, however, is new. And as with every new feature,
adopting this feature may present certain challenges.</p><p>This tutorial explores challenges and solutions that can be experienced by end users as well as
by authors of sidecar containers.</p><h2 id="benefits-of-a-built-in-sidecar-container">Benefits of a built-in sidecar container</h2><p>Using Kubernetes' native support for sidecar containers provides several benefits:</p><ol><li>You can configure a native sidecar container to start ahead of
<a class="glossary-tooltip" title="One or more initialization containers that must run to completion before any app containers run." href="/docs/concepts/workloads/pods/init-containers/" target="_blank">init containers</a>.</li><li>The built-in sidecar containers can be authored to guarantee that they are terminated last.
Sidecar containers are terminated with a <code>SIGTERM</code> signal once all the regular containers
are completed and terminated. If the sidecar container isn&#8217;t gracefully shut down, a
<code>SIGKILL</code> signal will be used to terminate it.</li><li>With Jobs, when Pod's <code>restartPolicy: OnFailure</code> or <code>restartPolicy: Never</code>,
native sidecar containers do not block Pod completion. With legacy sidecar containers,
special care is needed to handle this situation.</li><li>Also, with Jobs, built-in sidecar containers would keep being restarted once they are done,
even if regular containers would not with Pod's <code>restartPolicy: Never</code>.</li></ol><p>See <a href="/docs/concepts/workloads/pods/sidecar-containers/#differences-from-application-containers">differences from init containers</a>
to learn more about it.</p><h2 id="adopting-built-in-sidecar-containers">Adopting built-in sidecar containers</h2><p>The <code>SidecarContainers</code> <a href="/docs/reference/command-line-tools-reference/feature-gates/">feature gate</a>
is in beta state starting from Kubernetes version 1.29 and is enabled by default.
Some clusters may have this feature disabled or have software installed that is incompatible with the feature.</p><p>When this happens, the Pod may be rejected or the sidecar containers may block Pod startup,
rendering the Pod useless. This condition is easy to detect as the Pod simply gets stuck on
initialization. However, it is often unclear what caused the problem.</p><p>Here are the considerations and troubleshooting steps that one can take while adopting sidecar containers for their workload.</p><h3 id="ensure-the-feature-gate-is-enabled">Ensure the feature gate is enabled</h3><p>As a very first step, make sure that both API server and Nodes are at Kubernetes version v1.29 or
later. The feature will break on clusters where Nodes are running earlier versions where it is not enabled.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4>The feature can be enabled on nodes with the version 1.28. The behavior of built-in sidecar
container termination was different in version 1.28, and it is not recommended to adjust
the behavior of a sidecar to that behavior. However, if the only concern is the startup order, the
above statement can be changed to Nodes running version 1.28 with the feature gate enabled.</div><p>You should ensure that the feature gate is enabled for the API server(s) within the control plane
<strong>and</strong> for all nodes.</p><p>One of the ways to check the feature gate enablement is to run a command like this:</p><ul><li><p>For API Server:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get --raw /metrics | grep kubernetes_feature_enabled | grep SidecarContainers
</span></span></code></pre></div></li><li><p>For the individual node:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get --raw /api/v1/nodes/&lt;node-name&gt;/proxy/metrics | grep kubernetes_feature_enabled | grep SidecarContainers
</span></span></code></pre></div></li></ul><p>If you see something like this:</p><pre tabindex="0"><code>kubernetes_feature_enabled{name="SidecarContainers",stage="BETA"} 1
</code></pre><p>it means that the feature is enabled.</p><h3 id="check-for-3rd-party-tooling-and-mutating-webhooks">Check for 3rd party tooling and mutating webhooks</h3><p>If you experience issues when validating the feature, it may be an indication that one of the
3rd party tools or mutating webhooks are broken.</p><p>When the <code>SidecarContainers</code> feature gate is enabled, Pods gain a new field in their API.
Some tools or mutating webhooks might have been built with an earlier version of Kubernetes API.</p><p>If tools pass unknown fields as-is using various patching strategies to mutate a Pod object,
this will not be a problem. However, there are tools that will strip out unknown fields;
if you have those, they must be recompiled with the v1.28+ version of Kubernetes API client code.</p><p>The way to check this is to use the <code>kubectl describe pod</code> command with your Pod that has passed through
mutating admission. If any tools stripped out the new field (<code>restartPolicy:Always</code>),
you will not see it in the command output.</p><p>If you hit an issue like this, please advise the author of the tools or the webhooks
use one of the patching strategies for modifying objects instead of a full object update.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4>Mutating webhook may update Pods based on some conditions.
Thus, sidecar containers may work for some Pods and fail for others.</div><h3 id="automatic-injection-of-sidecars">Automatic injection of sidecars</h3><p>If you are using software that injects sidecars automatically,
there are a few possible strategies you may follow to
ensure that native sidecar containers can be used.
All strategies are generally options you may choose to decide whether
the Pod the sidecar will be injected to will land on a Node supporting the feature or not.</p><p>As an example, you can follow <a href="https://github.com/istio/istio/issues/48794">this conversation in Istio community</a>.
The discussion explores the options listed below.</p><ol><li>Mark Pods that land to nodes supporting sidecars. You can use node labels
and node affinity to mark nodes supporting sidecar containers and Pods landing on those nodes.</li><li>Check Nodes compatibility on injection. During sidecar injection, you may use
the following strategies to check node compatibility:<ul><li>query node version and assume the feature gate is enabled on the version 1.29+</li><li>query node prometheus metrics and check feature enablement status</li><li>assume the nodes are running with a <a href="/releases/version-skew-policy/#supported-version-skew">supported version skew</a>
from the API server</li><li>there may be other custom ways to detect nodes compatibility.</li></ul></li><li>Develop a universal sidecar injector. The idea of a universal sidecar injector is to
inject a sidecar container as a regular container as well as a native sidecar container.
And have a runtime logic to decide which one will work. The universal sidecar injector
is wasteful, as it will account for requests twice, but may be considered as a workable
solution for special cases.<ul><li>One way would be on start of a native sidecar container
detect the node version and exit immediately if the version does not support the sidecar feature.</li><li>Consider a runtime feature detection design:<ul><li>Define an empty dir so containers can communicate with each other</li><li>Inject an init container, let's call it <code>NativeSidecar</code> with <code>restartPolicy=Always</code>.</li><li><code>NativeSidecar</code> must write a file to an empty directory indicating the first run and exit
immediately with exit code <code>0</code>.</li><li><code>NativeSidecar</code> on restart (when native sidecars are supported) checks that file already
exists in the empty dir and changes it - indicating that the built-in sidecar containers
are supported and running.</li><li>Inject regular container, let's call it <code>OldWaySidecar</code>.</li><li><code>OldWaySidecar</code> on start checks the presence of a file in an empty dir.</li><li>If the file indicates that the <code>NativeSidecar</code> is NOT running, it assumes that the sidecar
feature is not supported and works assuming it is the sidecar.</li><li>If the file indicates that the <code>NativeSidecar</code> is running, it either does nothing and sleeps
forever (in the case when Pod&#8217;s <code>restartPolicy=Always</code>) or exits immediately with exit code <code>0</code>
(in the case when Pod&#8217;s <code>restartPolicy!=Always</code>).</li></ul></li></ul></li></ol><h2 id="what-s-next">What's next</h2><ul><li>Learn more about <a href="/docs/concepts/workloads/pods/sidecar-containers/">sidecar containers</a>.</li></ul></div></div><div><div class="td-content"><h1>Security</h1><p>Security is an important concern for most organizations and people who run Kubernetes
clusters. You can find a basic <a href="/docs/concepts/security/security-checklist/">security checklist</a>
elsewhere in the Kubernetes documentation.</p><p>To learn how to deploy and manage security aspects of Kubernetes, you can follow the
tutorials in this section.</p><div class="section-index"><hr class="panel-line"><div class="entry"><h5><a href="/docs/tutorials/security/cluster-level-pss/">Apply Pod Security Standards at the Cluster Level</a></h5><p></p></div><div class="entry"><h5><a href="/docs/tutorials/security/ns-level-pss/">Apply Pod Security Standards at the Namespace Level</a></h5><p></p></div><div class="entry"><h5><a href="/docs/tutorials/security/apparmor/">Restrict a Container's Access to Resources with AppArmor</a></h5><p></p></div><div class="entry"><h5><a href="/docs/tutorials/security/seccomp/">Restrict a Container's Syscalls with seccomp</a></h5><p></p></div></div></div></div><div><div class="td-content"><h1>Apply Pod Security Standards at the Cluster Level</h1><div class="alert alert-primary"><h4 class="alert-heading">Note</h4>This tutorial applies only for new clusters.</div><p>Pod Security is an admission controller that carries out checks against the Kubernetes
<a href="/docs/concepts/security/pod-security-standards/">Pod Security Standards</a> when new pods are
created. It is a feature GA'ed in v1.25.
This tutorial shows you how to enforce the <code>baseline</code> Pod Security
Standard at the cluster level which applies a standard configuration
to all namespaces in a cluster.</p><p>To apply Pod Security Standards to specific namespaces, refer to
<a href="/docs/tutorials/security/ns-level-pss/">Apply Pod Security Standards at the namespace level</a>.</p><p>If you are running a version of Kubernetes other than v1.34,
check the documentation for that version.</p><h2 id="before-you-begin">Before you begin</h2><p>Install the following on your workstation:</p><ul><li><a href="https://kind.sigs.k8s.io/docs/user/quick-start/#installation">kind</a></li><li><a href="/docs/tasks/tools/">kubectl</a></li></ul><p>This tutorial demonstrates what you can configure for a Kubernetes cluster that you fully
control. If you are learning how to configure Pod Security Admission for a managed cluster
where you are not able to configure the control plane, read
<a href="/docs/tutorials/security/ns-level-pss/">Apply Pod Security Standards at the namespace level</a>.</p><h2 id="choose-the-right-pod-security-standard-to-apply">Choose the right Pod Security Standard to apply</h2><p><a href="/docs/concepts/security/pod-security-admission/">Pod Security Admission</a>
lets you apply built-in <a href="/docs/concepts/security/pod-security-standards/">Pod Security Standards</a>
with the following modes: <code>enforce</code>, <code>audit</code>, and <code>warn</code>.</p><p>To gather information that helps you to choose the Pod Security Standards
that are most appropriate for your configuration, do the following:</p><ol><li><p>Create a cluster with no Pod Security Standards applied:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kind create cluster --name psa-wo-cluster-pss
</span></span></code></pre></div><p>The output is similar to:</p><pre tabindex="0"><code>Creating cluster "psa-wo-cluster-pss" ...
&#10003; Ensuring node image (kindest/node:v1.34.0) &#128444;
&#10003; Preparing nodes &#128230;
&#10003; Writing configuration &#128220;
&#10003; Starting control-plane &#128377;&#65039;
&#10003; Installing CNI &#128268;
&#10003; Installing StorageClass &#128190;
Set kubectl context to "kind-psa-wo-cluster-pss"
You can now use your cluster with:

kubectl cluster-info --context kind-psa-wo-cluster-pss

Thanks for using kind! &#128522;
</code></pre></li><li><p>Set the kubectl context to the new cluster:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl cluster-info --context kind-psa-wo-cluster-pss
</span></span></code></pre></div><p>The output is similar to this:</p><pre tabindex="0"><code>Kubernetes control plane is running at https://127.0.0.1:61350

CoreDNS is running at https://127.0.0.1:61350/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy

To further debug and diagnose cluster problems, use 'kubectl cluster-info dump'.
</code></pre></li><li><p>Get a list of namespaces in the cluster:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get ns
</span></span></code></pre></div><p>The output is similar to this:</p><pre tabindex="0"><code>NAME                 STATUS   AGE
default              Active   9m30s
kube-node-lease      Active   9m32s
kube-public          Active   9m32s
kube-system          Active   9m32s
local-path-storage   Active   9m26s
</code></pre></li><li><p>Use <code>--dry-run=server</code> to understand what happens when different Pod Security Standards
are applied:</p><ol><li><p>Privileged</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl label --dry-run<span>=</span>server --overwrite ns --all <span>\
</span></span></span><span><span><span></span>pod-security.kubernetes.io/enforce<span>=</span>privileged
</span></span></code></pre></div><p>The output is similar to:</p><pre tabindex="0"><code>namespace/default labeled
namespace/kube-node-lease labeled
namespace/kube-public labeled
namespace/kube-system labeled
namespace/local-path-storage labeled
</code></pre></li><li><p>Baseline</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl label --dry-run<span>=</span>server --overwrite ns --all <span>\
</span></span></span><span><span><span></span>pod-security.kubernetes.io/enforce<span>=</span>baseline
</span></span></code></pre></div><p>The output is similar to:</p><pre tabindex="0"><code>namespace/default labeled
namespace/kube-node-lease labeled
namespace/kube-public labeled
Warning: existing pods in namespace "kube-system" violate the new PodSecurity enforce level "baseline:latest"
Warning: etcd-psa-wo-cluster-pss-control-plane (and 3 other pods): host namespaces, hostPath volumes
Warning: kindnet-vzj42: non-default capabilities, host namespaces, hostPath volumes
Warning: kube-proxy-m6hwf: host namespaces, hostPath volumes, privileged
namespace/kube-system labeled
namespace/local-path-storage labeled
</code></pre></li><li><p>Restricted</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl label --dry-run<span>=</span>server --overwrite ns --all <span>\
</span></span></span><span><span><span></span>pod-security.kubernetes.io/enforce<span>=</span>restricted
</span></span></code></pre></div><p>The output is similar to:</p><pre tabindex="0"><code>namespace/default labeled
namespace/kube-node-lease labeled
namespace/kube-public labeled
Warning: existing pods in namespace "kube-system" violate the new PodSecurity enforce level "restricted:latest"
Warning: coredns-7bb9c7b568-hsptc (and 1 other pod): unrestricted capabilities, runAsNonRoot != true, seccompProfile
Warning: etcd-psa-wo-cluster-pss-control-plane (and 3 other pods): host namespaces, hostPath volumes, allowPrivilegeEscalation != false, unrestricted capabilities, restricted volume types, runAsNonRoot != true
Warning: kindnet-vzj42: non-default capabilities, host namespaces, hostPath volumes, allowPrivilegeEscalation != false, unrestricted capabilities, restricted volume types, runAsNonRoot != true, seccompProfile
Warning: kube-proxy-m6hwf: host namespaces, hostPath volumes, privileged, allowPrivilegeEscalation != false, unrestricted capabilities, restricted volume types, runAsNonRoot != true, seccompProfile
namespace/kube-system labeled
Warning: existing pods in namespace "local-path-storage" violate the new PodSecurity enforce level "restricted:latest"
Warning: local-path-provisioner-d6d9f7ffc-lw9lh: allowPrivilegeEscalation != false, unrestricted capabilities, runAsNonRoot != true, seccompProfile
namespace/local-path-storage labeled
</code></pre></li></ol></li></ol><p>From the previous output, you'll notice that applying the <code>privileged</code> Pod Security Standard shows no warnings
for any namespaces. However, <code>baseline</code> and <code>restricted</code> standards both have
warnings, specifically in the <code>kube-system</code> namespace.</p><h2 id="set-modes-versions-and-standards">Set modes, versions and standards</h2><p>In this section, you apply the following Pod Security Standards to the <code>latest</code> version:</p><ul><li><code>baseline</code> standard in <code>enforce</code> mode.</li><li><code>restricted</code> standard in <code>warn</code> and <code>audit</code> mode.</li></ul><p>The <code>baseline</code> Pod Security Standard provides a convenient
middle ground that allows keeping the exemption list short and prevents known
privilege escalations.</p><p>Additionally, to prevent pods from failing in <code>kube-system</code>, you'll exempt the namespace
from having Pod Security Standards applied.</p><p>When you implement Pod Security Admission in your own environment, consider the
following:</p><ol><li><p>Based on the risk posture applied to a cluster, a stricter Pod Security
Standard like <code>restricted</code> might be a better choice.</p></li><li><p>Exempting the <code>kube-system</code> namespace allows pods to run as
<code>privileged</code> in this namespace. For real world use, the Kubernetes project
strongly recommends that you apply strict RBAC
policies that limit access to <code>kube-system</code>, following the principle of least
privilege.
To implement the preceding standards, do the following:</p></li><li><p>Create a configuration file that can be consumed by the Pod Security
Admission Controller to implement these Pod Security Standards:</p><pre tabindex="0"><code>mkdir -p /tmp/pss
cat &lt;&lt;EOF &gt; /tmp/pss/cluster-level-pss.yaml
apiVersion: apiserver.config.k8s.io/v1
kind: AdmissionConfiguration
plugins:
- name: PodSecurity
  configuration:
    apiVersion: pod-security.admission.config.k8s.io/v1
    kind: PodSecurityConfiguration
    defaults:
      enforce: "baseline"
      enforce-version: "latest"
      audit: "restricted"
      audit-version: "latest"
      warn: "restricted"
      warn-version: "latest"
    exemptions:
      usernames: []
      runtimeClasses: []
      namespaces: [kube-system]
EOF
</code></pre><div class="alert alert-info"><h4 class="alert-heading">Note:</h4><code>pod-security.admission.config.k8s.io/v1</code> configuration requires v1.25+.
For v1.23 and v1.24, use <a href="https://v1-24.docs.kubernetes.io/docs/tasks/configure-pod-container/enforce-standards-admission-controller/">v1beta1</a>.
For v1.22, use <a href="https://v1-22.docs.kubernetes.io/docs/tasks/configure-pod-container/enforce-standards-admission-controller/">v1alpha1</a>.</div></li><li><p>Configure the API server to consume this file during cluster creation:</p><pre tabindex="0"><code>cat &lt;&lt;EOF &gt; /tmp/pss/cluster-config.yaml
kind: Cluster
apiVersion: kind.x-k8s.io/v1alpha4
nodes:
- role: control-plane
  kubeadmConfigPatches:
  - |
    kind: ClusterConfiguration
    apiServer:
        extraArgs:
          admission-control-config-file: /etc/config/cluster-level-pss.yaml
        extraVolumes:
          - name: accf
            hostPath: /etc/config
            mountPath: /etc/config
            readOnly: false
            pathType: "DirectoryOrCreate"
  extraMounts:
  - hostPath: /tmp/pss
    containerPath: /etc/config
    # optional: if set, the mount is read-only.
    # default false
    readOnly: false
    # optional: if set, the mount needs SELinux relabeling.
    # default false
    selinuxRelabel: false
    # optional: set propagation mode (None, HostToContainer or Bidirectional)
    # see https://kubernetes.io/docs/concepts/storage/volumes/#mount-propagation
    # default None
    propagation: None
EOF
</code></pre><div class="alert alert-info"><h4 class="alert-heading">Note:</h4>If you use Docker Desktop with <em>kind</em> on macOS, you can
add <code>/tmp</code> as a Shared Directory under the menu item
<strong>Preferences &gt; Resources &gt; File Sharing</strong>.</div></li><li><p>Create a cluster that uses Pod Security Admission to apply
these Pod Security Standards:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kind create cluster --name psa-with-cluster-pss --config /tmp/pss/cluster-config.yaml
</span></span></code></pre></div><p>The output is similar to this:</p><pre tabindex="0"><code>Creating cluster "psa-with-cluster-pss" ...
 &#10003; Ensuring node image (kindest/node:v1.34.0) &#128444;
 &#10003; Preparing nodes &#128230;
 &#10003; Writing configuration &#128220;
 &#10003; Starting control-plane &#128377;&#65039;
 &#10003; Installing CNI &#128268;
 &#10003; Installing StorageClass &#128190;
Set kubectl context to "kind-psa-with-cluster-pss"
You can now use your cluster with:

kubectl cluster-info --context kind-psa-with-cluster-pss

Have a question, bug, or feature request? Let us know! https://kind.sigs.k8s.io/#community &#128578;
</code></pre></li><li><p>Point kubectl to the cluster:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl cluster-info --context kind-psa-with-cluster-pss
</span></span></code></pre></div><p>The output is similar to this:</p><pre tabindex="0"><code>Kubernetes control plane is running at https://127.0.0.1:63855
CoreDNS is running at https://127.0.0.1:63855/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy

To further debug and diagnose cluster problems, use 'kubectl cluster-info dump'.
</code></pre></li><li><p>Create a Pod in the default namespace:</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/security/example-baseline-pod.yaml"><code>security/example-baseline-pod.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" title="Copy security/example-baseline-pod.yaml to clipboard"></div><div class="includecode" id="security-example-baseline-pod-yaml"><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span>apiVersion</span>:<span> </span>v1<span>
 </span></span></span><span><span><span></span><span>kind</span>:<span> </span>Pod<span>
 </span></span></span><span><span><span></span><span>metadata</span>:<span>
 </span></span></span><span><span><span>  </span><span>name</span>:<span> </span>nginx<span>
 </span></span></span><span><span><span></span><span>spec</span>:<span>
 </span></span></span><span><span><span>  </span><span>containers</span>:<span>
 </span></span></span><span><span><span>    </span>- <span>image</span>:<span> </span>nginx<span>
 </span></span></span><span><span><span>      </span><span>name</span>:<span> </span>nginx<span>
 </span></span></span><span><span><span>      </span><span>ports</span>:<span>
 </span></span></span><span><span><span>        </span>- <span>containerPort</span>:<span> </span><span>80</span><span>
 </span></span></span></code></pre></div></div></div><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl apply -f https://k8s.io/examples/security/example-baseline-pod.yaml
</span></span></code></pre></div><p>The pod is started normally, but the output includes a warning:</p><pre tabindex="0"><code>Warning: would violate PodSecurity "restricted:latest": allowPrivilegeEscalation != false (container "nginx" must set securityContext.allowPrivilegeEscalation=false), unrestricted capabilities (container "nginx" must set securityContext.capabilities.drop=["ALL"]), runAsNonRoot != true (pod or container "nginx" must set securityContext.runAsNonRoot=true), seccompProfile (pod or container "nginx" must set securityContext.seccompProfile.type to "RuntimeDefault" or "Localhost")
pod/nginx created
</code></pre></li></ol><h2 id="clean-up">Clean up</h2><p>Now delete the clusters which you created above by running the following command:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kind delete cluster --name psa-with-cluster-pss
</span></span></code></pre></div><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kind delete cluster --name psa-wo-cluster-pss
</span></span></code></pre></div><h2 id="what-s-next">What's next</h2><ul><li>Run a
<a href="/examples/security/kind-with-cluster-level-baseline-pod-security.sh">shell script</a>
to perform all the preceding steps at once:<ol><li>Create a Pod Security Standards based cluster level Configuration</li><li>Create a file to let API server consume this configuration</li><li>Create a cluster that creates an API server with this configuration</li><li>Set kubectl context to this new cluster</li><li>Create a minimal pod yaml file</li><li>Apply this file to create a Pod in the new cluster</li></ol></li><li><a href="/docs/concepts/security/pod-security-admission/">Pod Security Admission</a></li><li><a href="/docs/concepts/security/pod-security-standards/">Pod Security Standards</a></li><li><a href="/docs/tutorials/security/ns-level-pss/">Apply Pod Security Standards at the namespace level</a></li></ul></div></div><div><div class="td-content"><h1>Apply Pod Security Standards at the Namespace Level</h1><div class="alert alert-primary"><h4 class="alert-heading">Note</h4>This tutorial applies only for new clusters.</div><p>Pod Security Admission is an admission controller that applies
<a href="/docs/concepts/security/pod-security-standards/">Pod Security Standards</a>
when pods are created. It is a feature GA'ed in v1.25.
In this tutorial, you will enforce the <code>baseline</code> Pod Security Standard,
one namespace at a time.</p><p>You can also apply Pod Security Standards to multiple namespaces at once at the cluster
level. For instructions, refer to
<a href="/docs/tutorials/security/cluster-level-pss/">Apply Pod Security Standards at the cluster level</a>.</p><h2 id="before-you-begin">Before you begin</h2><p>Install the following on your workstation:</p><ul><li><a href="https://kind.sigs.k8s.io/docs/user/quick-start/#installation">kind</a></li><li><a href="/docs/tasks/tools/">kubectl</a></li></ul><h2 id="create-cluster">Create cluster</h2><ol><li><p>Create a <code>kind</code> cluster as follows:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kind create cluster --name psa-ns-level
</span></span></code></pre></div><p>The output is similar to this:</p><pre tabindex="0"><code>Creating cluster "psa-ns-level" ...
 &#10003; Ensuring node image (kindest/node:v1.34.0) &#128444; 
 &#10003; Preparing nodes &#128230;  
 &#10003; Writing configuration &#128220; 
 &#10003; Starting control-plane &#128377;&#65039; 
 &#10003; Installing CNI &#128268; 
 &#10003; Installing StorageClass &#128190; 
Set kubectl context to "kind-psa-ns-level"
You can now use your cluster with:

kubectl cluster-info --context kind-psa-ns-level

Not sure what to do next? &#128517;  Check out https://kind.sigs.k8s.io/docs/user/quick-start/
</code></pre></li><li><p>Set the kubectl context to the new cluster:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl cluster-info --context kind-psa-ns-level
</span></span></code></pre></div><p>The output is similar to this:</p><pre tabindex="0"><code>Kubernetes control plane is running at https://127.0.0.1:50996
CoreDNS is running at https://127.0.0.1:50996/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy

To further debug and diagnose cluster problems, use 'kubectl cluster-info dump'.
</code></pre></li></ol><h2 id="create-a-namespace">Create a namespace</h2><p>Create a new namespace called <code>example</code>:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl create ns example
</span></span></code></pre></div><p>The output is similar to this:</p><pre tabindex="0"><code>namespace/example created
</code></pre><h2 id="enable-pod-security-standards-checking-for-that-namespace">Enable Pod Security Standards checking for that namespace</h2><ol><li><p>Enable Pod Security Standards on this namespace using labels supported by
built-in Pod Security Admission. In this step you will configure a check to
warn on Pods that don't meet the latest version of the <em>baseline</em> pod
security standard.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl label --overwrite ns example <span>\
</span></span></span><span><span><span></span>   pod-security.kubernetes.io/warn<span>=</span>baseline <span>\
</span></span></span><span><span><span></span>   pod-security.kubernetes.io/warn-version<span>=</span>latest
</span></span></code></pre></div></li><li><p>You can configure multiple pod security standard checks on any namespace, using labels.
The following command will <code>enforce</code> the <code>baseline</code> Pod Security Standard, but
<code>warn</code> and <code>audit</code> for <code>restricted</code> Pod Security Standards as per the latest
version (default value)</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl label --overwrite ns example <span>\
</span></span></span><span><span><span></span>  pod-security.kubernetes.io/enforce<span>=</span>baseline <span>\
</span></span></span><span><span><span></span>  pod-security.kubernetes.io/enforce-version<span>=</span>latest <span>\
</span></span></span><span><span><span></span>  pod-security.kubernetes.io/warn<span>=</span>restricted <span>\
</span></span></span><span><span><span></span>  pod-security.kubernetes.io/warn-version<span>=</span>latest <span>\
</span></span></span><span><span><span></span>  pod-security.kubernetes.io/audit<span>=</span>restricted <span>\
</span></span></span><span><span><span></span>  pod-security.kubernetes.io/audit-version<span>=</span>latest
</span></span></code></pre></div></li></ol><h2 id="verify-the-pod-security-standard-enforcement">Verify the Pod Security Standard enforcement</h2><ol><li><p>Create a baseline Pod in the <code>example</code> namespace:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl apply -n example -f https://k8s.io/examples/security/example-baseline-pod.yaml
</span></span></code></pre></div><p>The Pod does start OK; the output includes a warning. For example:</p><pre tabindex="0"><code>Warning: would violate PodSecurity "restricted:latest": allowPrivilegeEscalation != false (container "nginx" must set securityContext.allowPrivilegeEscalation=false), unrestricted capabilities (container "nginx" must set securityContext.capabilities.drop=["ALL"]), runAsNonRoot != true (pod or container "nginx" must set securityContext.runAsNonRoot=true), seccompProfile (pod or container "nginx" must set securityContext.seccompProfile.type to "RuntimeDefault" or "Localhost")
pod/nginx created
</code></pre></li><li><p>Create a baseline Pod in the <code>default</code> namespace:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl apply -n default -f https://k8s.io/examples/security/example-baseline-pod.yaml
</span></span></code></pre></div><p>Output is similar to this:</p><pre tabindex="0"><code>pod/nginx created
</code></pre></li></ol><p>The Pod Security Standards enforcement and warning settings were applied only
to the <code>example</code> namespace. You could create the same Pod in the <code>default</code>
namespace with no warnings.</p><h2 id="clean-up">Clean up</h2><p>Now delete the cluster which you created above by running the following command:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kind delete cluster --name psa-ns-level
</span></span></code></pre></div><h2 id="what-s-next">What's next</h2><ul><li><p>Run a
<a href="/examples/security/kind-with-namespace-level-baseline-pod-security.sh">shell script</a>
to perform all the preceding steps all at once.</p><ol><li>Create kind cluster</li><li>Create new namespace</li><li>Apply <code>baseline</code> Pod Security Standard in <code>enforce</code> mode while applying
<code>restricted</code> Pod Security Standard also in <code>warn</code> and <code>audit</code> mode.</li><li>Create a new pod with the following pod security standards applied</li></ol></li><li><p><a href="/docs/concepts/security/pod-security-admission/">Pod Security Admission</a></p></li><li><p><a href="/docs/concepts/security/pod-security-standards/">Pod Security Standards</a></p></li><li><p><a href="/docs/tutorials/security/cluster-level-pss/">Apply Pod Security Standards at the cluster level</a></p></li></ul></div></div><div><div class="td-content"><h1>Restrict a Container's Access to Resources with AppArmor</h1><div class="feature-state-notice feature-stable" title="Feature Gate: AppArmor"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.31 [stable]</code> (enabled by default: true)</div><p>This page shows you how to load AppArmor profiles on your nodes and enforce
those profiles in Pods. To learn more about how Kubernetes can confine Pods using
AppArmor, see
<a href="/docs/concepts/security/linux-kernel-security-constraints/#apparmor">Linux kernel security constraints for Pods and containers</a>.</p><h2 id="objectives">Objectives</h2><ul><li>See an example of how to load a profile on a Node</li><li>Learn how to enforce the profile on a Pod</li><li>Learn how to check that the profile is loaded</li><li>See what happens when a profile is violated</li><li>See what happens when a profile cannot be loaded</li></ul><h2 id="before-you-begin">Before you begin</h2><p>AppArmor is an optional kernel module and Kubernetes feature, so verify it is supported on your
Nodes before proceeding:</p><ol><li><p>AppArmor kernel module is enabled -- For the Linux kernel to enforce an AppArmor profile, the
AppArmor kernel module must be installed and enabled. Several distributions enable the module by
default, such as Ubuntu and SUSE, and many others provide optional support. To check whether the
module is enabled, check the <code>/sys/module/apparmor/parameters/enabled</code> file:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>cat /sys/module/apparmor/parameters/enabled
</span></span><span><span>Y
</span></span></code></pre></div><p>The kubelet verifies that AppArmor is enabled on the host before admitting a pod with AppArmor
explicitly configured.</p></li><li><p>Container runtime supports AppArmor -- All common Kubernetes-supported container
runtimes should support AppArmor, including <a class="glossary-tooltip" title="A container runtime with an emphasis on simplicity, robustness and portability" href="https://containerd.io/docs/" target="_blank">containerd</a> and
<a class="glossary-tooltip" title="A lightweight container runtime specifically for Kubernetes" href="https://cri-o.io/#what-is-cri-o" target="_blank">CRI-O</a>. Please refer to the corresponding runtime
documentation and verify that the cluster fulfills the requirements to use AppArmor.</p></li><li><p>Profile is loaded -- AppArmor is applied to a Pod by specifying an AppArmor profile that each
container should be run with. If any of the specified profiles are not loaded in the
kernel, the kubelet will reject the Pod. You can view which profiles are loaded on a
node by checking the <code>/sys/kernel/security/apparmor/profiles</code> file. For example:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>ssh gke-test-default-pool-239f5d02-gyn2 <span>"sudo cat /sys/kernel/security/apparmor/profiles | sort"</span>
</span></span></code></pre></div><pre tabindex="0"><code>apparmor-test-deny-write (enforce)
apparmor-test-audit-write (enforce)
docker-default (enforce)
k8s-nginx (enforce)
</code></pre><p>For more details on loading profiles on nodes, see
<a href="#setting-up-nodes-with-profiles">Setting up nodes with profiles</a>.</p></li></ol><h2 id="securing-a-pod">Securing a Pod</h2><div class="alert alert-info"><h4 class="alert-heading">Note:</h4>Prior to Kubernetes v1.30, AppArmor was specified through annotations. Use the documentation version
selector to view the documentation with this deprecated API.</div><p>AppArmor profiles can be specified at the pod level or container level. The container AppArmor
profile takes precedence over the pod profile.</p><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span>securityContext</span>:<span>
</span></span></span><span><span><span>  </span><span>appArmorProfile</span>:<span>
</span></span></span><span><span><span>    </span><span>type</span>:<span> </span>&lt;profile_type&gt;<span>
</span></span></span></code></pre></div><p>Where <code>&lt;profile_type&gt;</code> is one of:</p><ul><li><code>RuntimeDefault</code> to use the runtime's default profile</li><li><code>Localhost</code> to use a profile loaded on the host (see below)</li><li><code>Unconfined</code> to run without AppArmor</li></ul><p>See <a href="#specifying-apparmor-confinement">Specifying AppArmor Confinement</a> for full details on the AppArmor profile API.</p><p>To verify that the profile was applied, you can check that the container's root process is
running with the correct profile by examining its proc attr:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl <span>exec</span> &lt;pod_name&gt; -- cat /proc/1/attr/current
</span></span></code></pre></div><p>The output should look something like this:</p><pre tabindex="0"><code>cri-containerd.apparmor.d (enforce)
</code></pre><h2 id="example">Example</h2><p><em>This example assumes you have already set up a cluster with AppArmor support.</em></p><p>First, load the profile you want to use onto your Nodes. This profile blocks all file write operations:</p><pre tabindex="0"><code>#include &lt;tunables/global&gt;

profile k8s-apparmor-example-deny-write flags=(attach_disconnected) {
  #include &lt;abstractions/base&gt;

  file,

  # Deny all file writes.
  deny /** w,
}
</code></pre><p>The profile needs to be loaded onto all nodes, since you don't know where the pod will be scheduled.
For this example you can use SSH to install the profiles, but other approaches are
discussed in <a href="#setting-up-nodes-with-profiles">Setting up nodes with profiles</a>.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span># This example assumes that node names match host names, and are reachable via SSH.</span>
</span></span><span><span><span>NODES</span><span>=(</span><span>$(</span> kubectl get node -o <span>jsonpath</span><span>=</span><span>'{.items[*].status.addresses[?(.type == "Hostname")].address}'</span> <span>)</span><span>)</span>
</span></span><span><span>
</span></span><span><span><span>for</span> NODE in <span>${</span><span>NODES</span>[*]<span>}</span>; <span>do</span> ssh <span>$NODE</span> <span>'sudo apparmor_parser -q &lt;&lt;EOF
</span></span></span><span><span><span>#include &lt;tunables/global&gt;
</span></span></span><span><span><span>
</span></span></span><span><span><span>profile k8s-apparmor-example-deny-write flags=(attach_disconnected) {
</span></span></span><span><span><span>  #include &lt;abstractions/base&gt;
</span></span></span><span><span><span>
</span></span></span><span><span><span>  file,
</span></span></span><span><span><span>
</span></span></span><span><span><span>  # Deny all file writes.
</span></span></span><span><span><span>  deny /** w,
</span></span></span><span><span><span>}
</span></span></span><span><span><span>EOF'</span>
</span></span><span><span><span>done</span>
</span></span></code></pre></div><p>Next, run a simple "Hello AppArmor" Pod with the deny-write profile:</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/pods/security/hello-apparmor.yaml"><code>pods/security/hello-apparmor.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" title="Copy pods/security/hello-apparmor.yaml to clipboard"></div><div class="includecode" id="pods-security-hello-apparmor-yaml"><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span>apiVersion</span>:<span> </span>v1<span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>Pod<span>
</span></span></span><span><span><span></span><span>metadata</span>:<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>hello-apparmor<span>
</span></span></span><span><span><span></span><span>spec</span>:<span>
</span></span></span><span><span><span>  </span><span>securityContext</span>:<span>
</span></span></span><span><span><span>    </span><span>appArmorProfile</span>:<span>
</span></span></span><span><span><span>      </span><span>type</span>:<span> </span>Localhost<span>
</span></span></span><span><span><span>      </span><span>localhostProfile</span>:<span> </span>k8s-apparmor-example-deny-write<span>
</span></span></span><span><span><span>  </span><span>containers</span>:<span>
</span></span></span><span><span><span>  </span>- <span>name</span>:<span> </span>hello<span>
</span></span></span><span><span><span>    </span><span>image</span>:<span> </span>busybox:1.28<span>
</span></span></span><span><span><span>    </span><span>command</span>:<span> </span>[<span> </span><span>"sh"</span>,<span> </span><span>"-c"</span>,<span> </span><span>"echo 'Hello AppArmor!' &amp;&amp; sleep 1h"</span><span> </span>]<span>
</span></span></span></code></pre></div></div></div><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl create -f hello-apparmor.yaml
</span></span></code></pre></div><p>You can verify that the container is actually running with that profile by checking <code>/proc/1/attr/current</code>:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl <span>exec</span> hello-apparmor -- cat /proc/1/attr/current
</span></span></code></pre></div><p>The output should be:</p><pre tabindex="0"><code>k8s-apparmor-example-deny-write (enforce)
</code></pre><p>Finally, you can see what happens if you violate the profile by writing to a file:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl <span>exec</span> hello-apparmor -- touch /tmp/test
</span></span></code></pre></div><pre tabindex="0"><code>touch: /tmp/test: Permission denied
error: error executing remote command: command terminated with non-zero exit code: Error executing in Docker Container: 1
</code></pre><p>To wrap up, see what happens if you try to specify a profile that hasn't been loaded:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl create -f /dev/stdin <span>&lt;&lt;EOF
</span></span></span><span><span><span>apiVersion: v1
</span></span></span><span><span><span>kind: Pod
</span></span></span><span><span><span>metadata:
</span></span></span><span><span><span>  name: hello-apparmor-2
</span></span></span><span><span><span>spec:
</span></span></span><span><span><span>  securityContext:
</span></span></span><span><span><span>    appArmorProfile:
</span></span></span><span><span><span>      type: Localhost
</span></span></span><span><span><span>      localhostProfile: k8s-apparmor-example-allow-write
</span></span></span><span><span><span>  containers:
</span></span></span><span><span><span>  - name: hello
</span></span></span><span><span><span>    image: busybox:1.28
</span></span></span><span><span><span>    command: [ "sh", "-c", "echo 'Hello AppArmor!' &amp;&amp; sleep 1h" ]
</span></span></span><span><span><span>EOF</span>
</span></span></code></pre></div><pre tabindex="0"><code>pod/hello-apparmor-2 created
</code></pre><p>Although the Pod was created successfully, further examination will show that it is stuck in pending:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl describe pod hello-apparmor-2
</span></span></code></pre></div><pre tabindex="0"><code>Name:          hello-apparmor-2
Namespace:     default
Node:          gke-test-default-pool-239f5d02-x1kf/10.128.0.27
Start Time:    Tue, 30 Aug 2016 17:58:56 -0700
Labels:        &lt;none&gt;
Annotations:   container.apparmor.security.beta.kubernetes.io/hello=localhost/k8s-apparmor-example-allow-write
Status:        Pending
... 
Events:
  Type     Reason     Age              From               Message
  ----     ------     ----             ----               -------
  Normal   Scheduled  10s              default-scheduler  Successfully assigned default/hello-apparmor to gke-test-default-pool-239f5d02-x1kf
  Normal   Pulled     8s               kubelet            Successfully pulled image "busybox:1.28" in 370.157088ms (370.172701ms including waiting)
  Normal   Pulling    7s (x2 over 9s)  kubelet            Pulling image "busybox:1.28"
  Warning  Failed     7s (x2 over 8s)  kubelet            Error: failed to get container spec opts: failed to generate apparmor spec opts: apparmor profile not found k8s-apparmor-example-allow-write
  Normal   Pulled     7s               kubelet            Successfully pulled image "busybox:1.28" in 90.980331ms (91.005869ms including waiting)
</code></pre><p>An Event provides the error message with the reason, the specific wording is runtime-dependent:</p><pre tabindex="0"><code>  Warning  Failed     7s (x2 over 8s)  kubelet            Error: failed to get container spec opts: failed to generate apparmor spec opts: apparmor profile not found 
</code></pre><h2 id="administration">Administration</h2><h3 id="setting-up-nodes-with-profiles">Setting up Nodes with profiles</h3><p>Kubernetes 1.34 does not provide any built-in mechanisms for loading AppArmor profiles onto
Nodes. Profiles can be loaded through custom infrastructure or tools like the
<a href="https://github.com/kubernetes-sigs/security-profiles-operator">Kubernetes Security Profiles Operator</a>.</p><p>The scheduler is not aware of which profiles are loaded onto which Node, so the full set of profiles
must be loaded onto every Node. An alternative approach is to add a Node label for each profile (or
class of profiles) on the Node, and use a
<a href="/docs/concepts/scheduling-eviction/assign-pod-node/">node selector</a> to ensure the Pod is run on a
Node with the required profile.</p><h2 id="authoring-profiles">Authoring Profiles</h2><p>Getting AppArmor profiles specified correctly can be a tricky business. Fortunately there are some
tools to help with that:</p><ul><li><code>aa-genprof</code> and <code>aa-logprof</code> generate profile rules by monitoring an application's activity and
logs, and admitting the actions it takes. Further instructions are provided by the
<a href="https://gitlab.com/apparmor/apparmor/wikis/Profiling_with_tools">AppArmor documentation</a>.</li><li><a href="https://github.com/jfrazelle/bane">bane</a> is an AppArmor profile generator for Docker that uses a
simplified profile language.</li></ul><p>To debug problems with AppArmor, you can check the system logs to see what, specifically, was
denied. AppArmor logs verbose messages to <code>dmesg</code>, and errors can usually be found in the system
logs or through <code>journalctl</code>. More information is provided in
<a href="https://gitlab.com/apparmor/apparmor/wikis/AppArmor_Failures">AppArmor failures</a>.</p><h2 id="specifying-apparmor-confinement">Specifying AppArmor confinement</h2><div class="alert alert-caution"><h4 class="alert-heading">Caution:</h4>Prior to Kubernetes v1.30, AppArmor was specified through annotations. Use the documentation version
selector to view the documentation with this deprecated API.</div><h3 id="appArmorProfile">AppArmor profile within security context</h3><p>You can specify the <code>appArmorProfile</code> on either a container's <code>securityContext</code> or on a Pod's
<code>securityContext</code>. If the profile is set at the pod level, it will be used as the default profile
for all containers in the pod (including init, sidecar, and ephemeral containers). If both a pod &amp; container
AppArmor profile are set, the container's profile will be used.</p><p>An AppArmor profile has 2 fields:</p><p><code>type</code> <em>(required)</em> - indicates which kind of AppArmor profile will be applied. Valid options are:</p><dl><dt><code>Localhost</code></dt><dd>a profile pre-loaded on the node (specified by <code>localhostProfile</code>).</dd><dt><code>RuntimeDefault</code></dt><dd>the container runtime's default profile.</dd><dt><code>Unconfined</code></dt><dd>no AppArmor enforcement.</dd></dl><p><code>localhostProfile</code> - The name of a profile loaded on the node that should be used.
The profile must be preconfigured on the node to work.
This option must be provided if and only if the <code>type</code> is <code>Localhost</code>.</p><h2 id="what-s-next">What's next</h2><p>Additional resources:</p><ul><li><a href="https://gitlab.com/apparmor/apparmor/wikis/QuickProfileLanguage">Quick guide to the AppArmor profile language</a></li><li><a href="https://gitlab.com/apparmor/apparmor/wikis/Policy_Layout">AppArmor core policy reference</a></li></ul></div></div><div><div class="td-content"><h1>Restrict a Container's Syscalls with seccomp</h1><div class="feature-state-notice feature-stable"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.19 [stable]</code></div><p>Seccomp stands for secure computing mode and has been a feature of the Linux
kernel since version 2.6.12. It can be used to sandbox the privileges of a
process, restricting the calls it is able to make from userspace into the
kernel. Kubernetes lets you automatically apply seccomp profiles loaded onto a
<a class="glossary-tooltip" title="A node is a worker machine in Kubernetes." href="/docs/concepts/architecture/nodes/" target="_blank">node</a> to your Pods and containers.</p><p>Identifying the privileges required for your workloads can be difficult. In this
tutorial, you will go through how to load seccomp profiles into a local
Kubernetes cluster, how to apply them to a Pod, and how you can begin to craft
profiles that give only the necessary privileges to your container processes.</p><h2 id="objectives">Objectives</h2><ul><li>Learn how to load seccomp profiles on a node</li><li>Learn how to apply a seccomp profile to a container</li><li>Observe auditing of syscalls made by a container process</li><li>Observe behavior when a missing profile is specified</li><li>Observe a violation of a seccomp profile</li><li>Learn how to create fine-grained seccomp profiles</li><li>Learn how to apply a container runtime default seccomp profile</li></ul><h2 id="before-you-begin">Before you begin</h2><p>In order to complete all steps in this tutorial, you must install
<a href="/docs/tasks/tools/#kind">kind</a> and <a href="/docs/tasks/tools/#kubectl">kubectl</a>.</p><p>The commands used in the tutorial assume that you are using
<a href="https://www.docker.com/">Docker</a> as your container runtime. (The cluster that <code>kind</code> creates may
use a different container runtime internally). You could also use
<a href="https://podman.io/">Podman</a> but in that case, you would have to follow specific
<a href="https://kind.sigs.k8s.io/docs/user/rootless/">instructions</a> in order to complete the tasks
successfully.</p><p>This tutorial shows some examples that are still beta (since v1.25) and
others that use only generally available seccomp functionality. You should
make sure that your cluster is
<a href="https://kind.sigs.k8s.io/docs/user/quick-start/#setting-kubernetes-version">configured correctly</a>
for the version you are using.</p><p>The tutorial also uses the <code>curl</code> tool for downloading examples to your computer.
You can adapt the steps to use a different tool if you prefer.</p><div class="alert alert-info"><h4 class="alert-heading">Note:</h4>It is not possible to apply a seccomp profile to a container running with
<code>privileged: true</code> set in the container's <code>securityContext</code>. Privileged containers always
run as <code>Unconfined</code>.</div><h2 id="download-profiles">Download example seccomp profiles</h2><p>The contents of these profiles will be explored later on, but for now go ahead
and download them into a directory named <code>profiles/</code> so that they can be loaded
into the cluster.</p><ul class="nav nav-tabs" id="tab-with-code"><li class="nav-item"><a class="nav-link active" href="#tab-with-code-0">audit.json</a></li><li class="nav-item"><a class="nav-link" href="#tab-with-code-1">violation.json</a></li><li class="nav-item"><a class="nav-link" href="#tab-with-code-2">fine-grained.json</a></li></ul><div class="tab-content" id="tab-with-code"><div id="tab-with-code-0" class="tab-pane show active"><p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/pods/security/seccomp/profiles/audit.json"><code>pods/security/seccomp/profiles/audit.json</code>
</a><img src="/images/copycode.svg" class="icon-copycode" title="Copy pods/security/seccomp/profiles/audit.json to clipboard"></div><div class="includecode" id="pods-security-seccomp-profiles-audit-json"><div class="highlight"><pre tabindex="0"><code class="language-json"><span><span>{
</span></span><span><span>    <span>"defaultAction"</span>: <span>"SCMP_ACT_LOG"</span>
</span></span><span><span>}</span></span></code></pre></div></div></div></p></div><div id="tab-with-code-1" class="tab-pane"><p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/pods/security/seccomp/profiles/violation.json"><code>pods/security/seccomp/profiles/violation.json</code>
</a><img src="/images/copycode.svg" class="icon-copycode" title="Copy pods/security/seccomp/profiles/violation.json to clipboard"></div><div class="includecode" id="pods-security-seccomp-profiles-violation-json"><div class="highlight"><pre tabindex="0"><code class="language-json"><span><span>{
</span></span><span><span>    <span>"defaultAction"</span>: <span>"SCMP_ACT_ERRNO"</span>
</span></span><span><span>}</span></span></code></pre></div></div></div></p></div><div id="tab-with-code-2" class="tab-pane"><p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/pods/security/seccomp/profiles/fine-grained.json"><code>pods/security/seccomp/profiles/fine-grained.json</code>
</a><img src="/images/copycode.svg" class="icon-copycode" title="Copy pods/security/seccomp/profiles/fine-grained.json to clipboard"></div><div class="includecode" id="pods-security-seccomp-profiles-fine-grained-json"><div class="highlight"><pre tabindex="0"><code class="language-json"><span><span>{
</span></span><span><span>    <span>"defaultAction"</span>: <span>"SCMP_ACT_ERRNO"</span>,
</span></span><span><span>    <span>"architectures"</span>: [
</span></span><span><span>        <span>"SCMP_ARCH_X86_64"</span>,
</span></span><span><span>        <span>"SCMP_ARCH_X86"</span>,
</span></span><span><span>        <span>"SCMP_ARCH_X32"</span>
</span></span><span><span>    ],
</span></span><span><span>    <span>"syscalls"</span>: [
</span></span><span><span>        {
</span></span><span><span>            <span>"names"</span>: [
</span></span><span><span>                <span>"accept4"</span>,
</span></span><span><span>                <span>"epoll_wait"</span>,
</span></span><span><span>                <span>"pselect6"</span>,
</span></span><span><span>                <span>"futex"</span>,
</span></span><span><span>                <span>"madvise"</span>,
</span></span><span><span>                <span>"epoll_ctl"</span>,
</span></span><span><span>                <span>"getsockname"</span>,
</span></span><span><span>                <span>"setsockopt"</span>,
</span></span><span><span>                <span>"vfork"</span>,
</span></span><span><span>                <span>"mmap"</span>,
</span></span><span><span>                <span>"read"</span>,
</span></span><span><span>                <span>"write"</span>,
</span></span><span><span>                <span>"close"</span>,
</span></span><span><span>                <span>"arch_prctl"</span>,
</span></span><span><span>                <span>"sched_getaffinity"</span>,
</span></span><span><span>                <span>"munmap"</span>,
</span></span><span><span>                <span>"brk"</span>,
</span></span><span><span>                <span>"rt_sigaction"</span>,
</span></span><span><span>                <span>"rt_sigprocmask"</span>,
</span></span><span><span>                <span>"sigaltstack"</span>,
</span></span><span><span>                <span>"gettid"</span>,
</span></span><span><span>                <span>"clone"</span>,
</span></span><span><span>                <span>"bind"</span>,
</span></span><span><span>                <span>"socket"</span>,
</span></span><span><span>                <span>"openat"</span>,
</span></span><span><span>                <span>"readlinkat"</span>,
</span></span><span><span>                <span>"exit_group"</span>,
</span></span><span><span>                <span>"epoll_create1"</span>,
</span></span><span><span>                <span>"listen"</span>,
</span></span><span><span>                <span>"rt_sigreturn"</span>,
</span></span><span><span>                <span>"sched_yield"</span>,
</span></span><span><span>                <span>"clock_gettime"</span>,
</span></span><span><span>                <span>"connect"</span>,
</span></span><span><span>                <span>"dup2"</span>,
</span></span><span><span>                <span>"epoll_pwait"</span>,
</span></span><span><span>                <span>"execve"</span>,
</span></span><span><span>                <span>"exit"</span>,
</span></span><span><span>                <span>"fcntl"</span>,
</span></span><span><span>                <span>"getpid"</span>,
</span></span><span><span>                <span>"getuid"</span>,
</span></span><span><span>                <span>"ioctl"</span>,
</span></span><span><span>                <span>"mprotect"</span>,
</span></span><span><span>                <span>"nanosleep"</span>,
</span></span><span><span>                <span>"open"</span>,
</span></span><span><span>                <span>"poll"</span>,
</span></span><span><span>                <span>"recvfrom"</span>,
</span></span><span><span>                <span>"sendto"</span>,
</span></span><span><span>                <span>"set_tid_address"</span>,
</span></span><span><span>                <span>"setitimer"</span>,
</span></span><span><span>                <span>"writev"</span>,
</span></span><span><span>                <span>"fstatfs"</span>,
</span></span><span><span>                <span>"getdents64"</span>,
</span></span><span><span>                <span>"pipe2"</span>,
</span></span><span><span>                <span>"getrlimit"</span>
</span></span><span><span>            ],
</span></span><span><span>            <span>"action"</span>: <span>"SCMP_ACT_ALLOW"</span>
</span></span><span><span>        }
</span></span><span><span>    ]
</span></span><span><span>}</span></span></code></pre></div></div></div></p></div></div><p>Run these commands:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>mkdir ./profiles
</span></span><span><span>curl -L -o profiles/audit.json https://k8s.io/examples/pods/security/seccomp/profiles/audit.json
</span></span><span><span>curl -L -o profiles/violation.json https://k8s.io/examples/pods/security/seccomp/profiles/violation.json
</span></span><span><span>curl -L -o profiles/fine-grained.json https://k8s.io/examples/pods/security/seccomp/profiles/fine-grained.json
</span></span><span><span>ls profiles
</span></span></code></pre></div><p>You should see three profiles listed at the end of the final step:</p><pre tabindex="0"><code>audit.json  fine-grained.json  violation.json
</code></pre><h2 id="create-a-local-kubernetes-cluster-with-kind">Create a local Kubernetes cluster with kind</h2><p>For simplicity, <a href="https://kind.sigs.k8s.io/">kind</a> can be used to create a single
node cluster with the seccomp profiles loaded. Kind runs Kubernetes in Docker,
so each node of the cluster is a container. This allows for files
to be mounted in the filesystem of each container similar to loading files
onto a node.</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/pods/security/seccomp/kind.yaml"><code>pods/security/seccomp/kind.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" title="Copy pods/security/seccomp/kind.yaml to clipboard"></div><div class="includecode" id="pods-security-seccomp-kind-yaml"><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span>apiVersion</span>:<span> </span>kind.x-k8s.io/v1alpha4<span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>Cluster<span>
</span></span></span><span><span><span></span><span>nodes</span>:<span>
</span></span></span><span><span><span></span>- <span>role</span>:<span> </span>control-plane<span>
</span></span></span><span><span><span>  </span><span>extraMounts</span>:<span>
</span></span></span><span><span><span>  </span>- <span>hostPath</span>:<span> </span><span>"./profiles"</span><span>
</span></span></span><span><span><span>    </span><span>containerPath</span>:<span> </span><span>"/var/lib/kubelet/seccomp/profiles"</span></span></span></code></pre></div></div></div><p>Download that example kind configuration, and save it to a file named <code>kind.yaml</code>:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>curl -L -O https://k8s.io/examples/pods/security/seccomp/kind.yaml
</span></span></code></pre></div><p>You can set a specific Kubernetes version by setting the node's container image.
See <a href="https://kind.sigs.k8s.io/docs/user/configuration/#nodes">Nodes</a> within the
kind documentation about configuration for more details on this.
This tutorial assumes you are using Kubernetes v1.34.</p><p>As a beta feature, you can configure Kubernetes to use the profile that the
<a class="glossary-tooltip" title="The container runtime is the software that is responsible for running containers." href="/docs/setup/production-environment/container-runtimes" target="_blank">container runtime</a>
prefers by default, rather than falling back to <code>Unconfined</code>.
If you want to try that, see
<a href="#enable-the-use-of-runtimedefault-as-the-default-seccomp-profile-for-all-workloads">enable the use of <code>RuntimeDefault</code> as the default seccomp profile for all workloads</a>
before you continue.</p><p>Once you have a kind configuration in place, create the kind cluster with
that configuration:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kind create cluster --config<span>=</span>kind.yaml
</span></span></code></pre></div><p>After the new Kubernetes cluster is ready, identify the Docker container running
as the single node cluster:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>docker ps
</span></span></code></pre></div><p>You should see output indicating that a container is running with name
<code>kind-control-plane</code>. The output is similar to:</p><pre tabindex="0"><code>CONTAINER ID        IMAGE                  COMMAND                  CREATED             STATUS              PORTS                       NAMES
6a96207fed4b        kindest/node:v1.18.2   "/usr/local/bin/entr&#8230;"   27 seconds ago      Up 24 seconds       127.0.0.1:42223-&gt;6443/tcp   kind-control-plane
</code></pre><p>If observing the filesystem of that container, you should see that the
<code>profiles/</code> directory has been successfully loaded into the default seccomp path
of the kubelet. Use <code>docker exec</code> to run a command in the Pod:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span># Change 6a96207fed4b to the container ID you saw from "docker ps"</span>
</span></span><span><span>docker <span>exec</span> -it 6a96207fed4b ls /var/lib/kubelet/seccomp/profiles
</span></span></code></pre></div><pre tabindex="0"><code>audit.json  fine-grained.json  violation.json
</code></pre><p>You have verified that these seccomp profiles are available to the kubelet
running within kind.</p><h2 id="create-a-pod-that-uses-the-container-runtime-default-seccomp-profile">Create a Pod that uses the container runtime default seccomp profile</h2><p>Most container runtimes provide a sane set of default syscalls that are allowed
or not. You can adopt these defaults for your workload by setting the seccomp
type in the security context of a pod or container to <code>RuntimeDefault</code>.</p><div class="alert alert-info"><h4 class="alert-heading">Note:</h4>If you have the <code>seccompDefault</code> <a href="/docs/reference/config-api/kubelet-config.v1beta1/">configuration</a>
enabled, then Pods use the <code>RuntimeDefault</code> seccomp profile whenever
no other seccomp profile is specified. Otherwise, the default is <code>Unconfined</code>.</div><p>Here's a manifest for a Pod that requests the <code>RuntimeDefault</code> seccomp profile
for all its containers:</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/pods/security/seccomp/ga/default-pod.yaml"><code>pods/security/seccomp/ga/default-pod.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" title="Copy pods/security/seccomp/ga/default-pod.yaml to clipboard"></div><div class="includecode" id="pods-security-seccomp-ga-default-pod-yaml"><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span>apiVersion</span>:<span> </span>v1<span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>Pod<span>
</span></span></span><span><span><span></span><span>metadata</span>:<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>default-pod<span>
</span></span></span><span><span><span>  </span><span>labels</span>:<span>
</span></span></span><span><span><span>    </span><span>app</span>:<span> </span>default-pod<span>
</span></span></span><span><span><span></span><span>spec</span>:<span>
</span></span></span><span><span><span>  </span><span>securityContext</span>:<span>
</span></span></span><span><span><span>    </span><span>seccompProfile</span>:<span>
</span></span></span><span><span><span>      </span><span>type</span>:<span> </span>RuntimeDefault<span>
</span></span></span><span><span><span>  </span><span>containers</span>:<span>
</span></span></span><span><span><span>  </span>- <span>name</span>:<span> </span>test-container<span>
</span></span></span><span><span><span>    </span><span>image</span>:<span> </span>hashicorp/http-echo:1.0<span>
</span></span></span><span><span><span>    </span><span>args</span>:<span>
</span></span></span><span><span><span>    </span>- <span>"-text=just made some more syscalls!"</span><span>
</span></span></span><span><span><span>    </span><span>securityContext</span>:<span>
</span></span></span><span><span><span>      </span><span>allowPrivilegeEscalation</span>:<span> </span><span>false</span></span></span></code></pre></div></div></div><p>Create that Pod:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl apply -f https://k8s.io/examples/pods/security/seccomp/ga/default-pod.yaml
</span></span></code></pre></div><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pod default-pod
</span></span></code></pre></div><p>The Pod should be showing as having started successfully:</p><pre tabindex="0"><code>NAME        READY   STATUS    RESTARTS   AGE
default-pod 1/1     Running   0          20s
</code></pre><p>Delete the Pod before moving to the next section:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl delete pod default-pod --wait --now
</span></span></code></pre></div><h2 id="create-a-pod-with-a-seccomp-profile-for-syscall-auditing">Create a Pod with a seccomp profile for syscall auditing</h2><p>To start off, apply the <code>audit.json</code> profile, which will log all syscalls of the
process, to a new Pod.</p><p>Here's a manifest for that Pod:</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/pods/security/seccomp/ga/audit-pod.yaml"><code>pods/security/seccomp/ga/audit-pod.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" title="Copy pods/security/seccomp/ga/audit-pod.yaml to clipboard"></div><div class="includecode" id="pods-security-seccomp-ga-audit-pod-yaml"><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span>apiVersion</span>:<span> </span>v1<span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>Pod<span>
</span></span></span><span><span><span></span><span>metadata</span>:<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>audit-pod<span>
</span></span></span><span><span><span>  </span><span>labels</span>:<span>
</span></span></span><span><span><span>    </span><span>app</span>:<span> </span>audit-pod<span>
</span></span></span><span><span><span></span><span>spec</span>:<span>
</span></span></span><span><span><span>  </span><span>securityContext</span>:<span>
</span></span></span><span><span><span>    </span><span>seccompProfile</span>:<span>
</span></span></span><span><span><span>      </span><span>type</span>:<span> </span>Localhost<span>
</span></span></span><span><span><span>      </span><span>localhostProfile</span>:<span> </span>profiles/audit.json<span>
</span></span></span><span><span><span>  </span><span>containers</span>:<span>
</span></span></span><span><span><span>  </span>- <span>name</span>:<span> </span>test-container<span>
</span></span></span><span><span><span>    </span><span>image</span>:<span> </span>hashicorp/http-echo:1.0<span>
</span></span></span><span><span><span>    </span><span>args</span>:<span>
</span></span></span><span><span><span>    </span>- <span>"-text=just made some syscalls!"</span><span>
</span></span></span><span><span><span>    </span><span>securityContext</span>:<span>
</span></span></span><span><span><span>      </span><span>allowPrivilegeEscalation</span>:<span> </span><span>false</span></span></span></code></pre></div></div></div><div class="alert alert-info"><h4 class="alert-heading">Note:</h4>Older versions of Kubernetes allowed you to configure seccomp
behavior using <a class="glossary-tooltip" title="A key-value pair that is used to attach arbitrary non-identifying metadata to objects." href="/docs/concepts/overview/working-with-objects/annotations" target="_blank">annotations</a>.
Kubernetes 1.34 only supports using fields within
<code>.spec.securityContext</code> to configure seccomp, and this tutorial explains that
approach.</div><p>Create the Pod in the cluster:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl apply -f https://k8s.io/examples/pods/security/seccomp/ga/audit-pod.yaml
</span></span></code></pre></div><p>This profile does not restrict any syscalls, so the Pod should start
successfully.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pod audit-pod
</span></span></code></pre></div><pre tabindex="0"><code>NAME        READY   STATUS    RESTARTS   AGE
audit-pod   1/1     Running   0          30s
</code></pre><p>In order to be able to interact with this endpoint exposed by this
container, create a NodePort <a class="glossary-tooltip" title="A way to expose an application running on a set of Pods as a network service." href="/docs/concepts/services-networking/service/" target="_blank">Service</a>
that allows access to the endpoint from inside the kind control plane container.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl expose pod audit-pod --type NodePort --port <span>5678</span>
</span></span></code></pre></div><p>Check what port the Service has been assigned on the node.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get service audit-pod
</span></span></code></pre></div><p>The output is similar to:</p><pre tabindex="0"><code>NAME        TYPE       CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE
audit-pod   NodePort   10.111.36.142   &lt;none&gt;        5678:32373/TCP   72s
</code></pre><p>Now you can use <code>curl</code> to access that endpoint from inside the kind control plane container,
at the port exposed by this Service. Use <code>docker exec</code> to run the <code>curl</code> command within the
container belonging to that control plane container:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span># Change 6a96207fed4b to the control plane container ID and 32373 to the port number you saw from "docker ps"</span>
</span></span><span><span>docker <span>exec</span> -it 6a96207fed4b curl localhost:32373
</span></span></code></pre></div><pre tabindex="0"><code>just made some syscalls!
</code></pre><p>You can see that the process is running, but what syscalls did it actually make?
Because this Pod is running in a local cluster, you should be able to see those
in <code>/var/log/syslog</code> on your local system. Open up a new terminal window and <code>tail</code> the output for
calls from <code>http-echo</code>:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span># The log path on your computer might be different from "/var/log/syslog"</span>
</span></span><span><span>tail -f /var/log/syslog | grep <span>'http-echo'</span>
</span></span></code></pre></div><p>You should already see some logs of syscalls made by <code>http-echo</code>, and if you run <code>curl</code> again inside
the control plane container you will see more output written to the log.</p><p>For example:</p><pre tabindex="0"><code>Jul  6 15:37:40 my-machine kernel: [369128.669452] audit: type=1326 audit(1594067860.484:14536): auid=4294967295 uid=0 gid=0 ses=4294967295 pid=29064 comm="http-echo" exe="/http-echo" sig=0 arch=c000003e syscall=51 compat=0 ip=0x46fe1f code=0x7ffc0000
Jul  6 15:37:40 my-machine kernel: [369128.669453] audit: type=1326 audit(1594067860.484:14537): auid=4294967295 uid=0 gid=0 ses=4294967295 pid=29064 comm="http-echo" exe="/http-echo" sig=0 arch=c000003e syscall=54 compat=0 ip=0x46fdba code=0x7ffc0000
Jul  6 15:37:40 my-machine kernel: [369128.669455] audit: type=1326 audit(1594067860.484:14538): auid=4294967295 uid=0 gid=0 ses=4294967295 pid=29064 comm="http-echo" exe="/http-echo" sig=0 arch=c000003e syscall=202 compat=0 ip=0x455e53 code=0x7ffc0000
Jul  6 15:37:40 my-machine kernel: [369128.669456] audit: type=1326 audit(1594067860.484:14539): auid=4294967295 uid=0 gid=0 ses=4294967295 pid=29064 comm="http-echo" exe="/http-echo" sig=0 arch=c000003e syscall=288 compat=0 ip=0x46fdba code=0x7ffc0000
Jul  6 15:37:40 my-machine kernel: [369128.669517] audit: type=1326 audit(1594067860.484:14540): auid=4294967295 uid=0 gid=0 ses=4294967295 pid=29064 comm="http-echo" exe="/http-echo" sig=0 arch=c000003e syscall=0 compat=0 ip=0x46fd44 code=0x7ffc0000
Jul  6 15:37:40 my-machine kernel: [369128.669519] audit: type=1326 audit(1594067860.484:14541): auid=4294967295 uid=0 gid=0 ses=4294967295 pid=29064 comm="http-echo" exe="/http-echo" sig=0 arch=c000003e syscall=270 compat=0 ip=0x4559b1 code=0x7ffc0000
Jul  6 15:38:40 my-machine kernel: [369188.671648] audit: type=1326 audit(1594067920.488:14559): auid=4294967295 uid=0 gid=0 ses=4294967295 pid=29064 comm="http-echo" exe="/http-echo" sig=0 arch=c000003e syscall=270 compat=0 ip=0x4559b1 code=0x7ffc0000
Jul  6 15:38:40 my-machine kernel: [369188.671726] audit: type=1326 audit(1594067920.488:14560): auid=4294967295 uid=0 gid=0 ses=4294967295 pid=29064 comm="http-echo" exe="/http-echo" sig=0 arch=c000003e syscall=202 compat=0 ip=0x455e53 code=0x7ffc0000
</code></pre><p>You can begin to understand the syscalls required by the <code>http-echo</code> process by
looking at the <code>syscall=</code> entry on each line. While these are unlikely to
encompass all syscalls it uses, it can serve as a basis for a seccomp profile
for this container.</p><p>Delete the Service and the Pod before moving to the next section:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl delete service audit-pod --wait
</span></span><span><span>kubectl delete pod audit-pod --wait --now
</span></span></code></pre></div><h2 id="create-a-pod-with-a-seccomp-profile-that-causes-violation">Create a Pod with a seccomp profile that causes violation</h2><p>For demonstration, apply a profile to the Pod that does not allow for any
syscalls.</p><p>The manifest for this demonstration is:</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/pods/security/seccomp/ga/violation-pod.yaml"><code>pods/security/seccomp/ga/violation-pod.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" title="Copy pods/security/seccomp/ga/violation-pod.yaml to clipboard"></div><div class="includecode" id="pods-security-seccomp-ga-violation-pod-yaml"><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span>apiVersion</span>:<span> </span>v1<span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>Pod<span>
</span></span></span><span><span><span></span><span>metadata</span>:<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>violation-pod<span>
</span></span></span><span><span><span>  </span><span>labels</span>:<span>
</span></span></span><span><span><span>    </span><span>app</span>:<span> </span>violation-pod<span>
</span></span></span><span><span><span></span><span>spec</span>:<span>
</span></span></span><span><span><span>  </span><span>securityContext</span>:<span>
</span></span></span><span><span><span>    </span><span>seccompProfile</span>:<span>
</span></span></span><span><span><span>      </span><span>type</span>:<span> </span>Localhost<span>
</span></span></span><span><span><span>      </span><span>localhostProfile</span>:<span> </span>profiles/violation.json<span>
</span></span></span><span><span><span>  </span><span>containers</span>:<span>
</span></span></span><span><span><span>  </span>- <span>name</span>:<span> </span>test-container<span>
</span></span></span><span><span><span>    </span><span>image</span>:<span> </span>hashicorp/http-echo:1.0<span>
</span></span></span><span><span><span>    </span><span>args</span>:<span>
</span></span></span><span><span><span>    </span>- <span>"-text=just made some syscalls!"</span><span>
</span></span></span><span><span><span>    </span><span>securityContext</span>:<span>
</span></span></span><span><span><span>      </span><span>allowPrivilegeEscalation</span>:<span> </span><span>false</span></span></span></code></pre></div></div></div><p>Attempt to create the Pod in the cluster:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl apply -f https://k8s.io/examples/pods/security/seccomp/ga/violation-pod.yaml
</span></span></code></pre></div><p>The Pod creates, but there is an issue.
If you check the status of the Pod, you should see that it failed to start.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pod violation-pod
</span></span></code></pre></div><pre tabindex="0"><code>NAME            READY   STATUS             RESTARTS   AGE
violation-pod   0/1     CrashLoopBackOff   1          6s
</code></pre><p>As seen in the previous example, the <code>http-echo</code> process requires quite a few
syscalls. Here seccomp has been instructed to error on any syscall by setting
<code>"defaultAction": "SCMP_ACT_ERRNO"</code>. This is extremely secure, but removes the
ability to do anything meaningful. What you really want is to give workloads
only the privileges they need.</p><p>Delete the Pod before moving to the next section:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl delete pod violation-pod --wait --now
</span></span></code></pre></div><h2 id="create-a-pod-with-a-seccomp-profile-that-only-allows-necessary-syscalls">Create a Pod with a seccomp profile that only allows necessary syscalls</h2><p>If you take a look at the <code>fine-grained.json</code> profile, you will notice some of the syscalls
seen in syslog of the first example where the profile set <code>"defaultAction": "SCMP_ACT_LOG"</code>. Now the profile is setting <code>"defaultAction": "SCMP_ACT_ERRNO"</code>,
but explicitly allowing a set of syscalls in the <code>"action": "SCMP_ACT_ALLOW"</code>
block. Ideally, the container will run successfully and you will see no messages
sent to <code>syslog</code>.</p><p>The manifest for this example is:</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/pods/security/seccomp/ga/fine-pod.yaml"><code>pods/security/seccomp/ga/fine-pod.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" title="Copy pods/security/seccomp/ga/fine-pod.yaml to clipboard"></div><div class="includecode" id="pods-security-seccomp-ga-fine-pod-yaml"><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span>apiVersion</span>:<span> </span>v1<span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>Pod<span>
</span></span></span><span><span><span></span><span>metadata</span>:<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>fine-pod<span>
</span></span></span><span><span><span>  </span><span>labels</span>:<span>
</span></span></span><span><span><span>    </span><span>app</span>:<span> </span>fine-pod<span>
</span></span></span><span><span><span></span><span>spec</span>:<span>
</span></span></span><span><span><span>  </span><span>securityContext</span>:<span>
</span></span></span><span><span><span>    </span><span>seccompProfile</span>:<span>
</span></span></span><span><span><span>      </span><span>type</span>:<span> </span>Localhost<span>
</span></span></span><span><span><span>      </span><span>localhostProfile</span>:<span> </span>profiles/fine-grained.json<span>
</span></span></span><span><span><span>  </span><span>containers</span>:<span>
</span></span></span><span><span><span>  </span>- <span>name</span>:<span> </span>test-container<span>
</span></span></span><span><span><span>    </span><span>image</span>:<span> </span>hashicorp/http-echo:1.0<span>
</span></span></span><span><span><span>    </span><span>args</span>:<span>
</span></span></span><span><span><span>    </span>- <span>"-text=just made some syscalls!"</span><span>
</span></span></span><span><span><span>    </span><span>securityContext</span>:<span>
</span></span></span><span><span><span>      </span><span>allowPrivilegeEscalation</span>:<span> </span><span>false</span></span></span></code></pre></div></div></div><p>Create the Pod in your cluster:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl apply -f https://k8s.io/examples/pods/security/seccomp/ga/fine-pod.yaml
</span></span></code></pre></div><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pod fine-pod
</span></span></code></pre></div><p>The Pod should be showing as having started successfully:</p><pre tabindex="0"><code>NAME        READY   STATUS    RESTARTS   AGE
fine-pod   1/1     Running   0          30s
</code></pre><p>Open up a new terminal window and use <code>tail</code> to monitor for log entries that
mention calls from <code>http-echo</code>:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span># The log path on your computer might be different from "/var/log/syslog"</span>
</span></span><span><span>tail -f /var/log/syslog | grep <span>'http-echo'</span>
</span></span></code></pre></div><p>Next, expose the Pod with a NodePort Service:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl expose pod fine-pod --type NodePort --port <span>5678</span>
</span></span></code></pre></div><p>Check what port the Service has been assigned on the node:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get service fine-pod
</span></span></code></pre></div><p>The output is similar to:</p><pre tabindex="0"><code>NAME        TYPE       CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE
fine-pod    NodePort   10.111.36.142   &lt;none&gt;        5678:32373/TCP   72s
</code></pre><p>Use <code>curl</code> to access that endpoint from inside the kind control plane container:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span># Change 6a96207fed4b to the control plane container ID and 32373 to the port number you saw from "docker ps"</span>
</span></span><span><span>docker <span>exec</span> -it 6a96207fed4b curl localhost:32373
</span></span></code></pre></div><pre tabindex="0"><code>just made some syscalls!
</code></pre><p>You should see no output in the <code>syslog</code>. This is because the profile allowed all
necessary syscalls and specified that an error should occur if one outside of
the list is invoked. This is an ideal situation from a security perspective, but
required some effort in analyzing the program. It would be nice if there was a
simple way to get closer to this security without requiring as much effort.</p><p>Delete the Service and the Pod before moving to the next section:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl delete service fine-pod --wait
</span></span><span><span>kubectl delete pod fine-pod --wait --now
</span></span></code></pre></div><h2 id="enable-the-use-of-runtimedefault-as-the-default-seccomp-profile-for-all-workloads">Enable the use of <code>RuntimeDefault</code> as the default seccomp profile for all workloads</h2><div class="feature-state-notice feature-stable"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.27 [stable]</code></div><p>To use seccomp profile defaulting, you must run the kubelet with the
<code>--seccomp-default</code>
<a href="/docs/reference/command-line-tools-reference/kubelet/">command line flag</a>
enabled for each node where you want to use it.</p><p>If enabled, the kubelet will use the <code>RuntimeDefault</code> seccomp profile by default, which is
defined by the container runtime, instead of using the <code>Unconfined</code> (seccomp disabled) mode.
The default profiles aim to provide a strong set
of security defaults while preserving the functionality of the workload. It is
possible that the default profiles differ between container runtimes and their
release versions, for example when comparing those from CRI-O and containerd.</p><div class="alert alert-info"><h4 class="alert-heading">Note:</h4>Enabling the feature will neither change the Kubernetes
<code>securityContext.seccompProfile</code> API field nor add the deprecated annotations of
the workload. This provides users the possibility to rollback anytime without
actually changing the workload configuration. Tools like
<a href="https://github.com/kubernetes-sigs/cri-tools"><code>crictl inspect</code></a> can be used to
verify which seccomp profile is being used by a container.</div><p>Some workloads may require a lower amount of syscall restrictions than others.
This means that they can fail during runtime even with the <code>RuntimeDefault</code>
profile. To mitigate such a failure, you can:</p><ul><li>Run the workload explicitly as <code>Unconfined</code>.</li><li>Disable the <code>SeccompDefault</code> feature for the nodes. Also making sure that
workloads get scheduled on nodes where the feature is disabled.</li><li>Create a custom seccomp profile for the workload.</li></ul><p>If you were introducing this feature into production-like cluster, the Kubernetes project
recommends that you enable this feature gate on a subset of your nodes and then
test workload execution before rolling the change out cluster-wide.</p><p>You can find more detailed information about a possible upgrade and downgrade strategy
in the related Kubernetes Enhancement Proposal (KEP):
<a href="https://github.com/kubernetes/enhancements/tree/9a124fd29d1f9ddf2ff455c49a630e3181992c25/keps/sig-node/2413-seccomp-by-default#upgrade--downgrade-strategy">Enable seccomp by default</a>.</p><p>Kubernetes 1.34 lets you configure the seccomp profile
that applies when the spec for a Pod doesn't define a specific seccomp profile.
However, you still need to enable this defaulting for each node where you would
like to use it.</p><p>If you are running a Kubernetes 1.34 cluster and want to
enable the feature, either run the kubelet with the <code>--seccomp-default</code> command
line flag, or enable it through the <a href="/docs/tasks/administer-cluster/kubelet-config-file/">kubelet configuration
file</a>. To enable the
feature gate in <a href="https://kind.sigs.k8s.io">kind</a>, ensure that <code>kind</code> provides
the minimum required Kubernetes version and enables the <code>SeccompDefault</code> feature
<a href="https://kind.sigs.k8s.io/docs/user/quick-start/#enable-feature-gates-in-your-cluster">in the kind configuration</a>:</p><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span>kind</span>:<span> </span>Cluster<span>
</span></span></span><span><span><span></span><span>apiVersion</span>:<span> </span>kind.x-k8s.io/v1alpha4<span>
</span></span></span><span><span><span></span><span>nodes</span>:<span>
</span></span></span><span><span><span>  </span>- <span>role</span>:<span> </span>control-plane<span>
</span></span></span><span><span><span>    </span><span>image</span>:<span> </span>kindest/node:v1.28.0@sha256:9f3ff58f19dcf1a0611d11e8ac989fdb30a28f40f236f59f0bea31fb956ccf5c<span>
</span></span></span><span><span><span>    </span><span>kubeadmConfigPatches</span>:<span>
</span></span></span><span><span><span>      </span>- |<span>
</span></span></span><span><span><span>        kind: JoinConfiguration
</span></span></span><span><span><span>        nodeRegistration:
</span></span></span><span><span><span>          kubeletExtraArgs:
</span></span></span><span><span><span>            seccomp-default: "true"</span><span>        
</span></span></span><span><span><span>  </span>- <span>role</span>:<span> </span>worker<span>
</span></span></span><span><span><span>    </span><span>image</span>:<span> </span>kindest/node:v1.28.0@sha256:9f3ff58f19dcf1a0611d11e8ac989fdb30a28f40f236f59f0bea31fb956ccf5c<span>
</span></span></span><span><span><span>    </span><span>kubeadmConfigPatches</span>:<span>
</span></span></span><span><span><span>      </span>- |<span>
</span></span></span><span><span><span>        kind: JoinConfiguration
</span></span></span><span><span><span>        nodeRegistration:
</span></span></span><span><span><span>          kubeletExtraArgs:
</span></span></span><span><span><span>            seccomp-default: "true"</span><span>        
</span></span></span></code></pre></div><p>If the cluster is ready, then running a pod:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl run --rm -it --restart<span>=</span>Never --image<span>=</span>alpine alpine -- sh
</span></span></code></pre></div><p>Should now have the default seccomp profile attached. This can be verified by
using <code>docker exec</code> to run <code>crictl inspect</code> for the container on the kind
worker:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>docker <span>exec</span> -it kind-worker bash -c <span>\
</span></span></span><span><span><span></span>    <span>'crictl inspect $(crictl ps --name=alpine -q) | jq .info.runtimeSpec.linux.seccomp'</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0"><code class="language-json"><span><span>{
</span></span><span><span>  <span>"defaultAction"</span>: <span>"SCMP_ACT_ERRNO"</span>,
</span></span><span><span>  <span>"architectures"</span>: [<span>"SCMP_ARCH_X86_64"</span>, <span>"SCMP_ARCH_X86"</span>, <span>"SCMP_ARCH_X32"</span>],
</span></span><span><span>  <span>"syscalls"</span>: [
</span></span><span><span>    {
</span></span><span><span>      <span>"names"</span>: [<span>"..."</span>]
</span></span><span><span>    }
</span></span><span><span>  ]
</span></span><span><span>}
</span></span></code></pre></div><h2 id="what-s-next">What's next</h2><p>You can learn more about Linux seccomp:</p><ul><li><a href="https://lwn.net/Articles/656307/">A seccomp Overview</a></li><li><a href="https://docs.docker.com/engine/security/seccomp/">Seccomp Security Profiles for Docker</a></li></ul></div></div><div><div class="td-content"><h1>Stateless Applications</h1><div class="section-index"><hr class="panel-line"><div class="entry"><h5><a href="/docs/tutorials/stateless-application/expose-external-ip-address/">Exposing an External IP Address to Access an Application in a Cluster</a></h5><p></p></div><div class="entry"><h5><a href="/docs/tutorials/stateless-application/guestbook/">Example: Deploying PHP Guestbook application with Redis</a></h5><p></p></div></div></div></div><div><div class="td-content"><h1>Exposing an External IP Address to Access an Application in a Cluster</h1><p>This page shows how to create a Kubernetes Service object that exposes an
external IP address.</p><h2 id="before-you-begin">Before you begin</h2><ul><li>Install <a href="/docs/tasks/tools/">kubectl</a>.</li><li>Use a cloud provider like Google Kubernetes Engine or Amazon Web Services to
create a Kubernetes cluster. This tutorial creates an
<a href="/docs/tasks/access-application-cluster/create-external-load-balancer/">external load balancer</a>,
which requires a cloud provider.</li><li>Configure <code>kubectl</code> to communicate with your Kubernetes API server. For instructions, see the
documentation for your cloud provider.</li></ul><h2 id="objectives">Objectives</h2><ul><li>Run five instances of a Hello World application.</li><li>Create a Service object that exposes an external IP address.</li><li>Use the Service object to access the running application.</li></ul><h2 id="creating-a-service-for-an-application-running-in-five-pods">Creating a service for an application running in five pods</h2><ol><li><p>Run a Hello World application in your cluster:</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/service/load-balancer-example.yaml"><code>service/load-balancer-example.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" title="Copy service/load-balancer-example.yaml to clipboard"></div><div class="includecode" id="service-load-balancer-example-yaml"><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span>apiVersion</span>:<span> </span>apps/v1<span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>Deployment<span>
</span></span></span><span><span><span></span><span>metadata</span>:<span>
</span></span></span><span><span><span>  </span><span>labels</span>:<span>
</span></span></span><span><span><span>    </span><span>app.kubernetes.io/name</span>:<span> </span>load-balancer-example<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>hello-world<span>
</span></span></span><span><span><span></span><span>spec</span>:<span>
</span></span></span><span><span><span>  </span><span>replicas</span>:<span> </span><span>5</span><span>
</span></span></span><span><span><span>  </span><span>selector</span>:<span>
</span></span></span><span><span><span>    </span><span>matchLabels</span>:<span>
</span></span></span><span><span><span>      </span><span>app.kubernetes.io/name</span>:<span> </span>load-balancer-example<span>
</span></span></span><span><span><span>  </span><span>template</span>:<span>
</span></span></span><span><span><span>    </span><span>metadata</span>:<span>
</span></span></span><span><span><span>      </span><span>labels</span>:<span>
</span></span></span><span><span><span>        </span><span>app.kubernetes.io/name</span>:<span> </span>load-balancer-example<span>
</span></span></span><span><span><span>    </span><span>spec</span>:<span>
</span></span></span><span><span><span>      </span><span>containers</span>:<span>
</span></span></span><span><span><span>      </span>- <span>image</span>:<span> </span>gcr.io/google-samples/hello-app:2.0<span>
</span></span></span><span><span><span>        </span><span>name</span>:<span> </span>hello-world<span>
</span></span></span><span><span><span>        </span><span>ports</span>:<span>
</span></span></span><span><span><span>        </span>- <span>containerPort</span>:<span> </span><span>8080</span><span>
</span></span></span></code></pre></div></div></div><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl apply -f https://k8s.io/examples/service/load-balancer-example.yaml
</span></span></code></pre></div><p>The preceding command creates a
<a class="glossary-tooltip" title="Manages a replicated application on your cluster." href="/docs/concepts/workloads/controllers/deployment/" target="_blank">Deployment</a>
and an associated
<a class="glossary-tooltip" title="ReplicaSet ensures that a specified number of Pod replicas are running at one time" href="/docs/concepts/workloads/controllers/replicaset/" target="_blank">ReplicaSet</a>.
The ReplicaSet has five
<a class="glossary-tooltip" title="A Pod represents a set of running containers in your cluster." href="/docs/concepts/workloads/pods/" target="_blank">Pods</a>
each of which runs the Hello World application.</p></li><li><p>Display information about the Deployment:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get deployments hello-world
</span></span><span><span>kubectl describe deployments hello-world
</span></span></code></pre></div></li><li><p>Display information about your ReplicaSet objects:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get replicasets
</span></span><span><span>kubectl describe replicasets
</span></span></code></pre></div></li><li><p>Create a Service object that exposes the deployment:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl expose deployment hello-world --type<span>=</span>LoadBalancer --name<span>=</span>my-service
</span></span></code></pre></div></li><li><p>Display information about the Service:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get services my-service
</span></span></code></pre></div><p>The output is similar to:</p><div class="highlight"><pre tabindex="0"><code class="language-console"><span><span><span>NAME         TYPE           CLUSTER-IP     EXTERNAL-IP      PORT(S)    AGE
</span></span></span><span><span><span>my-service   LoadBalancer   10.3.245.137   104.198.205.71   8080/TCP   54s
</span></span></span></code></pre></div><div class="alert alert-info"><h4 class="alert-heading">Note:</h4>The <code>type=LoadBalancer</code> service is backed by external cloud providers, which is not covered in this example. Please refer to <a href="/docs/concepts/services-networking/service/#loadbalancer">setting <code>type: LoadBalancer</code> for your Service</a> for the details.</div><div class="alert alert-info"><h4 class="alert-heading">Note:</h4>If the external IP address is shown as &lt;pending&gt;, wait for a minute and enter the same command again.</div></li><li><p>Display detailed information about the Service:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl describe services my-service
</span></span></code></pre></div><p>The output is similar to:</p><div class="highlight"><pre tabindex="0"><code class="language-console"><span><span><span>Name:           my-service
</span></span></span><span><span><span>Namespace:      default
</span></span></span><span><span><span>Labels:         app.kubernetes.io/name=load-balancer-example
</span></span></span><span><span><span>Annotations:    &lt;none&gt;
</span></span></span><span><span><span>Selector:       app.kubernetes.io/name=load-balancer-example
</span></span></span><span><span><span>Type:           LoadBalancer
</span></span></span><span><span><span>IP:             10.3.245.137
</span></span></span><span><span><span>LoadBalancer Ingress:   104.198.205.71
</span></span></span><span><span><span>Port:           &lt;unset&gt; 8080/TCP
</span></span></span><span><span><span>NodePort:       &lt;unset&gt; 32377/TCP
</span></span></span><span><span><span>Endpoints:      10.0.0.6:8080,10.0.1.6:8080,10.0.1.7:8080 + 2 more...
</span></span></span><span><span><span>Session Affinity:   None
</span></span></span><span><span><span>Events:         &lt;none&gt;
</span></span></span></code></pre></div><p>Make a note of the external IP address (<code>LoadBalancer Ingress</code>) exposed by
your service. In this example, the external IP address is 104.198.205.71.
Also note the value of <code>Port</code> and <code>NodePort</code>. In this example, the <code>Port</code>
is 8080 and the <code>NodePort</code> is 32377.</p></li><li><p>In the preceding output, you can see that the service has several endpoints:
10.0.0.6:8080,10.0.1.6:8080,10.0.1.7:8080 + 2 more. These are internal
addresses of the pods that are running the Hello World application. To
verify these are pod addresses, enter this command:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pods --output<span>=</span>wide
</span></span></code></pre></div><p>The output is similar to:</p><div class="highlight"><pre tabindex="0"><code class="language-console"><span><span><span>NAME                         ...  IP         NODE
</span></span></span><span><span><span>hello-world-2895499144-1jaz9 ...  10.0.1.6   gke-cluster-1-default-pool-e0b8d269-1afc
</span></span></span><span><span><span>hello-world-2895499144-2e5uh ...  10.0.1.8   gke-cluster-1-default-pool-e0b8d269-1afc
</span></span></span><span><span><span>hello-world-2895499144-9m4h1 ...  10.0.0.6   gke-cluster-1-default-pool-e0b8d269-5v7a
</span></span></span><span><span><span>hello-world-2895499144-o4z13 ...  10.0.1.7   gke-cluster-1-default-pool-e0b8d269-1afc
</span></span></span><span><span><span>hello-world-2895499144-segjf ...  10.0.2.5   gke-cluster-1-default-pool-e0b8d269-cpuc
</span></span></span></code></pre></div></li><li><p>Use the external IP address (<code>LoadBalancer Ingress</code>) to access the Hello
World application:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>curl http://&lt;external-ip&gt;:&lt;port&gt;
</span></span></code></pre></div><p>where <code>&lt;external-ip&gt;</code> is the external IP address (<code>LoadBalancer Ingress</code>)
of your Service, and <code>&lt;port&gt;</code> is the value of <code>Port</code> in your Service
description.
If you are using minikube, typing <code>minikube service my-service</code> will
automatically open the Hello World application in a browser.</p><p>The response to a successful request is a hello message:</p><div class="highlight"><pre tabindex="0"><code class="language-console"><span><span><span>Hello, world!
</span></span></span><span><span><span>Version: 2.0.0
</span></span></span><span><span><span>Hostname: 0bd46b45f32f
</span></span></span></code></pre></div></li></ol><h2 id="cleaning-up">Cleaning up</h2><p>To delete the Service, enter this command:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl delete services my-service
</span></span></code></pre></div><p>To delete the Deployment, the ReplicaSet, and the Pods that are running
the Hello World application, enter this command:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl delete deployment hello-world
</span></span></code></pre></div><h2 id="what-s-next">What's next</h2><p>Learn more about
<a href="/docs/tutorials/services/connect-applications-service/">connecting applications with services</a>.</p></div></div><div><div class="td-content"><h1>Example: Deploying PHP Guestbook application with Redis</h1><p>This tutorial shows you how to build and deploy a simple <em>(not production
ready)</em>, multi-tier web application using Kubernetes and
<a href="https://www.docker.com/">Docker</a>. This example consists of the following
components:</p><ul><li>A single-instance <a href="https://www.redis.io/">Redis</a> to store guestbook entries</li><li>Multiple web frontend instances</li></ul><h2 id="objectives">Objectives</h2><ul><li>Start up a Redis leader.</li><li>Start up two Redis followers.</li><li>Start up the guestbook frontend.</li><li>Expose and view the Frontend Service.</li><li>Clean up.</li></ul><h2 id="before-you-begin">Before you begin</h2><p>You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. It is recommended to run this tutorial on a cluster with at least two nodes that are not acting as control plane hosts. If you do not already have a
cluster, you can create one by using
<a href="https://minikube.sigs.k8s.io/docs/tutorials/multi_node/">minikube</a>
or you can use one of these Kubernetes playgrounds:</p><ul><li><a href="https://labs.iximiuz.com/playgrounds?category=kubernetes&amp;filter=all">iximiuz Labs</a></li><li><a href="https://killercoda.com/playgrounds/scenario/kubernetes">Killercoda</a></li><li><a href="https://kodekloud.com/public-playgrounds">KodeKloud</a></li><li><a href="https://labs.play-with-k8s.com/">Play with Kubernetes</a></li></ul>Your Kubernetes server must be at or later than version v1.14.<p>To check the version, enter <code>kubectl version</code>.</p><h2 id="start-up-the-redis-database">Start up the Redis Database</h2><p>The guestbook application uses Redis to store its data.</p><h3 id="creating-the-redis-deployment">Creating the Redis Deployment</h3><p>The manifest file, included below, specifies a Deployment controller that runs a single replica Redis Pod.</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/application/guestbook/redis-leader-deployment.yaml"><code>application/guestbook/redis-leader-deployment.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" title="Copy application/guestbook/redis-leader-deployment.yaml to clipboard"></div><div class="includecode" id="application-guestbook-redis-leader-deployment-yaml"><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span># SOURCE: https://cloud.google.com/kubernetes-engine/docs/tutorials/guestbook</span><span>
</span></span></span><span><span><span></span><span>apiVersion</span>:<span> </span>apps/v1<span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>Deployment<span>
</span></span></span><span><span><span></span><span>metadata</span>:<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>redis-leader<span>
</span></span></span><span><span><span>  </span><span>labels</span>:<span>
</span></span></span><span><span><span>    </span><span>app</span>:<span> </span>redis<span>
</span></span></span><span><span><span>    </span><span>role</span>:<span> </span>leader<span>
</span></span></span><span><span><span>    </span><span>tier</span>:<span> </span>backend<span>
</span></span></span><span><span><span></span><span>spec</span>:<span>
</span></span></span><span><span><span>  </span><span>replicas</span>:<span> </span><span>1</span><span>
</span></span></span><span><span><span>  </span><span>selector</span>:<span>
</span></span></span><span><span><span>    </span><span>matchLabels</span>:<span>
</span></span></span><span><span><span>      </span><span>app</span>:<span> </span>redis<span>
</span></span></span><span><span><span>  </span><span>template</span>:<span>
</span></span></span><span><span><span>    </span><span>metadata</span>:<span>
</span></span></span><span><span><span>      </span><span>labels</span>:<span>
</span></span></span><span><span><span>        </span><span>app</span>:<span> </span>redis<span>
</span></span></span><span><span><span>        </span><span>role</span>:<span> </span>leader<span>
</span></span></span><span><span><span>        </span><span>tier</span>:<span> </span>backend<span>
</span></span></span><span><span><span>    </span><span>spec</span>:<span>
</span></span></span><span><span><span>      </span><span>containers</span>:<span>
</span></span></span><span><span><span>      </span>- <span>name</span>:<span> </span>leader<span>
</span></span></span><span><span><span>        </span><span>image</span>:<span> </span><span>"docker.io/redis:6.0.5"</span><span>
</span></span></span><span><span><span>        </span><span>resources</span>:<span>
</span></span></span><span><span><span>          </span><span>requests</span>:<span>
</span></span></span><span><span><span>            </span><span>cpu</span>:<span> </span>100m<span>
</span></span></span><span><span><span>            </span><span>memory</span>:<span> </span>100Mi<span>
</span></span></span><span><span><span>        </span><span>ports</span>:<span>
</span></span></span><span><span><span>        </span>- <span>containerPort</span>:<span> </span><span>6379</span></span></span></code></pre></div></div></div><ol><li><p>Launch a terminal window in the directory you downloaded the manifest files.</p></li><li><p>Apply the Redis Deployment from the <code>redis-leader-deployment.yaml</code> file:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl apply -f https://k8s.io/examples/application/guestbook/redis-leader-deployment.yaml
</span></span></code></pre></div></li><li><p>Query the list of Pods to verify that the Redis Pod is running:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pods
</span></span></code></pre></div><p>The response should be similar to this:</p><pre tabindex="0"><code>NAME                           READY   STATUS    RESTARTS   AGE
redis-leader-fb76b4755-xjr2n   1/1     Running   0          13s
</code></pre></li><li><p>Run the following command to view the logs from the Redis leader Pod:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl logs -f deployment/redis-leader
</span></span></code></pre></div></li></ol><h3 id="creating-the-redis-leader-service">Creating the Redis leader Service</h3><p>The guestbook application needs to communicate to the Redis to write its data.
You need to apply a <a href="/docs/concepts/services-networking/service/">Service</a> to
proxy the traffic to the Redis Pod. A Service defines a policy to access the
Pods.</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/application/guestbook/redis-leader-service.yaml"><code>application/guestbook/redis-leader-service.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" title="Copy application/guestbook/redis-leader-service.yaml to clipboard"></div><div class="includecode" id="application-guestbook-redis-leader-service-yaml"><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span># SOURCE: https://cloud.google.com/kubernetes-engine/docs/tutorials/guestbook</span><span>
</span></span></span><span><span><span></span><span>apiVersion</span>:<span> </span>v1<span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>Service<span>
</span></span></span><span><span><span></span><span>metadata</span>:<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>redis-leader<span>
</span></span></span><span><span><span>  </span><span>labels</span>:<span>
</span></span></span><span><span><span>    </span><span>app</span>:<span> </span>redis<span>
</span></span></span><span><span><span>    </span><span>role</span>:<span> </span>leader<span>
</span></span></span><span><span><span>    </span><span>tier</span>:<span> </span>backend<span>
</span></span></span><span><span><span></span><span>spec</span>:<span>
</span></span></span><span><span><span>  </span><span>ports</span>:<span>
</span></span></span><span><span><span>  </span>- <span>port</span>:<span> </span><span>6379</span><span>
</span></span></span><span><span><span>    </span><span>targetPort</span>:<span> </span><span>6379</span><span>
</span></span></span><span><span><span>  </span><span>selector</span>:<span>
</span></span></span><span><span><span>    </span><span>app</span>:<span> </span>redis<span>
</span></span></span><span><span><span>    </span><span>role</span>:<span> </span>leader<span>
</span></span></span><span><span><span>    </span><span>tier</span>:<span> </span>backend</span></span></code></pre></div></div></div><ol><li><p>Apply the Redis Service from the following <code>redis-leader-service.yaml</code> file:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl apply -f https://k8s.io/examples/application/guestbook/redis-leader-service.yaml
</span></span></code></pre></div></li><li><p>Query the list of Services to verify that the Redis Service is running:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get service
</span></span></code></pre></div><p>The response should be similar to this:</p><pre tabindex="0"><code>NAME           TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)    AGE
kubernetes     ClusterIP   10.0.0.1     &lt;none&gt;        443/TCP    1m
redis-leader   ClusterIP   10.103.78.24 &lt;none&gt;        6379/TCP   16s
</code></pre></li></ol><div class="alert alert-info"><h4 class="alert-heading">Note:</h4>This manifest file creates a Service named <code>redis-leader</code> with a set of labels
that match the labels previously defined, so the Service routes network
traffic to the Redis Pod.</div><h3 id="set-up-redis-followers">Set up Redis followers</h3><p>Although the Redis leader is a single Pod, you can make it highly available
and meet traffic demands by adding a few Redis followers, or replicas.</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/application/guestbook/redis-follower-deployment.yaml"><code>application/guestbook/redis-follower-deployment.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" title="Copy application/guestbook/redis-follower-deployment.yaml to clipboard"></div><div class="includecode" id="application-guestbook-redis-follower-deployment-yaml"><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span># SOURCE: https://cloud.google.com/kubernetes-engine/docs/tutorials/guestbook</span><span>
</span></span></span><span><span><span></span><span>apiVersion</span>:<span> </span>apps/v1<span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>Deployment<span>
</span></span></span><span><span><span></span><span>metadata</span>:<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>redis-follower<span>
</span></span></span><span><span><span>  </span><span>labels</span>:<span>
</span></span></span><span><span><span>    </span><span>app</span>:<span> </span>redis<span>
</span></span></span><span><span><span>    </span><span>role</span>:<span> </span>follower<span>
</span></span></span><span><span><span>    </span><span>tier</span>:<span> </span>backend<span>
</span></span></span><span><span><span></span><span>spec</span>:<span>
</span></span></span><span><span><span>  </span><span>replicas</span>:<span> </span><span>2</span><span>
</span></span></span><span><span><span>  </span><span>selector</span>:<span>
</span></span></span><span><span><span>    </span><span>matchLabels</span>:<span>
</span></span></span><span><span><span>      </span><span>app</span>:<span> </span>redis<span>
</span></span></span><span><span><span>  </span><span>template</span>:<span>
</span></span></span><span><span><span>    </span><span>metadata</span>:<span>
</span></span></span><span><span><span>      </span><span>labels</span>:<span>
</span></span></span><span><span><span>        </span><span>app</span>:<span> </span>redis<span>
</span></span></span><span><span><span>        </span><span>role</span>:<span> </span>follower<span>
</span></span></span><span><span><span>        </span><span>tier</span>:<span> </span>backend<span>
</span></span></span><span><span><span>    </span><span>spec</span>:<span>
</span></span></span><span><span><span>      </span><span>containers</span>:<span>
</span></span></span><span><span><span>      </span>- <span>name</span>:<span> </span>follower<span>
</span></span></span><span><span><span>        </span><span>image</span>:<span> </span>us-docker.pkg.dev/google-samples/containers/gke/gb-redis-follower:v2<span>
</span></span></span><span><span><span>        </span><span>resources</span>:<span>
</span></span></span><span><span><span>          </span><span>requests</span>:<span>
</span></span></span><span><span><span>            </span><span>cpu</span>:<span> </span>100m<span>
</span></span></span><span><span><span>            </span><span>memory</span>:<span> </span>100Mi<span>
</span></span></span><span><span><span>        </span><span>ports</span>:<span>
</span></span></span><span><span><span>        </span>- <span>containerPort</span>:<span> </span><span>6379</span></span></span></code></pre></div></div></div><ol><li><p>Apply the Redis Deployment from the following <code>redis-follower-deployment.yaml</code> file:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl apply -f https://k8s.io/examples/application/guestbook/redis-follower-deployment.yaml
</span></span></code></pre></div></li><li><p>Verify that the two Redis follower replicas are running by querying the list of Pods:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pods
</span></span></code></pre></div><p>The response should be similar to this:</p><pre tabindex="0"><code>NAME                             READY   STATUS    RESTARTS   AGE
redis-follower-dddfbdcc9-82sfr   1/1     Running   0          37s
redis-follower-dddfbdcc9-qrt5k   1/1     Running   0          38s
redis-leader-fb76b4755-xjr2n     1/1     Running   0          11m
</code></pre></li></ol><h3 id="creating-the-redis-follower-service">Creating the Redis follower service</h3><p>The guestbook application needs to communicate with the Redis followers to
read data. To make the Redis followers discoverable, you must set up another
<a href="/docs/concepts/services-networking/service/">Service</a>.</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/application/guestbook/redis-follower-service.yaml"><code>application/guestbook/redis-follower-service.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" title="Copy application/guestbook/redis-follower-service.yaml to clipboard"></div><div class="includecode" id="application-guestbook-redis-follower-service-yaml"><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span># SOURCE: https://cloud.google.com/kubernetes-engine/docs/tutorials/guestbook</span><span>
</span></span></span><span><span><span></span><span>apiVersion</span>:<span> </span>v1<span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>Service<span>
</span></span></span><span><span><span></span><span>metadata</span>:<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>redis-follower<span>
</span></span></span><span><span><span>  </span><span>labels</span>:<span>
</span></span></span><span><span><span>    </span><span>app</span>:<span> </span>redis<span>
</span></span></span><span><span><span>    </span><span>role</span>:<span> </span>follower<span>
</span></span></span><span><span><span>    </span><span>tier</span>:<span> </span>backend<span>
</span></span></span><span><span><span></span><span>spec</span>:<span>
</span></span></span><span><span><span>  </span><span>ports</span>:<span>
</span></span></span><span><span><span>    </span><span># the port that this service should serve on</span><span>
</span></span></span><span><span><span>  </span>- <span>port</span>:<span> </span><span>6379</span><span>
</span></span></span><span><span><span>  </span><span>selector</span>:<span>
</span></span></span><span><span><span>    </span><span>app</span>:<span> </span>redis<span>
</span></span></span><span><span><span>    </span><span>role</span>:<span> </span>follower<span>
</span></span></span><span><span><span>    </span><span>tier</span>:<span> </span>backend</span></span></code></pre></div></div></div><ol><li><p>Apply the Redis Service from the following <code>redis-follower-service.yaml</code> file:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl apply -f https://k8s.io/examples/application/guestbook/redis-follower-service.yaml
</span></span></code></pre></div></li><li><p>Query the list of Services to verify that the Redis Service is running:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get service
</span></span></code></pre></div><p>The response should be similar to this:</p><pre tabindex="0"><code>NAME             TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)    AGE
kubernetes       ClusterIP   10.96.0.1       &lt;none&gt;        443/TCP    3d19h
redis-follower   ClusterIP   10.110.162.42   &lt;none&gt;        6379/TCP   9s
redis-leader     ClusterIP   10.103.78.24    &lt;none&gt;        6379/TCP   6m10s
</code></pre></li></ol><div class="alert alert-info"><h4 class="alert-heading">Note:</h4>This manifest file creates a Service named <code>redis-follower</code> with a set of
labels that match the labels previously defined, so the Service routes network
traffic to the Redis Pod.</div><h2 id="set-up-and-expose-the-guestbook-frontend">Set up and Expose the Guestbook Frontend</h2><p>Now that you have the Redis storage of your guestbook up and running, start
the guestbook web servers. Like the Redis followers, the frontend is deployed
using a Kubernetes Deployment.</p><p>The guestbook app uses a PHP frontend. It is configured to communicate with
either the Redis follower or leader Services, depending on whether the request
is a read or a write. The frontend exposes a JSON interface, and serves a
jQuery-Ajax-based UX.</p><h3 id="creating-the-guestbook-frontend-deployment">Creating the Guestbook Frontend Deployment</h3><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/application/guestbook/frontend-deployment.yaml"><code>application/guestbook/frontend-deployment.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" title="Copy application/guestbook/frontend-deployment.yaml to clipboard"></div><div class="includecode" id="application-guestbook-frontend-deployment-yaml"><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span># SOURCE: https://cloud.google.com/kubernetes-engine/docs/tutorials/guestbook</span><span>
</span></span></span><span><span><span></span><span>apiVersion</span>:<span> </span>apps/v1<span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>Deployment<span>
</span></span></span><span><span><span></span><span>metadata</span>:<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>frontend<span>
</span></span></span><span><span><span></span><span>spec</span>:<span>
</span></span></span><span><span><span>  </span><span>replicas</span>:<span> </span><span>3</span><span>
</span></span></span><span><span><span>  </span><span>selector</span>:<span>
</span></span></span><span><span><span>    </span><span>matchLabels</span>:<span>
</span></span></span><span><span><span>        </span><span>app</span>:<span> </span>guestbook<span>
</span></span></span><span><span><span>        </span><span>tier</span>:<span> </span>frontend<span>
</span></span></span><span><span><span>  </span><span>template</span>:<span>
</span></span></span><span><span><span>    </span><span>metadata</span>:<span>
</span></span></span><span><span><span>      </span><span>labels</span>:<span>
</span></span></span><span><span><span>        </span><span>app</span>:<span> </span>guestbook<span>
</span></span></span><span><span><span>        </span><span>tier</span>:<span> </span>frontend<span>
</span></span></span><span><span><span>    </span><span>spec</span>:<span>
</span></span></span><span><span><span>      </span><span>containers</span>:<span>
</span></span></span><span><span><span>      </span>- <span>name</span>:<span> </span>php-redis<span>
</span></span></span><span><span><span>        </span><span>image</span>:<span> </span>us-docker.pkg.dev/google-samples/containers/gke/gb-frontend:v5<span>
</span></span></span><span><span><span>        </span><span>env</span>:<span>
</span></span></span><span><span><span>        </span>- <span>name</span>:<span> </span>GET_HOSTS_FROM<span>
</span></span></span><span><span><span>          </span><span>value</span>:<span> </span><span>"dns"</span><span>
</span></span></span><span><span><span>        </span><span>resources</span>:<span>
</span></span></span><span><span><span>          </span><span>requests</span>:<span>
</span></span></span><span><span><span>            </span><span>cpu</span>:<span> </span>100m<span>
</span></span></span><span><span><span>            </span><span>memory</span>:<span> </span>100Mi<span>
</span></span></span><span><span><span>        </span><span>ports</span>:<span>
</span></span></span><span><span><span>        </span>- <span>containerPort</span>:<span> </span><span>80</span><span>
</span></span></span></code></pre></div></div></div><ol><li><p>Apply the frontend Deployment from the <code>frontend-deployment.yaml</code> file:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl apply -f https://k8s.io/examples/application/guestbook/frontend-deployment.yaml
</span></span></code></pre></div></li><li><p>Query the list of Pods to verify that the three frontend replicas are running:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pods -l <span>app</span><span>=</span>guestbook -l <span>tier</span><span>=</span>frontend
</span></span></code></pre></div><p>The response should be similar to this:</p><pre tabindex="0"><code>NAME                        READY   STATUS    RESTARTS   AGE
frontend-85595f5bf9-5tqhb   1/1     Running   0          47s
frontend-85595f5bf9-qbzwm   1/1     Running   0          47s
frontend-85595f5bf9-zchwc   1/1     Running   0          47s
</code></pre></li></ol><h3 id="creating-the-frontend-service">Creating the Frontend Service</h3><p>The <code>Redis</code> Services you applied is only accessible within the Kubernetes
cluster because the default type for a Service is
<a href="/docs/concepts/services-networking/service/#publishing-services-service-types">ClusterIP</a>.
<code>ClusterIP</code> provides a single IP address for the set of Pods the Service is
pointing to. This IP address is accessible only within the cluster.</p><p>If you want guests to be able to access your guestbook, you must configure the
frontend Service to be externally visible, so a client can request the Service
from outside the Kubernetes cluster. However a Kubernetes user can use
<code>kubectl port-forward</code> to access the service even though it uses a
<code>ClusterIP</code>.</p><div class="alert alert-info"><h4 class="alert-heading">Note:</h4>Some cloud providers, like Google Compute Engine or Google Kubernetes Engine,
support external load balancers. If your cloud provider supports load
balancers and you want to use it, uncomment <code>type: LoadBalancer</code>.</div><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/application/guestbook/frontend-service.yaml"><code>application/guestbook/frontend-service.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" title="Copy application/guestbook/frontend-service.yaml to clipboard"></div><div class="includecode" id="application-guestbook-frontend-service-yaml"><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span># SOURCE: https://cloud.google.com/kubernetes-engine/docs/tutorials/guestbook</span><span>
</span></span></span><span><span><span></span><span>apiVersion</span>:<span> </span>v1<span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>Service<span>
</span></span></span><span><span><span></span><span>metadata</span>:<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>frontend<span>
</span></span></span><span><span><span>  </span><span>labels</span>:<span>
</span></span></span><span><span><span>    </span><span>app</span>:<span> </span>guestbook<span>
</span></span></span><span><span><span>    </span><span>tier</span>:<span> </span>frontend<span>
</span></span></span><span><span><span></span><span>spec</span>:<span>
</span></span></span><span><span><span>  </span><span># if your cluster supports it, uncomment the following to automatically create</span><span>
</span></span></span><span><span><span>  </span><span># an external load-balanced IP for the frontend service.</span><span>
</span></span></span><span><span><span>  </span><span># type: LoadBalancer</span><span>
</span></span></span><span><span><span>  </span><span>#type: LoadBalancer</span><span>
</span></span></span><span><span><span>  </span><span>ports</span>:<span>
</span></span></span><span><span><span>    </span><span># the port that this service should serve on</span><span>
</span></span></span><span><span><span>  </span>- <span>port</span>:<span> </span><span>80</span><span>
</span></span></span><span><span><span>  </span><span>selector</span>:<span>
</span></span></span><span><span><span>    </span><span>app</span>:<span> </span>guestbook<span>
</span></span></span><span><span><span>    </span><span>tier</span>:<span> </span>frontend</span></span></code></pre></div></div></div><ol><li><p>Apply the frontend Service from the <code>frontend-service.yaml</code> file:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl apply -f https://k8s.io/examples/application/guestbook/frontend-service.yaml
</span></span></code></pre></div></li><li><p>Query the list of Services to verify that the frontend Service is running:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get services
</span></span></code></pre></div><p>The response should be similar to this:</p><pre tabindex="0"><code>NAME             TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)    AGE
frontend         ClusterIP   10.97.28.230    &lt;none&gt;        80/TCP     19s
kubernetes       ClusterIP   10.96.0.1       &lt;none&gt;        443/TCP    3d19h
redis-follower   ClusterIP   10.110.162.42   &lt;none&gt;        6379/TCP   5m48s
redis-leader     ClusterIP   10.103.78.24    &lt;none&gt;        6379/TCP   11m
</code></pre></li></ol><h3 id="viewing-the-frontend-service-via-kubectl-port-forward">Viewing the Frontend Service via <code>kubectl port-forward</code></h3><ol><li><p>Run the following command to forward port <code>8080</code> on your local machine to port <code>80</code> on the service.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl port-forward svc/frontend 8080:80
</span></span></code></pre></div><p>The response should be similar to this:</p><pre tabindex="0"><code>Forwarding from 127.0.0.1:8080 -&gt; 80
Forwarding from [::1]:8080 -&gt; 80
</code></pre></li><li><p>load the page <a href="http://localhost:8080">http://localhost:8080</a> in your browser to view your guestbook.</p></li></ol><h3 id="viewing-the-frontend-service-via-loadbalancer">Viewing the Frontend Service via <code>LoadBalancer</code></h3><p>If you deployed the <code>frontend-service.yaml</code> manifest with type: <code>LoadBalancer</code>
you need to find the IP address to view your Guestbook.</p><ol><li><p>Run the following command to get the IP address for the frontend Service.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get service frontend
</span></span></code></pre></div><p>The response should be similar to this:</p><pre tabindex="0"><code>NAME       TYPE           CLUSTER-IP      EXTERNAL-IP        PORT(S)        AGE
frontend   LoadBalancer   10.51.242.136   109.197.92.229     80:32372/TCP   1m
</code></pre></li><li><p>Copy the external IP address, and load the page in your browser to view your guestbook.</p></li></ol><div class="alert alert-info"><h4 class="alert-heading">Note:</h4>Try adding some guestbook entries by typing in a message, and clicking Submit.
The message you typed appears in the frontend. This message indicates that
data is successfully added to Redis through the Services you created earlier.</div><h2 id="scale-the-web-frontend">Scale the Web Frontend</h2><p>You can scale up or down as needed because your servers are defined as a
Service that uses a Deployment controller.</p><ol><li><p>Run the following command to scale up the number of frontend Pods:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl scale deployment frontend --replicas<span>=</span><span>5</span>
</span></span></code></pre></div></li><li><p>Query the list of Pods to verify the number of frontend Pods running:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pods
</span></span></code></pre></div><p>The response should look similar to this:</p><pre tabindex="0"><code>NAME                             READY   STATUS    RESTARTS   AGE
frontend-85595f5bf9-5df5m        1/1     Running   0          83s
frontend-85595f5bf9-7zmg5        1/1     Running   0          83s
frontend-85595f5bf9-cpskg        1/1     Running   0          15m
frontend-85595f5bf9-l2l54        1/1     Running   0          14m
frontend-85595f5bf9-l9c8z        1/1     Running   0          14m
redis-follower-dddfbdcc9-82sfr   1/1     Running   0          97m
redis-follower-dddfbdcc9-qrt5k   1/1     Running   0          97m
redis-leader-fb76b4755-xjr2n     1/1     Running   0          108m
</code></pre></li><li><p>Run the following command to scale down the number of frontend Pods:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl scale deployment frontend --replicas<span>=</span><span>2</span>
</span></span></code></pre></div></li><li><p>Query the list of Pods to verify the number of frontend Pods running:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pods
</span></span></code></pre></div><p>The response should look similar to this:</p><pre tabindex="0"><code>NAME                             READY   STATUS    RESTARTS   AGE
frontend-85595f5bf9-cpskg        1/1     Running   0          16m
frontend-85595f5bf9-l9c8z        1/1     Running   0          15m
redis-follower-dddfbdcc9-82sfr   1/1     Running   0          98m
redis-follower-dddfbdcc9-qrt5k   1/1     Running   0          98m
redis-leader-fb76b4755-xjr2n     1/1     Running   0          109m
</code></pre></li></ol><h2 id="cleaning-up">Cleaning up</h2><p>Deleting the Deployments and Services also deletes any running Pods. Use
labels to delete multiple resources with one command.</p><ol><li><p>Run the following commands to delete all Pods, Deployments, and Services.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl delete deployment -l <span>app</span><span>=</span>redis
</span></span><span><span>kubectl delete service -l <span>app</span><span>=</span>redis
</span></span><span><span>kubectl delete deployment frontend
</span></span><span><span>kubectl delete service frontend
</span></span></code></pre></div><p>The response should look similar to this:</p><pre tabindex="0"><code>deployment.apps "redis-follower" deleted
deployment.apps "redis-leader" deleted
deployment.apps "frontend" deleted
service "frontend" deleted
</code></pre></li><li><p>Query the list of Pods to verify that no Pods are running:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pods
</span></span></code></pre></div><p>The response should look similar to this:</p><pre tabindex="0"><code>No resources found in default namespace.
</code></pre></li></ol><h2 id="what-s-next">What's next</h2><ul><li>Complete the <a href="/docs/tutorials/kubernetes-basics/">Kubernetes Basics</a> Interactive Tutorials</li><li>Use Kubernetes to create a blog using <a href="/docs/tutorials/stateful-application/mysql-wordpress-persistent-volume/#visit-your-new-wordpress-blog">Persistent Volumes for MySQL and Wordpress</a></li><li>Read more about <a href="/docs/tutorials/services/connect-applications-service/">connecting applications with services</a></li><li>Read more about <a href="/docs/concepts/overview/working-with-objects/labels/#using-labels-effectively">using labels effectively</a></li></ul></div></div><div><div class="td-content"><h1>Stateful Applications</h1><div class="section-index"><hr class="panel-line"><div class="entry"><h5><a href="/docs/tutorials/stateful-application/basic-stateful-set/">StatefulSet Basics</a></h5><p></p></div><div class="entry"><h5><a href="/docs/tutorials/stateful-application/mysql-wordpress-persistent-volume/">Example: Deploying WordPress and MySQL with Persistent Volumes</a></h5><p></p></div><div class="entry"><h5><a href="/docs/tutorials/stateful-application/cassandra/">Example: Deploying Cassandra with a StatefulSet</a></h5><p></p></div><div class="entry"><h5><a href="/docs/tutorials/stateful-application/zookeeper/">Running ZooKeeper, A Distributed System Coordinator</a></h5><p></p></div></div></div></div><div><div class="td-content"><h1>StatefulSet Basics</h1><p>This tutorial provides an introduction to managing applications with
<a class="glossary-tooltip" title="A StatefulSet manages deployment and scaling of a set of Pods, with durable storage and persistent identifiers for each Pod." href="/docs/concepts/workloads/controllers/statefulset/" target="_blank">StatefulSets</a>.
It demonstrates how to create, delete, scale, and update the Pods of StatefulSets.</p><h2 id="before-you-begin">Before you begin</h2><p>Before you begin this tutorial, you should familiarize yourself with the
following Kubernetes concepts:</p><ul><li><a href="/docs/concepts/workloads/pods/">Pods</a></li><li><a href="/docs/concepts/services-networking/dns-pod-service/">Cluster DNS</a></li><li><a href="/docs/concepts/services-networking/service/#headless-services">Headless Services</a></li><li><a href="/docs/concepts/storage/persistent-volumes/">PersistentVolumes</a></li><li><a href="https://github.com/kubernetes/examples/tree/master/staging/persistent-volume-provisioning/">PersistentVolume Provisioning</a></li><li>The <a href="/docs/reference/kubectl/kubectl/">kubectl</a> command line tool</li></ul><p>You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. It is recommended to run this tutorial on a cluster with at least two nodes that are not acting as control plane hosts. If you do not already have a
cluster, you can create one by using
<a href="https://minikube.sigs.k8s.io/docs/tutorials/multi_node/">minikube</a>
or you can use one of these Kubernetes playgrounds:</p><ul><li><a href="https://labs.iximiuz.com/playgrounds?category=kubernetes&amp;filter=all">iximiuz Labs</a></li><li><a href="https://killercoda.com/playgrounds/scenario/kubernetes">Killercoda</a></li><li><a href="https://kodekloud.com/public-playgrounds">KodeKloud</a></li><li><a href="https://labs.play-with-k8s.com/">Play with Kubernetes</a></li></ul><p>You should configure <code>kubectl</code> to use a context that uses the <code>default</code>
namespace.
If you are using an existing cluster, make sure that it's OK to use that
cluster's default namespace to practice. Ideally, practice in a cluster
that doesn't run any real workloads.</p><p>It's also useful to read the concept page about <a href="/docs/concepts/workloads/controllers/statefulset/">StatefulSets</a>.</p><div class="alert alert-info"><h4 class="alert-heading">Note:</h4>This tutorial assumes that your cluster is configured to dynamically provision
PersistentVolumes. You'll also need to have a <a href="/docs/concepts/storage/storage-classes/#default-storageclass">default StorageClass</a>.
If your cluster is not configured to provision storage dynamically, you
will have to manually provision two 1 GiB volumes prior to starting this
tutorial and
set up your cluster so that those PersistentVolumes map to the
PersistentVolumeClaim templates that the StatefulSet defines.</div><h2 id="objectives">Objectives</h2><p>StatefulSets are intended to be used with stateful applications and distributed
systems. However, the administration of stateful applications and
distributed systems on Kubernetes is a broad, complex topic. In order to
demonstrate the basic features of a StatefulSet, and not to conflate the former
topic with the latter, you will deploy a simple web application using a StatefulSet.</p><p>After this tutorial, you will be familiar with the following.</p><ul><li>How to create a StatefulSet</li><li>How a StatefulSet manages its Pods</li><li>How to delete a StatefulSet</li><li>How to scale a StatefulSet</li><li>How to update a StatefulSet's Pods</li></ul><h2 id="creating-a-statefulset">Creating a StatefulSet</h2><p>Begin by creating a StatefulSet (and the Service that it relies upon) using
the example below. It is similar to the example presented in the
<a href="/docs/concepts/workloads/controllers/statefulset/">StatefulSets</a> concept.
It creates a <a href="/docs/concepts/services-networking/service/#headless-services">headless Service</a>,
<code>nginx</code>, to publish the IP addresses of Pods in the StatefulSet, <code>web</code>.</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/application/web/web.yaml"><code>application/web/web.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" title="Copy application/web/web.yaml to clipboard"></div><div class="includecode" id="application-web-web-yaml"><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span>apiVersion</span>:<span> </span>v1<span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>Service<span>
</span></span></span><span><span><span></span><span>metadata</span>:<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>nginx<span>
</span></span></span><span><span><span>  </span><span>labels</span>:<span>
</span></span></span><span><span><span>    </span><span>app</span>:<span> </span>nginx<span>
</span></span></span><span><span><span></span><span>spec</span>:<span>
</span></span></span><span><span><span>  </span><span>ports</span>:<span>
</span></span></span><span><span><span>  </span>- <span>port</span>:<span> </span><span>80</span><span>
</span></span></span><span><span><span>    </span><span>name</span>:<span> </span>web<span>
</span></span></span><span><span><span>  </span><span>clusterIP</span>:<span> </span>None<span>
</span></span></span><span><span><span>  </span><span>selector</span>:<span>
</span></span></span><span><span><span>    </span><span>app</span>:<span> </span>nginx<span>
</span></span></span><span><span><span></span><span>---</span><span>
</span></span></span><span><span><span></span><span>apiVersion</span>:<span> </span>apps/v1<span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>StatefulSet<span>
</span></span></span><span><span><span></span><span>metadata</span>:<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>web<span>
</span></span></span><span><span><span></span><span>spec</span>:<span>
</span></span></span><span><span><span>  </span><span>serviceName</span>:<span> </span><span>"nginx"</span><span>
</span></span></span><span><span><span>  </span><span>replicas</span>:<span> </span><span>2</span><span>
</span></span></span><span><span><span>  </span><span>selector</span>:<span>
</span></span></span><span><span><span>    </span><span>matchLabels</span>:<span>
</span></span></span><span><span><span>      </span><span>app</span>:<span> </span>nginx<span>
</span></span></span><span><span><span>  </span><span>template</span>:<span>
</span></span></span><span><span><span>    </span><span>metadata</span>:<span>
</span></span></span><span><span><span>      </span><span>labels</span>:<span>
</span></span></span><span><span><span>        </span><span>app</span>:<span> </span>nginx<span>
</span></span></span><span><span><span>    </span><span>spec</span>:<span>
</span></span></span><span><span><span>      </span><span>containers</span>:<span>
</span></span></span><span><span><span>      </span>- <span>name</span>:<span> </span>nginx<span>
</span></span></span><span><span><span>        </span><span>image</span>:<span> </span>registry.k8s.io/nginx-slim:0.21<span>
</span></span></span><span><span><span>        </span><span>ports</span>:<span>
</span></span></span><span><span><span>        </span>- <span>containerPort</span>:<span> </span><span>80</span><span>
</span></span></span><span><span><span>          </span><span>name</span>:<span> </span>web<span>
</span></span></span><span><span><span>        </span><span>volumeMounts</span>:<span>
</span></span></span><span><span><span>        </span>- <span>name</span>:<span> </span>www<span>
</span></span></span><span><span><span>          </span><span>mountPath</span>:<span> </span>/usr/share/nginx/html<span>
</span></span></span><span><span><span>  </span><span>volumeClaimTemplates</span>:<span>
</span></span></span><span><span><span>  </span>- <span>metadata</span>:<span>
</span></span></span><span><span><span>      </span><span>name</span>:<span> </span>www<span>
</span></span></span><span><span><span>    </span><span>spec</span>:<span>
</span></span></span><span><span><span>      </span><span>accessModes</span>:<span> </span>[<span> </span><span>"ReadWriteOnce"</span><span> </span>]<span>
</span></span></span><span><span><span>      </span><span>resources</span>:<span>
</span></span></span><span><span><span>        </span><span>requests</span>:<span>
</span></span></span><span><span><span>          </span><span>storage</span>:<span> </span>1Gi<span>
</span></span></span><span><span><span>
</span></span></span></code></pre></div></div></div><p>You will need to use at least two terminal windows. In the first terminal, use
<a href="/docs/reference/generated/kubectl/kubectl-commands/#get"><code>kubectl get</code></a> to <a class="glossary-tooltip" title="A verb that is used to track changes to an object in Kubernetes as a stream." href="/docs/reference/using-api/api-concepts/#api-verbs" target="_blank">watch</a> the creation
of the StatefulSet's Pods.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span># use this terminal to run commands that specify --watch</span>
</span></span><span><span><span># end this watch when you are asked to start a new watch</span>
</span></span><span><span>kubectl get pods --watch -l <span>app</span><span>=</span>nginx
</span></span></code></pre></div><p>In the second terminal, use
<a href="/docs/reference/generated/kubectl/kubectl-commands/#apply"><code>kubectl apply</code></a> to create the
headless Service and StatefulSet:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl apply -f https://k8s.io/examples/application/web/web.yaml
</span></span></code></pre></div><pre tabindex="0"><code>service/nginx created
statefulset.apps/web created
</code></pre><p>The command above creates two Pods, each running an
<a href="https://www.nginx.com">NGINX</a> webserver. Get the <code>nginx</code> Service...</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get service nginx
</span></span></code></pre></div><pre tabindex="0"><code>NAME      TYPE         CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE
nginx     ClusterIP    None         &lt;none&gt;        80/TCP    12s
</code></pre><p>...then get the <code>web</code> StatefulSet, to verify that both were created successfully:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get statefulset web
</span></span></code></pre></div><pre tabindex="0"><code>NAME   READY   AGE
web    2/2     37s
</code></pre><h3 id="ordered-pod-creation">Ordered Pod creation</h3><p>A StatefulSet defaults to creating its Pods in a strict order.</p><p>For a StatefulSet with <em>n</em> replicas, when Pods are being deployed, they are
created sequentially, ordered from <em>{0..n-1}</em>. Examine the output of the
<code>kubectl get</code> command in the first terminal. Eventually, the output will
look like the example below.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span># Do not start a new watch;</span>
</span></span><span><span><span># this should already be running</span>
</span></span><span><span>kubectl get pods --watch -l <span>app</span><span>=</span>nginx
</span></span></code></pre></div><pre tabindex="0"><code>NAME      READY     STATUS    RESTARTS   AGE
web-0     0/1       Pending   0          0s
web-0     0/1       Pending   0         0s
web-0     0/1       ContainerCreating   0         0s
web-0     1/1       Running   0         19s
web-1     0/1       Pending   0         0s
web-1     0/1       Pending   0         0s
web-1     0/1       ContainerCreating   0         0s
web-1     1/1       Running   0         18s
</code></pre><p>Notice that the <code>web-1</code> Pod is not launched until the <code>web-0</code> Pod is
<em>Running</em> (see <a href="/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase">Pod Phase</a>)
and <em>Ready</em> (see <code>type</code> in <a href="/docs/concepts/workloads/pods/pod-lifecycle/#pod-conditions">Pod Conditions</a>).</p><p>Later in this tutorial you will practice <a href="#parallel-pod-management">parallel startup</a>.</p><div class="alert alert-info"><h4 class="alert-heading">Note:</h4>To configure the integer ordinal assigned to each Pod in a StatefulSet, see
<a href="/docs/concepts/workloads/controllers/statefulset/#start-ordinal">Start ordinal</a>.</div><h2 id="pods-in-a-statefulset">Pods in a StatefulSet</h2><p>Pods in a StatefulSet have a unique ordinal index and a stable network identity.</p><h3 id="examining-the-pod-s-ordinal-index">Examining the Pod's ordinal index</h3><p>Get the StatefulSet's Pods:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pods -l <span>app</span><span>=</span>nginx
</span></span></code></pre></div><pre tabindex="0"><code>NAME      READY     STATUS    RESTARTS   AGE
web-0     1/1       Running   0          1m
web-1     1/1       Running   0          1m
</code></pre><p>As mentioned in the <a href="/docs/concepts/workloads/controllers/statefulset/">StatefulSets</a>
concept, the Pods in a StatefulSet have a sticky, unique identity. This identity
is based on a unique ordinal index that is assigned to each Pod by the
StatefulSet <a class="glossary-tooltip" title="A control loop that watches the shared state of the cluster through the apiserver and makes changes attempting to move the current state towards the desired state." href="/docs/concepts/architecture/controller/" target="_blank">controller</a>.<br>The Pods' names take the form <code>&lt;statefulset name&gt;-&lt;ordinal index&gt;</code>.
Since the <code>web</code> StatefulSet has two replicas, it creates two Pods, <code>web-0</code> and <code>web-1</code>.</p><h3 id="using-stable-network-identities">Using stable network identities</h3><p>Each Pod has a stable hostname based on its ordinal index. Use
<a href="/docs/reference/generated/kubectl/kubectl-commands/#exec"><code>kubectl exec</code></a> to execute the
<code>hostname</code> command in each Pod:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span>for</span> i in <span>0</span> 1; <span>do</span> kubectl <span>exec</span> <span>"web-</span><span>$i</span><span>"</span> -- sh -c <span>'hostname'</span>; <span>done</span>
</span></span></code></pre></div><pre tabindex="0"><code>web-0
web-1
</code></pre><p>Use <a href="/docs/reference/generated/kubectl/kubectl-commands/#run"><code>kubectl run</code></a> to execute
a container that provides the <code>nslookup</code> command from the <code>dnsutils</code> package.
Using <code>nslookup</code> on the Pods' hostnames, you can examine their in-cluster DNS
addresses:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl run -i --tty --image busybox:1.28 dns-test --restart<span>=</span>Never --rm
</span></span></code></pre></div><p>which starts a new shell. In that new shell, run:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span># Run this in the dns-test container shell</span>
</span></span><span><span>nslookup web-0.nginx
</span></span></code></pre></div><p>The output is similar to:</p><pre tabindex="0"><code>Server:    10.0.0.10
Address 1: 10.0.0.10 kube-dns.kube-system.svc.cluster.local

Name:      web-0.nginx
Address 1: 10.244.1.6

nslookup web-1.nginx
Server:    10.0.0.10
Address 1: 10.0.0.10 kube-dns.kube-system.svc.cluster.local

Name:      web-1.nginx
Address 1: 10.244.2.6
</code></pre><p>(and now exit the container shell: <code>exit</code>)</p><p>The CNAME of the headless service points to SRV records (one for each Pod that
is Running and Ready). The SRV records point to A record entries that
contain the Pods' IP addresses.</p><p>In one terminal, watch the StatefulSet's Pods:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span># Start a new watch</span>
</span></span><span><span><span># End this watch when you've seen that the delete is finished</span>
</span></span><span><span>kubectl get pod --watch -l <span>app</span><span>=</span>nginx
</span></span></code></pre></div><p>In a second terminal, use
<a href="/docs/reference/generated/kubectl/kubectl-commands/#delete"><code>kubectl delete</code></a> to delete all
the Pods in the StatefulSet:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl delete pod -l <span>app</span><span>=</span>nginx
</span></span></code></pre></div><pre tabindex="0"><code>pod "web-0" deleted
pod "web-1" deleted
</code></pre><p>Wait for the StatefulSet to restart them, and for both Pods to transition to
Running and Ready:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span># This should already be running</span>
</span></span><span><span>kubectl get pod --watch -l <span>app</span><span>=</span>nginx
</span></span></code></pre></div><pre tabindex="0"><code>NAME      READY     STATUS              RESTARTS   AGE
web-0     0/1       ContainerCreating   0          0s
NAME      READY     STATUS    RESTARTS   AGE
web-0     1/1       Running   0          2s
web-1     0/1       Pending   0         0s
web-1     0/1       Pending   0         0s
web-1     0/1       ContainerCreating   0         0s
web-1     1/1       Running   0         34s
</code></pre><p>Use <code>kubectl exec</code> and <code>kubectl run</code> to view the Pods' hostnames and in-cluster
DNS entries. First, view the Pods' hostnames:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span>for</span> i in <span>0</span> 1; <span>do</span> kubectl <span>exec</span> web-<span>$i</span> -- sh -c <span>'hostname'</span>; <span>done</span>
</span></span></code></pre></div><pre tabindex="0"><code>web-0
web-1
</code></pre><p>then, run:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl run -i --tty --image busybox:1.28 dns-test --restart<span>=</span>Never --rm
</span></span></code></pre></div><p>which starts a new shell.<br>In that new shell, run:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span># Run this in the dns-test container shell</span>
</span></span><span><span>nslookup web-0.nginx
</span></span></code></pre></div><p>The output is similar to:</p><pre tabindex="0"><code>Server:    10.0.0.10
Address 1: 10.0.0.10 kube-dns.kube-system.svc.cluster.local

Name:      web-0.nginx
Address 1: 10.244.1.7

nslookup web-1.nginx
Server:    10.0.0.10
Address 1: 10.0.0.10 kube-dns.kube-system.svc.cluster.local

Name:      web-1.nginx
Address 1: 10.244.2.8
</code></pre><p>(and now exit the container shell: <code>exit</code>)</p><p>The Pods' ordinals, hostnames, SRV records, and A record names have not changed,
but the IP addresses associated with the Pods may have changed. In the cluster
used for this tutorial, they have. This is why it is important not to configure
other applications to connect to Pods in a StatefulSet by the IP address
of a particular Pod (it is OK to connect to Pods by resolving their hostname).</p><h4 id="discovery-for-specific-pods-in-a-statefulset">Discovery for specific Pods in a StatefulSet</h4><p>If you need to find and connect to the active members of a StatefulSet, you
should query the CNAME of the headless Service
(<code>nginx.default.svc.cluster.local</code>). The SRV records associated with the
CNAME will contain only the Pods in the StatefulSet that are Running and
Ready.</p><p>If your application already implements connection logic that tests for
liveness and readiness, you can use the SRV records of the Pods (
<code>web-0.nginx.default.svc.cluster.local</code>,
<code>web-1.nginx.default.svc.cluster.local</code>), as they are stable, and your
application will be able to discover the Pods' addresses when they transition
to Running and Ready.</p><p>If your application wants to find any healthy Pod in a StatefulSet,
and therefore does not need to track each specific Pod,
you could also connect to the IP address of a <code>type: ClusterIP</code> Service,
backed by the Pods in that StatefulSet. You can use the same Service that
tracks the StatefulSet (specified in the <code>serviceName</code> of the StatefulSet)
or a separate Service that selects the right set of Pods.</p><h3 id="writing-to-stable-storage">Writing to stable storage</h3><p>Get the PersistentVolumeClaims for <code>web-0</code> and <code>web-1</code>:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pvc -l <span>app</span><span>=</span>nginx
</span></span></code></pre></div><p>The output is similar to:</p><pre tabindex="0"><code>NAME        STATUS    VOLUME                                     CAPACITY   ACCESSMODES   AGE
www-web-0   Bound     pvc-15c268c7-b507-11e6-932f-42010a800002   1Gi        RWO           48s
www-web-1   Bound     pvc-15c79307-b507-11e6-932f-42010a800002   1Gi        RWO           48s
</code></pre><p>The StatefulSet controller created two
<a class="glossary-tooltip" title="Claims storage resources defined in a PersistentVolume so that it can be mounted as a volume in a container." href="/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims" target="_blank">PersistentVolumeClaims</a>
that are bound to two
<a class="glossary-tooltip" title="API object that represents a piece of storage in the cluster." href="/docs/concepts/storage/persistent-volumes/" target="_blank">PersistentVolumes</a>.</p><p>As the cluster used in this tutorial is configured to dynamically provision PersistentVolumes,
the PersistentVolumes were created and bound automatically.</p><p>The NGINX webserver, by default, serves an index file from
<code>/usr/share/nginx/html/index.html</code>. The <code>volumeMounts</code> field in the
StatefulSet's <code>spec</code> ensures that the <code>/usr/share/nginx/html</code> directory is
backed by a PersistentVolume.</p><p>Write the Pods' hostnames to their <code>index.html</code> files and verify that the NGINX
webservers serve the hostnames:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span>for</span> i in <span>0</span> 1; <span>do</span> kubectl <span>exec</span> <span>"web-</span><span>$i</span><span>"</span> -- sh -c <span>'echo "$(hostname)" &gt; /usr/share/nginx/html/index.html'</span>; <span>done</span>
</span></span><span><span>
</span></span><span><span><span>for</span> i in <span>0</span> 1; <span>do</span> kubectl <span>exec</span> -i -t <span>"web-</span><span>$i</span><span>"</span> -- curl http://localhost/; <span>done</span>
</span></span></code></pre></div><pre tabindex="0"><code>web-0
web-1
</code></pre><div class="alert alert-info"><h4 class="alert-heading">Note:</h4><p>If you instead see <strong>403 Forbidden</strong> responses for the above curl command,
you will need to fix the permissions of the directory mounted by the <code>volumeMounts</code>
(due to a <a href="https://github.com/kubernetes/kubernetes/issues/2630">bug when using hostPath volumes</a>),
by running:</p><p><code>for i in 0 1; do kubectl exec web-$i -- chmod 755 /usr/share/nginx/html; done</code></p><p>before retrying the <code>curl</code> command above.</p></div><p>In one terminal, watch the StatefulSet's Pods:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span># End this watch when you've reached the end of the section.</span>
</span></span><span><span><span># At the start of "Scaling a StatefulSet" you'll start a new watch.</span>
</span></span><span><span>kubectl get pod --watch -l <span>app</span><span>=</span>nginx
</span></span></code></pre></div><p>In a second terminal, delete all of the StatefulSet's Pods:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl delete pod -l <span>app</span><span>=</span>nginx
</span></span></code></pre></div><pre tabindex="0"><code>pod "web-0" deleted
pod "web-1" deleted
</code></pre><p>Examine the output of the <code>kubectl get</code> command in the first terminal, and wait
for all of the Pods to transition to Running and Ready.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span># This should already be running</span>
</span></span><span><span>kubectl get pod --watch -l <span>app</span><span>=</span>nginx
</span></span></code></pre></div><pre tabindex="0"><code>NAME      READY     STATUS              RESTARTS   AGE
web-0     0/1       ContainerCreating   0          0s
NAME      READY     STATUS    RESTARTS   AGE
web-0     1/1       Running   0          2s
web-1     0/1       Pending   0         0s
web-1     0/1       Pending   0         0s
web-1     0/1       ContainerCreating   0         0s
web-1     1/1       Running   0         34s
</code></pre><p>Verify the web servers continue to serve their hostnames:</p><pre tabindex="0"><code>for i in 0 1; do kubectl exec -i -t "web-$i" -- curl http://localhost/; done
</code></pre><pre tabindex="0"><code>web-0
web-1
</code></pre><p>Even though <code>web-0</code> and <code>web-1</code> were rescheduled, they continue to serve their
hostnames because the PersistentVolumes associated with their
PersistentVolumeClaims are remounted to their <code>volumeMounts</code>. No matter what
node <code>web-0</code>and <code>web-1</code> are scheduled on, their PersistentVolumes will be
mounted to the appropriate mount points.</p><h2 id="scaling-a-statefulset">Scaling a StatefulSet</h2><p>Scaling a StatefulSet refers to increasing or decreasing the number of replicas
(horizontal scaling).
This is accomplished by updating the <code>replicas</code> field. You can use either
<a href="/docs/reference/generated/kubectl/kubectl-commands/#scale"><code>kubectl scale</code></a> or
<a href="/docs/reference/generated/kubectl/kubectl-commands/#patch"><code>kubectl patch</code></a> to scale a StatefulSet.</p><h3 id="scaling-up">Scaling up</h3><p>Scaling up means adding more replicas.
Provided that your app is able to distribute work across the StatefulSet, the new
larger set of Pods can perform more of that work.</p><p>In one terminal window, watch the Pods in the StatefulSet:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span># If you already have a watch running, you can continue using that.</span>
</span></span><span><span><span># Otherwise, start one.</span>
</span></span><span><span><span># End this watch when there are 5 healthy Pods for the StatefulSet</span>
</span></span><span><span>kubectl get pods --watch -l <span>app</span><span>=</span>nginx
</span></span></code></pre></div><p>In another terminal window, use <code>kubectl scale</code> to scale the number of replicas
to 5:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl scale sts web --replicas<span>=</span><span>5</span>
</span></span></code></pre></div><pre tabindex="0"><code>statefulset.apps/web scaled
</code></pre><p>Examine the output of the <code>kubectl get</code> command in the first terminal, and wait
for the three additional Pods to transition to Running and Ready.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span># This should already be running</span>
</span></span><span><span>kubectl get pod --watch -l <span>app</span><span>=</span>nginx
</span></span></code></pre></div><pre tabindex="0"><code>NAME      READY     STATUS    RESTARTS   AGE
web-0     1/1       Running   0          2h
web-1     1/1       Running   0          2h
NAME      READY     STATUS    RESTARTS   AGE
web-2     0/1       Pending   0          0s
web-2     0/1       Pending   0         0s
web-2     0/1       ContainerCreating   0         0s
web-2     1/1       Running   0         19s
web-3     0/1       Pending   0         0s
web-3     0/1       Pending   0         0s
web-3     0/1       ContainerCreating   0         0s
web-3     1/1       Running   0         18s
web-4     0/1       Pending   0         0s
web-4     0/1       Pending   0         0s
web-4     0/1       ContainerCreating   0         0s
web-4     1/1       Running   0         19s
</code></pre><p>The StatefulSet controller scaled the number of replicas. As with
<a href="#ordered-pod-creation">StatefulSet creation</a>, the StatefulSet controller
created each Pod sequentially with respect to its ordinal index, and it
waited for each Pod's predecessor to be Running and Ready before launching the
subsequent Pod.</p><h3 id="scaling-down">Scaling down</h3><p>Scaling down means reducing the number of replicas. For example, you
might do this because the level of traffic to a service has decreased,
and at the current scale there are idle resources.</p><p>In one terminal, watch the StatefulSet's Pods:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span># End this watch when there are only 3 Pods for the StatefulSet</span>
</span></span><span><span>kubectl get pod --watch -l <span>app</span><span>=</span>nginx
</span></span></code></pre></div><p>In another terminal, use <code>kubectl patch</code> to scale the StatefulSet back down to
three replicas:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl patch sts web -p <span>'{"spec":{"replicas":3}}'</span>
</span></span></code></pre></div><pre tabindex="0"><code>statefulset.apps/web patched
</code></pre><p>Wait for <code>web-4</code> and <code>web-3</code> to transition to Terminating.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span># This should already be running</span>
</span></span><span><span>kubectl get pods --watch -l <span>app</span><span>=</span>nginx
</span></span></code></pre></div><pre tabindex="0"><code>NAME      READY     STATUS              RESTARTS   AGE
web-0     1/1       Running             0          3h
web-1     1/1       Running             0          3h
web-2     1/1       Running             0          55s
web-3     1/1       Running             0          36s
web-4     0/1       ContainerCreating   0          18s
NAME      READY     STATUS    RESTARTS   AGE
web-4     1/1       Running   0          19s
web-4     1/1       Terminating   0         24s
web-4     1/1       Terminating   0         24s
web-3     1/1       Terminating   0         42s
web-3     1/1       Terminating   0         42s
</code></pre><h3 id="ordered-pod-termination">Ordered Pod termination</h3><p>The control plane deleted one Pod at a time, in reverse order with respect
to its ordinal index, and it waited for each Pod to be completely shut down
before deleting the next one.</p><p>Get the StatefulSet's PersistentVolumeClaims:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pvc -l <span>app</span><span>=</span>nginx
</span></span></code></pre></div><pre tabindex="0"><code>NAME        STATUS    VOLUME                                     CAPACITY   ACCESSMODES   AGE
www-web-0   Bound     pvc-15c268c7-b507-11e6-932f-42010a800002   1Gi        RWO           13h
www-web-1   Bound     pvc-15c79307-b507-11e6-932f-42010a800002   1Gi        RWO           13h
www-web-2   Bound     pvc-e1125b27-b508-11e6-932f-42010a800002   1Gi        RWO           13h
www-web-3   Bound     pvc-e1176df6-b508-11e6-932f-42010a800002   1Gi        RWO           13h
www-web-4   Bound     pvc-e11bb5f8-b508-11e6-932f-42010a800002   1Gi        RWO           13h
</code></pre><p>There are still five PersistentVolumeClaims and five PersistentVolumes.
When exploring a Pod's <a href="#writing-to-stable-storage">stable storage</a>, you saw that
the PersistentVolumes mounted to the Pods of a StatefulSet are not deleted when the
StatefulSet's Pods are deleted. This is still true when Pod deletion is caused by
scaling the StatefulSet down.</p><h2 id="updating-statefulsets">Updating StatefulSets</h2><p>The StatefulSet controller supports automated updates. The
strategy used is determined by the <code>spec.updateStrategy</code> field of the
StatefulSet API object. This feature can be used to upgrade the container
images, resource requests and/or limits, labels, and annotations of the Pods in a
StatefulSet.</p><p>There are two valid update strategies, <code>RollingUpdate</code> (the default) and
<code>OnDelete</code>.</p><h3 id="rolling-update">RollingUpdate</h3><p>The <code>RollingUpdate</code> update strategy will update all Pods in a StatefulSet, in
reverse ordinal order, while respecting the StatefulSet guarantees.</p><p>You can split updates to a StatefulSet that uses the <code>RollingUpdate</code> strategy
into <em>partitions</em>, by specifying <code>.spec.updateStrategy.rollingUpdate.partition</code>.
You'll practice that later in this tutorial.</p><p>First, try a simple rolling update.</p><p>In one terminal window, patch the <code>web</code> StatefulSet to change the container
image again:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl patch statefulset web --type<span>=</span><span>'json'</span> -p<span>=</span><span>'[{"op": "replace", "path": "/spec/template/spec/containers/0/image", "value":"registry.k8s.io/nginx-slim:0.24"}]'</span>
</span></span></code></pre></div><pre tabindex="0"><code>statefulset.apps/web patched
</code></pre><p>In another terminal, watch the Pods in the StatefulSet:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span># End this watch when the rollout is complete</span>
</span></span><span><span><span>#</span>
</span></span><span><span><span># If you're not sure, leave it running one more minute</span>
</span></span><span><span>kubectl get pod -l <span>app</span><span>=</span>nginx --watch
</span></span></code></pre></div><p>The output is similar to:</p><pre tabindex="0"><code>NAME      READY     STATUS    RESTARTS   AGE
web-0     1/1       Running   0          7m
web-1     1/1       Running   0          7m
web-2     1/1       Running   0          8m
web-2     1/1       Terminating   0         8m
web-2     1/1       Terminating   0         8m
web-2     0/1       Terminating   0         8m
web-2     0/1       Terminating   0         8m
web-2     0/1       Terminating   0         8m
web-2     0/1       Terminating   0         8m
web-2     0/1       Pending   0         0s
web-2     0/1       Pending   0         0s
web-2     0/1       ContainerCreating   0         0s
web-2     1/1       Running   0         19s
web-1     1/1       Terminating   0         8m
web-1     0/1       Terminating   0         8m
web-1     0/1       Terminating   0         8m
web-1     0/1       Terminating   0         8m
web-1     0/1       Pending   0         0s
web-1     0/1       Pending   0         0s
web-1     0/1       ContainerCreating   0         0s
web-1     1/1       Running   0         6s
web-0     1/1       Terminating   0         7m
web-0     1/1       Terminating   0         7m
web-0     0/1       Terminating   0         7m
web-0     0/1       Terminating   0         7m
web-0     0/1       Terminating   0         7m
web-0     0/1       Terminating   0         7m
web-0     0/1       Pending   0         0s
web-0     0/1       Pending   0         0s
web-0     0/1       ContainerCreating   0         0s
web-0     1/1       Running   0         10s
</code></pre><p>The Pods in the StatefulSet are updated in reverse ordinal order. The
StatefulSet controller terminates each Pod, and waits for it to transition to Running and
Ready prior to updating the next Pod. Note that, even though the StatefulSet
controller will not proceed to update the next Pod until its ordinal successor
is Running and Ready, it will restore any Pod that fails during the update to
that Pod's existing version.</p><p>Pods that have already received the update will be restored to the updated version,
and Pods that have not yet received the update will be restored to the previous
version. In this way, the controller attempts to continue to keep the application
healthy and the update consistent in the presence of intermittent failures.</p><p>Get the Pods to view their container images:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span>for</span> p in <span>0</span> <span>1</span> 2; <span>do</span> kubectl get pod <span>"web-</span><span>$p</span><span>"</span> --template <span>'{{range $i, $c := .spec.containers}}{{$c.image}}{{end}}'</span>; echo; <span>done</span>
</span></span></code></pre></div><pre tabindex="0"><code>registry.k8s.io/nginx-slim:0.24
registry.k8s.io/nginx-slim:0.24
registry.k8s.io/nginx-slim:0.24
</code></pre><p>All the Pods in the StatefulSet are now running the previous container image.</p><div class="alert alert-info"><h4 class="alert-heading">Note:</h4>You can also use <code>kubectl rollout status sts/&lt;name&gt;</code> to view
the status of a rolling update to a StatefulSet</div><h4 id="staging-an-update">Staging an update</h4><p>You can split updates to a StatefulSet that uses the <code>RollingUpdate</code> strategy
into <em>partitions</em>, by specifying <code>.spec.updateStrategy.rollingUpdate.partition</code>.</p><p>For more context, you can read <a href="/docs/concepts/workloads/controllers/statefulset/#partitions">Partitioned rolling updates</a>
in the StatefulSet concept page.</p><p>You can stage an update to a StatefulSet by using the <code>partition</code> field within
<code>.spec.updateStrategy.rollingUpdate</code>.
For this update, you will keep the existing Pods in the StatefulSet
unchanged whilst you change the pod template for the StatefulSet.
Then you - or, outside of a tutorial, some external automation - can
trigger that prepared update.</p><p>First, patch the <code>web</code> StatefulSet to add a partition to the <code>updateStrategy</code> field:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span># The value of "partition" determines which ordinals a change applies to</span>
</span></span><span><span><span># Make sure to use a number bigger than the last ordinal for the</span>
</span></span><span><span><span># StatefulSet</span>
</span></span><span><span>kubectl patch statefulset web -p <span>'{"spec":{"updateStrategy":{"type":"RollingUpdate","rollingUpdate":{"partition":3}}}}'</span>
</span></span></code></pre></div><pre tabindex="0"><code>statefulset.apps/web patched
</code></pre><p>Patch the StatefulSet again to change the container image that this
StatefulSet uses:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl patch statefulset web --type<span>=</span><span>'json'</span> -p<span>=</span><span>'[{"op": "replace", "path": "/spec/template/spec/containers/0/image", "value":"registry.k8s.io/nginx-slim:0.21"}]'</span>
</span></span></code></pre></div><pre tabindex="0"><code>statefulset.apps/web patched
</code></pre><p>Delete a Pod in the StatefulSet:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl delete pod web-2
</span></span></code></pre></div><pre tabindex="0"><code>pod "web-2" deleted
</code></pre><p>Wait for the replacement <code>web-2</code> Pod to be Running and Ready:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span># End the watch when you see that web-2 is healthy</span>
</span></span><span><span>kubectl get pod -l <span>app</span><span>=</span>nginx --watch
</span></span></code></pre></div><pre tabindex="0"><code>NAME      READY     STATUS              RESTARTS   AGE
web-0     1/1       Running             0          4m
web-1     1/1       Running             0          4m
web-2     0/1       ContainerCreating   0          11s
web-2     1/1       Running   0         18s
</code></pre><p>Get the Pod's container image:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pod web-2 --template <span>'{{range $i, $c := .spec.containers}}{{$c.image}}{{end}}'</span>
</span></span></code></pre></div><pre tabindex="0"><code>registry.k8s.io/nginx-slim:0.24
</code></pre><p>Notice that, even though the update strategy is <code>RollingUpdate</code> the StatefulSet
restored the Pod with the original container image. This is because the
ordinal of the Pod is less than the <code>partition</code> specified by the
<code>updateStrategy</code>.</p><h4 id="rolling-out-a-canary">Rolling out a canary</h4><p>You're now going to try a <a href="https://glossary.cncf.io/canary-deployment/">canary rollout</a>
of that staged change.</p><p>You can roll out a canary (to test the modified template) by decrementing the <code>partition</code>
you specified <a href="#staging-an-update">above</a>.</p><p>Patch the StatefulSet to decrement the partition:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span># The value of "partition" should match the highest existing ordinal for</span>
</span></span><span><span><span># the StatefulSet</span>
</span></span><span><span>kubectl patch statefulset web -p <span>'{"spec":{"updateStrategy":{"type":"RollingUpdate","rollingUpdate":{"partition":2}}}}'</span>
</span></span></code></pre></div><pre tabindex="0"><code>statefulset.apps/web patched
</code></pre><p>The control plane triggers replacement for <code>web-2</code> (implemented by
a graceful <strong>delete</strong> followed by creating a new Pod once the deletion
is complete).
Wait for the new <code>web-2</code> Pod to be Running and Ready.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span># This should already be running</span>
</span></span><span><span>kubectl get pod -l <span>app</span><span>=</span>nginx --watch
</span></span></code></pre></div><pre tabindex="0"><code>NAME      READY     STATUS              RESTARTS   AGE
web-0     1/1       Running             0          4m
web-1     1/1       Running             0          4m
web-2     0/1       ContainerCreating   0          11s
web-2     1/1       Running   0         18s
</code></pre><p>Get the Pod's container:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pod web-2 --template <span>'{{range $i, $c := .spec.containers}}{{$c.image}}{{end}}'</span>
</span></span></code></pre></div><pre tabindex="0"><code>registry.k8s.io/nginx-slim:0.21
</code></pre><p>When you changed the <code>partition</code>, the StatefulSet controller automatically
updated the <code>web-2</code> Pod because the Pod's ordinal was greater than or equal to
the <code>partition</code>.</p><p>Delete the <code>web-1</code> Pod:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl delete pod web-1
</span></span></code></pre></div><pre tabindex="0"><code>pod "web-1" deleted
</code></pre><p>Wait for the <code>web-1</code> Pod to be Running and Ready.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span># This should already be running</span>
</span></span><span><span>kubectl get pod -l <span>app</span><span>=</span>nginx --watch
</span></span></code></pre></div><p>The output is similar to:</p><pre tabindex="0"><code>NAME      READY     STATUS        RESTARTS   AGE
web-0     1/1       Running       0          6m
web-1     0/1       Terminating   0          6m
web-2     1/1       Running       0          2m
web-1     0/1       Terminating   0         6m
web-1     0/1       Terminating   0         6m
web-1     0/1       Terminating   0         6m
web-1     0/1       Pending   0         0s
web-1     0/1       Pending   0         0s
web-1     0/1       ContainerCreating   0         0s
web-1     1/1       Running   0         18s
</code></pre><p>Get the <code>web-1</code> Pod's container image:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pod web-1 --template <span>'{{range $i, $c := .spec.containers}}{{$c.image}}{{end}}'</span>
</span></span></code></pre></div><pre tabindex="0"><code>registry.k8s.io/nginx-slim:0.24
</code></pre><p><code>web-1</code> was restored to its original configuration because the Pod's ordinal
was less than the partition. When a partition is specified, all Pods with an
ordinal that is greater than or equal to the partition will be updated when the
StatefulSet's <code>.spec.template</code> is updated. If a Pod that has an ordinal less
than the partition is deleted or otherwise terminated, it will be restored to
its original configuration.</p><h4 id="phased-roll-outs">Phased roll outs</h4><p>You can perform a phased roll out (e.g. a linear, geometric, or exponential
roll out) using a partitioned rolling update in a similar manner to how you
rolled out a <a href="#rolling-out-a-canary">canary</a>. To perform a phased roll out, set
the <code>partition</code> to the ordinal at which you want the controller to pause the
update.</p><p>The partition is currently set to <code>2</code>. Set the partition to <code>0</code>:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl patch statefulset web -p <span>'{"spec":{"updateStrategy":{"type":"RollingUpdate","rollingUpdate":{"partition":0}}}}'</span>
</span></span></code></pre></div><pre tabindex="0"><code>statefulset.apps/web patched
</code></pre><p>Wait for all of the Pods in the StatefulSet to become Running and Ready.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span># This should already be running</span>
</span></span><span><span>kubectl get pod -l <span>app</span><span>=</span>nginx --watch
</span></span></code></pre></div><p>The output is similar to:</p><pre tabindex="0"><code>NAME      READY     STATUS              RESTARTS   AGE
web-0     1/1       Running             0          3m
web-1     0/1       ContainerCreating   0          11s
web-2     1/1       Running             0          2m
web-1     1/1       Running   0         18s
web-0     1/1       Terminating   0         3m
web-0     1/1       Terminating   0         3m
web-0     0/1       Terminating   0         3m
web-0     0/1       Terminating   0         3m
web-0     0/1       Terminating   0         3m
web-0     0/1       Terminating   0         3m
web-0     0/1       Pending   0         0s
web-0     0/1       Pending   0         0s
web-0     0/1       ContainerCreating   0         0s
web-0     1/1       Running   0         3s
</code></pre><p>Get the container image details for the Pods in the StatefulSet:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span>for</span> p in <span>0</span> <span>1</span> 2; <span>do</span> kubectl get pod <span>"web-</span><span>$p</span><span>"</span> --template <span>'{{range $i, $c := .spec.containers}}{{$c.image}}{{end}}'</span>; echo; <span>done</span>
</span></span></code></pre></div><pre tabindex="0"><code>registry.k8s.io/nginx-slim:0.21
registry.k8s.io/nginx-slim:0.21
registry.k8s.io/nginx-slim:0.21
</code></pre><p>By moving the <code>partition</code> to <code>0</code>, you allowed the StatefulSet to
continue the update process.</p><h3 id="on-delete">OnDelete</h3><p>You select this update strategy for a StatefulSet by setting the
<code>.spec.template.updateStrategy.type</code> to <code>OnDelete</code>.</p><p>Patch the <code>web</code> StatefulSet to use the <code>OnDelete</code> update strategy:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl patch statefulset web -p <span>'{"spec":{"updateStrategy":{"type":"OnDelete", "rollingUpdate": null}}}'</span>
</span></span></code></pre></div><pre tabindex="0"><code>statefulset.apps/web patched
</code></pre><p>When you select this update strategy, the StatefulSet controller does not
automatically update Pods when a modification is made to the StatefulSet's
<code>.spec.template</code> field. You need to manage the rollout yourself - either
manually, or using separate automation.</p><h2 id="deleting-statefulsets">Deleting StatefulSets</h2><p>StatefulSet supports both <em>non-cascading</em> and <em>cascading</em> deletion. In a
non-cascading <strong>delete</strong>, the StatefulSet's Pods are not deleted when the
StatefulSet is deleted. In a cascading <strong>delete</strong>, both the StatefulSet and
its Pods are deleted.</p><p>Read <a href="/docs/tasks/administer-cluster/use-cascading-deletion/">Use Cascading Deletion in a Cluster</a>
to learn about cascading deletion generally.</p><h3 id="non-cascading-delete">Non-cascading delete</h3><p>In one terminal window, watch the Pods in the StatefulSet.</p><pre tabindex="0"><code># End this watch when there are no Pods for the StatefulSet
kubectl get pods --watch -l app=nginx
</code></pre><p>Use <a href="/docs/reference/generated/kubectl/kubectl-commands/#delete"><code>kubectl delete</code></a> to delete the
StatefulSet. Make sure to supply the <code>--cascade=orphan</code> parameter to the
command. This parameter tells Kubernetes to only delete the StatefulSet, and to
<strong>not</strong> delete any of its Pods.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl delete statefulset web --cascade<span>=</span>orphan
</span></span></code></pre></div><pre tabindex="0"><code>statefulset.apps "web" deleted
</code></pre><p>Get the Pods, to examine their status:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pods -l <span>app</span><span>=</span>nginx
</span></span></code></pre></div><pre tabindex="0"><code>NAME      READY     STATUS    RESTARTS   AGE
web-0     1/1       Running   0          6m
web-1     1/1       Running   0          7m
web-2     1/1       Running   0          5m
</code></pre><p>Even though <code>web</code> has been deleted, all of the Pods are still Running and Ready.
Delete <code>web-0</code>:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl delete pod web-0
</span></span></code></pre></div><pre tabindex="0"><code>pod "web-0" deleted
</code></pre><p>Get the StatefulSet's Pods:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pods -l <span>app</span><span>=</span>nginx
</span></span></code></pre></div><pre tabindex="0"><code>NAME      READY     STATUS    RESTARTS   AGE
web-1     1/1       Running   0          10m
web-2     1/1       Running   0          7m
</code></pre><p>As the <code>web</code> StatefulSet has been deleted, <code>web-0</code> has not been relaunched.</p><p>In one terminal, watch the StatefulSet's Pods.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span># Leave this watch running until the next time you start a watch</span>
</span></span><span><span>kubectl get pods --watch -l <span>app</span><span>=</span>nginx
</span></span></code></pre></div><p>In a second terminal, recreate the StatefulSet. Note that, unless
you deleted the <code>nginx</code> Service (which you should not have), you will see
an error indicating that the Service already exists.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl apply -f https://k8s.io/examples/application/web/web.yaml
</span></span></code></pre></div><pre tabindex="0"><code>statefulset.apps/web created
service/nginx unchanged
</code></pre><p>Ignore the error. It only indicates that an attempt was made to create the <em>nginx</em>
headless Service even though that Service already exists.</p><p>Examine the output of the <code>kubectl get</code> command running in the first terminal.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span># This should already be running</span>
</span></span><span><span>kubectl get pods --watch -l <span>app</span><span>=</span>nginx
</span></span></code></pre></div><pre tabindex="0"><code>NAME      READY     STATUS    RESTARTS   AGE
web-1     1/1       Running   0          16m
web-2     1/1       Running   0          2m
NAME      READY     STATUS    RESTARTS   AGE
web-0     0/1       Pending   0          0s
web-0     0/1       Pending   0         0s
web-0     0/1       ContainerCreating   0         0s
web-0     1/1       Running   0         18s
web-2     1/1       Terminating   0         3m
web-2     0/1       Terminating   0         3m
web-2     0/1       Terminating   0         3m
web-2     0/1       Terminating   0         3m
</code></pre><p>When the <code>web</code> StatefulSet was recreated, it first relaunched <code>web-0</code>.
Since <code>web-1</code> was already Running and Ready, when <code>web-0</code> transitioned to
Running and Ready, it adopted this Pod. Since you recreated the StatefulSet
with <code>replicas</code> equal to 2, once <code>web-0</code> had been recreated, and once
<code>web-1</code> had been determined to already be Running and Ready, <code>web-2</code> was
terminated.</p><p>Now take another look at the contents of the <code>index.html</code> file served by the
Pods' webservers:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span>for</span> i in <span>0</span> 1; <span>do</span> kubectl <span>exec</span> -i -t <span>"web-</span><span>$i</span><span>"</span> -- curl http://localhost/; <span>done</span>
</span></span></code></pre></div><pre tabindex="0"><code>web-0
web-1
</code></pre><p>Even though you deleted both the StatefulSet and the <code>web-0</code> Pod, it still
serves the hostname originally entered into its <code>index.html</code> file. This is
because the StatefulSet never deletes the PersistentVolumes associated with a
Pod. When you recreated the StatefulSet and it relaunched <code>web-0</code>, its original
PersistentVolume was remounted.</p><h3 id="cascading-delete">Cascading delete</h3><p>In one terminal window, watch the Pods in the StatefulSet.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span># Leave this running until the next page section</span>
</span></span><span><span>kubectl get pods --watch -l <span>app</span><span>=</span>nginx
</span></span></code></pre></div><p>In another terminal, delete the StatefulSet again. This time, omit the
<code>--cascade=orphan</code> parameter.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl delete statefulset web
</span></span></code></pre></div><pre tabindex="0"><code>statefulset.apps "web" deleted
</code></pre><p>Examine the output of the <code>kubectl get</code> command running in the first terminal,
and wait for all of the Pods to transition to Terminating.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span># This should already be running</span>
</span></span><span><span>kubectl get pods --watch -l <span>app</span><span>=</span>nginx
</span></span></code></pre></div><pre tabindex="0"><code>NAME      READY     STATUS    RESTARTS   AGE
web-0     1/1       Running   0          11m
web-1     1/1       Running   0          27m
NAME      READY     STATUS        RESTARTS   AGE
web-0     1/1       Terminating   0          12m
web-1     1/1       Terminating   0         29m
web-0     0/1       Terminating   0         12m
web-0     0/1       Terminating   0         12m
web-0     0/1       Terminating   0         12m
web-1     0/1       Terminating   0         29m
web-1     0/1       Terminating   0         29m
web-1     0/1       Terminating   0         29m
</code></pre><p>As you saw in the <a href="#scaling-down">Scaling Down</a> section, the Pods
are terminated one at a time, with respect to the reverse order of their ordinal
indices. Before terminating a Pod, the StatefulSet controller waits for
the Pod's successor to be completely terminated.</p><div class="alert alert-info"><h4 class="alert-heading">Note:</h4>Although a cascading delete removes a StatefulSet together with its Pods,
the cascade does <strong>not</strong> delete the headless Service associated with the StatefulSet.
You must delete the <code>nginx</code> Service manually.</div><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl delete service nginx
</span></span></code></pre></div><pre tabindex="0"><code>service "nginx" deleted
</code></pre><p>Recreate the StatefulSet and headless Service one more time:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl apply -f https://k8s.io/examples/application/web/web.yaml
</span></span></code></pre></div><pre tabindex="0"><code>service/nginx created
statefulset.apps/web created
</code></pre><p>When all of the StatefulSet's Pods transition to Running and Ready, retrieve
the contents of their <code>index.html</code> files:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span>for</span> i in <span>0</span> 1; <span>do</span> kubectl <span>exec</span> -i -t <span>"web-</span><span>$i</span><span>"</span> -- curl http://localhost/; <span>done</span>
</span></span></code></pre></div><pre tabindex="0"><code>web-0
web-1
</code></pre><p>Even though you completely deleted the StatefulSet, and all of its Pods, the
Pods are recreated with their PersistentVolumes mounted, and <code>web-0</code> and
<code>web-1</code> continue to serve their hostnames.</p><p>Finally, delete the <code>nginx</code> Service...</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl delete service nginx
</span></span></code></pre></div><pre tabindex="0"><code>service "nginx" deleted
</code></pre><p>...and the <code>web</code> StatefulSet:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl delete statefulset web
</span></span></code></pre></div><pre tabindex="0"><code>statefulset "web" deleted
</code></pre><h2 id="pod-management-policy">Pod management policy</h2><p>For some distributed systems, the StatefulSet ordering guarantees are
unnecessary and/or undesirable. These systems require only uniqueness and
identity.</p><p>You can specify a <a href="/docs/concepts/workloads/controllers/statefulset/#pod-management-policies">Pod management policy</a>
to avoid this strict ordering; either <code>OrderedReady</code> (the default), or <code>Parallel</code>.</p><h3 id="orderedready-pod-management">OrderedReady Pod management</h3><p><code>OrderedReady</code> pod management is the default for StatefulSets. It tells the
StatefulSet controller to respect the ordering guarantees demonstrated
above.</p><p>Use this when your application requires or expects that changes, such as rolling out a new
version of your application, happen in the strict order of the ordinal (pod number) that the StatefulSet provides.
In other words, if you have Pods <code>app-0</code>, <code>app-1</code> and <code>app-2</code>, Kubernetes will update <code>app-0</code> first and check it.
Once the checks are good, Kubernetes updates <code>app-1</code> and finally <code>app-2</code>.</p><p>If you added two more Pods, Kubernetes would set up <code>app-3</code> and wait for that to become healthy before deploying
<code>app-4</code>.</p><p>Because this is the default setting, you've already practised using it.</p><h3 id="parallel-pod-management">Parallel Pod management</h3><p>The alternative, <code>Parallel</code> pod management, tells the StatefulSet controller to launch or
terminate all Pods in parallel, and not to wait for Pods to become <code>Running</code>
and <code>Ready</code> or completely terminated prior to launching or terminating another
Pod.</p><p>The <code>Parallel</code> pod management option only affects the behavior for scaling operations. Updates are not affected;
Kubernetes still rolls out changes in order. For this tutorial, the application is very simple: a webserver that
tells you its hostname (because this is a StatefulSet, the hostname for each Pod is different and predictable).</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/application/web/web-parallel.yaml"><code>application/web/web-parallel.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" title="Copy application/web/web-parallel.yaml to clipboard"></div><div class="includecode" id="application-web-web-parallel-yaml"><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span>apiVersion</span>:<span> </span>v1<span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>Service<span>
</span></span></span><span><span><span></span><span>metadata</span>:<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>nginx<span>
</span></span></span><span><span><span>  </span><span>labels</span>:<span>
</span></span></span><span><span><span>    </span><span>app</span>:<span> </span>nginx<span>
</span></span></span><span><span><span></span><span>spec</span>:<span>
</span></span></span><span><span><span>  </span><span>ports</span>:<span>
</span></span></span><span><span><span>  </span>- <span>port</span>:<span> </span><span>80</span><span>
</span></span></span><span><span><span>    </span><span>name</span>:<span> </span>web<span>
</span></span></span><span><span><span>  </span><span>clusterIP</span>:<span> </span>None<span>
</span></span></span><span><span><span>  </span><span>selector</span>:<span>
</span></span></span><span><span><span>    </span><span>app</span>:<span> </span>nginx<span>
</span></span></span><span><span><span></span><span>---</span><span>
</span></span></span><span><span><span></span><span>apiVersion</span>:<span> </span>apps/v1<span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>StatefulSet<span>
</span></span></span><span><span><span></span><span>metadata</span>:<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>web<span>
</span></span></span><span><span><span></span><span>spec</span>:<span>
</span></span></span><span><span><span>  </span><span>serviceName</span>:<span> </span><span>"nginx"</span><span>
</span></span></span><span><span><span>  </span><span>podManagementPolicy</span>:<span> </span><span>"Parallel"</span><span>
</span></span></span><span><span><span>  </span><span>replicas</span>:<span> </span><span>2</span><span>
</span></span></span><span><span><span>  </span><span>selector</span>:<span>
</span></span></span><span><span><span>    </span><span>matchLabels</span>:<span>
</span></span></span><span><span><span>      </span><span>app</span>:<span> </span>nginx<span>
</span></span></span><span><span><span>  </span><span>template</span>:<span>
</span></span></span><span><span><span>    </span><span>metadata</span>:<span>
</span></span></span><span><span><span>      </span><span>labels</span>:<span>
</span></span></span><span><span><span>        </span><span>app</span>:<span> </span>nginx<span>
</span></span></span><span><span><span>    </span><span>spec</span>:<span>
</span></span></span><span><span><span>      </span><span>containers</span>:<span>
</span></span></span><span><span><span>      </span>- <span>name</span>:<span> </span>nginx<span>
</span></span></span><span><span><span>        </span><span>image</span>:<span> </span>registry.k8s.io/nginx-slim:0.24<span>
</span></span></span><span><span><span>        </span><span>ports</span>:<span>
</span></span></span><span><span><span>        </span>- <span>containerPort</span>:<span> </span><span>80</span><span>
</span></span></span><span><span><span>          </span><span>name</span>:<span> </span>web<span>
</span></span></span><span><span><span>        </span><span>volumeMounts</span>:<span>
</span></span></span><span><span><span>        </span>- <span>name</span>:<span> </span>www<span>
</span></span></span><span><span><span>          </span><span>mountPath</span>:<span> </span>/usr/share/nginx/html<span>
</span></span></span><span><span><span>  </span><span>volumeClaimTemplates</span>:<span>
</span></span></span><span><span><span>  </span>- <span>metadata</span>:<span>
</span></span></span><span><span><span>      </span><span>name</span>:<span> </span>www<span>
</span></span></span><span><span><span>    </span><span>spec</span>:<span>
</span></span></span><span><span><span>      </span><span>accessModes</span>:<span> </span>[<span> </span><span>"ReadWriteOnce"</span><span> </span>]<span>
</span></span></span><span><span><span>      </span><span>resources</span>:<span>
</span></span></span><span><span><span>        </span><span>requests</span>:<span>
</span></span></span><span><span><span>          </span><span>storage</span>:<span> </span>1Gi<span>
</span></span></span></code></pre></div></div></div><p>This manifest is identical to the one you downloaded above except that the <code>.spec.podManagementPolicy</code>
of the <code>web</code> StatefulSet is set to <code>Parallel</code>.</p><p>In one terminal, watch the Pods in the StatefulSet.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span># Leave this watch running until the end of the section</span>
</span></span><span><span>kubectl get pod -l <span>app</span><span>=</span>nginx --watch
</span></span></code></pre></div><p>In another terminal, reconfigure the StatefulSet for <code>Parallel</code> Pod management:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl apply -f https://k8s.io/examples/application/web/web-parallel.yaml
</span></span></code></pre></div><pre tabindex="0"><code>service/nginx updated
statefulset.apps/web updated
</code></pre><p>Keep the terminal open where you're running the watch. In another terminal window, scale the
StatefulSet:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl scale statefulset/web --replicas<span>=</span><span>5</span>
</span></span></code></pre></div><pre tabindex="0"><code>statefulset.apps/web scaled
</code></pre><p>Examine the output of the terminal where the <code>kubectl get</code> command is running. It may look something like</p><pre tabindex="0"><code>web-3     0/1       Pending   0         0s
web-3     0/1       Pending   0         0s
web-3     0/1       Pending   0         7s
web-3     0/1       ContainerCreating   0         7s
web-2     0/1       Pending   0         0s
web-4     0/1       Pending   0         0s
web-2     1/1       Running   0         8s
web-4     0/1       ContainerCreating   0         4s
web-3     1/1       Running   0         26s
web-4     1/1       Running   0         2s
</code></pre><p>The StatefulSet launched three new Pods, and it did not wait for
the first to become Running and Ready prior to launching the second and third Pods.</p><p>This approach is useful if your workload has a stateful element, or needs Pods to be able to identify each other
with predictable naming, and especially if you sometimes need to provide a lot more capacity quickly. If this
simple web service for the tutorial suddenly got an extra 1,000,000 requests per minute then you would want to run
some more Pods - but you also would not want to wait for each new Pod to launch. Starting the extra Pods in parallel
cuts the time between requesting the extra capacity and having it available for use.</p><h2 id="cleaning-up">Cleaning up</h2><p>You should have two terminals open, ready for you to run <code>kubectl</code> commands as
part of cleanup.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl delete sts web
</span></span><span><span><span># sts is an abbreviation for statefulset</span>
</span></span></code></pre></div><p>You can watch <code>kubectl get</code> to see those Pods being deleted.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span># end the watch when you've seen what you need to</span>
</span></span><span><span>kubectl get pod -l <span>app</span><span>=</span>nginx --watch
</span></span></code></pre></div><pre tabindex="0"><code>web-3     1/1       Terminating   0         9m
web-2     1/1       Terminating   0         9m
web-3     1/1       Terminating   0         9m
web-2     1/1       Terminating   0         9m
web-1     1/1       Terminating   0         44m
web-0     1/1       Terminating   0         44m
web-0     0/1       Terminating   0         44m
web-3     0/1       Terminating   0         9m
web-2     0/1       Terminating   0         9m
web-1     0/1       Terminating   0         44m
web-0     0/1       Terminating   0         44m
web-2     0/1       Terminating   0         9m
web-2     0/1       Terminating   0         9m
web-2     0/1       Terminating   0         9m
web-1     0/1       Terminating   0         44m
web-1     0/1       Terminating   0         44m
web-1     0/1       Terminating   0         44m
web-0     0/1       Terminating   0         44m
web-0     0/1       Terminating   0         44m
web-0     0/1       Terminating   0         44m
web-3     0/1       Terminating   0         9m
web-3     0/1       Terminating   0         9m
web-3     0/1       Terminating   0         9m
</code></pre><p>During deletion, a StatefulSet removes all Pods concurrently; it does not wait for
a Pod's ordinal successor to terminate prior to deleting that Pod.</p><p>Close the terminal where the <code>kubectl get</code> command is running and delete the <code>nginx</code>
Service:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl delete svc nginx
</span></span></code></pre></div><p>Delete the persistent storage media for the PersistentVolumes used in this tutorial.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pvc
</span></span></code></pre></div><pre tabindex="0"><code>NAME        STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   AGE
www-web-0   Bound    pvc-2bf00408-d366-4a12-bad0-1869c65d0bee   1Gi        RWO            standard       25m
www-web-1   Bound    pvc-ba3bfe9c-413e-4b95-a2c0-3ea8a54dbab4   1Gi        RWO            standard       24m
www-web-2   Bound    pvc-cba6cfa6-3a47-486b-a138-db5930207eaf   1Gi        RWO            standard       15m
www-web-3   Bound    pvc-0c04d7f0-787a-4977-8da3-d9d3a6d8d752   1Gi        RWO            standard       15m
www-web-4   Bound    pvc-b2c73489-e70b-4a4e-9ec1-9eab439aa43e   1Gi        RWO            standard       14m
</code></pre><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pv
</span></span></code></pre></div><pre tabindex="0"><code>NAME                                       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM               STORAGECLASS   REASON   AGE
pvc-0c04d7f0-787a-4977-8da3-d9d3a6d8d752   1Gi        RWO            Delete           Bound    default/www-web-3   standard                15m
pvc-2bf00408-d366-4a12-bad0-1869c65d0bee   1Gi        RWO            Delete           Bound    default/www-web-0   standard                25m
pvc-b2c73489-e70b-4a4e-9ec1-9eab439aa43e   1Gi        RWO            Delete           Bound    default/www-web-4   standard                14m
pvc-ba3bfe9c-413e-4b95-a2c0-3ea8a54dbab4   1Gi        RWO            Delete           Bound    default/www-web-1   standard                24m
pvc-cba6cfa6-3a47-486b-a138-db5930207eaf   1Gi        RWO            Delete           Bound    default/www-web-2   standard                15m
</code></pre><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl delete pvc www-web-0 www-web-1 www-web-2 www-web-3 www-web-4
</span></span></code></pre></div><pre tabindex="0"><code>persistentvolumeclaim "www-web-0" deleted
persistentvolumeclaim "www-web-1" deleted
persistentvolumeclaim "www-web-2" deleted
persistentvolumeclaim "www-web-3" deleted
persistentvolumeclaim "www-web-4" deleted
</code></pre><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pvc
</span></span></code></pre></div><pre tabindex="0"><code>No resources found in default namespace.
</code></pre><div class="alert alert-info"><h4 class="alert-heading">Note:</h4>You also need to delete the persistent storage media for the PersistentVolumes
used in this tutorial.
Follow the necessary steps, based on your environment, storage configuration,
and provisioning method, to ensure that all storage is reclaimed.</div></div></div><div><div class="td-content"><h1>Example: Deploying WordPress and MySQL with Persistent Volumes</h1><p>This tutorial shows you how to deploy a WordPress site and a MySQL database using
Minikube. Both applications use PersistentVolumes and PersistentVolumeClaims to store data.</p><p>A <a href="/docs/concepts/storage/persistent-volumes/">PersistentVolume</a> (PV) is a piece
of storage in the cluster that has been manually provisioned by an administrator,
or dynamically provisioned by Kubernetes using a <a href="/docs/concepts/storage/storage-classes/">StorageClass</a>.
A <a href="/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims">PersistentVolumeClaim</a> (PVC)
is a request for storage by a user that can be fulfilled by a PV. PersistentVolumes and
PersistentVolumeClaims are independent from Pod lifecycles and preserve data through
restarting, rescheduling, and even deleting Pods.</p><div class="alert alert-danger"><h4 class="alert-heading">Warning:</h4>This deployment is not suitable for production use cases, as it uses single instance
WordPress and MySQL Pods. Consider using
<a href="https://github.com/bitnami/charts/tree/master/bitnami/wordpress">WordPress Helm Chart</a>
to deploy WordPress in production.</div><div class="alert alert-info"><h4 class="alert-heading">Note:</h4>The files provided in this tutorial are using GA Deployment APIs and are specific
to kubernetes version 1.9 and later. If you wish to use this tutorial with an earlier
version of Kubernetes, please update the API version appropriately, or reference
earlier versions of this tutorial.</div><h2 id="objectives">Objectives</h2><ul><li>Create PersistentVolumeClaims and PersistentVolumes</li><li>Create a <code>kustomization.yaml</code> with<ul><li>a Secret generator</li><li>MySQL resource configs</li><li>WordPress resource configs</li></ul></li><li>Apply the kustomization directory by <code>kubectl apply -k ./</code></li><li>Clean up</li></ul><h2 id="before-you-begin">Before you begin</h2><p><p>You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. It is recommended to run this tutorial on a cluster with at least two nodes that are not acting as control plane hosts. If you do not already have a
cluster, you can create one by using
<a href="https://minikube.sigs.k8s.io/docs/tutorials/multi_node/">minikube</a>
or you can use one of these Kubernetes playgrounds:</p><ul><li><a href="https://labs.iximiuz.com/playgrounds?category=kubernetes&amp;filter=all">iximiuz Labs</a></li><li><a href="https://killercoda.com/playgrounds/scenario/kubernetes">Killercoda</a></li><li><a href="https://kodekloud.com/public-playgrounds">KodeKloud</a></li><li><a href="https://labs.play-with-k8s.com/">Play with Kubernetes</a></li></ul><p>To check the version, enter <code>kubectl version</code>.</p></p><p>The example shown on this page works with <code>kubectl</code> 1.27 and above.</p><p>Download the following configuration files:</p><ol><li><p><a href="/examples/application/wordpress/mysql-deployment.yaml">mysql-deployment.yaml</a></p></li><li><p><a href="/examples/application/wordpress/wordpress-deployment.yaml">wordpress-deployment.yaml</a></p></li></ol><h2 id="create-persistentvolumeclaims-and-persistentvolumes">Create PersistentVolumeClaims and PersistentVolumes</h2><p>MySQL and Wordpress each require a PersistentVolume to store data.
Their PersistentVolumeClaims will be created at the deployment step.</p><p>Many cluster environments have a default StorageClass installed.
When a StorageClass is not specified in the PersistentVolumeClaim,
the cluster's default StorageClass is used instead.</p><p>When a PersistentVolumeClaim is created, a PersistentVolume is dynamically
provisioned based on the StorageClass configuration.</p><div class="alert alert-danger"><h4 class="alert-heading">Warning:</h4>In local clusters, the default StorageClass uses the <code>hostPath</code> provisioner.
<code>hostPath</code> volumes are only suitable for development and testing. With <code>hostPath</code>
volumes, your data lives in <code>/tmp</code> on the node the Pod is scheduled onto and does
not move between nodes. If a Pod dies and gets scheduled to another node in the
cluster, or the node is rebooted, the data is lost.</div><div class="alert alert-info"><h4 class="alert-heading">Note:</h4>If you are bringing up a cluster that needs to use the <code>hostPath</code> provisioner,
the <code>--enable-hostpath-provisioner</code> flag must be set in the <code>controller-manager</code> component.</div><div class="alert alert-info"><h4 class="alert-heading">Note:</h4>If you have a Kubernetes cluster running on Google Kubernetes Engine, please
follow <a href="https://cloud.google.com/kubernetes-engine/docs/tutorials/persistent-disk">this guide</a>.</div><h2 id="create-a-kustomization-yaml">Create a kustomization.yaml</h2><h3 id="add-a-secret-generator">Add a Secret generator</h3><p>A <a href="/docs/concepts/configuration/secret/">Secret</a> is an object that stores a piece
of sensitive data like a password or key. Since 1.14, <code>kubectl</code> supports the
management of Kubernetes objects using a kustomization file. You can create a Secret
by generators in <code>kustomization.yaml</code>.</p><p>Add a Secret generator in <code>kustomization.yaml</code> from the following command.
You will need to replace <code>YOUR_PASSWORD</code> with the password you want to use.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>cat <span>&lt;&lt;EOF &gt;./kustomization.yaml
</span></span></span><span><span><span>secretGenerator:
</span></span></span><span><span><span>- name: mysql-pass
</span></span></span><span><span><span>  literals:
</span></span></span><span><span><span>  - password=YOUR_PASSWORD
</span></span></span><span><span><span>EOF</span>
</span></span></code></pre></div><h2 id="add-resource-configs-for-mysql-and-wordpress">Add resource configs for MySQL and WordPress</h2><p>The following manifest describes a single-instance MySQL Deployment. The MySQL
container mounts the PersistentVolume at /var/lib/mysql. The <code>MYSQL_ROOT_PASSWORD</code>
environment variable sets the database password from the Secret.</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/application/wordpress/mysql-deployment.yaml"><code>application/wordpress/mysql-deployment.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" title="Copy application/wordpress/mysql-deployment.yaml to clipboard"></div><div class="includecode" id="application-wordpress-mysql-deployment-yaml"><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span>apiVersion</span>:<span> </span>v1<span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>Service<span>
</span></span></span><span><span><span></span><span>metadata</span>:<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>wordpress-mysql<span>
</span></span></span><span><span><span>  </span><span>labels</span>:<span>
</span></span></span><span><span><span>    </span><span>app</span>:<span> </span>wordpress<span>
</span></span></span><span><span><span></span><span>spec</span>:<span>
</span></span></span><span><span><span>  </span><span>ports</span>:<span>
</span></span></span><span><span><span>    </span>- <span>port</span>:<span> </span><span>3306</span><span>
</span></span></span><span><span><span>  </span><span>selector</span>:<span>
</span></span></span><span><span><span>    </span><span>app</span>:<span> </span>wordpress<span>
</span></span></span><span><span><span>    </span><span>tier</span>:<span> </span>mysql<span>
</span></span></span><span><span><span>  </span><span>clusterIP</span>:<span> </span>None<span>
</span></span></span><span><span><span></span><span>---</span><span>
</span></span></span><span><span><span></span><span>apiVersion</span>:<span> </span>v1<span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>PersistentVolumeClaim<span>
</span></span></span><span><span><span></span><span>metadata</span>:<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>mysql-pv-claim<span>
</span></span></span><span><span><span>  </span><span>labels</span>:<span>
</span></span></span><span><span><span>    </span><span>app</span>:<span> </span>wordpress<span>
</span></span></span><span><span><span></span><span>spec</span>:<span>
</span></span></span><span><span><span>  </span><span>accessModes</span>:<span>
</span></span></span><span><span><span>    </span>- ReadWriteOnce<span>
</span></span></span><span><span><span>  </span><span>resources</span>:<span>
</span></span></span><span><span><span>    </span><span>requests</span>:<span>
</span></span></span><span><span><span>      </span><span>storage</span>:<span> </span>20Gi<span>
</span></span></span><span><span><span></span><span>---</span><span>
</span></span></span><span><span><span></span><span>apiVersion</span>:<span> </span>apps/v1<span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>Deployment<span>
</span></span></span><span><span><span></span><span>metadata</span>:<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>wordpress-mysql<span>
</span></span></span><span><span><span>  </span><span>labels</span>:<span>
</span></span></span><span><span><span>    </span><span>app</span>:<span> </span>wordpress<span>
</span></span></span><span><span><span></span><span>spec</span>:<span>
</span></span></span><span><span><span>  </span><span>selector</span>:<span>
</span></span></span><span><span><span>    </span><span>matchLabels</span>:<span>
</span></span></span><span><span><span>      </span><span>app</span>:<span> </span>wordpress<span>
</span></span></span><span><span><span>      </span><span>tier</span>:<span> </span>mysql<span>
</span></span></span><span><span><span>  </span><span>strategy</span>:<span>
</span></span></span><span><span><span>    </span><span>type</span>:<span> </span>Recreate<span>
</span></span></span><span><span><span>  </span><span>template</span>:<span>
</span></span></span><span><span><span>    </span><span>metadata</span>:<span>
</span></span></span><span><span><span>      </span><span>labels</span>:<span>
</span></span></span><span><span><span>        </span><span>app</span>:<span> </span>wordpress<span>
</span></span></span><span><span><span>        </span><span>tier</span>:<span> </span>mysql<span>
</span></span></span><span><span><span>    </span><span>spec</span>:<span>
</span></span></span><span><span><span>      </span><span>containers</span>:<span>
</span></span></span><span><span><span>      </span>- <span>image</span>:<span> </span>mysql:8.0<span>
</span></span></span><span><span><span>        </span><span>name</span>:<span> </span>mysql<span>
</span></span></span><span><span><span>        </span><span>env</span>:<span>
</span></span></span><span><span><span>        </span>- <span>name</span>:<span> </span>MYSQL_ROOT_PASSWORD<span>
</span></span></span><span><span><span>          </span><span>valueFrom</span>:<span>
</span></span></span><span><span><span>            </span><span>secretKeyRef</span>:<span>
</span></span></span><span><span><span>              </span><span>name</span>:<span> </span>mysql-pass<span>
</span></span></span><span><span><span>              </span><span>key</span>:<span> </span>password<span>
</span></span></span><span><span><span>        </span>- <span>name</span>:<span> </span>MYSQL_DATABASE<span>
</span></span></span><span><span><span>          </span><span>value</span>:<span> </span>wordpress<span>
</span></span></span><span><span><span>        </span>- <span>name</span>:<span> </span>MYSQL_USER<span>
</span></span></span><span><span><span>          </span><span>value</span>:<span> </span>wordpress<span>
</span></span></span><span><span><span>        </span>- <span>name</span>:<span> </span>MYSQL_PASSWORD<span>
</span></span></span><span><span><span>          </span><span>valueFrom</span>:<span>
</span></span></span><span><span><span>            </span><span>secretKeyRef</span>:<span>
</span></span></span><span><span><span>              </span><span>name</span>:<span> </span>mysql-pass<span>
</span></span></span><span><span><span>              </span><span>key</span>:<span> </span>password<span>
</span></span></span><span><span><span>        </span><span>ports</span>:<span>
</span></span></span><span><span><span>        </span>- <span>containerPort</span>:<span> </span><span>3306</span><span>
</span></span></span><span><span><span>          </span><span>name</span>:<span> </span>mysql<span>
</span></span></span><span><span><span>        </span><span>volumeMounts</span>:<span>
</span></span></span><span><span><span>        </span>- <span>name</span>:<span> </span>mysql-persistent-storage<span>
</span></span></span><span><span><span>          </span><span>mountPath</span>:<span> </span>/var/lib/mysql<span>
</span></span></span><span><span><span>      </span><span>volumes</span>:<span>
</span></span></span><span><span><span>      </span>- <span>name</span>:<span> </span>mysql-persistent-storage<span>
</span></span></span><span><span><span>        </span><span>persistentVolumeClaim</span>:<span>
</span></span></span><span><span><span>          </span><span>claimName</span>:<span> </span>mysql-pv-claim<span>
</span></span></span></code></pre></div></div></div><p>The following manifest describes a single-instance WordPress Deployment. The WordPress container mounts the
PersistentVolume at <code>/var/www/html</code> for website data files. The <code>WORDPRESS_DB_HOST</code> environment variable sets
the name of the MySQL Service defined above, and WordPress will access the database by Service. The
<code>WORDPRESS_DB_PASSWORD</code> environment variable sets the database password from the Secret kustomize generated.</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/application/wordpress/wordpress-deployment.yaml"><code>application/wordpress/wordpress-deployment.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" title="Copy application/wordpress/wordpress-deployment.yaml to clipboard"></div><div class="includecode" id="application-wordpress-wordpress-deployment-yaml"><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span>apiVersion</span>:<span> </span>v1<span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>Service<span>
</span></span></span><span><span><span></span><span>metadata</span>:<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>wordpress<span>
</span></span></span><span><span><span>  </span><span>labels</span>:<span>
</span></span></span><span><span><span>    </span><span>app</span>:<span> </span>wordpress<span>
</span></span></span><span><span><span></span><span>spec</span>:<span>
</span></span></span><span><span><span>  </span><span>ports</span>:<span>
</span></span></span><span><span><span>    </span>- <span>port</span>:<span> </span><span>80</span><span>
</span></span></span><span><span><span>  </span><span>selector</span>:<span>
</span></span></span><span><span><span>    </span><span>app</span>:<span> </span>wordpress<span>
</span></span></span><span><span><span>    </span><span>tier</span>:<span> </span>frontend<span>
</span></span></span><span><span><span>  </span><span>type</span>:<span> </span>LoadBalancer<span>
</span></span></span><span><span><span></span><span>---</span><span>
</span></span></span><span><span><span></span><span>apiVersion</span>:<span> </span>v1<span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>PersistentVolumeClaim<span>
</span></span></span><span><span><span></span><span>metadata</span>:<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>wp-pv-claim<span>
</span></span></span><span><span><span>  </span><span>labels</span>:<span>
</span></span></span><span><span><span>    </span><span>app</span>:<span> </span>wordpress<span>
</span></span></span><span><span><span></span><span>spec</span>:<span>
</span></span></span><span><span><span>  </span><span>accessModes</span>:<span>
</span></span></span><span><span><span>    </span>- ReadWriteOnce<span>
</span></span></span><span><span><span>  </span><span>resources</span>:<span>
</span></span></span><span><span><span>    </span><span>requests</span>:<span>
</span></span></span><span><span><span>      </span><span>storage</span>:<span> </span>20Gi<span>
</span></span></span><span><span><span></span><span>---</span><span>
</span></span></span><span><span><span></span><span>apiVersion</span>:<span> </span>apps/v1<span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>Deployment<span>
</span></span></span><span><span><span></span><span>metadata</span>:<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>wordpress<span>
</span></span></span><span><span><span>  </span><span>labels</span>:<span>
</span></span></span><span><span><span>    </span><span>app</span>:<span> </span>wordpress<span>
</span></span></span><span><span><span></span><span>spec</span>:<span>
</span></span></span><span><span><span>  </span><span>selector</span>:<span>
</span></span></span><span><span><span>    </span><span>matchLabels</span>:<span>
</span></span></span><span><span><span>      </span><span>app</span>:<span> </span>wordpress<span>
</span></span></span><span><span><span>      </span><span>tier</span>:<span> </span>frontend<span>
</span></span></span><span><span><span>  </span><span>strategy</span>:<span>
</span></span></span><span><span><span>    </span><span>type</span>:<span> </span>Recreate<span>
</span></span></span><span><span><span>  </span><span>template</span>:<span>
</span></span></span><span><span><span>    </span><span>metadata</span>:<span>
</span></span></span><span><span><span>      </span><span>labels</span>:<span>
</span></span></span><span><span><span>        </span><span>app</span>:<span> </span>wordpress<span>
</span></span></span><span><span><span>        </span><span>tier</span>:<span> </span>frontend<span>
</span></span></span><span><span><span>    </span><span>spec</span>:<span>
</span></span></span><span><span><span>      </span><span>containers</span>:<span>
</span></span></span><span><span><span>      </span>- <span>image</span>:<span> </span>wordpress:6.2.1-apache<span>
</span></span></span><span><span><span>        </span><span>name</span>:<span> </span>wordpress<span>
</span></span></span><span><span><span>        </span><span>env</span>:<span>
</span></span></span><span><span><span>        </span>- <span>name</span>:<span> </span>WORDPRESS_DB_HOST<span>
</span></span></span><span><span><span>          </span><span>value</span>:<span> </span>wordpress-mysql<span>
</span></span></span><span><span><span>        </span>- <span>name</span>:<span> </span>WORDPRESS_DB_PASSWORD<span>
</span></span></span><span><span><span>          </span><span>valueFrom</span>:<span>
</span></span></span><span><span><span>            </span><span>secretKeyRef</span>:<span>
</span></span></span><span><span><span>              </span><span>name</span>:<span> </span>mysql-pass<span>
</span></span></span><span><span><span>              </span><span>key</span>:<span> </span>password<span>
</span></span></span><span><span><span>        </span>- <span>name</span>:<span> </span>WORDPRESS_DB_USER<span>
</span></span></span><span><span><span>          </span><span>value</span>:<span> </span>wordpress<span>
</span></span></span><span><span><span>        </span><span>ports</span>:<span>
</span></span></span><span><span><span>        </span>- <span>containerPort</span>:<span> </span><span>80</span><span>
</span></span></span><span><span><span>          </span><span>name</span>:<span> </span>wordpress<span>
</span></span></span><span><span><span>        </span><span>volumeMounts</span>:<span>
</span></span></span><span><span><span>        </span>- <span>name</span>:<span> </span>wordpress-persistent-storage<span>
</span></span></span><span><span><span>          </span><span>mountPath</span>:<span> </span>/var/www/html<span>
</span></span></span><span><span><span>      </span><span>volumes</span>:<span>
</span></span></span><span><span><span>      </span>- <span>name</span>:<span> </span>wordpress-persistent-storage<span>
</span></span></span><span><span><span>        </span><span>persistentVolumeClaim</span>:<span>
</span></span></span><span><span><span>          </span><span>claimName</span>:<span> </span>wp-pv-claim<span>
</span></span></span></code></pre></div></div></div><ol><li><p>Download the MySQL deployment configuration file.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>curl -LO https://k8s.io/examples/application/wordpress/mysql-deployment.yaml
</span></span></code></pre></div></li><li><p>Download the WordPress configuration file.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>curl -LO https://k8s.io/examples/application/wordpress/wordpress-deployment.yaml
</span></span></code></pre></div></li><li><p>Add them to <code>kustomization.yaml</code> file.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>cat <span>&lt;&lt;EOF &gt;&gt;./kustomization.yaml
</span></span></span><span><span><span>resources:
</span></span></span><span><span><span>  - mysql-deployment.yaml
</span></span></span><span><span><span>  - wordpress-deployment.yaml
</span></span></span><span><span><span>EOF</span>
</span></span></code></pre></div></li></ol><h2 id="apply-and-verify">Apply and Verify</h2><p>The <code>kustomization.yaml</code> contains all the resources for deploying a WordPress site and a
MySQL database. You can apply the directory by</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl apply -k ./
</span></span></code></pre></div><p>Now you can verify that all objects exist.</p><ol><li><p>Verify that the Secret exists by running the following command:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get secrets
</span></span></code></pre></div><p>The response should be like this:</p><pre tabindex="0"><code>NAME                    TYPE                                  DATA   AGE
mysql-pass-c57bb4t7mf   Opaque                                1      9s
</code></pre></li><li><p>Verify that a PersistentVolume got dynamically provisioned.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pvc
</span></span></code></pre></div><div class="alert alert-info"><h4 class="alert-heading">Note:</h4>It can take up to a few minutes for the PVs to be provisioned and bound.</div><p>The response should be like this:</p><pre tabindex="0"><code>NAME             STATUS    VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS       AGE
mysql-pv-claim   Bound     pvc-8cbd7b2e-4044-11e9-b2bb-42010a800002   20Gi       RWO            standard           77s
wp-pv-claim      Bound     pvc-8cd0df54-4044-11e9-b2bb-42010a800002   20Gi       RWO            standard           77s
</code></pre></li><li><p>Verify that the Pod is running by running the following command:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pods
</span></span></code></pre></div><div class="alert alert-info"><h4 class="alert-heading">Note:</h4>It can take up to a few minutes for the Pod's Status to be <code>RUNNING</code>.</div><p>The response should be like this:</p><pre tabindex="0"><code>NAME                               READY     STATUS    RESTARTS   AGE
wordpress-mysql-1894417608-x5dzt   1/1       Running   0          40s
</code></pre></li><li><p>Verify that the Service is running by running the following command:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get services wordpress
</span></span></code></pre></div><p>The response should be like this:</p><pre tabindex="0"><code>NAME        TYPE            CLUSTER-IP   EXTERNAL-IP   PORT(S)        AGE
wordpress   LoadBalancer    10.0.0.89    &lt;pending&gt;     80:32406/TCP   4m
</code></pre><div class="alert alert-info"><h4 class="alert-heading">Note:</h4>Minikube can only expose Services through <code>NodePort</code>. The EXTERNAL-IP is always pending.</div></li><li><p>Run the following command to get the IP Address for the WordPress Service:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>minikube service wordpress --url
</span></span></code></pre></div><p>The response should be like this:</p><pre tabindex="0"><code>http://1.2.3.4:32406
</code></pre></li><li><p>Copy the IP address, and load the page in your browser to view your site.</p><p>You should see the WordPress set up page similar to the following screenshot.</p><p><img alt="wordpress-init" src="https://raw.githubusercontent.com/kubernetes/examples/master/mysql-wordpress-pd/WordPress.png"></p><div class="alert alert-danger"><h4 class="alert-heading">Warning:</h4>Do not leave your WordPress installation on this page. If another user finds it,
they can set up a website on your instance and use it to serve malicious content.<br><br>Either install WordPress by creating a username and password or delete your instance.</div></li></ol><h2 id="cleaning-up">Cleaning up</h2><ol><li><p>Run the following command to delete your Secret, Deployments, Services and PersistentVolumeClaims:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl delete -k ./
</span></span></code></pre></div></li></ol><h2 id="what-s-next">What's next</h2><ul><li>Learn more about <a href="/docs/tasks/debug/debug-application/debug-running-pod/">Introspection and Debugging</a></li><li>Learn more about <a href="/docs/concepts/workloads/controllers/job/">Jobs</a></li><li>Learn more about <a href="/docs/tasks/access-application-cluster/port-forward-access-application-cluster/">Port Forwarding</a></li><li>Learn how to <a href="/docs/tasks/debug/debug-application/get-shell-running-container/">Get a Shell to a Container</a></li></ul></div></div><div><div class="td-content"><h1>Example: Deploying Cassandra with a StatefulSet</h1><p>This tutorial shows you how to run <a href="https://cassandra.apache.org/">Apache Cassandra</a> on Kubernetes.
Cassandra, a database, needs persistent storage to provide data durability (application <em>state</em>).
In this example, a custom Cassandra seed provider lets the database discover new Cassandra instances as they join the Cassandra cluster.</p><p><em>StatefulSets</em> make it easier to deploy stateful applications into your Kubernetes cluster.
For more information on the features used in this tutorial, see
<a href="/docs/concepts/workloads/controllers/statefulset/">StatefulSet</a>.</p><div class="alert alert-info"><h4 class="alert-heading">Note:</h4><p>Cassandra and Kubernetes both use the term <em>node</em> to mean a member of a cluster. In this
tutorial, the Pods that belong to the StatefulSet are Cassandra nodes and are members
of the Cassandra cluster (called a <em>ring</em>). When those Pods run in your Kubernetes cluster,
the Kubernetes control plane schedules those Pods onto Kubernetes
<a class="glossary-tooltip" title="A node is a worker machine in Kubernetes." href="/docs/concepts/architecture/nodes/" target="_blank">Nodes</a>.</p><p>When a Cassandra node starts, it uses a <em>seed list</em> to bootstrap discovery of other
nodes in the ring.
This tutorial deploys a custom Cassandra seed provider that lets the database discover
new Cassandra Pods as they appear inside your Kubernetes cluster.</p></div><h2 id="objectives">Objectives</h2><ul><li>Create and validate a Cassandra headless <a class="glossary-tooltip" title="A way to expose an application running on a set of Pods as a network service." href="/docs/concepts/services-networking/service/" target="_blank">Service</a>.</li><li>Use a <a class="glossary-tooltip" title="A StatefulSet manages deployment and scaling of a set of Pods, with durable storage and persistent identifiers for each Pod." href="/docs/concepts/workloads/controllers/statefulset/" target="_blank">StatefulSet</a> to create a Cassandra ring.</li><li>Validate the StatefulSet.</li><li>Modify the StatefulSet.</li><li>Delete the StatefulSet and its <a class="glossary-tooltip" title="A Pod represents a set of running containers in your cluster." href="/docs/concepts/workloads/pods/" target="_blank">Pods</a>.</li></ul><h2 id="before-you-begin">Before you begin</h2><p>You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. It is recommended to run this tutorial on a cluster with at least two nodes that are not acting as control plane hosts. If you do not already have a
cluster, you can create one by using
<a href="https://minikube.sigs.k8s.io/docs/tutorials/multi_node/">minikube</a>
or you can use one of these Kubernetes playgrounds:</p><ul><li><a href="https://labs.iximiuz.com/playgrounds?category=kubernetes&amp;filter=all">iximiuz Labs</a></li><li><a href="https://killercoda.com/playgrounds/scenario/kubernetes">Killercoda</a></li><li><a href="https://kodekloud.com/public-playgrounds">KodeKloud</a></li><li><a href="https://labs.play-with-k8s.com/">Play with Kubernetes</a></li></ul><p>To complete this tutorial, you should already have a basic familiarity with
<a class="glossary-tooltip" title="A Pod represents a set of running containers in your cluster." href="/docs/concepts/workloads/pods/" target="_blank">Pods</a>,
<a class="glossary-tooltip" title="A way to expose an application running on a set of Pods as a network service." href="/docs/concepts/services-networking/service/" target="_blank">Services</a>, and
<a class="glossary-tooltip" title="A StatefulSet manages deployment and scaling of a set of Pods, with durable storage and persistent identifiers for each Pod." href="/docs/concepts/workloads/controllers/statefulset/" target="_blank">StatefulSets</a>.</p><h3 id="additional-minikube-setup-instructions">Additional Minikube setup instructions</h3><div class="alert alert-caution"><h4 class="alert-heading">Caution:</h4><p><a href="https://minikube.sigs.k8s.io/docs/">Minikube</a> defaults to 2048MB of memory and 2 CPU.
Running Minikube with the default resource configuration results in insufficient resource
errors during this tutorial. To avoid these errors, start Minikube with the following settings:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>minikube start --memory <span>5120</span> --cpus<span>=</span><span>4</span>
</span></span></code></pre></div></div><h2 id="creating-a-cassandra-headless-service">Creating a headless Service for Cassandra</h2><p>In Kubernetes, a <a class="glossary-tooltip" title="A way to expose an application running on a set of Pods as a network service." href="/docs/concepts/services-networking/service/" target="_blank">Service</a> describes a set of
<a class="glossary-tooltip" title="A Pod represents a set of running containers in your cluster." href="/docs/concepts/workloads/pods/" target="_blank">Pods</a> that perform the same task.</p><p>The following Service is used for DNS lookups between Cassandra Pods and clients within your cluster:</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/application/cassandra/cassandra-service.yaml"><code>application/cassandra/cassandra-service.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" title="Copy application/cassandra/cassandra-service.yaml to clipboard"></div><div class="includecode" id="application-cassandra-cassandra-service-yaml"><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span>apiVersion</span>:<span> </span>v1<span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>Service<span>
</span></span></span><span><span><span></span><span>metadata</span>:<span>
</span></span></span><span><span><span>  </span><span>labels</span>:<span>
</span></span></span><span><span><span>    </span><span>app</span>:<span> </span>cassandra<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>cassandra<span>
</span></span></span><span><span><span></span><span>spec</span>:<span>
</span></span></span><span><span><span>  </span><span>clusterIP</span>:<span> </span>None<span>
</span></span></span><span><span><span>  </span><span>ports</span>:<span>
</span></span></span><span><span><span>  </span>- <span>port</span>:<span> </span><span>9042</span><span>
</span></span></span><span><span><span>  </span><span>selector</span>:<span>
</span></span></span><span><span><span>    </span><span>app</span>:<span> </span>cassandra<span>
</span></span></span></code></pre></div></div></div><p>Create a Service to track all Cassandra StatefulSet members from the <code>cassandra-service.yaml</code> file:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl apply -f https://k8s.io/examples/application/cassandra/cassandra-service.yaml
</span></span></code></pre></div><h3 id="validating">Validating (optional)</h3><p>Get the Cassandra Service.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get svc cassandra
</span></span></code></pre></div><p>The response is</p><pre tabindex="0"><code>NAME        TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)    AGE
cassandra   ClusterIP   None         &lt;none&gt;        9042/TCP   45s
</code></pre><p>If you don't see a Service named <code>cassandra</code>, that means creation failed. Read
<a href="/docs/tasks/debug/debug-application/debug-service/">Debug Services</a>
for help troubleshooting common issues.</p><h2 id="using-a-statefulset-to-create-a-cassandra-ring">Using a StatefulSet to create a Cassandra ring</h2><p>The StatefulSet manifest, included below, creates a Cassandra ring that consists of three Pods.</p><div class="alert alert-info"><h4 class="alert-heading">Note:</h4>This example uses the default provisioner for Minikube.
Please update the following StatefulSet for the cloud you are working with.</div><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/application/cassandra/cassandra-statefulset.yaml"><code>application/cassandra/cassandra-statefulset.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" title="Copy application/cassandra/cassandra-statefulset.yaml to clipboard"></div><div class="includecode" id="application-cassandra-cassandra-statefulset-yaml"><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span>apiVersion</span>:<span> </span>apps/v1<span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>StatefulSet<span>
</span></span></span><span><span><span></span><span>metadata</span>:<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>cassandra<span>
</span></span></span><span><span><span>  </span><span>labels</span>:<span>
</span></span></span><span><span><span>    </span><span>app</span>:<span> </span>cassandra<span>
</span></span></span><span><span><span></span><span>spec</span>:<span>
</span></span></span><span><span><span>  </span><span>serviceName</span>:<span> </span>cassandra<span>
</span></span></span><span><span><span>  </span><span>replicas</span>:<span> </span><span>3</span><span>
</span></span></span><span><span><span>  </span><span>selector</span>:<span>
</span></span></span><span><span><span>    </span><span>matchLabels</span>:<span>
</span></span></span><span><span><span>      </span><span>app</span>:<span> </span>cassandra<span>
</span></span></span><span><span><span>  </span><span>template</span>:<span>
</span></span></span><span><span><span>    </span><span>metadata</span>:<span>
</span></span></span><span><span><span>      </span><span>labels</span>:<span>
</span></span></span><span><span><span>        </span><span>app</span>:<span> </span>cassandra<span>
</span></span></span><span><span><span>    </span><span>spec</span>:<span>
</span></span></span><span><span><span>      </span><span>terminationGracePeriodSeconds</span>:<span> </span><span>500</span><span>
</span></span></span><span><span><span>      </span><span>containers</span>:<span>
</span></span></span><span><span><span>      </span>- <span>name</span>:<span> </span>cassandra<span>
</span></span></span><span><span><span>        </span><span>image</span>:<span> </span>gcr.io/google-samples/cassandra:v13<span>
</span></span></span><span><span><span>        </span><span>imagePullPolicy</span>:<span> </span>Always<span>
</span></span></span><span><span><span>        </span><span>ports</span>:<span>
</span></span></span><span><span><span>        </span>- <span>containerPort</span>:<span> </span><span>7000</span><span>
</span></span></span><span><span><span>          </span><span>name</span>:<span> </span>intra-node<span>
</span></span></span><span><span><span>        </span>- <span>containerPort</span>:<span> </span><span>7001</span><span>
</span></span></span><span><span><span>          </span><span>name</span>:<span> </span>tls-intra-node<span>
</span></span></span><span><span><span>        </span>- <span>containerPort</span>:<span> </span><span>7199</span><span>
</span></span></span><span><span><span>          </span><span>name</span>:<span> </span>jmx<span>
</span></span></span><span><span><span>        </span>- <span>containerPort</span>:<span> </span><span>9042</span><span>
</span></span></span><span><span><span>          </span><span>name</span>:<span> </span>cql<span>
</span></span></span><span><span><span>        </span><span>resources</span>:<span>
</span></span></span><span><span><span>          </span><span>limits</span>:<span>
</span></span></span><span><span><span>            </span><span>cpu</span>:<span> </span><span>"500m"</span><span>
</span></span></span><span><span><span>            </span><span>memory</span>:<span> </span>1Gi<span>
</span></span></span><span><span><span>          </span><span>requests</span>:<span>
</span></span></span><span><span><span>            </span><span>cpu</span>:<span> </span><span>"500m"</span><span>
</span></span></span><span><span><span>            </span><span>memory</span>:<span> </span>1Gi<span>
</span></span></span><span><span><span>        </span><span>securityContext</span>:<span>
</span></span></span><span><span><span>          </span><span>capabilities</span>:<span>
</span></span></span><span><span><span>            </span><span>add</span>:<span>
</span></span></span><span><span><span>              </span>- IPC_LOCK<span>
</span></span></span><span><span><span>        </span><span>lifecycle</span>:<span>
</span></span></span><span><span><span>          </span><span>preStop</span>:<span>
</span></span></span><span><span><span>            </span><span>exec</span>:<span>
</span></span></span><span><span><span>              </span><span>command</span>:<span> 
</span></span></span><span><span><span>              </span>- /bin/sh<span>
</span></span></span><span><span><span>              </span>- -c<span>
</span></span></span><span><span><span>              </span>- nodetool drain<span>
</span></span></span><span><span><span>        </span><span>env</span>:<span>
</span></span></span><span><span><span>          </span>- <span>name</span>:<span> </span>MAX_HEAP_SIZE<span>
</span></span></span><span><span><span>            </span><span>value</span>:<span> </span>512M<span>
</span></span></span><span><span><span>          </span>- <span>name</span>:<span> </span>HEAP_NEWSIZE<span>
</span></span></span><span><span><span>            </span><span>value</span>:<span> </span>100M<span>
</span></span></span><span><span><span>          </span>- <span>name</span>:<span> </span>CASSANDRA_SEEDS<span>
</span></span></span><span><span><span>            </span><span>value</span>:<span> </span><span>"cassandra-0.cassandra.default.svc.cluster.local"</span><span>
</span></span></span><span><span><span>          </span>- <span>name</span>:<span> </span>CASSANDRA_CLUSTER_NAME<span>
</span></span></span><span><span><span>            </span><span>value</span>:<span> </span><span>"K8Demo"</span><span>
</span></span></span><span><span><span>          </span>- <span>name</span>:<span> </span>CASSANDRA_DC<span>
</span></span></span><span><span><span>            </span><span>value</span>:<span> </span><span>"DC1-K8Demo"</span><span>
</span></span></span><span><span><span>          </span>- <span>name</span>:<span> </span>CASSANDRA_RACK<span>
</span></span></span><span><span><span>            </span><span>value</span>:<span> </span><span>"Rack1-K8Demo"</span><span>
</span></span></span><span><span><span>          </span>- <span>name</span>:<span> </span>POD_IP<span>
</span></span></span><span><span><span>            </span><span>valueFrom</span>:<span>
</span></span></span><span><span><span>              </span><span>fieldRef</span>:<span>
</span></span></span><span><span><span>                </span><span>fieldPath</span>:<span> </span>status.podIP<span>
</span></span></span><span><span><span>        </span><span>readinessProbe</span>:<span>
</span></span></span><span><span><span>          </span><span>exec</span>:<span>
</span></span></span><span><span><span>            </span><span>command</span>:<span>
</span></span></span><span><span><span>            </span>- /bin/bash<span>
</span></span></span><span><span><span>            </span>- -c<span>
</span></span></span><span><span><span>            </span>- /ready-probe.sh<span>
</span></span></span><span><span><span>          </span><span>initialDelaySeconds</span>:<span> </span><span>15</span><span>
</span></span></span><span><span><span>          </span><span>timeoutSeconds</span>:<span> </span><span>5</span><span>
</span></span></span><span><span><span>        </span><span># These volume mounts are persistent. They are like inline claims,</span><span>
</span></span></span><span><span><span>        </span><span># but not exactly because the names need to match exactly one of</span><span>
</span></span></span><span><span><span>        </span><span># the stateful pod volumes.</span><span>
</span></span></span><span><span><span>        </span><span>volumeMounts</span>:<span>
</span></span></span><span><span><span>        </span>- <span>name</span>:<span> </span>cassandra-data<span>
</span></span></span><span><span><span>          </span><span>mountPath</span>:<span> </span>/cassandra_data<span>
</span></span></span><span><span><span>  </span><span># These are converted to volume claims by the controller</span><span>
</span></span></span><span><span><span>  </span><span># and mounted at the paths mentioned above.</span><span>
</span></span></span><span><span><span>  </span><span># do not use these in production until ssd GCEPersistentDisk or other ssd pd</span><span>
</span></span></span><span><span><span>  </span><span>volumeClaimTemplates</span>:<span>
</span></span></span><span><span><span>  </span>- <span>metadata</span>:<span>
</span></span></span><span><span><span>      </span><span>name</span>:<span> </span>cassandra-data<span>
</span></span></span><span><span><span>    </span><span>spec</span>:<span>
</span></span></span><span><span><span>      </span><span>accessModes</span>:<span> </span>[<span> </span><span>"ReadWriteOnce"</span><span> </span>]<span>
</span></span></span><span><span><span>      </span><span>storageClassName</span>:<span> </span>fast<span>
</span></span></span><span><span><span>      </span><span>resources</span>:<span>
</span></span></span><span><span><span>        </span><span>requests</span>:<span>
</span></span></span><span><span><span>          </span><span>storage</span>:<span> </span>1Gi<span>
</span></span></span><span><span><span></span><span>---</span><span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>StorageClass<span>
</span></span></span><span><span><span></span><span>apiVersion</span>:<span> </span>storage.k8s.io/v1<span>
</span></span></span><span><span><span></span><span>metadata</span>:<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>fast<span>
</span></span></span><span><span><span></span><span>provisioner</span>:<span> </span>k8s.io/minikube-hostpath<span>
</span></span></span><span><span><span></span><span>parameters</span>:<span>
</span></span></span><span><span><span>  </span><span>type</span>:<span> </span>pd-ssd<span>
</span></span></span></code></pre></div></div></div><p>Create the Cassandra StatefulSet from the <code>cassandra-statefulset.yaml</code> file:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span># Use this if you are able to apply cassandra-statefulset.yaml unmodified</span>
</span></span><span><span>kubectl apply -f https://k8s.io/examples/application/cassandra/cassandra-statefulset.yaml
</span></span></code></pre></div><p>If you need to modify <code>cassandra-statefulset.yaml</code> to suit your cluster, download
<a href="https://k8s.io/examples/application/cassandra/cassandra-statefulset.yaml">https://k8s.io/examples/application/cassandra/cassandra-statefulset.yaml</a> and then apply
that manifest, from the folder you saved the modified version into:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span># Use this if you needed to modify cassandra-statefulset.yaml locally</span>
</span></span><span><span>kubectl apply -f cassandra-statefulset.yaml
</span></span></code></pre></div><h2 id="validating-the-cassandra-statefulset">Validating the Cassandra StatefulSet</h2><ol><li><p>Get the Cassandra StatefulSet:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get statefulset cassandra
</span></span></code></pre></div><p>The response should be similar to:</p><pre tabindex="0"><code>NAME        DESIRED   CURRENT   AGE
cassandra   3         0         13s
</code></pre><p>The <code>StatefulSet</code> resource deploys Pods sequentially.</p></li><li><p>Get the Pods to see the ordered creation status:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pods -l<span>=</span><span>"app=cassandra"</span>
</span></span></code></pre></div><p>The response should be similar to:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>NAME          READY     STATUS              RESTARTS   AGE
</span></span><span><span>cassandra-0   1/1       Running             <span>0</span>          1m
</span></span><span><span>cassandra-1   0/1       ContainerCreating   <span>0</span>          8s
</span></span></code></pre></div><p>It can take several minutes for all three Pods to deploy. Once they are deployed, the same command
returns output similar to:</p><pre tabindex="0"><code>NAME          READY     STATUS    RESTARTS   AGE
cassandra-0   1/1       Running   0          10m
cassandra-1   1/1       Running   0          9m
cassandra-2   1/1       Running   0          8m
</code></pre></li><li><p>Run the Cassandra <a href="https://cwiki.apache.org/confluence/display/CASSANDRA2/NodeTool">nodetool</a> inside the first Pod, to
display the status of the ring.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl <span>exec</span> -it cassandra-0 -- nodetool status
</span></span></code></pre></div><p>The response should look something like:</p><pre tabindex="0"><code>Datacenter: DC1-K8Demo
======================
Status=Up/Down
|/ State=Normal/Leaving/Joining/Moving
--  Address     Load       Tokens       Owns (effective)  Host ID                               Rack
UN  172.17.0.5  83.57 KiB  32           74.0%             e2dd09e6-d9d3-477e-96c5-45094c08db0f  Rack1-K8Demo
UN  172.17.0.4  101.04 KiB  32           58.8%             f89d6835-3a42-4419-92b3-0e62cae1479c  Rack1-K8Demo
UN  172.17.0.6  84.74 KiB  32           67.1%             a6a1e8c2-3dc5-4417-b1a0-26507af2aaad  Rack1-K8Demo
</code></pre></li></ol><h2 id="modifying-the-cassandra-statefulset">Modifying the Cassandra StatefulSet</h2><p>Use <code>kubectl edit</code> to modify the size of a Cassandra StatefulSet.</p><ol><li><p>Run the following command:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl edit statefulset cassandra
</span></span></code></pre></div><p>This command opens an editor in your terminal. The line you need to change is the <code>replicas</code> field.
The following sample is an excerpt of the StatefulSet file:</p><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span># Please edit the object below. Lines beginning with a '#' will be ignored,</span><span>
</span></span></span><span><span><span></span><span># and an empty file will abort the edit. If an error occurs while saving this file will be</span><span>
</span></span></span><span><span><span></span><span># reopened with the relevant failures.</span><span>
</span></span></span><span><span><span></span><span>#</span><span>
</span></span></span><span><span><span></span><span>apiVersion</span>:<span> </span>apps/v1<span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>StatefulSet<span>
</span></span></span><span><span><span></span><span>metadata</span>:<span>
</span></span></span><span><span><span>  </span><span>creationTimestamp</span>:<span> </span>2016-08-13T18:40:58Z<span>
</span></span></span><span><span><span>  </span><span>generation</span>:<span> </span><span>1</span><span>
</span></span></span><span><span><span>  </span><span>labels</span>:<span>
</span></span></span><span><span><span>  </span><span>app</span>:<span> </span>cassandra<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>cassandra<span>
</span></span></span><span><span><span>  </span><span>namespace</span>:<span> </span>default<span>
</span></span></span><span><span><span>  </span><span>resourceVersion</span>:<span> </span><span>"323"</span><span>
</span></span></span><span><span><span>  </span><span>uid</span>:<span> </span>7a219483-6185-11e6-a910-42010a8a0fc0<span>
</span></span></span><span><span><span></span><span>spec</span>:<span>
</span></span></span><span><span><span>  </span><span>replicas</span>:<span> </span><span>3</span><span>
</span></span></span></code></pre></div></li><li><p>Change the number of replicas to 4, and then save the manifest.</p><p>The StatefulSet now scales to run with 4 Pods.</p></li><li><p>Get the Cassandra StatefulSet to verify your change:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get statefulset cassandra
</span></span></code></pre></div><p>The response should be similar to:</p><pre tabindex="0"><code>NAME        DESIRED   CURRENT   AGE
cassandra   4         4         36m
</code></pre></li></ol><h2 id="cleaning-up">Cleaning up</h2><p>Deleting or scaling a StatefulSet down does not delete the volumes associated with the StatefulSet.
This setting is for your safety because your data is more valuable than automatically purging all related StatefulSet resources.</p><div class="alert alert-danger"><h4 class="alert-heading">Warning:</h4>Depending on the storage class and reclaim policy, deleting the <em>PersistentVolumeClaims</em> may cause the associated volumes
to also be deleted. Never assume you'll be able to access data if its volume claims are deleted.</div><ol><li><p>Run the following commands (chained together into a single command) to delete everything in the Cassandra StatefulSet:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span>grace</span><span>=</span><span>$(</span>kubectl get pod cassandra-0 -o<span>=</span><span>jsonpath</span><span>=</span><span>'{.spec.terminationGracePeriodSeconds}'</span><span>)</span> <span>\
</span></span></span><span><span><span></span>  <span>&amp;&amp;</span> kubectl delete statefulset -l <span>app</span><span>=</span>cassandra <span>\
</span></span></span><span><span><span></span>  <span>&amp;&amp;</span> <span>echo</span> <span>"Sleeping </span><span>${</span><span>grace</span><span>}</span><span> seconds"</span> 1&gt;&amp;<span>2</span> <span>\
</span></span></span><span><span><span></span>  <span>&amp;&amp;</span> sleep <span>$grace</span> <span>\
</span></span></span><span><span><span></span>  <span>&amp;&amp;</span> kubectl delete persistentvolumeclaim -l <span>app</span><span>=</span>cassandra
</span></span></code></pre></div></li><li><p>Run the following command to delete the Service you set up for Cassandra:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl delete service -l <span>app</span><span>=</span>cassandra
</span></span></code></pre></div></li></ol><h2 id="cassandra-container-environment-variables">Cassandra container environment variables</h2><p>The Pods in this tutorial use the <a href="https://github.com/kubernetes/examples/blob/master/cassandra/image/Dockerfile"><code>gcr.io/google-samples/cassandra:v13</code></a>
image from Google's <a href="https://cloud.google.com/container-registry/docs/">container registry</a>.
The Docker image above is based on <a href="https://github.com/kubernetes/release/tree/master/images/build/debian-base">debian-base</a>
and includes OpenJDK 8.</p><p>This image includes a standard Cassandra installation from the Apache Debian repo.
By using environment variables you can change values that are inserted into <code>cassandra.yaml</code>.</p><table><thead><tr><th>Environment variable</th><th>Default value</th></tr></thead><tbody><tr><td><code>CASSANDRA_CLUSTER_NAME</code></td><td><code>'Test Cluster'</code></td></tr><tr><td><code>CASSANDRA_NUM_TOKENS</code></td><td><code>32</code></td></tr><tr><td><code>CASSANDRA_RPC_ADDRESS</code></td><td><code>0.0.0.0</code></td></tr></tbody></table><h2 id="what-s-next">What's next</h2><ul><li>Learn how to <a href="/docs/tasks/run-application/scale-stateful-set/">Scale a StatefulSet</a>.</li><li>Learn more about the <a href="https://github.com/kubernetes/examples/blob/master/cassandra/java/src/main/java/io/k8s/cassandra/KubernetesSeedProvider.java"><em>KubernetesSeedProvider</em></a></li><li>See more custom <a href="https://git.k8s.io/examples/cassandra/java/README.md">Seed Provider Configurations</a></li></ul></div></div><div><div class="td-content"><h1>Running ZooKeeper, A Distributed System Coordinator</h1><p>This tutorial demonstrates running <a href="https://zookeeper.apache.org">Apache Zookeeper</a> on
Kubernetes using <a href="/docs/concepts/workloads/controllers/statefulset/">StatefulSets</a>,
<a href="/docs/concepts/workloads/pods/disruptions/#pod-disruption-budget">PodDisruptionBudgets</a>,
and <a href="/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity">PodAntiAffinity</a>.</p><h2 id="before-you-begin">Before you begin</h2><p>Before starting this tutorial, you should be familiar with the following
Kubernetes concepts:</p><ul><li><a href="/docs/concepts/workloads/pods/">Pods</a></li><li><a href="/docs/concepts/services-networking/dns-pod-service/">Cluster DNS</a></li><li><a href="/docs/concepts/services-networking/service/#headless-services">Headless Services</a></li><li><a href="/docs/concepts/storage/persistent-volumes/">PersistentVolumes</a></li><li><a href="https://github.com/kubernetes/examples/tree/master/staging/persistent-volume-provisioning/">PersistentVolume Provisioning</a></li><li><a href="/docs/concepts/workloads/controllers/statefulset/">StatefulSets</a></li><li><a href="/docs/concepts/workloads/pods/disruptions/#pod-disruption-budget">PodDisruptionBudgets</a></li><li><a href="/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity">PodAntiAffinity</a></li><li><a href="/docs/reference/kubectl/kubectl/">kubectl CLI</a></li></ul><p>You must have a cluster with at least four nodes, and each node requires at least 2 CPUs and 4 GiB of memory. In this tutorial you will cordon and drain the cluster's nodes. <strong>This means that the cluster will terminate and evict all Pods on its nodes, and the nodes will temporarily become unschedulable.</strong> You should use a dedicated cluster for this tutorial, or you should ensure that the disruption you cause will not interfere with other tenants.</p><p>This tutorial assumes that you have configured your cluster to dynamically provision
PersistentVolumes. If your cluster is not configured to do so, you
will have to manually provision three 20 GiB volumes before starting this
tutorial.</p><h2 id="objectives">Objectives</h2><p>After this tutorial, you will know the following.</p><ul><li>How to deploy a ZooKeeper ensemble using StatefulSet.</li><li>How to consistently configure the ensemble.</li><li>How to spread the deployment of ZooKeeper servers in the ensemble.</li><li>How to use PodDisruptionBudgets to ensure service availability during planned maintenance.</li></ul><h3 id="zookeeper">ZooKeeper</h3><p><a href="https://zookeeper.apache.org/doc/current/">Apache ZooKeeper</a> is a
distributed, open-source coordination service for distributed applications.
ZooKeeper allows you to read, write, and observe updates to data. Data are
organized in a file system like hierarchy and replicated to all ZooKeeper
servers in the ensemble (a set of ZooKeeper servers). All operations on data
are atomic and sequentially consistent. ZooKeeper ensures this by using the
<a href="https://pdfs.semanticscholar.org/b02c/6b00bd5dbdbd951fddb00b906c82fa80f0b3.pdf">Zab</a>
consensus protocol to replicate a state machine across all servers in the ensemble.</p><p>The ensemble uses the Zab protocol to elect a leader, and the ensemble cannot write data until that election is complete. Once complete, the ensemble uses Zab to ensure that it replicates all writes to a quorum before it acknowledges and makes them visible to clients. Without respect to weighted quorums, a quorum is a majority component of the ensemble containing the current leader. For instance, if the ensemble has three servers, a component that contains the leader and one other server constitutes a quorum. If the ensemble can not achieve a quorum, the ensemble cannot write data.</p><p>ZooKeeper servers keep their entire state machine in memory, and write every mutation to a durable WAL (Write Ahead Log) on storage media. When a server crashes, it can recover its previous state by replaying the WAL. To prevent the WAL from growing without bound, ZooKeeper servers will periodically snapshot them in memory state to storage media. These snapshots can be loaded directly into memory, and all WAL entries that preceded the snapshot may be discarded.</p><h2 id="creating-a-zookeeper-ensemble">Creating a ZooKeeper ensemble</h2><p>The manifest below contains a
<a href="/docs/concepts/services-networking/service/#headless-services">Headless Service</a>,
a <a href="/docs/concepts/services-networking/service/">Service</a>,
a <a href="/docs/concepts/workloads/pods/disruptions/#pod-disruption-budgets">PodDisruptionBudget</a>,
and a <a href="/docs/concepts/workloads/controllers/statefulset/">StatefulSet</a>.</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/application/zookeeper/zookeeper.yaml"><code>application/zookeeper/zookeeper.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" title="Copy application/zookeeper/zookeeper.yaml to clipboard"></div><div class="includecode" id="application-zookeeper-zookeeper-yaml"><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span>apiVersion</span>:<span> </span>v1<span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>Service<span>
</span></span></span><span><span><span></span><span>metadata</span>:<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>zk-hs<span>
</span></span></span><span><span><span>  </span><span>labels</span>:<span>
</span></span></span><span><span><span>    </span><span>app</span>:<span> </span>zk<span>
</span></span></span><span><span><span></span><span>spec</span>:<span>
</span></span></span><span><span><span>  </span><span>ports</span>:<span>
</span></span></span><span><span><span>  </span>- <span>port</span>:<span> </span><span>2888</span><span>
</span></span></span><span><span><span>    </span><span>name</span>:<span> </span>server<span>
</span></span></span><span><span><span>  </span>- <span>port</span>:<span> </span><span>3888</span><span>
</span></span></span><span><span><span>    </span><span>name</span>:<span> </span>leader-election<span>
</span></span></span><span><span><span>  </span><span>clusterIP</span>:<span> </span>None<span>
</span></span></span><span><span><span>  </span><span>selector</span>:<span>
</span></span></span><span><span><span>    </span><span>app</span>:<span> </span>zk<span>
</span></span></span><span><span><span></span><span>---</span><span>
</span></span></span><span><span><span></span><span>apiVersion</span>:<span> </span>v1<span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>Service<span>
</span></span></span><span><span><span></span><span>metadata</span>:<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>zk-cs<span>
</span></span></span><span><span><span>  </span><span>labels</span>:<span>
</span></span></span><span><span><span>    </span><span>app</span>:<span> </span>zk<span>
</span></span></span><span><span><span></span><span>spec</span>:<span>
</span></span></span><span><span><span>  </span><span>ports</span>:<span>
</span></span></span><span><span><span>  </span>- <span>port</span>:<span> </span><span>2181</span><span>
</span></span></span><span><span><span>    </span><span>name</span>:<span> </span>client<span>
</span></span></span><span><span><span>  </span><span>selector</span>:<span>
</span></span></span><span><span><span>    </span><span>app</span>:<span> </span>zk<span>
</span></span></span><span><span><span></span><span>---</span><span>
</span></span></span><span><span><span></span><span>apiVersion</span>:<span> </span>policy/v1<span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>PodDisruptionBudget<span>
</span></span></span><span><span><span></span><span>metadata</span>:<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>zk-pdb<span>
</span></span></span><span><span><span></span><span>spec</span>:<span>
</span></span></span><span><span><span>  </span><span>selector</span>:<span>
</span></span></span><span><span><span>    </span><span>matchLabels</span>:<span>
</span></span></span><span><span><span>      </span><span>app</span>:<span> </span>zk<span>
</span></span></span><span><span><span>  </span><span>maxUnavailable</span>:<span> </span><span>1</span><span>
</span></span></span><span><span><span></span><span>---</span><span>
</span></span></span><span><span><span></span><span>apiVersion</span>:<span> </span>apps/v1<span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>StatefulSet<span>
</span></span></span><span><span><span></span><span>metadata</span>:<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>zk<span>
</span></span></span><span><span><span></span><span>spec</span>:<span>
</span></span></span><span><span><span>  </span><span>selector</span>:<span>
</span></span></span><span><span><span>    </span><span>matchLabels</span>:<span>
</span></span></span><span><span><span>      </span><span>app</span>:<span> </span>zk<span>
</span></span></span><span><span><span>  </span><span>serviceName</span>:<span> </span>zk-hs<span>
</span></span></span><span><span><span>  </span><span>replicas</span>:<span> </span><span>3</span><span>
</span></span></span><span><span><span>  </span><span>updateStrategy</span>:<span>
</span></span></span><span><span><span>    </span><span>type</span>:<span> </span>RollingUpdate<span>
</span></span></span><span><span><span>  </span><span>podManagementPolicy</span>:<span> </span>OrderedReady<span>
</span></span></span><span><span><span>  </span><span>template</span>:<span>
</span></span></span><span><span><span>    </span><span>metadata</span>:<span>
</span></span></span><span><span><span>      </span><span>labels</span>:<span>
</span></span></span><span><span><span>        </span><span>app</span>:<span> </span>zk<span>
</span></span></span><span><span><span>    </span><span>spec</span>:<span>
</span></span></span><span><span><span>      </span><span>affinity</span>:<span>
</span></span></span><span><span><span>        </span><span>podAntiAffinity</span>:<span>
</span></span></span><span><span><span>          </span><span>requiredDuringSchedulingIgnoredDuringExecution</span>:<span>
</span></span></span><span><span><span>            </span>- <span>labelSelector</span>:<span>
</span></span></span><span><span><span>                </span><span>matchExpressions</span>:<span>
</span></span></span><span><span><span>                  </span>- <span>key</span>:<span> </span><span>"app"</span><span>
</span></span></span><span><span><span>                    </span><span>operator</span>:<span> </span>In<span>
</span></span></span><span><span><span>                    </span><span>values</span>:<span>
</span></span></span><span><span><span>                    </span>- zk<span>
</span></span></span><span><span><span>              </span><span>topologyKey</span>:<span> </span><span>"kubernetes.io/hostname"</span><span>
</span></span></span><span><span><span>      </span><span>containers</span>:<span>
</span></span></span><span><span><span>      </span>- <span>name</span>:<span> </span>kubernetes-zookeeper<span>
</span></span></span><span><span><span>        </span><span>imagePullPolicy</span>:<span> </span>Always<span>
</span></span></span><span><span><span>        </span><span>image</span>:<span> </span><span>"registry.k8s.io/kubernetes-zookeeper:1.0-3.4.10"</span><span>
</span></span></span><span><span><span>        </span><span>resources</span>:<span>
</span></span></span><span><span><span>          </span><span>requests</span>:<span>
</span></span></span><span><span><span>            </span><span>memory</span>:<span> </span><span>"1Gi"</span><span>
</span></span></span><span><span><span>            </span><span>cpu</span>:<span> </span><span>"0.5"</span><span>
</span></span></span><span><span><span>        </span><span>ports</span>:<span>
</span></span></span><span><span><span>        </span>- <span>containerPort</span>:<span> </span><span>2181</span><span>
</span></span></span><span><span><span>          </span><span>name</span>:<span> </span>client<span>
</span></span></span><span><span><span>        </span>- <span>containerPort</span>:<span> </span><span>2888</span><span>
</span></span></span><span><span><span>          </span><span>name</span>:<span> </span>server<span>
</span></span></span><span><span><span>        </span>- <span>containerPort</span>:<span> </span><span>3888</span><span>
</span></span></span><span><span><span>          </span><span>name</span>:<span> </span>leader-election<span>
</span></span></span><span><span><span>        </span><span>command</span>:<span>
</span></span></span><span><span><span>        </span>- sh<span>
</span></span></span><span><span><span>        </span>- -c<span>
</span></span></span><span><span><span>        </span>- <span>"start-zookeeper \
</span></span></span><span><span><span>          --servers=3 \
</span></span></span><span><span><span>          --data_dir=/var/lib/zookeeper/data \
</span></span></span><span><span><span>          --data_log_dir=/var/lib/zookeeper/data/log \
</span></span></span><span><span><span>          --conf_dir=/opt/zookeeper/conf \
</span></span></span><span><span><span>          --client_port=2181 \
</span></span></span><span><span><span>          --election_port=3888 \
</span></span></span><span><span><span>          --server_port=2888 \
</span></span></span><span><span><span>          --tick_time=2000 \
</span></span></span><span><span><span>          --init_limit=10 \
</span></span></span><span><span><span>          --sync_limit=5 \
</span></span></span><span><span><span>          --heap=512M \
</span></span></span><span><span><span>          --max_client_cnxns=60 \
</span></span></span><span><span><span>          --snap_retain_count=3 \
</span></span></span><span><span><span>          --purge_interval=12 \
</span></span></span><span><span><span>          --max_session_timeout=40000 \
</span></span></span><span><span><span>          --min_session_timeout=4000 \
</span></span></span><span><span><span>          --log_level=INFO"</span><span>
</span></span></span><span><span><span>        </span><span>readinessProbe</span>:<span>
</span></span></span><span><span><span>          </span><span>exec</span>:<span>
</span></span></span><span><span><span>            </span><span>command</span>:<span>
</span></span></span><span><span><span>            </span>- sh<span>
</span></span></span><span><span><span>            </span>- -c<span>
</span></span></span><span><span><span>            </span>- <span>"zookeeper-ready 2181"</span><span>
</span></span></span><span><span><span>          </span><span>initialDelaySeconds</span>:<span> </span><span>10</span><span>
</span></span></span><span><span><span>          </span><span>timeoutSeconds</span>:<span> </span><span>5</span><span>
</span></span></span><span><span><span>        </span><span>livenessProbe</span>:<span>
</span></span></span><span><span><span>          </span><span>exec</span>:<span>
</span></span></span><span><span><span>            </span><span>command</span>:<span>
</span></span></span><span><span><span>            </span>- sh<span>
</span></span></span><span><span><span>            </span>- -c<span>
</span></span></span><span><span><span>            </span>- <span>"zookeeper-ready 2181"</span><span>
</span></span></span><span><span><span>          </span><span>initialDelaySeconds</span>:<span> </span><span>10</span><span>
</span></span></span><span><span><span>          </span><span>timeoutSeconds</span>:<span> </span><span>5</span><span>
</span></span></span><span><span><span>        </span><span>volumeMounts</span>:<span>
</span></span></span><span><span><span>        </span>- <span>name</span>:<span> </span>datadir<span>
</span></span></span><span><span><span>          </span><span>mountPath</span>:<span> </span>/var/lib/zookeeper<span>
</span></span></span><span><span><span>      </span><span>securityContext</span>:<span>
</span></span></span><span><span><span>        </span><span>runAsUser</span>:<span> </span><span>1000</span><span>
</span></span></span><span><span><span>        </span><span>fsGroup</span>:<span> </span><span>1000</span><span>
</span></span></span><span><span><span>  </span><span>volumeClaimTemplates</span>:<span>
</span></span></span><span><span><span>  </span>- <span>metadata</span>:<span>
</span></span></span><span><span><span>      </span><span>name</span>:<span> </span>datadir<span>
</span></span></span><span><span><span>    </span><span>spec</span>:<span>
</span></span></span><span><span><span>      </span><span>accessModes</span>:<span> </span>[<span> </span><span>"ReadWriteOnce"</span><span> </span>]<span>
</span></span></span><span><span><span>      </span><span>resources</span>:<span>
</span></span></span><span><span><span>        </span><span>requests</span>:<span>
</span></span></span><span><span><span>          </span><span>storage</span>:<span> </span>10Gi<span>
</span></span></span></code></pre></div></div></div><p>Open a terminal, and use the
<a href="/docs/reference/generated/kubectl/kubectl-commands/#apply"><code>kubectl apply</code></a> command to create the
manifest.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl apply -f https://k8s.io/examples/application/zookeeper/zookeeper.yaml
</span></span></code></pre></div><p>This creates the <code>zk-hs</code> Headless Service, the <code>zk-cs</code> Service,
the <code>zk-pdb</code> PodDisruptionBudget, and the <code>zk</code> StatefulSet.</p><pre tabindex="0"><code>service/zk-hs created
service/zk-cs created
poddisruptionbudget.policy/zk-pdb created
statefulset.apps/zk created
</code></pre><p>Use <a href="/docs/reference/generated/kubectl/kubectl-commands/#get"><code>kubectl get</code></a> to watch the
StatefulSet controller create the StatefulSet's Pods.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pods -w -l <span>app</span><span>=</span>zk
</span></span></code></pre></div><p>Once the <code>zk-2</code> Pod is Running and Ready, use <code>CTRL-C</code> to terminate kubectl.</p><pre tabindex="0"><code>NAME      READY     STATUS    RESTARTS   AGE
zk-0      0/1       Pending   0          0s
zk-0      0/1       Pending   0         0s
zk-0      0/1       ContainerCreating   0         0s
zk-0      0/1       Running   0         19s
zk-0      1/1       Running   0         40s
zk-1      0/1       Pending   0         0s
zk-1      0/1       Pending   0         0s
zk-1      0/1       ContainerCreating   0         0s
zk-1      0/1       Running   0         18s
zk-1      1/1       Running   0         40s
zk-2      0/1       Pending   0         0s
zk-2      0/1       Pending   0         0s
zk-2      0/1       ContainerCreating   0         0s
zk-2      0/1       Running   0         19s
zk-2      1/1       Running   0         40s
</code></pre><p>The StatefulSet controller creates three Pods, and each Pod has a container with
a <a href="https://archive.apache.org/dist/zookeeper/stable/">ZooKeeper</a> server.</p><h3 id="facilitating-leader-election">Facilitating leader election</h3><p>Because there is no terminating algorithm for electing a leader in an anonymous network, Zab requires explicit membership configuration to perform leader election. Each server in the ensemble needs to have a unique identifier, all servers need to know the global set of identifiers, and each identifier needs to be associated with a network address.</p><p>Use <a href="/docs/reference/generated/kubectl/kubectl-commands/#exec"><code>kubectl exec</code></a> to get the hostnames
of the Pods in the <code>zk</code> StatefulSet.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span>for</span> i in <span>0</span> <span>1</span> 2; <span>do</span> kubectl <span>exec</span> zk-<span>$i</span> -- hostname; <span>done</span>
</span></span></code></pre></div><p>The StatefulSet controller provides each Pod with a unique hostname based on its ordinal index. The hostnames take the form of <code>&lt;statefulset name&gt;-&lt;ordinal index&gt;</code>. Because the <code>replicas</code> field of the <code>zk</code> StatefulSet is set to <code>3</code>, the Set's controller creates three Pods with their hostnames set to <code>zk-0</code>, <code>zk-1</code>, and
<code>zk-2</code>.</p><pre tabindex="0"><code>zk-0
zk-1
zk-2
</code></pre><p>The servers in a ZooKeeper ensemble use natural numbers as unique identifiers, and store each server's identifier in a file called <code>myid</code> in the server's data directory.</p><p>To examine the contents of the <code>myid</code> file for each server use the following command.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span>for</span> i in <span>0</span> <span>1</span> 2; <span>do</span> <span>echo</span> <span>"myid zk-</span><span>$i</span><span>"</span>;kubectl <span>exec</span> zk-<span>$i</span> -- cat /var/lib/zookeeper/data/myid; <span>done</span>
</span></span></code></pre></div><p>Because the identifiers are natural numbers and the ordinal indices are non-negative integers, you can generate an identifier by adding 1 to the ordinal.</p><pre tabindex="0"><code>myid zk-0
1
myid zk-1
2
myid zk-2
3
</code></pre><p>To get the Fully Qualified Domain Name (FQDN) of each Pod in the <code>zk</code> StatefulSet use the following command.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span>for</span> i in <span>0</span> <span>1</span> 2; <span>do</span> kubectl <span>exec</span> zk-<span>$i</span> -- hostname -f; <span>done</span>
</span></span></code></pre></div><p>The <code>zk-hs</code> Service creates a domain for all of the Pods,
<code>zk-hs.default.svc.cluster.local</code>.</p><pre tabindex="0"><code>zk-0.zk-hs.default.svc.cluster.local
zk-1.zk-hs.default.svc.cluster.local
zk-2.zk-hs.default.svc.cluster.local
</code></pre><p>The A records in <a href="/docs/concepts/services-networking/dns-pod-service/">Kubernetes DNS</a> resolve the FQDNs to the Pods' IP addresses. If Kubernetes reschedules the Pods, it will update the A records with the Pods' new IP addresses, but the A records names will not change.</p><p>ZooKeeper stores its application configuration in a file named <code>zoo.cfg</code>. Use <code>kubectl exec</code> to view the contents of the <code>zoo.cfg</code> file in the <code>zk-0</code> Pod.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl <span>exec</span> zk-0 -- cat /opt/zookeeper/conf/zoo.cfg
</span></span></code></pre></div><p>In the <code>server.1</code>, <code>server.2</code>, and <code>server.3</code> properties at the bottom of
the file, the <code>1</code>, <code>2</code>, and <code>3</code> correspond to the identifiers in the
ZooKeeper servers' <code>myid</code> files. They are set to the FQDNs for the Pods in
the <code>zk</code> StatefulSet.</p><pre tabindex="0"><code>clientPort=2181
dataDir=/var/lib/zookeeper/data
dataLogDir=/var/lib/zookeeper/log
tickTime=2000
initLimit=10
syncLimit=2000
maxClientCnxns=60
minSessionTimeout= 4000
maxSessionTimeout= 40000
autopurge.snapRetainCount=3
autopurge.purgeInterval=0
server.1=zk-0.zk-hs.default.svc.cluster.local:2888:3888
server.2=zk-1.zk-hs.default.svc.cluster.local:2888:3888
server.3=zk-2.zk-hs.default.svc.cluster.local:2888:3888
</code></pre><h3 id="achieving-consensus">Achieving consensus</h3><p>Consensus protocols require that the identifiers of each participant be unique. No two participants in the Zab protocol should claim the same unique identifier. This is necessary to allow the processes in the system to agree on which processes have committed which data. If two Pods are launched with the same ordinal, two ZooKeeper servers would both identify themselves as the same server.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pods -w -l <span>app</span><span>=</span>zk
</span></span></code></pre></div><pre tabindex="0"><code>NAME      READY     STATUS    RESTARTS   AGE
zk-0      0/1       Pending   0          0s
zk-0      0/1       Pending   0         0s
zk-0      0/1       ContainerCreating   0         0s
zk-0      0/1       Running   0         19s
zk-0      1/1       Running   0         40s
zk-1      0/1       Pending   0         0s
zk-1      0/1       Pending   0         0s
zk-1      0/1       ContainerCreating   0         0s
zk-1      0/1       Running   0         18s
zk-1      1/1       Running   0         40s
zk-2      0/1       Pending   0         0s
zk-2      0/1       Pending   0         0s
zk-2      0/1       ContainerCreating   0         0s
zk-2      0/1       Running   0         19s
zk-2      1/1       Running   0         40s
</code></pre><p>The A records for each Pod are entered when the Pod becomes Ready. Therefore,
the FQDNs of the ZooKeeper servers will resolve to a single endpoint, and that
endpoint will be the unique ZooKeeper server claiming the identity configured
in its <code>myid</code> file.</p><pre tabindex="0"><code>zk-0.zk-hs.default.svc.cluster.local
zk-1.zk-hs.default.svc.cluster.local
zk-2.zk-hs.default.svc.cluster.local
</code></pre><p>This ensures that the <code>servers</code> properties in the ZooKeepers' <code>zoo.cfg</code> files
represents a correctly configured ensemble.</p><pre tabindex="0"><code>server.1=zk-0.zk-hs.default.svc.cluster.local:2888:3888
server.2=zk-1.zk-hs.default.svc.cluster.local:2888:3888
server.3=zk-2.zk-hs.default.svc.cluster.local:2888:3888
</code></pre><p>When the servers use the Zab protocol to attempt to commit a value, they will either achieve consensus and commit the value (if leader election has succeeded and at least two of the Pods are Running and Ready), or they will fail to do so (if either of the conditions are not met). No state will arise where one server acknowledges a write on behalf of another.</p><h3 id="sanity-testing-the-ensemble">Sanity testing the ensemble</h3><p>The most basic sanity test is to write data to one ZooKeeper server and
to read the data from another.</p><p>The command below executes the <code>zkCli.sh</code> script to write <code>world</code> to the path <code>/hello</code> on the <code>zk-0</code> Pod in the ensemble.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl <span>exec</span> zk-0 -- zkCli.sh create /hello world
</span></span></code></pre></div><pre tabindex="0"><code>WATCHER::

WatchedEvent state:SyncConnected type:None path:null
Created /hello
</code></pre><p>To get the data from the <code>zk-1</code> Pod use the following command.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl <span>exec</span> zk-1 -- zkCli.sh get /hello
</span></span></code></pre></div><p>The data that you created on <code>zk-0</code> is available on all the servers in the
ensemble.</p><pre tabindex="0"><code>WATCHER::

WatchedEvent state:SyncConnected type:None path:null
world
cZxid = 0x100000002
ctime = Thu Dec 08 15:13:30 UTC 2016
mZxid = 0x100000002
mtime = Thu Dec 08 15:13:30 UTC 2016
pZxid = 0x100000002
cversion = 0
dataVersion = 0
aclVersion = 0
ephemeralOwner = 0x0
dataLength = 5
numChildren = 0
</code></pre><h3 id="providing-durable-storage">Providing durable storage</h3><p>As mentioned in the <a href="#zookeeper">ZooKeeper Basics</a> section,
ZooKeeper commits all entries to a durable WAL, and periodically writes snapshots
in memory state, to storage media. Using WALs to provide durability is a common
technique for applications that use consensus protocols to achieve a replicated
state machine.</p><p>Use the <a href="/docs/reference/generated/kubectl/kubectl-commands/#delete"><code>kubectl delete</code></a> command to delete the
<code>zk</code> StatefulSet.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl delete statefulset zk
</span></span></code></pre></div><pre tabindex="0"><code>statefulset.apps "zk" deleted
</code></pre><p>Watch the termination of the Pods in the StatefulSet.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pods -w -l <span>app</span><span>=</span>zk
</span></span></code></pre></div><p>When <code>zk-0</code> if fully terminated, use <code>CTRL-C</code> to terminate kubectl.</p><pre tabindex="0"><code>zk-2      1/1       Terminating   0         9m
zk-0      1/1       Terminating   0         11m
zk-1      1/1       Terminating   0         10m
zk-2      0/1       Terminating   0         9m
zk-2      0/1       Terminating   0         9m
zk-2      0/1       Terminating   0         9m
zk-1      0/1       Terminating   0         10m
zk-1      0/1       Terminating   0         10m
zk-1      0/1       Terminating   0         10m
zk-0      0/1       Terminating   0         11m
zk-0      0/1       Terminating   0         11m
zk-0      0/1       Terminating   0         11m
</code></pre><p>Reapply the manifest in <code>zookeeper.yaml</code>.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl apply -f https://k8s.io/examples/application/zookeeper/zookeeper.yaml
</span></span></code></pre></div><p>This creates the <code>zk</code> StatefulSet object, but the other API objects in the manifest are not modified because they already exist.</p><p>Watch the StatefulSet controller recreate the StatefulSet's Pods.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pods -w -l <span>app</span><span>=</span>zk
</span></span></code></pre></div><p>Once the <code>zk-2</code> Pod is Running and Ready, use <code>CTRL-C</code> to terminate kubectl.</p><pre tabindex="0"><code>NAME      READY     STATUS    RESTARTS   AGE
zk-0      0/1       Pending   0          0s
zk-0      0/1       Pending   0         0s
zk-0      0/1       ContainerCreating   0         0s
zk-0      0/1       Running   0         19s
zk-0      1/1       Running   0         40s
zk-1      0/1       Pending   0         0s
zk-1      0/1       Pending   0         0s
zk-1      0/1       ContainerCreating   0         0s
zk-1      0/1       Running   0         18s
zk-1      1/1       Running   0         40s
zk-2      0/1       Pending   0         0s
zk-2      0/1       Pending   0         0s
zk-2      0/1       ContainerCreating   0         0s
zk-2      0/1       Running   0         19s
zk-2      1/1       Running   0         40s
</code></pre><p>Use the command below to get the value you entered during the <a href="#sanity-testing-the-ensemble">sanity test</a>,
from the <code>zk-2</code> Pod.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl <span>exec</span> zk-2 zkCli.sh get /hello
</span></span></code></pre></div><p>Even though you terminated and recreated all of the Pods in the <code>zk</code> StatefulSet, the ensemble still serves the original value.</p><pre tabindex="0"><code>WATCHER::

WatchedEvent state:SyncConnected type:None path:null
world
cZxid = 0x100000002
ctime = Thu Dec 08 15:13:30 UTC 2016
mZxid = 0x100000002
mtime = Thu Dec 08 15:13:30 UTC 2016
pZxid = 0x100000002
cversion = 0
dataVersion = 0
aclVersion = 0
ephemeralOwner = 0x0
dataLength = 5
numChildren = 0
</code></pre><p>The <code>volumeClaimTemplates</code> field of the <code>zk</code> StatefulSet's <code>spec</code> specifies a PersistentVolume provisioned for each Pod.</p><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span>volumeClaimTemplates</span>:<span>
</span></span></span><span><span><span>  </span>- <span>metadata</span>:<span>
</span></span></span><span><span><span>      </span><span>name</span>:<span> </span>datadir<span>
</span></span></span><span><span><span>      </span><span>annotations</span>:<span>
</span></span></span><span><span><span>        </span><span>volume.alpha.kubernetes.io/storage-class</span>:<span> </span>anything<span>
</span></span></span><span><span><span>    </span><span>spec</span>:<span>
</span></span></span><span><span><span>      </span><span>accessModes</span>:<span> </span>[<span> </span><span>"ReadWriteOnce"</span><span> </span>]<span>
</span></span></span><span><span><span>      </span><span>resources</span>:<span>
</span></span></span><span><span><span>        </span><span>requests</span>:<span>
</span></span></span><span><span><span>          </span><span>storage</span>:<span> </span>20Gi<span>
</span></span></span></code></pre></div><p>The <code>StatefulSet</code> controller generates a <code>PersistentVolumeClaim</code> for each Pod in
the <code>StatefulSet</code>.</p><p>Use the following command to get the <code>StatefulSet</code>'s <code>PersistentVolumeClaims</code>.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pvc -l <span>app</span><span>=</span>zk
</span></span></code></pre></div><p>When the <code>StatefulSet</code> recreated its Pods, it remounts the Pods' PersistentVolumes.</p><pre tabindex="0"><code>NAME           STATUS    VOLUME                                     CAPACITY   ACCESSMODES   AGE
datadir-zk-0   Bound     pvc-bed742cd-bcb1-11e6-994f-42010a800002   20Gi       RWO           1h
datadir-zk-1   Bound     pvc-bedd27d2-bcb1-11e6-994f-42010a800002   20Gi       RWO           1h
datadir-zk-2   Bound     pvc-bee0817e-bcb1-11e6-994f-42010a800002   20Gi       RWO           1h
</code></pre><p>The <code>volumeMounts</code> section of the <code>StatefulSet</code>'s container <code>template</code> mounts the PersistentVolumes in the ZooKeeper servers' data directories.</p><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span>volumeMounts</span>:<span>
</span></span></span><span><span><span></span>- <span>name</span>:<span> </span>datadir<span>
</span></span></span><span><span><span>  </span><span>mountPath</span>:<span> </span>/var/lib/zookeeper<span>
</span></span></span></code></pre></div><p>When a Pod in the <code>zk</code> <code>StatefulSet</code> is (re)scheduled, it will always have the
same <code>PersistentVolume</code> mounted to the ZooKeeper server's data directory.
Even when the Pods are rescheduled, all the writes made to the ZooKeeper
servers' WALs, and all their snapshots, remain durable.</p><h2 id="ensuring-consistent-configuration">Ensuring consistent configuration</h2><p>As noted in the <a href="#facilitating-leader-election">Facilitating Leader Election</a> and
<a href="#achieving-consensus">Achieving Consensus</a> sections, the servers in a
ZooKeeper ensemble require consistent configuration to elect a leader
and form a quorum. They also require consistent configuration of the Zab protocol
in order for the protocol to work correctly over a network. In our example we
achieve consistent configuration by embedding the configuration directly into
the manifest.</p><p>Get the <code>zk</code> StatefulSet.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get sts zk -o yaml
</span></span></code></pre></div><pre tabindex="0"><code>&#8230;
command:
      - sh
      - -c
      - "start-zookeeper \
        --servers=3 \
        --data_dir=/var/lib/zookeeper/data \
        --data_log_dir=/var/lib/zookeeper/data/log \
        --conf_dir=/opt/zookeeper/conf \
        --client_port=2181 \
        --election_port=3888 \
        --server_port=2888 \
        --tick_time=2000 \
        --init_limit=10 \
        --sync_limit=5 \
        --heap=512M \
        --max_client_cnxns=60 \
        --snap_retain_count=3 \
        --purge_interval=12 \
        --max_session_timeout=40000 \
        --min_session_timeout=4000 \
        --log_level=INFO"
&#8230;
</code></pre><p>The command used to start the ZooKeeper servers passed the configuration as command line parameter. You can also use environment variables to pass configuration to the ensemble.</p><h3 id="configuring-logging">Configuring logging</h3><p>One of the files generated by the <code>zkGenConfig.sh</code> script controls ZooKeeper's logging.
ZooKeeper uses <a href="https://logging.apache.org/log4j/2.x/">Log4j</a>, and, by default,
it uses a time and size based rolling file appender for its logging configuration.</p><p>Use the command below to get the logging configuration from one of Pods in the <code>zk</code> <code>StatefulSet</code>.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl <span>exec</span> zk-0 cat /usr/etc/zookeeper/log4j.properties
</span></span></code></pre></div><p>The logging configuration below will cause the ZooKeeper process to write all
of its logs to the standard output file stream.</p><pre tabindex="0"><code>zookeeper.root.logger=CONSOLE
zookeeper.console.threshold=INFO
log4j.rootLogger=${zookeeper.root.logger}
log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender
log4j.appender.CONSOLE.Threshold=${zookeeper.console.threshold}
log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout
log4j.appender.CONSOLE.layout.ConversionPattern=%d{ISO8601} [myid:%X{myid}] - %-5p [%t:%C{1}@%L] - %m%n
</code></pre><p>This is the simplest possible way to safely log inside the container.
Because the applications write logs to standard out, Kubernetes will handle log rotation for you.
Kubernetes also implements a sane retention policy that ensures application logs written to
standard out and standard error do not exhaust local storage media.</p><p>Use <a href="/docs/reference/generated/kubectl/kubectl-commands/#logs"><code>kubectl logs</code></a> to retrieve the last 20 log lines from one of the Pods.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl logs zk-0 --tail <span>20</span>
</span></span></code></pre></div><p>You can view application logs written to standard out or standard error using <code>kubectl logs</code> and from the Kubernetes Dashboard.</p><pre tabindex="0"><code>2016-12-06 19:34:16,236 [myid:1] - INFO  [NIOServerCxn.Factory:0.0.0.0/0.0.0.0:2181:NIOServerCnxn@827] - Processing ruok command from /127.0.0.1:52740
2016-12-06 19:34:16,237 [myid:1] - INFO  [Thread-1136:NIOServerCnxn@1008] - Closed socket connection for client /127.0.0.1:52740 (no session established for client)
2016-12-06 19:34:26,155 [myid:1] - INFO  [NIOServerCxn.Factory:0.0.0.0/0.0.0.0:2181:NIOServerCnxnFactory@192] - Accepted socket connection from /127.0.0.1:52749
2016-12-06 19:34:26,155 [myid:1] - INFO  [NIOServerCxn.Factory:0.0.0.0/0.0.0.0:2181:NIOServerCnxn@827] - Processing ruok command from /127.0.0.1:52749
2016-12-06 19:34:26,156 [myid:1] - INFO  [Thread-1137:NIOServerCnxn@1008] - Closed socket connection for client /127.0.0.1:52749 (no session established for client)
2016-12-06 19:34:26,222 [myid:1] - INFO  [NIOServerCxn.Factory:0.0.0.0/0.0.0.0:2181:NIOServerCnxnFactory@192] - Accepted socket connection from /127.0.0.1:52750
2016-12-06 19:34:26,222 [myid:1] - INFO  [NIOServerCxn.Factory:0.0.0.0/0.0.0.0:2181:NIOServerCnxn@827] - Processing ruok command from /127.0.0.1:52750
2016-12-06 19:34:26,226 [myid:1] - INFO  [Thread-1138:NIOServerCnxn@1008] - Closed socket connection for client /127.0.0.1:52750 (no session established for client)
2016-12-06 19:34:36,151 [myid:1] - INFO  [NIOServerCxn.Factory:0.0.0.0/0.0.0.0:2181:NIOServerCnxnFactory@192] - Accepted socket connection from /127.0.0.1:52760
2016-12-06 19:34:36,152 [myid:1] - INFO  [NIOServerCxn.Factory:0.0.0.0/0.0.0.0:2181:NIOServerCnxn@827] - Processing ruok command from /127.0.0.1:52760
2016-12-06 19:34:36,152 [myid:1] - INFO  [Thread-1139:NIOServerCnxn@1008] - Closed socket connection for client /127.0.0.1:52760 (no session established for client)
2016-12-06 19:34:36,230 [myid:1] - INFO  [NIOServerCxn.Factory:0.0.0.0/0.0.0.0:2181:NIOServerCnxnFactory@192] - Accepted socket connection from /127.0.0.1:52761
2016-12-06 19:34:36,231 [myid:1] - INFO  [NIOServerCxn.Factory:0.0.0.0/0.0.0.0:2181:NIOServerCnxn@827] - Processing ruok command from /127.0.0.1:52761
2016-12-06 19:34:36,231 [myid:1] - INFO  [Thread-1140:NIOServerCnxn@1008] - Closed socket connection for client /127.0.0.1:52761 (no session established for client)
2016-12-06 19:34:46,149 [myid:1] - INFO  [NIOServerCxn.Factory:0.0.0.0/0.0.0.0:2181:NIOServerCnxnFactory@192] - Accepted socket connection from /127.0.0.1:52767
2016-12-06 19:34:46,149 [myid:1] - INFO  [NIOServerCxn.Factory:0.0.0.0/0.0.0.0:2181:NIOServerCnxn@827] - Processing ruok command from /127.0.0.1:52767
2016-12-06 19:34:46,149 [myid:1] - INFO  [Thread-1141:NIOServerCnxn@1008] - Closed socket connection for client /127.0.0.1:52767 (no session established for client)
2016-12-06 19:34:46,230 [myid:1] - INFO  [NIOServerCxn.Factory:0.0.0.0/0.0.0.0:2181:NIOServerCnxnFactory@192] - Accepted socket connection from /127.0.0.1:52768
2016-12-06 19:34:46,230 [myid:1] - INFO  [NIOServerCxn.Factory:0.0.0.0/0.0.0.0:2181:NIOServerCnxn@827] - Processing ruok command from /127.0.0.1:52768
2016-12-06 19:34:46,230 [myid:1] - INFO  [Thread-1142:NIOServerCnxn@1008] - Closed socket connection for client /127.0.0.1:52768 (no session established for client)
</code></pre><p>Kubernetes integrates with many logging solutions. You can choose a logging solution
that best fits your cluster and applications. For cluster-level logging and aggregation,
consider deploying a <a href="/docs/concepts/cluster-administration/logging/#sidecar-container-with-logging-agent">sidecar container</a> to rotate and ship your logs.</p><h3 id="configuring-a-non-privileged-user">Configuring a non-privileged user</h3><p>The best practices to allow an application to run as a privileged
user inside of a container are a matter of debate. If your organization requires
that applications run as a non-privileged user you can use a
<a href="/docs/tasks/configure-pod-container/security-context/">SecurityContext</a> to control the user that
the entry point runs as.</p><p>The <code>zk</code> <code>StatefulSet</code>'s Pod <code>template</code> contains a <code>SecurityContext</code>.</p><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span>securityContext</span>:<span>
</span></span></span><span><span><span>  </span><span>runAsUser</span>:<span> </span><span>1000</span><span>
</span></span></span><span><span><span>  </span><span>fsGroup</span>:<span> </span><span>1000</span><span>
</span></span></span></code></pre></div><p>In the Pods' containers, UID 1000 corresponds to the zookeeper user and GID 1000
corresponds to the zookeeper group.</p><p>Get the ZooKeeper process information from the <code>zk-0</code> Pod.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl <span>exec</span> zk-0 -- ps -elf
</span></span></code></pre></div><p>As the <code>runAsUser</code> field of the <code>securityContext</code> object is set to 1000,
instead of running as root, the ZooKeeper process runs as the zookeeper user.</p><pre tabindex="0"><code>F S UID        PID  PPID  C PRI  NI ADDR SZ WCHAN  STIME TTY          TIME CMD
4 S zookeep+     1     0  0  80   0 -  1127 -      20:46 ?        00:00:00 sh -c zkGenConfig.sh &amp;&amp; zkServer.sh start-foreground
0 S zookeep+    27     1  0  80   0 - 1155556 -    20:46 ?        00:00:19 /usr/lib/jvm/java-8-openjdk-amd64/bin/java -Dzookeeper.log.dir=/var/log/zookeeper -Dzookeeper.root.logger=INFO,CONSOLE -cp /usr/bin/../build/classes:/usr/bin/../build/lib/*.jar:/usr/bin/../share/zookeeper/zookeeper-3.4.9.jar:/usr/bin/../share/zookeeper/slf4j-log4j12-1.6.1.jar:/usr/bin/../share/zookeeper/slf4j-api-1.6.1.jar:/usr/bin/../share/zookeeper/netty-3.10.5.Final.jar:/usr/bin/../share/zookeeper/log4j-1.2.16.jar:/usr/bin/../share/zookeeper/jline-0.9.94.jar:/usr/bin/../src/java/lib/*.jar:/usr/bin/../etc/zookeeper: -Xmx2G -Xms2G -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.local.only=false org.apache.zookeeper.server.quorum.QuorumPeerMain /usr/bin/../etc/zookeeper/zoo.cfg
</code></pre><p>By default, when the Pod's PersistentVolumes is mounted to the ZooKeeper server's data directory, it is only accessible by the root user. This configuration prevents the ZooKeeper process from writing to its WAL and storing its snapshots.</p><p>Use the command below to get the file permissions of the ZooKeeper data directory on the <code>zk-0</code> Pod.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl <span>exec</span> -ti zk-0 -- ls -ld /var/lib/zookeeper/data
</span></span></code></pre></div><p>Because the <code>fsGroup</code> field of the <code>securityContext</code> object is set to 1000, the ownership of the Pods' PersistentVolumes is set to the zookeeper group, and the ZooKeeper process is able to read and write its data.</p><pre tabindex="0"><code>drwxr-sr-x 3 zookeeper zookeeper 4096 Dec  5 20:45 /var/lib/zookeeper/data
</code></pre><h2 id="managing-the-zookeeper-process">Managing the ZooKeeper process</h2><p>The <a href="https://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_supervision">ZooKeeper documentation</a>
mentions that "You will want to have a supervisory process that
manages each of your ZooKeeper server processes (JVM)." Utilizing a watchdog
(supervisory process) to restart failed processes in a distributed system is a
common pattern. When deploying an application in Kubernetes, rather than using
an external utility as a supervisory process, you should use Kubernetes as the
watchdog for your application.</p><h3 id="updating-the-ensemble">Updating the ensemble</h3><p>The <code>zk</code> <code>StatefulSet</code> is configured to use the <code>RollingUpdate</code> update strategy.</p><p>You can use <code>kubectl patch</code> to update the number of <code>cpus</code> allocated to the servers.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl patch sts zk --type<span>=</span><span>'json'</span> -p<span>=</span><span>'[{"op": "replace", "path": "/spec/template/spec/containers/0/resources/requests/cpu", "value":"0.3"}]'</span>
</span></span></code></pre></div><pre tabindex="0"><code>statefulset.apps/zk patched
</code></pre><p>Use <code>kubectl rollout status</code> to watch the status of the update.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl rollout status sts/zk
</span></span></code></pre></div><pre tabindex="0"><code>waiting for statefulset rolling update to complete 0 pods at revision zk-5db4499664...
Waiting for 1 pods to be ready...
Waiting for 1 pods to be ready...
waiting for statefulset rolling update to complete 1 pods at revision zk-5db4499664...
Waiting for 1 pods to be ready...
Waiting for 1 pods to be ready...
waiting for statefulset rolling update to complete 2 pods at revision zk-5db4499664...
Waiting for 1 pods to be ready...
Waiting for 1 pods to be ready...
statefulset rolling update complete 3 pods at revision zk-5db4499664...
</code></pre><p>This terminates the Pods, one at a time, in reverse ordinal order, and recreates them with the new configuration. This ensures that quorum is maintained during a rolling update.</p><p>Use the <code>kubectl rollout history</code> command to view a history or previous configurations.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl rollout <span>history</span> sts/zk
</span></span></code></pre></div><p>The output is similar to this:</p><pre tabindex="0"><code>statefulsets "zk"
REVISION
1
2
</code></pre><p>Use the <code>kubectl rollout undo</code> command to roll back the modification.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl rollout undo sts/zk
</span></span></code></pre></div><p>The output is similar to this:</p><pre tabindex="0"><code>statefulset.apps/zk rolled back
</code></pre><h3 id="handling-process-failure">Handling process failure</h3><p><a href="/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy">Restart Policies</a> control how
Kubernetes handles process failures for the entry point of the container in a Pod.
For Pods in a <code>StatefulSet</code>, the only appropriate <code>RestartPolicy</code> is Always, and this
is the default value. For stateful applications you should <strong>never</strong> override
the default policy.</p><p>Use the following command to examine the process tree for the ZooKeeper server running in the <code>zk-0</code> Pod.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl <span>exec</span> zk-0 -- ps -ef
</span></span></code></pre></div><p>The command used as the container's entry point has PID 1, and
the ZooKeeper process, a child of the entry point, has PID 27.</p><pre tabindex="0"><code>UID        PID  PPID  C STIME TTY          TIME CMD
zookeep+     1     0  0 15:03 ?        00:00:00 sh -c zkGenConfig.sh &amp;&amp; zkServer.sh start-foreground
zookeep+    27     1  0 15:03 ?        00:00:03 /usr/lib/jvm/java-8-openjdk-amd64/bin/java -Dzookeeper.log.dir=/var/log/zookeeper -Dzookeeper.root.logger=INFO,CONSOLE -cp /usr/bin/../build/classes:/usr/bin/../build/lib/*.jar:/usr/bin/../share/zookeeper/zookeeper-3.4.9.jar:/usr/bin/../share/zookeeper/slf4j-log4j12-1.6.1.jar:/usr/bin/../share/zookeeper/slf4j-api-1.6.1.jar:/usr/bin/../share/zookeeper/netty-3.10.5.Final.jar:/usr/bin/../share/zookeeper/log4j-1.2.16.jar:/usr/bin/../share/zookeeper/jline-0.9.94.jar:/usr/bin/../src/java/lib/*.jar:/usr/bin/../etc/zookeeper: -Xmx2G -Xms2G -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.local.only=false org.apache.zookeeper.server.quorum.QuorumPeerMain /usr/bin/../etc/zookeeper/zoo.cfg
</code></pre><p>In another terminal watch the Pods in the <code>zk</code> <code>StatefulSet</code> with the following command.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pod -w -l <span>app</span><span>=</span>zk
</span></span></code></pre></div><p>In another terminal, terminate the ZooKeeper process in Pod <code>zk-0</code> with the following command.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl <span>exec</span> zk-0 -- pkill java
</span></span></code></pre></div><p>The termination of the ZooKeeper process caused its parent process to terminate. Because the <code>RestartPolicy</code> of the container is Always, it restarted the parent process.</p><pre tabindex="0"><code>NAME      READY     STATUS    RESTARTS   AGE
zk-0      1/1       Running   0          21m
zk-1      1/1       Running   0          20m
zk-2      1/1       Running   0          19m
NAME      READY     STATUS    RESTARTS   AGE
zk-0      0/1       Error     0          29m
zk-0      0/1       Running   1         29m
zk-0      1/1       Running   1         29m
</code></pre><p>If your application uses a script (such as <code>zkServer.sh</code>) to launch the process
that implements the application's business logic, the script must terminate with the
child process. This ensures that Kubernetes will restart the application's
container when the process implementing the application's business logic fails.</p><h3 id="testing-for-liveness">Testing for liveness</h3><p>Configuring your application to restart failed processes is not enough to
keep a distributed system healthy. There are scenarios where
a system's processes can be both alive and unresponsive, or otherwise
unhealthy. You should use liveness probes to notify Kubernetes
that your application's processes are unhealthy and it should restart them.</p><p>The Pod <code>template</code> for the <code>zk</code> <code>StatefulSet</code> specifies a liveness probe.</p><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span>  </span><span>livenessProbe</span>:<span>
</span></span></span><span><span><span>    </span><span>exec</span>:<span>
</span></span></span><span><span><span>      </span><span>command</span>:<span>
</span></span></span><span><span><span>      </span>- sh<span>
</span></span></span><span><span><span>      </span>- -c<span>
</span></span></span><span><span><span>      </span>- <span>"zookeeper-ready 2181"</span><span>
</span></span></span><span><span><span>    </span><span>initialDelaySeconds</span>:<span> </span><span>15</span><span>
</span></span></span><span><span><span>    </span><span>timeoutSeconds</span>:<span> </span><span>5</span><span>
</span></span></span></code></pre></div><p>The probe calls a bash script that uses the ZooKeeper <code>ruok</code> four letter
word to test the server's health.</p><pre tabindex="0"><code>OK=$(echo ruok | nc 127.0.0.1 $1)
if [ "$OK" == "imok" ]; then
    exit 0
else
    exit 1
fi
</code></pre><p>In one terminal window, use the following command to watch the Pods in the <code>zk</code> StatefulSet.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pod -w -l <span>app</span><span>=</span>zk
</span></span></code></pre></div><p>In another window, using the following command to delete the <code>zookeeper-ready</code> script from the file system of Pod <code>zk-0</code>.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl <span>exec</span> zk-0 -- rm /opt/zookeeper/bin/zookeeper-ready
</span></span></code></pre></div><p>When the liveness probe for the ZooKeeper process fails, Kubernetes will
automatically restart the process for you, ensuring that unhealthy processes in
the ensemble are restarted.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pod -w -l <span>app</span><span>=</span>zk
</span></span></code></pre></div><pre tabindex="0"><code>NAME      READY     STATUS    RESTARTS   AGE
zk-0      1/1       Running   0          1h
zk-1      1/1       Running   0          1h
zk-2      1/1       Running   0          1h
NAME      READY     STATUS    RESTARTS   AGE
zk-0      0/1       Running   0          1h
zk-0      0/1       Running   1         1h
zk-0      1/1       Running   1         1h
</code></pre><h3 id="testing-for-readiness">Testing for readiness</h3><p>Readiness is not the same as liveness. If a process is alive, it is scheduled
and healthy. If a process is ready, it is able to process input. Liveness is
a necessary, but not sufficient, condition for readiness. There are cases,
particularly during initialization and termination, when a process can be
alive but not ready.</p><p>If you specify a readiness probe, Kubernetes will ensure that your application's
processes will not receive network traffic until their readiness checks pass.</p><p>For a ZooKeeper server, liveness implies readiness. Therefore, the readiness
probe from the <code>zookeeper.yaml</code> manifest is identical to the liveness probe.</p><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span>  </span><span>readinessProbe</span>:<span>
</span></span></span><span><span><span>    </span><span>exec</span>:<span>
</span></span></span><span><span><span>      </span><span>command</span>:<span>
</span></span></span><span><span><span>      </span>- sh<span>
</span></span></span><span><span><span>      </span>- -c<span>
</span></span></span><span><span><span>      </span>- <span>"zookeeper-ready 2181"</span><span>
</span></span></span><span><span><span>    </span><span>initialDelaySeconds</span>:<span> </span><span>15</span><span>
</span></span></span><span><span><span>    </span><span>timeoutSeconds</span>:<span> </span><span>5</span><span>
</span></span></span></code></pre></div><p>Even though the liveness and readiness probes are identical, it is important
to specify both. This ensures that only healthy servers in the ZooKeeper
ensemble receive network traffic.</p><h2 id="tolerating-node-failure">Tolerating Node failure</h2><p>ZooKeeper needs a quorum of servers to successfully commit mutations
to data. For a three server ensemble, two servers must be healthy for
writes to succeed. In quorum based systems, members are deployed across failure
domains to ensure availability. To avoid an outage, due to the loss of an
individual machine, best practices preclude co-locating multiple instances of the
application on the same machine.</p><p>By default, Kubernetes may co-locate Pods in a <code>StatefulSet</code> on the same node.
For the three server ensemble you created, if two servers are on the same node, and that node fails,
the clients of your ZooKeeper service will experience an outage until at least one of the Pods can be rescheduled.</p><p>You should always provision additional capacity to allow the processes of critical
systems to be rescheduled in the event of node failures. If you do so, then the
outage will only last until the Kubernetes scheduler reschedules one of the ZooKeeper
servers. However, if you want your service to tolerate node failures with no downtime,
you should set <code>podAntiAffinity</code>.</p><p>Use the command below to get the nodes for Pods in the <code>zk</code> <code>StatefulSet</code>.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span>for</span> i in <span>0</span> <span>1</span> 2; <span>do</span> kubectl get pod zk-<span>$i</span> --template <span>{{</span>.spec.nodeName<span>}}</span>; <span>echo</span> <span>""</span>; <span>done</span>
</span></span></code></pre></div><p>All of the Pods in the <code>zk</code> <code>StatefulSet</code> are deployed on different nodes.</p><pre tabindex="0"><code>kubernetes-node-cxpk
kubernetes-node-a5aq
kubernetes-node-2g2d
</code></pre><p>This is because the Pods in the <code>zk</code> <code>StatefulSet</code> have a <code>PodAntiAffinity</code> specified.</p><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span>affinity</span>:<span>
</span></span></span><span><span><span>  </span><span>podAntiAffinity</span>:<span>
</span></span></span><span><span><span>    </span><span>requiredDuringSchedulingIgnoredDuringExecution</span>:<span>
</span></span></span><span><span><span>      </span>- <span>labelSelector</span>:<span>
</span></span></span><span><span><span>          </span><span>matchExpressions</span>:<span>
</span></span></span><span><span><span>            </span>- <span>key</span>:<span> </span><span>"app"</span><span>
</span></span></span><span><span><span>              </span><span>operator</span>:<span> </span>In<span>
</span></span></span><span><span><span>              </span><span>values</span>:<span>
</span></span></span><span><span><span>                </span>- zk<span>
</span></span></span><span><span><span>        </span><span>topologyKey</span>:<span> </span><span>"kubernetes.io/hostname"</span><span>
</span></span></span></code></pre></div><p>The <code>requiredDuringSchedulingIgnoredDuringExecution</code> field tells the
Kubernetes Scheduler that it should never co-locate two Pods which have <code>app</code> label
as <code>zk</code> in the domain defined by the <code>topologyKey</code>. The <code>topologyKey</code>
<code>kubernetes.io/hostname</code> indicates that the domain is an individual node. Using
different rules, labels, and selectors, you can extend this technique to spread
your ensemble across physical, network, and power failure domains.</p><h2 id="surviving-maintenance">Surviving maintenance</h2><p>In this section you will cordon and drain nodes. If you are using this tutorial
on a shared cluster, be sure that this will not adversely affect other tenants.</p><p>The previous section showed you how to spread your Pods across nodes to survive
unplanned node failures, but you also need to plan for temporary node failures
that occur due to planned maintenance.</p><p>Use this command to get the nodes in your cluster.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get nodes
</span></span></code></pre></div><p>This tutorial assumes a cluster with at least four nodes. If the cluster has more than four, use <a href="/docs/reference/generated/kubectl/kubectl-commands/#cordon"><code>kubectl cordon</code></a> to cordon all but four nodes. Constraining to four nodes will ensure Kubernetes encounters affinity and PodDisruptionBudget constraints when scheduling zookeeper Pods in the following maintenance simulation.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl cordon &lt;node-name&gt;
</span></span></code></pre></div><p>Use this command to get the <code>zk-pdb</code> <code>PodDisruptionBudget</code>.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pdb zk-pdb
</span></span></code></pre></div><p>The <code>max-unavailable</code> field indicates to Kubernetes that at most one Pod from
<code>zk</code> <code>StatefulSet</code> can be unavailable at any time.</p><pre tabindex="0"><code>NAME      MIN-AVAILABLE   MAX-UNAVAILABLE   ALLOWED-DISRUPTIONS   AGE
zk-pdb    N/A             1                 1
</code></pre><p>In one terminal, use this command to watch the Pods in the <code>zk</code> <code>StatefulSet</code>.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pods -w -l <span>app</span><span>=</span>zk
</span></span></code></pre></div><p>In another terminal, use this command to get the nodes that the Pods are currently scheduled on.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span>for</span> i in <span>0</span> <span>1</span> 2; <span>do</span> kubectl get pod zk-<span>$i</span> --template <span>{{</span>.spec.nodeName<span>}}</span>; <span>echo</span> <span>""</span>; <span>done</span>
</span></span></code></pre></div><p>The output is similar to this:</p><pre tabindex="0"><code>kubernetes-node-pb41
kubernetes-node-ixsl
kubernetes-node-i4c4
</code></pre><p>Use <a href="/docs/reference/generated/kubectl/kubectl-commands/#drain"><code>kubectl drain</code></a> to cordon and
drain the node on which the <code>zk-0</code> Pod is scheduled.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl drain <span>$(</span>kubectl get pod zk-0 --template <span>{{</span>.spec.nodeName<span>}}</span><span>)</span> --ignore-daemonsets --force --delete-emptydir-data
</span></span></code></pre></div><p>The output is similar to this:</p><pre tabindex="0"><code>node "kubernetes-node-pb41" cordoned

WARNING: Deleting pods not managed by ReplicationController, ReplicaSet, Job, or DaemonSet: fluentd-cloud-logging-kubernetes-node-pb41, kube-proxy-kubernetes-node-pb41; Ignoring DaemonSet-managed pods: node-problem-detector-v0.1-o5elz
pod "zk-0" deleted
node "kubernetes-node-pb41" drained
</code></pre><p>As there are four nodes in your cluster, <code>kubectl drain</code>, succeeds and the
<code>zk-0</code> is rescheduled to another node.</p><pre tabindex="0"><code>NAME      READY     STATUS    RESTARTS   AGE
zk-0      1/1       Running   2          1h
zk-1      1/1       Running   0          1h
zk-2      1/1       Running   0          1h
NAME      READY     STATUS        RESTARTS   AGE
zk-0      1/1       Terminating   2          2h
zk-0      0/1       Terminating   2         2h
zk-0      0/1       Terminating   2         2h
zk-0      0/1       Terminating   2         2h
zk-0      0/1       Pending   0         0s
zk-0      0/1       Pending   0         0s
zk-0      0/1       ContainerCreating   0         0s
zk-0      0/1       Running   0         51s
zk-0      1/1       Running   0         1m
</code></pre><p>Keep watching the <code>StatefulSet</code>'s Pods in the first terminal and drain the node on which
<code>zk-1</code> is scheduled.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl drain <span>$(</span>kubectl get pod zk-1 --template <span>{{</span>.spec.nodeName<span>}}</span><span>)</span> --ignore-daemonsets --force --delete-emptydir-data
</span></span></code></pre></div><p>The output is similar to this:</p><pre tabindex="0"><code>"kubernetes-node-ixsl" cordoned
WARNING: Deleting pods not managed by ReplicationController, ReplicaSet, Job, or DaemonSet: fluentd-cloud-logging-kubernetes-node-ixsl, kube-proxy-kubernetes-node-ixsl; Ignoring DaemonSet-managed pods: node-problem-detector-v0.1-voc74
pod "zk-1" deleted
node "kubernetes-node-ixsl" drained
</code></pre><p>The <code>zk-1</code> Pod cannot be scheduled because the <code>zk</code> <code>StatefulSet</code> contains a <code>PodAntiAffinity</code> rule preventing
co-location of the Pods, and as only two nodes are schedulable, the Pod will remain in a Pending state.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pods -w -l <span>app</span><span>=</span>zk
</span></span></code></pre></div><p>The output is similar to this:</p><pre tabindex="0"><code>NAME      READY     STATUS    RESTARTS   AGE
zk-0      1/1       Running   2          1h
zk-1      1/1       Running   0          1h
zk-2      1/1       Running   0          1h
NAME      READY     STATUS        RESTARTS   AGE
zk-0      1/1       Terminating   2          2h
zk-0      0/1       Terminating   2         2h
zk-0      0/1       Terminating   2         2h
zk-0      0/1       Terminating   2         2h
zk-0      0/1       Pending   0         0s
zk-0      0/1       Pending   0         0s
zk-0      0/1       ContainerCreating   0         0s
zk-0      0/1       Running   0         51s
zk-0      1/1       Running   0         1m
zk-1      1/1       Terminating   0         2h
zk-1      0/1       Terminating   0         2h
zk-1      0/1       Terminating   0         2h
zk-1      0/1       Terminating   0         2h
zk-1      0/1       Pending   0         0s
zk-1      0/1       Pending   0         0s
</code></pre><p>Continue to watch the Pods of the StatefulSet, and drain the node on which
<code>zk-2</code> is scheduled.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl drain <span>$(</span>kubectl get pod zk-2 --template <span>{{</span>.spec.nodeName<span>}}</span><span>)</span> --ignore-daemonsets --force --delete-emptydir-data
</span></span></code></pre></div><p>The output is similar to this:</p><pre tabindex="0"><code>node "kubernetes-node-i4c4" cordoned

WARNING: Deleting pods not managed by ReplicationController, ReplicaSet, Job, or DaemonSet: fluentd-cloud-logging-kubernetes-node-i4c4, kube-proxy-kubernetes-node-i4c4; Ignoring DaemonSet-managed pods: node-problem-detector-v0.1-dyrog
WARNING: Ignoring DaemonSet-managed pods: node-problem-detector-v0.1-dyrog; Deleting pods not managed by ReplicationController, ReplicaSet, Job, or DaemonSet: fluentd-cloud-logging-kubernetes-node-i4c4, kube-proxy-kubernetes-node-i4c4
There are pending pods when an error occurred: Cannot evict pod as it would violate the pod's disruption budget.
pod/zk-2
</code></pre><p>Use <code>CTRL-C</code> to terminate kubectl.</p><p>You cannot drain the third node because evicting <code>zk-2</code> would violate <code>zk-budget</code>. However, the node will remain cordoned.</p><p>Use <code>zkCli.sh</code> to retrieve the value you entered during the sanity test from <code>zk-0</code>.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl <span>exec</span> zk-0 zkCli.sh get /hello
</span></span></code></pre></div><p>The service is still available because its <code>PodDisruptionBudget</code> is respected.</p><pre tabindex="0"><code>WatchedEvent state:SyncConnected type:None path:null
world
cZxid = 0x200000002
ctime = Wed Dec 07 00:08:59 UTC 2016
mZxid = 0x200000002
mtime = Wed Dec 07 00:08:59 UTC 2016
pZxid = 0x200000002
cversion = 0
dataVersion = 0
aclVersion = 0
ephemeralOwner = 0x0
dataLength = 5
numChildren = 0
</code></pre><p>Use <a href="/docs/reference/generated/kubectl/kubectl-commands/#uncordon"><code>kubectl uncordon</code></a> to uncordon the first node.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl uncordon kubernetes-node-pb41
</span></span></code></pre></div><p>The output is similar to this:</p><pre tabindex="0"><code>node "kubernetes-node-pb41" uncordoned
</code></pre><p><code>zk-1</code> is rescheduled on this node. Wait until <code>zk-1</code> is Running and Ready.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pods -w -l <span>app</span><span>=</span>zk
</span></span></code></pre></div><p>The output is similar to this:</p><pre tabindex="0"><code>NAME      READY     STATUS    RESTARTS   AGE
zk-0      1/1       Running   2          1h
zk-1      1/1       Running   0          1h
zk-2      1/1       Running   0          1h
NAME      READY     STATUS        RESTARTS   AGE
zk-0      1/1       Terminating   2          2h
zk-0      0/1       Terminating   2         2h
zk-0      0/1       Terminating   2         2h
zk-0      0/1       Terminating   2         2h
zk-0      0/1       Pending   0         0s
zk-0      0/1       Pending   0         0s
zk-0      0/1       ContainerCreating   0         0s
zk-0      0/1       Running   0         51s
zk-0      1/1       Running   0         1m
zk-1      1/1       Terminating   0         2h
zk-1      0/1       Terminating   0         2h
zk-1      0/1       Terminating   0         2h
zk-1      0/1       Terminating   0         2h
zk-1      0/1       Pending   0         0s
zk-1      0/1       Pending   0         0s
zk-1      0/1       Pending   0         12m
zk-1      0/1       ContainerCreating   0         12m
zk-1      0/1       Running   0         13m
zk-1      1/1       Running   0         13m
</code></pre><p>Attempt to drain the node on which <code>zk-2</code> is scheduled.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl drain <span>$(</span>kubectl get pod zk-2 --template <span>{{</span>.spec.nodeName<span>}}</span><span>)</span> --ignore-daemonsets --force --delete-emptydir-data
</span></span></code></pre></div><p>The output is similar to this:</p><pre tabindex="0"><code>node "kubernetes-node-i4c4" already cordoned
WARNING: Deleting pods not managed by ReplicationController, ReplicaSet, Job, or DaemonSet: fluentd-cloud-logging-kubernetes-node-i4c4, kube-proxy-kubernetes-node-i4c4; Ignoring DaemonSet-managed pods: node-problem-detector-v0.1-dyrog
pod "heapster-v1.2.0-2604621511-wht1r" deleted
pod "zk-2" deleted
node "kubernetes-node-i4c4" drained
</code></pre><p>This time <code>kubectl drain</code> succeeds.</p><p>Uncordon the second node to allow <code>zk-2</code> to be rescheduled.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl uncordon kubernetes-node-ixsl
</span></span></code></pre></div><p>The output is similar to this:</p><pre tabindex="0"><code>node "kubernetes-node-ixsl" uncordoned
</code></pre><p>You can use <code>kubectl drain</code> in conjunction with <code>PodDisruptionBudgets</code> to ensure that your services remain available during maintenance.
If drain is used to cordon nodes and evict pods prior to taking the node offline for maintenance,
services that express a disruption budget will have that budget respected.
You should always allocate additional capacity for critical services so that their Pods can be immediately rescheduled.</p><h2 id="cleaning-up">Cleaning up</h2><ul><li>Use <code>kubectl uncordon</code> to uncordon all the nodes in your cluster.</li><li>You must delete the persistent storage media for the PersistentVolumes used in this tutorial.
Follow the necessary steps, based on your environment, storage configuration,
and provisioning method, to ensure that all storage is reclaimed.</li></ul></div></div><div><div class="td-content"><h1>Cluster Management</h1><div class="section-index"><hr class="panel-line"><div class="entry"><h5><a href="/docs/tutorials/cluster-management/kubelet-standalone/">Running Kubelet in Standalone Mode</a></h5><p></p></div><div class="entry"><h5><a href="/docs/tutorials/cluster-management/provision-swap-memory/">Configuring swap memory on Kubernetes nodes</a></h5><p></p></div><div class="entry"><h5><a href="/docs/tutorials/cluster-management/install-use-dra/">Install Drivers and Allocate Devices with DRA</a></h5><p></p></div><div class="entry"><h5><a href="/docs/tutorials/cluster-management/namespaces-walkthrough/">Namespaces Walkthrough</a></h5><p></p></div></div></div></div><div><div class="td-content"><h1>Running Kubelet in Standalone Mode</h1><p>This tutorial shows you how to run a standalone kubelet instance.</p><p>You may have different motivations for running a standalone kubelet.
This tutorial is aimed at introducing you to Kubernetes, even if you don't have
much experience with it. You can follow this tutorial and learn about node setup,
basic (static) Pods, and how Kubernetes manages containers.</p><p>Once you have followed this tutorial, you could try using a cluster that has a
<a class="glossary-tooltip" title="The container orchestration layer that exposes the API and interfaces to define, deploy, and manage the lifecycle of containers." href="/docs/reference/glossary/?all=true#term-control-plane" target="_blank">control plane</a> to manage pods
and nodes, and other types of objects. For example,
<a href="/docs/tutorials/hello-minikube/">Hello, minikube</a>.</p><p>You can also run the kubelet in standalone mode to suit production use cases, such as
to run the control plane for a highly available, resiliently deployed cluster. This
tutorial does not cover the details you need for running a resilient control plane.</p><h2 id="objectives">Objectives</h2><ul><li>Install <code>cri-o</code>, and <code>kubelet</code> on a Linux system and run them as <code>systemd</code> services.</li><li>Launch a Pod running <code>nginx</code> that listens to requests on TCP port 80 on the Pod's IP address.</li><li>Learn how the different components of the solution interact among themselves.</li></ul><div class="alert alert-caution"><h4 class="alert-heading">Caution:</h4>The kubelet configuration used for this tutorial is insecure by design and should
<em>not</em> be used in a production environment.</div><h2 id="before-you-begin">Before you begin</h2><ul><li>Admin (<code>root</code>) access to a Linux system that uses <code>systemd</code> and <code>iptables</code>
(or nftables with <code>iptables</code> emulation).</li><li>Access to the Internet to download the components needed for the tutorial, such as:<ul><li>A <a class="glossary-tooltip" title="The container runtime is the software that is responsible for running containers." href="/docs/setup/production-environment/container-runtimes" target="_blank">container runtime</a>
that implements the Kubernetes <a class="glossary-tooltip" title="Protocol for communication between the kubelet and the local container runtime." href="/docs/concepts/architecture/cri" target="_blank">(CRI)</a>.</li><li>Network plugins (these are often known as
<a class="glossary-tooltip" title="Container network interface (CNI) plugins are a type of Network plugin that adheres to the appc/CNI specification." href="/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/" target="_blank">Container Networking Interface (CNI)</a>)</li><li>Required CLI tools: <code>curl</code>, <code>tar</code>, <code>jq</code>.</li></ul></li></ul><h2 id="prepare-the-system">Prepare the system</h2><h3 id="swap-configuration">Swap configuration</h3><p>By default, kubelet fails to start if swap memory is detected on a node.
This means that swap should either be disabled or tolerated by kubelet.</p><div class="alert alert-info"><h4 class="alert-heading">Note:</h4>If you configure the kubelet to tolerate swap, the kubelet still configures Pods (and the
containers in those Pods) not to use swap space. To find out how Pods can actually
use the available swap, you can read more about
<a href="/docs/concepts/architecture/nodes/#swap-memory">swap memory management</a> on Linux nodes.</div><p>If you have swap memory enabled, either disable it or add <code>failSwapOn: false</code> to the
kubelet configuration file.</p><p>To check if swap is enabled:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>sudo swapon --show
</span></span></code></pre></div><p>If there is no output from the command, then swap memory is already disabled.</p><p>To disable swap temporarily:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>sudo swapoff -a
</span></span></code></pre></div><p>To make this change persistent across reboots:</p><p>Make sure swap is disabled in either <code>/etc/fstab</code> or <code>systemd.swap</code>, depending on how it was
configured on your system.</p><h3 id="enable-ipv4-packet-forwarding">Enable IPv4 packet forwarding</h3><p>To check if IPv4 packet forwarding is enabled:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>cat /proc/sys/net/ipv4/ip_forward
</span></span></code></pre></div><p>If the output is <code>1</code>, it is already enabled. If the output is <code>0</code>, then follow next steps.</p><p>To enable IPv4 packet forwarding, create a configuration file that sets the
<code>net.ipv4.ip_forward</code> parameter to <code>1</code>:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>sudo tee /etc/sysctl.d/k8s.conf <span>&lt;&lt;EOF
</span></span></span><span><span><span>net.ipv4.ip_forward = 1
</span></span></span><span><span><span>EOF</span>
</span></span></code></pre></div><p>Apply the changes to the system:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>sudo sysctl --system
</span></span></code></pre></div><p>The output is similar to:</p><pre tabindex="0"><code>...
* Applying /etc/sysctl.d/k8s.conf ...
net.ipv4.ip_forward = 1
* Applying /etc/sysctl.conf ...
</code></pre><h2 id="download-install-and-configure-the-components">Download, install, and configure the components</h2><div class="alert alert-secondary callout third-party-content"><strong>Note:</strong>&#8200;This section links to third party projects that provide functionality required by Kubernetes. The Kubernetes project authors aren't responsible for these projects, which are listed alphabetically. To add a project to this list, read the <a href="/docs/contribute/style/content-guide/#third-party-content">content guide</a> before submitting a change. <a href="#third-party-content-disclaimer">More information.</a></div><h3 id="container-runtime">Install a container runtime</h3><p>Download the latest available versions of the required packages (recommended).</p><p>This tutorial suggests installing the <a href="https://github.com/cri-o/cri-o">CRI-O container runtime</a>
(external link).</p><p>There are several <a href="https://github.com/cri-o/cri-o/blob/main/install.md">ways to install</a>
the CRI-O container runtime, depending on your particular Linux distribution. Although
CRI-O recommends using either <code>deb</code> or <code>rpm</code> packages, this tutorial uses the
<em>static binary bundle</em> script of the
<a href="https://github.com/cri-o/packaging/blob/main/README.md">CRI-O Packaging project</a>,
both to streamline the overall process, and to remain distribution agnostic.</p><p>The script installs and configures additional required software, such as
<a href="https://github.com/containernetworking/cni"><code>cni-plugins</code></a>, for container
networking, and <a href="https://github.com/containers/crun"><code>crun</code></a> and
<a href="https://github.com/opencontainers/runc"><code>runc</code></a>, for running containers.</p><p>The script will automatically detect your system's processor architecture
(<code>amd64</code> or <code>arm64</code>) and select and install the latest versions of the software packages.</p><h3 id="cri-o-setup">Set up CRI-O</h3><p>Visit the <a href="https://github.com/cri-o/cri-o/releases">releases</a> page (external link).</p><p>Download the static binary bundle script:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>curl https://raw.githubusercontent.com/cri-o/packaging/main/get &gt; crio-install
</span></span></code></pre></div><p>Run the installer script:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>sudo bash crio-install
</span></span></code></pre></div><p>Enable and start the <code>crio</code> service:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>sudo systemctl daemon-reload
</span></span><span><span>sudo systemctl <span>enable</span> --now crio.service
</span></span></code></pre></div><p>Quick test:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>sudo systemctl is-active crio.service
</span></span></code></pre></div><p>The output is similar to:</p><pre tabindex="0"><code>active
</code></pre><p>Detailed service check:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>sudo journalctl -f -u crio.service
</span></span></code></pre></div><h3 id="install-network-plugins">Install network plugins</h3><p>The <code>cri-o</code> installer installs and configures the <code>cni-plugins</code> package. You can
verify the installation running the following command:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>/opt/cni/bin/bridge --version
</span></span></code></pre></div><p>The output is similar to:</p><pre tabindex="0"><code>CNI bridge plugin v1.5.1
CNI protocol versions supported: 0.1.0, 0.2.0, 0.3.0, 0.3.1, 0.4.0, 1.0.0
</code></pre><p>To check the default configuration:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>cat /etc/cni/net.d/11-crio-ipv4-bridge.conflist
</span></span></code></pre></div><p>The output is similar to:</p><div class="highlight"><pre tabindex="0"><code class="language-json"><span><span>{
</span></span><span><span>  <span>"cniVersion"</span>: <span>"1.0.0"</span>,
</span></span><span><span>  <span>"name"</span>: <span>"crio"</span>,
</span></span><span><span>  <span>"plugins"</span>: [
</span></span><span><span>    {
</span></span><span><span>      <span>"type"</span>: <span>"bridge"</span>,
</span></span><span><span>      <span>"bridge"</span>: <span>"cni0"</span>,
</span></span><span><span>      <span>"isGateway"</span>: <span>true</span>,
</span></span><span><span>      <span>"ipMasq"</span>: <span>true</span>,
</span></span><span><span>      <span>"hairpinMode"</span>: <span>true</span>,
</span></span><span><span>      <span>"ipam"</span>: {
</span></span><span><span>        <span>"type"</span>: <span>"host-local"</span>,
</span></span><span><span>        <span>"routes"</span>: [
</span></span><span><span>            { <span>"dst"</span>: <span>"0.0.0.0/0"</span> }
</span></span><span><span>        ],
</span></span><span><span>        <span>"ranges"</span>: [
</span></span><span><span>            [{ <span>"subnet"</span>: <span>"10.85.0.0/16"</span> }]
</span></span><span><span>        ]
</span></span><span><span>      }
</span></span><span><span>    }
</span></span><span><span>  ]
</span></span><span><span>}
</span></span></code></pre></div><div class="alert alert-info"><h4 class="alert-heading">Note:</h4>Make sure that the default <code>subnet</code> range (<code>10.85.0.0/16</code>) does not overlap with
any of your active networks. If there is an overlap, you can edit the file and change it
accordingly. Restart the service after the change.</div><h3 id="download-and-set-up-the-kubelet">Download and set up the kubelet</h3><p>Download the <a href="/releases/download/">latest stable release</a> of the kubelet.</p><ul class="nav nav-tabs" id="download-kubelet"><li class="nav-item"><a class="nav-link active" href="#download-kubelet-0">x86-64</a></li><li class="nav-item"><a class="nav-link" href="#download-kubelet-1">ARM64</a></li></ul><div class="tab-content" id="download-kubelet"><div id="download-kubelet-0" class="tab-pane show active"><p><div class="highlight"><pre tabindex="0"><code class="language-bash"><span><span>
</span></span><span><span>curl -LO <span>"https://dl.k8s.io/release/</span><span>$(</span>curl -L -s https://dl.k8s.io/release/stable.txt<span>)</span><span>/bin/linux/amd64/kubelet"</span>
</span></span></code></pre></div></p></div><div id="download-kubelet-1" class="tab-pane"><p><div class="highlight"><pre tabindex="0"><code class="language-bash"><span><span>
</span></span><span><span>curl -LO <span>"https://dl.k8s.io/release/</span><span>$(</span>curl -L -s https://dl.k8s.io/release/stable.txt<span>)</span><span>/bin/linux/arm64/kubelet"</span>
</span></span></code></pre></div></p></div></div><p>Configure:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>sudo mkdir -p /etc/kubernetes/manifests
</span></span></code></pre></div><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>sudo tee /etc/kubernetes/kubelet.yaml <span>&lt;&lt;EOF
</span></span></span><span><span><span>apiVersion: kubelet.config.k8s.io/v1beta1
</span></span></span><span><span><span>kind: KubeletConfiguration
</span></span></span><span><span><span>authentication:
</span></span></span><span><span><span>  webhook:
</span></span></span><span><span><span>    enabled: false # Do NOT use in production clusters!
</span></span></span><span><span><span>authorization:
</span></span></span><span><span><span>  mode: AlwaysAllow # Do NOT use in production clusters!
</span></span></span><span><span><span>enableServer: false
</span></span></span><span><span><span>logging:
</span></span></span><span><span><span>  format: text
</span></span></span><span><span><span>address: 127.0.0.1 # Restrict access to localhost
</span></span></span><span><span><span>readOnlyPort: 10255 # Do NOT use in production clusters!
</span></span></span><span><span><span>staticPodPath: /etc/kubernetes/manifests
</span></span></span><span><span><span>containerRuntimeEndpoint: unix:///var/run/crio/crio.sock
</span></span></span><span><span><span>EOF</span>
</span></span></code></pre></div><div class="alert alert-info"><h4 class="alert-heading">Note:</h4><p>Because you are not setting up a production cluster, you are using plain HTTP
(<code>readOnlyPort: 10255</code>) for unauthenticated queries to the kubelet's API.</p><p>The <em>authentication webhook</em> is disabled and <em>authorization mode</em> is set to <code>AlwaysAllow</code>
for the purpose of this tutorial. You can learn more about
<a href="/docs/reference/access-authn-authz/authorization/#authorization-modules">authorization modes</a>
and <a href="/docs/reference/access-authn-authz/webhook/">webhook authentication</a> to properly
configure kubelet in standalone mode in your environment.</p><p>See <a href="/docs/reference/networking/ports-and-protocols/">Ports and Protocols</a> to
understand which ports Kubernetes components use.</p></div><p>Install:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>chmod +x kubelet
</span></span><span><span>sudo cp kubelet /usr/bin/
</span></span></code></pre></div><p>Create a <code>systemd</code> service unit file:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>sudo tee /etc/systemd/system/kubelet.service <span>&lt;&lt;EOF
</span></span></span><span><span><span>[Unit]
</span></span></span><span><span><span>Description=Kubelet
</span></span></span><span><span><span>
</span></span></span><span><span><span>[Service]
</span></span></span><span><span><span>ExecStart=/usr/bin/kubelet \
</span></span></span><span><span><span> --config=/etc/kubernetes/kubelet.yaml
</span></span></span><span><span><span>Restart=always
</span></span></span><span><span><span>
</span></span></span><span><span><span>[Install]
</span></span></span><span><span><span>WantedBy=multi-user.target
</span></span></span><span><span><span>EOF</span>
</span></span></code></pre></div><p>The command line argument <code>--kubeconfig</code> has been intentionally omitted in the
service configuration file. This argument sets the path to a
<a href="/docs/concepts/configuration/organize-cluster-access-kubeconfig/">kubeconfig</a>
file that specifies how to connect to the API server, enabling API server mode.
Omitting it, enables standalone mode.</p><p>Enable and start the <code>kubelet</code> service:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>sudo systemctl daemon-reload
</span></span><span><span>sudo systemctl <span>enable</span> --now kubelet.service
</span></span></code></pre></div><p>Quick test:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>sudo systemctl is-active kubelet.service
</span></span></code></pre></div><p>The output is similar to:</p><pre tabindex="0"><code>active
</code></pre><p>Detailed service check:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>sudo journalctl -u kubelet.service
</span></span></code></pre></div><p>Check the kubelet's API <code>/healthz</code> endpoint:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>curl http://localhost:10255/healthz?verbose
</span></span></code></pre></div><p>The output is similar to:</p><pre tabindex="0"><code>[+]ping ok
[+]log ok
[+]syncloop ok
healthz check passed
</code></pre><p>Query the kubelet's API <code>/pods</code> endpoint:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>curl http://localhost:10255/pods | jq <span>'.'</span>
</span></span></code></pre></div><p>The output is similar to:</p><div class="highlight"><pre tabindex="0"><code class="language-json"><span><span>{
</span></span><span><span>  <span>"kind"</span>: <span>"PodList"</span>,
</span></span><span><span>  <span>"apiVersion"</span>: <span>"v1"</span>,
</span></span><span><span>  <span>"metadata"</span>: {},
</span></span><span><span>  <span>"items"</span>: <span>null</span>
</span></span><span><span>}
</span></span></code></pre></div><h2 id="run-a-pod-in-the-kubelet">Run a Pod in the kubelet</h2><p>In standalone mode, you can run Pods using Pod manifests. The manifests can either
be on the local filesystem, or fetched via HTTP from a configuration source.</p><p>Create a manifest for a Pod:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>cat <span>&lt;&lt;EOF &gt; static-web.yaml
</span></span></span><span><span><span>apiVersion: v1
</span></span></span><span><span><span>kind: Pod
</span></span></span><span><span><span>metadata:
</span></span></span><span><span><span>  name: static-web
</span></span></span><span><span><span>spec:
</span></span></span><span><span><span>  containers:
</span></span></span><span><span><span>    - name: web
</span></span></span><span><span><span>      image: nginx
</span></span></span><span><span><span>      ports:
</span></span></span><span><span><span>        - name: web
</span></span></span><span><span><span>          containerPort: 80
</span></span></span><span><span><span>          protocol: TCP
</span></span></span><span><span><span>EOF</span>
</span></span></code></pre></div><p>Copy the <code>static-web.yaml</code> manifest file to the <code>/etc/kubernetes/manifests</code> directory.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>sudo cp static-web.yaml /etc/kubernetes/manifests/
</span></span></code></pre></div><h3 id="find-out-information">Find out information about the kubelet and the Pod</h3><p>The Pod networking plugin creates a network bridge (<code>cni0</code>) and a pair of <code>veth</code> interfaces
for each Pod (one of the pair is inside the newly made Pod, and the other is at the host level).</p><p>Query the kubelet's API endpoint at <code>http://localhost:10255/pods</code>:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>curl http://localhost:10255/pods | jq <span>'.'</span>
</span></span></code></pre></div><p>To obtain the IP address of the <code>static-web</code> Pod:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>curl http://localhost:10255/pods | jq <span>'.items[].status.podIP'</span>
</span></span></code></pre></div><p>The output is similar to:</p><pre tabindex="0"><code>"10.85.0.4"
</code></pre><p>Connect to the <code>nginx</code> server Pod on <code>http://&lt;IP&gt;:&lt;Port&gt;</code> (port 80 is the default), in this case:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>curl http://10.85.0.4
</span></span></code></pre></div><p>The output is similar to:</p><div class="highlight"><pre tabindex="0"><code class="language-html"><span><span><span>&lt;!DOCTYPE html&gt;</span>
</span></span><span><span>&lt;<span>html</span>&gt;
</span></span><span><span>&lt;<span>head</span>&gt;
</span></span><span><span>&lt;<span>title</span>&gt;Welcome to nginx!&lt;/<span>title</span>&gt;
</span></span><span><span>...
</span></span></code></pre></div><h2 id="where-to-look-for-more-details">Where to look for more details</h2><p>If you need to diagnose a problem getting this tutorial to work, you can look
within the following directories for monitoring and troubleshooting:</p><pre tabindex="0"><code>/var/lib/cni
/var/lib/containers
/var/lib/kubelet

/var/log/containers
/var/log/pods
</code></pre><h2 id="clean-up">Clean up</h2><h3 id="kubelet">kubelet</h3><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>sudo systemctl disable --now kubelet.service
</span></span><span><span>sudo systemctl daemon-reload
</span></span><span><span>sudo rm /etc/systemd/system/kubelet.service
</span></span><span><span>sudo rm /usr/bin/kubelet
</span></span><span><span>sudo rm -rf /etc/kubernetes
</span></span><span><span>sudo rm -rf /var/lib/kubelet
</span></span><span><span>sudo rm -rf /var/log/containers
</span></span><span><span>sudo rm -rf /var/log/pods
</span></span></code></pre></div><h3 id="container-runtime-1">Container Runtime</h3><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>sudo systemctl disable --now crio.service
</span></span><span><span>sudo systemctl daemon-reload
</span></span><span><span>sudo rm -rf /usr/local/bin
</span></span><span><span>sudo rm -rf /usr/local/lib
</span></span><span><span>sudo rm -rf /usr/local/share
</span></span><span><span>sudo rm -rf /usr/libexec/crio
</span></span><span><span>sudo rm -rf /etc/crio
</span></span><span><span>sudo rm -rf /etc/containers
</span></span></code></pre></div><h3 id="network-plugins">Network Plugins</h3><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>sudo rm -rf /opt/cni
</span></span><span><span>sudo rm -rf /etc/cni
</span></span><span><span>sudo rm -rf /var/lib/cni
</span></span></code></pre></div><h2 id="conclusion">Conclusion</h2><p>This page covered the basic aspects of deploying a kubelet in standalone mode.
You are now ready to deploy Pods and test additional functionality.</p><p>Notice that in standalone mode the kubelet does <em>not</em> support fetching Pod
configurations from the control plane (because there is no control plane connection).</p><p>You also cannot use a <a class="glossary-tooltip" title="An API object used to store non-confidential data in key-value pairs. Can be consumed as environment variables, command-line arguments, or configuration files in a volume." href="/docs/concepts/configuration/configmap/" target="_blank">ConfigMap</a> or a
<a class="glossary-tooltip" title="Stores sensitive information, such as passwords, OAuth tokens, and ssh keys." href="/docs/concepts/configuration/secret/" target="_blank">Secret</a> to configure the containers
in a static Pod.</p><h2 id="what-s-next">What's next</h2><ul><li>Follow <a href="/docs/tutorials/hello-minikube/">Hello, minikube</a> to learn about running Kubernetes
<em>with</em> a control plane. The minikube tool helps you set up a practice cluster on your own computer.</li><li>Learn more about <a href="/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/">Network Plugins</a></li><li>Learn more about <a href="/docs/setup/production-environment/container-runtimes/">Container Runtimes</a></li><li>Learn more about <a href="/docs/reference/command-line-tools-reference/kubelet/">kubelet</a></li><li>Learn more about <a href="/docs/tasks/configure-pod-container/static-pod/">static Pods</a></li></ul></div></div><div><div class="td-content"><h1>Configuring swap memory on Kubernetes nodes</h1><p>This page provides an example of how to provision and configure swap memory on a Kubernetes node using kubeadm.</p><h2 id="objectives">Objectives</h2><ul><li>Provision swap memory on a Kubernetes node using kubeadm.</li><li>Learn to configure both encrypted and unencrypted swap.</li><li>Learn to enable swap on boot.</li></ul><h2 id="before-you-begin">Before you begin</h2><p><p>You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. It is recommended to run this tutorial on a cluster with at least two nodes that are not acting as control plane hosts. If you do not already have a
cluster, you can create one by using
<a href="https://minikube.sigs.k8s.io/docs/tutorials/multi_node/">minikube</a>
or you can use one of these Kubernetes playgrounds:</p><ul><li><a href="https://labs.iximiuz.com/playgrounds?category=kubernetes&amp;filter=all">iximiuz Labs</a></li><li><a href="https://killercoda.com/playgrounds/scenario/kubernetes">Killercoda</a></li><li><a href="https://kodekloud.com/public-playgrounds">KodeKloud</a></li><li><a href="https://labs.play-with-k8s.com/">Play with Kubernetes</a></li></ul>Your Kubernetes server must be at or later than version 1.33.<p>To check the version, enter <code>kubectl version</code>.</p></p><p>You need at least one worker node in your cluster which needs to run a Linux operating system.
It is required for this demo that the kubeadm tool be installed, following the steps outlined in the
<a href="/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/">kubeadm installation guide</a>.</p><p>On each worker node where you will configure swap use, you need:</p><ul><li><p><code>fallocate</code></p></li><li><p><code>mkswap</code></p></li><li><p><code>swapon</code></p></li><li><p>For encrypted swap space (recommended), you also need:</p></li><li><p><code>cryptsetup</code></p></li></ul><h2 id="install-a-swap-enabled-cluster-with-kubeadm">Install a swap-enabled cluster with kubeadm</h2><h3 id="create-a-swap-file-and-turn-swap-on">Create a swap file and turn swap on</h3><p>If swap is not enabled, there's a need to provision swap on the node.
The following sections demonstrate creating 4GiB of swap, both in the encrypted and unencrypted case.</p><ul class="nav nav-tabs" id="create-a-swap-file-and-turn-swap-on"><li class="nav-item"><a class="nav-link active" href="#create-a-swap-file-and-turn-swap-on-0">Setting up encrypted swap</a></li><li class="nav-item"><a class="nav-link" href="#create-a-swap-file-and-turn-swap-on-1">Setting up unencrypted swap</a></li></ul><div class="tab-content" id="create-a-swap-file-and-turn-swap-on"><div id="create-a-swap-file-and-turn-swap-on-0" class="tab-pane show active"><p><p>An encrypted swap file can be set up as follows.
Bear in mind that this example uses the <code>cryptsetup</code> binary (which is available
on most Linux distributions).</p><div class="highlight"><pre tabindex="0"><code class="language-bash"><span><span><span># Allocate storage and restrict access</span>
</span></span><span><span>fallocate --length 4GiB /swapfile
</span></span><span><span>chmod <span>600</span> /swapfile
</span></span><span><span>
</span></span><span><span><span># Create an encrypted device backed by the allocated storage</span>
</span></span><span><span>cryptsetup --type plain --cipher aes-xts-plain64 --key-size <span>256</span> -d /dev/urandom open /swapfile cryptswap
</span></span><span><span>
</span></span><span><span><span># Format the swap space</span>
</span></span><span><span>mkswap /dev/mapper/cryptswap
</span></span><span><span>
</span></span><span><span><span># Activate the swap space for paging</span>
</span></span><span><span>swapon /dev/mapper/cryptswap
</span></span></code></pre></div></p></div><div id="create-a-swap-file-and-turn-swap-on-1" class="tab-pane"><p><p>An unencrypted swap file can be set up as follows.</p><div class="highlight"><pre tabindex="0"><code class="language-bash"><span><span><span># Allocate storage and restrict access</span>
</span></span><span><span>fallocate --length 4GiB /swapfile
</span></span><span><span>chmod <span>600</span> /swapfile
</span></span><span><span>
</span></span><span><span><span># Format the swap space</span>
</span></span><span><span>mkswap /swapfile
</span></span><span><span>
</span></span><span><span><span># Activate the swap space for paging</span>
</span></span><span><span>swapon /swapfile
</span></span></code></pre></div></p></div></div><h4 id="verify-that-swap-is-enabled">Verify that swap is enabled</h4><p>Swap can be verified to be enabled with both <code>swapon -s</code> command or the <code>free</code> command.</p><p>Using <code>swapon -s</code>:</p><pre tabindex="0"><code>Filename       Type		Size		Used		Priority
/dev/dm-0      partition 	4194300		0		-2
</code></pre><p>Using <code>free -h</code>:</p><pre tabindex="0"><code>               total        used        free      shared  buff/cache   available
Mem:           3.8Gi       1.3Gi       249Mi        25Mi       2.5Gi       2.5Gi
Swap:          4.0Gi          0B       4.0Gi
</code></pre><h4 id="enable-swap-on-boot">Enable swap on boot</h4><p>After setting up swap, to start the swap file at boot time,
you typically either set up a systemd unit to activate (encrypted) swap, or you
add a line similar to <code>/swapfile swap swap defaults 0 0</code> into <code>/etc/fstab</code>.</p><p>Using systemd for swap activation allows the system to delay kubelet start until swap is available,
if that is something you want to ensure.
In a similar way, using systemd allows your server to leave swap active until kubelet
(and, typically, your container runtime) have shut down.</p><h3 id="set-up-kubelet-configuration">Set up kubelet configuration</h3><p>After enabling swap on the node, kubelet needs to be configured to use it.
You need to select a <a href="/docs/reference/node/swap-behavior/">swap behavior</a>
for this node. You'll configure <em>LimitedSwap</em> behavior for this tutorial.</p><p>Find and edit the kubelet configuration file, and:</p><ul><li>set <code>failSwapOn</code> to false</li><li>set <code>memorySwap.swapBehavior</code> to LimitedSwap</li></ul><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span> </span><span># this fragment goes into the kubelet's configuration file</span><span>
</span></span></span><span><span><span> </span><span>failSwapOn</span>:<span> </span><span>false</span><span>
</span></span></span><span><span><span> </span><span>memorySwap</span>:<span>
</span></span></span><span><span><span>     </span><span>swapBehavior</span>:<span> </span>LimitedSwap<span>
</span></span></span></code></pre></div><p>In order for these configurations to take effect, kubelet needs to be restarted.
Typically you do that by running:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>systemctl restart kubelet.service
</span></span></code></pre></div><p>You should find that the kubelet is now healthy, and that you can run Pods
that use swap memory as needed.</p></div></div><div><div class="td-content"><h1>Install Drivers and Allocate Devices with DRA</h1><div class="feature-state-notice feature-stable" title="Feature Gate: DynamicResourceAllocation"><span class="feature-state-name">FEATURE STATE:</span>
<code>Kubernetes v1.34 [stable]</code> (enabled by default: true)</div><p>This tutorial shows you how to install <a class="glossary-tooltip" title="A Kubernetes feature for requesting and sharing resources, like hardware accelerators, among Pods." href="/docs/concepts/scheduling-eviction/dynamic-resource-allocation/" target="_blank">Dynamic Resource Allocation (DRA)</a> drivers in your cluster and how to
use them in conjunction with the DRA APIs to allocate <a class="glossary-tooltip" title="Any resource that's directly or indirectly attached your cluster's nodes, like GPUs or circuit boards." href="/docs/reference/glossary/?all=true#term-device" target="_blank">devices</a> to Pods. This page is intended for cluster administrators.</p><p><a class="glossary-tooltip" title="A Kubernetes feature for requesting and sharing resources, like hardware accelerators, among Pods." href="/docs/concepts/scheduling-eviction/dynamic-resource-allocation/" target="_blank">Dynamic Resource Allocation (DRA)</a>
lets a cluster manage availability and allocation of hardware resources to
satisfy Pod-based claims for hardware requirements and preferences. To support
this, a mixture of Kubernetes built-in components (like the Kubernetes
scheduler, kubelet, and kube-controller-manager) and third-party drivers from
device owners (called DRA drivers) share the responsibility to advertise,
allocate, prepare, mount, healthcheck, unprepare, and cleanup resources
throughout the Pod lifecycle. These components share information via a series of
DRA specific APIs in the <code>resource.k8s.io</code> API group including <a class="glossary-tooltip" title="A category of devices in the cluster. Users can claim specific devices in a DeviceClass." href="/docs/concepts/scheduling-eviction/dynamic-resource-allocation/#deviceclass" target="_blank">DeviceClasses</a>, <a class="glossary-tooltip" title="Represents one or more infrastructure resources, like devices, in a pool of similar resources." href="/docs/reference/kubernetes-api/workload-resources/resource-slice-v1beta1/" target="_blank">ResourceSlices</a>, <a class="glossary-tooltip" title="Describes the resources that a workload needs, such as devices. ResourceClaims can request devices from DeviceClasses." href="/docs/concepts/scheduling-eviction/dynamic-resource-allocation/#resourceclaims-templates" target="_blank">ResourceClaims</a>, as well as
new fields in the Pod spec itself.</p><h3 id="objectives">Objectives</h3><ul><li>Deploy an example DRA driver</li><li>Deploy a Pod requesting a hardware claim using DRA APIs</li><li>Delete a Pod that has a claim</li></ul><h2 id="before-you-begin">Before you begin</h2><p>Your cluster should support <a href="/docs/reference/access-authn-authz/rbac/">RBAC</a>.
You can try this tutorial with a cluster using a different authorization
mechanism, but in that case you will have to adapt the steps around defining
roles and permissions.</p><p>You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. It is recommended to run this tutorial on a cluster with at least two nodes that are not acting as control plane hosts. If you do not already have a
cluster, you can create one by using
<a href="https://minikube.sigs.k8s.io/docs/tutorials/multi_node/">minikube</a>
or you can use one of these Kubernetes playgrounds:</p><ul><li><a href="https://labs.iximiuz.com/playgrounds?category=kubernetes&amp;filter=all">iximiuz Labs</a></li><li><a href="https://killercoda.com/playgrounds/scenario/kubernetes">Killercoda</a></li><li><a href="https://kodekloud.com/public-playgrounds">KodeKloud</a></li><li><a href="https://labs.play-with-k8s.com/">Play with Kubernetes</a></li></ul><p>This tutorial has been tested with Linux nodes, though it may also work with
other types of nodes.</p>Your Kubernetes server must be version v1.34.<p>To check the version, enter <code>kubectl version</code>.</p><p>If your cluster is not currently running Kubernetes 1.34 then please check the documentation for the version of Kubernetes that you
plan to use.</p><h2 id="explore-initial-state">Explore the initial cluster state</h2><p>You can spend some time to observe the initial state of a cluster with DRA
enabled, especially if you have not used these APIs extensively before. If you
set up a new cluster for this tutorial, with no driver installed and no Pod
claims yet to satisfy, the output of these commands won't show any resources.</p><ol><li><p>Get a list of <a class="glossary-tooltip" title="A category of devices in the cluster. Users can claim specific devices in a DeviceClass." href="/docs/concepts/scheduling-eviction/dynamic-resource-allocation/#deviceclass" target="_blank">DeviceClasses</a>:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get deviceclasses
</span></span></code></pre></div><p>The output is similar to this:</p><pre tabindex="0"><code>No resources found
</code></pre></li><li><p>Get a list of <a class="glossary-tooltip" title="Represents one or more infrastructure resources, like devices, in a pool of similar resources." href="/docs/reference/kubernetes-api/workload-resources/resource-slice-v1beta1/" target="_blank">ResourceSlices</a>:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get resourceslices
</span></span></code></pre></div><p>The output is similar to this:</p><pre tabindex="0"><code>No resources found
</code></pre></li><li><p>Get a list of <a class="glossary-tooltip" title="Describes the resources that a workload needs, such as devices. ResourceClaims can request devices from DeviceClasses." href="/docs/concepts/scheduling-eviction/dynamic-resource-allocation/#resourceclaims-templates" target="_blank">ResourceClaims</a> and <a class="glossary-tooltip" title="Defines a template for Kubernetes to create ResourceClaims. Used to provide per-Pod access to separate, similar resources." href="/docs/concepts/scheduling-eviction/dynamic-resource-allocation/#resourceclaims-templates" target="_blank">ResourceClaimTemplates</a></p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get resourceclaims -A
</span></span><span><span>kubectl get resourceclaimtemplates -A
</span></span></code></pre></div><p>The output is similar to this:</p><pre tabindex="0"><code>No resources found
No resources found
</code></pre></li></ol><p>At this point, you have confirmed that DRA is enabled and configured properly in
the cluster, and that no DRA drivers have advertised any resources to the DRA
APIs yet.</p><h2 id="install-example-driver">Install an example DRA driver</h2><p>DRA drivers are third-party applications that run on each node of your cluster
to interface with the hardware of that node and Kubernetes' built-in DRA
components. The installation procedure depends on the driver you choose, but is
likely deployed as a <a class="glossary-tooltip" title="Ensures a copy of a Pod is running across a set of nodes in a cluster." href="/docs/concepts/workloads/controllers/daemonset" target="_blank">DaemonSet</a> to all or a
selection of the nodes (using <a class="glossary-tooltip" title="Allows users to filter a list of resources based on labels." href="/docs/concepts/overview/working-with-objects/labels/" target="_blank">selectors</a> or similar mechanisms) in your cluster.</p><p>Check your driver's documentation for specific installation instructions, which
might include a Helm chart, a set of manifests, or other deployment tooling.</p><p>This tutorial uses an example driver which can be found in the
<a href="https://github.com/kubernetes-sigs/dra-example-driver">kubernetes-sigs/dra-example-driver</a>
repository to demonstrate driver installation. This example driver advertises
simulated GPUs to Kubernetes for your Pods to interact with.</p><h3 id="prepare-cluster-driver">Prepare your cluster for driver installation</h3><p>To simplify cleanup, create a namespace named dra-tutorial:</p><ol><li><p>Create the namespace:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl create namespace dra-tutorial 
</span></span></code></pre></div></li></ol><p>In a production environment, you would likely be using a previously released or
qualified image from the driver vendor or your own organization, and your nodes
would need to have access to the image registry where the driver image is
hosted. In this tutorial, you will use a publicly released image of the
dra-example-driver to simulate access to a DRA driver image.</p><ol><li><p>Confirm your nodes have access to the image by running the following
from within one of your cluster's nodes:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>docker pull registry.k8s.io/dra-example-driver/dra-example-driver:v0.2.0
</span></span></code></pre></div></li></ol><h3 id="deploy-the-dra-driver-components">Deploy the DRA driver components</h3><p>For this tutorial, you will install the critical example resource driver
components individually with <code>kubectl</code>.</p><ol><li><p>Create the DeviceClass representing the device types this DRA driver
supports:</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/dra/driver-install/deviceclass.yaml"><code>dra/driver-install/deviceclass.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" title="Copy dra/driver-install/deviceclass.yaml to clipboard"></div><div class="includecode" id="dra-driver-install-deviceclass-yaml"><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span>apiVersion</span>:<span> </span>resource.k8s.io/v1<span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>DeviceClass<span>
</span></span></span><span><span><span></span><span>metadata</span>:<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>gpu.example.com<span>
</span></span></span><span><span><span></span><span>spec</span>:<span>
</span></span></span><span><span><span>  </span><span>selectors</span>:<span>
</span></span></span><span><span><span>  </span>- <span>cel</span>:<span> 
</span></span></span><span><span><span>      </span><span>expression</span>:<span> </span><span>"device.driver == 'gpu.example.com'"</span></span></span></code></pre></div></div></div><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl apply --server-side -f http://k8s.io/examples/dra/driver-install/deviceclass.yaml
</span></span></code></pre></div></li><li><p>Create the ServiceAccount, ClusterRole and ClusterRoleBinding that will
be used by the driver to gain permissions to interact with the Kubernetes API
on this cluster:</p><ol><li><p>Create the Service Account:</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/dra/driver-install/serviceaccount.yaml"><code>dra/driver-install/serviceaccount.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" title="Copy dra/driver-install/serviceaccount.yaml to clipboard"></div><div class="includecode" id="dra-driver-install-serviceaccount-yaml"><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span>apiVersion</span>:<span> </span>v1<span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>ServiceAccount<span>
</span></span></span><span><span><span></span><span>metadata</span>:<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>dra-example-driver-service-account<span>
</span></span></span><span><span><span>  </span><span>namespace</span>:<span> </span>dra-tutorial<span>
</span></span></span><span><span><span>  </span><span>labels</span>:<span>
</span></span></span><span><span><span>    </span><span>app.kubernetes.io/name</span>:<span> </span>dra-example-driver<span>
</span></span></span><span><span><span>    </span><span>app.kubernetes.io/instance</span>:<span> </span>dra-example-driver</span></span></code></pre></div></div></div><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl apply --server-side -f http://k8s.io/examples/dra/driver-install/serviceaccount.yaml
</span></span></code></pre></div></li><li><p>Create the ClusterRole:</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/dra/driver-install/clusterrole.yaml"><code>dra/driver-install/clusterrole.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" title="Copy dra/driver-install/clusterrole.yaml to clipboard"></div><div class="includecode" id="dra-driver-install-clusterrole-yaml"><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span>apiVersion</span>:<span> </span>rbac.authorization.k8s.io/v1<span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>ClusterRole<span>
</span></span></span><span><span><span></span><span>metadata</span>:<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>dra-example-driver-role<span>
</span></span></span><span><span><span></span><span>rules</span>:<span>
</span></span></span><span><span><span></span>- <span>apiGroups</span>:<span> </span>[<span>"resource.k8s.io"</span>]<span>
</span></span></span><span><span><span>  </span><span>resources</span>:<span> </span>[<span>"resourceclaims"</span>]<span>
</span></span></span><span><span><span>  </span><span>verbs</span>:<span> </span>[<span>"get"</span>]<span>
</span></span></span><span><span><span></span>- <span>apiGroups</span>:<span> </span>[<span>""</span>]<span>
</span></span></span><span><span><span>  </span><span>resources</span>:<span> </span>[<span>"nodes"</span>]<span>
</span></span></span><span><span><span>  </span><span>verbs</span>:<span> </span>[<span>"get"</span>]<span>
</span></span></span><span><span><span></span>- <span>apiGroups</span>:<span> </span>[<span>"resource.k8s.io"</span>]<span>
</span></span></span><span><span><span>  </span><span>resources</span>:<span> </span>[<span>"resourceslices"</span>]<span>
</span></span></span><span><span><span>  </span><span>verbs</span>:<span> </span>[<span>"get"</span>,<span> </span><span>"list"</span>,<span> </span><span>"watch"</span>,<span> </span><span>"create"</span>,<span> </span><span>"update"</span>,<span> </span><span>"patch"</span>,<span> </span><span>"delete"</span>]</span></span></code></pre></div></div></div><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl apply --server-side -f http://k8s.io/examples/dra/driver-install/clusterrole.yaml
</span></span></code></pre></div></li><li><p>Create the ClusterRoleBinding:</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/dra/driver-install/clusterrolebinding.yaml"><code>dra/driver-install/clusterrolebinding.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" title="Copy dra/driver-install/clusterrolebinding.yaml to clipboard"></div><div class="includecode" id="dra-driver-install-clusterrolebinding-yaml"><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span>apiVersion</span>:<span> </span>rbac.authorization.k8s.io/v1<span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>ClusterRoleBinding<span>
</span></span></span><span><span><span></span><span>metadata</span>:<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>dra-example-driver-role-binding<span>
</span></span></span><span><span><span></span><span>subjects</span>:<span>
</span></span></span><span><span><span></span>- <span>kind</span>:<span> </span>ServiceAccount<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>dra-example-driver-service-account<span>
</span></span></span><span><span><span>  </span><span>namespace</span>:<span> </span>dra-tutorial<span>
</span></span></span><span><span><span></span><span>roleRef</span>:<span>
</span></span></span><span><span><span>  </span><span>kind</span>:<span> </span>ClusterRole<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>dra-example-driver-role<span>
</span></span></span><span><span><span>  </span><span>apiGroup</span>:<span> </span>rbac.authorization.k8s.io</span></span></code></pre></div></div></div><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl apply --server-side -f http://k8s.io/examples/dra/driver-install/clusterrolebinding.yaml
</span></span></code></pre></div></li></ol></li><li><p>Create a <a class="glossary-tooltip" title="A mapping from a class name to the scheduling priority that a Pod should have." href="/docs/concepts/scheduling-eviction/pod-priority-preemption/#priorityclass" target="_blank">PriorityClass</a> for the DRA
driver. The PriorityClass prevents preemption of th DRA driver component,
which is responsible for important lifecycle operations for Pods with
claims. Learn more about <a href="/docs/concepts/scheduling-eviction/pod-priority-preemption/">pod priority and preemption
here</a>.</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/dra/driver-install/priorityclass.yaml"><code>dra/driver-install/priorityclass.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" title="Copy dra/driver-install/priorityclass.yaml to clipboard"></div><div class="includecode" id="dra-driver-install-priorityclass-yaml"><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span>apiVersion</span>:<span> </span>scheduling.k8s.io/v1<span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>PriorityClass<span>
</span></span></span><span><span><span></span><span>metadata</span>:<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>dra-driver-high-priority<span>
</span></span></span><span><span><span></span><span>value</span>:<span> </span><span>1000000</span><span>
</span></span></span><span><span><span></span><span>globalDefault</span>:<span> </span><span>false</span><span>
</span></span></span><span><span><span></span><span>description</span>:<span> </span><span>"This priority class should be used for DRA driver pods only."</span></span></span></code></pre></div></div></div><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl apply --server-side -f http://k8s.io/examples/dra/driver-install/priorityclass.yaml
</span></span></code></pre></div></li><li><p>Deploy the actual DRA driver as a DaemonSet configured to run the example
driver binary with the permissions provisioned above. The DaemonSet has the
permissions that you granted to the ServiceAccount in the previous steps.</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/dra/driver-install/daemonset.yaml"><code>dra/driver-install/daemonset.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" title="Copy dra/driver-install/daemonset.yaml to clipboard"></div><div class="includecode" id="dra-driver-install-daemonset-yaml"><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span>apiVersion</span>:<span> </span>apps/v1<span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>DaemonSet<span>
</span></span></span><span><span><span></span><span>metadata</span>:<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>dra-example-driver-kubeletplugin<span>
</span></span></span><span><span><span>  </span><span>namespace</span>:<span> </span>dra-tutorial<span>
</span></span></span><span><span><span>  </span><span>labels</span>:<span>
</span></span></span><span><span><span>    </span><span>app.kubernetes.io/name</span>:<span> </span>dra-example-driver<span>
</span></span></span><span><span><span></span><span>spec</span>:<span>
</span></span></span><span><span><span>  </span><span>selector</span>:<span>
</span></span></span><span><span><span>    </span><span>matchLabels</span>:<span>
</span></span></span><span><span><span>      </span><span>app.kubernetes.io/name</span>:<span> </span>dra-example-driver<span>
</span></span></span><span><span><span>  </span><span>updateStrategy</span>:<span>
</span></span></span><span><span><span>    </span><span>type</span>:<span> </span>RollingUpdate<span>
</span></span></span><span><span><span>  </span><span>template</span>:<span>
</span></span></span><span><span><span>    </span><span>metadata</span>:<span>
</span></span></span><span><span><span>      </span><span>labels</span>:<span>
</span></span></span><span><span><span>        </span><span>app.kubernetes.io/name</span>:<span> </span>dra-example-driver<span>
</span></span></span><span><span><span>    </span><span>spec</span>:<span>
</span></span></span><span><span><span>      </span><span>priorityClassName</span>:<span> </span>dra-driver-high-priority<span>
</span></span></span><span><span><span>      </span><span>serviceAccountName</span>:<span> </span>dra-example-driver-service-account<span>
</span></span></span><span><span><span>      </span><span>securityContext</span>:<span>
</span></span></span><span><span><span>        </span>{}<span>
</span></span></span><span><span><span>      </span><span>containers</span>:<span>
</span></span></span><span><span><span>      </span>- <span>name</span>:<span> </span>plugin<span>
</span></span></span><span><span><span>        </span><span>securityContext</span>:<span>
</span></span></span><span><span><span>          </span><span>privileged</span>:<span> </span><span>true</span><span>
</span></span></span><span><span><span>        </span><span>image</span>:<span> </span>registry.k8s.io/dra-example-driver/dra-example-driver:v0.2.0<span>
</span></span></span><span><span><span>        </span><span>imagePullPolicy</span>:<span> </span>IfNotPresent<span>
</span></span></span><span><span><span>        </span><span>command</span>:<span> </span>[<span>"dra-example-kubeletplugin"</span>]<span>
</span></span></span><span><span><span>        </span><span>resources</span>:<span>
</span></span></span><span><span><span>          </span>{}<span>
</span></span></span><span><span><span>        </span><span># Production drivers should always implement a liveness probe</span><span>
</span></span></span><span><span><span>        </span><span># For the tutorial we simply omit it</span><span>
</span></span></span><span><span><span>        </span><span># livenessProbe:</span><span>
</span></span></span><span><span><span>        </span><span>#   grpc:</span><span>
</span></span></span><span><span><span>        </span><span>#     port: 51515</span><span>
</span></span></span><span><span><span>        </span><span>#     service: liveness</span><span>
</span></span></span><span><span><span>        </span><span>#   failureThreshold: 3</span><span>
</span></span></span><span><span><span>        </span><span>#   periodSeconds: 10</span><span>
</span></span></span><span><span><span>        </span><span>env</span>:<span>
</span></span></span><span><span><span>        </span>- <span>name</span>:<span> </span>CDI_ROOT<span>
</span></span></span><span><span><span>          </span><span>value</span>:<span> </span>/var/run/cdi<span>
</span></span></span><span><span><span>        </span>- <span>name</span>:<span> </span>KUBELET_REGISTRAR_DIRECTORY_PATH<span>
</span></span></span><span><span><span>          </span><span>value</span>:<span> </span><span>"/var/lib/kubelet/plugins_registry"</span><span>
</span></span></span><span><span><span>        </span>- <span>name</span>:<span> </span>KUBELET_PLUGINS_DIRECTORY_PATH<span>
</span></span></span><span><span><span>          </span><span>value</span>:<span> </span><span>"/var/lib/kubelet/plugins"</span><span>
</span></span></span><span><span><span>        </span>- <span>name</span>:<span> </span>NODE_NAME<span>
</span></span></span><span><span><span>          </span><span>valueFrom</span>:<span>
</span></span></span><span><span><span>            </span><span>fieldRef</span>:<span>
</span></span></span><span><span><span>              </span><span>fieldPath</span>:<span> </span>spec.nodeName<span>
</span></span></span><span><span><span>        </span>- <span>name</span>:<span> </span>NAMESPACE<span>
</span></span></span><span><span><span>          </span><span>valueFrom</span>:<span>
</span></span></span><span><span><span>            </span><span>fieldRef</span>:<span>
</span></span></span><span><span><span>              </span><span>fieldPath</span>:<span> </span>metadata.namespace<span>
</span></span></span><span><span><span>        </span><span># Simulated number of devices the example driver will pretend to have.</span><span>
</span></span></span><span><span><span>        </span>- <span>name</span>:<span> </span>NUM_DEVICES<span>
</span></span></span><span><span><span>          </span><span>value</span>:<span> </span><span>"9"</span><span>
</span></span></span><span><span><span>        </span>- <span>name</span>:<span> </span>HEALTHCHECK_PORT<span>
</span></span></span><span><span><span>          </span><span>value</span>:<span> </span><span>"51515"</span><span>
</span></span></span><span><span><span>        </span><span>volumeMounts</span>:<span>
</span></span></span><span><span><span>        </span>- <span>name</span>:<span> </span>plugins-registry<span>
</span></span></span><span><span><span>          </span><span>mountPath</span>:<span> </span><span>"/var/lib/kubelet/plugins_registry"</span><span>
</span></span></span><span><span><span>        </span>- <span>name</span>:<span> </span>plugins<span>
</span></span></span><span><span><span>          </span><span>mountPath</span>:<span> </span><span>"/var/lib/kubelet/plugins"</span><span>
</span></span></span><span><span><span>        </span>- <span>name</span>:<span> </span>cdi<span>
</span></span></span><span><span><span>          </span><span>mountPath</span>:<span> </span>/var/run/cdi<span>
</span></span></span><span><span><span>      </span><span>volumes</span>:<span>
</span></span></span><span><span><span>      </span>- <span>name</span>:<span> </span>plugins-registry<span>
</span></span></span><span><span><span>        </span><span>hostPath</span>:<span>
</span></span></span><span><span><span>          </span><span>path</span>:<span> </span><span>"/var/lib/kubelet/plugins_registry"</span><span>
</span></span></span><span><span><span>      </span>- <span>name</span>:<span> </span>plugins<span>
</span></span></span><span><span><span>        </span><span>hostPath</span>:<span>
</span></span></span><span><span><span>          </span><span>path</span>:<span> </span><span>"/var/lib/kubelet/plugins"</span><span>
</span></span></span><span><span><span>      </span>- <span>name</span>:<span> </span>cdi<span>
</span></span></span><span><span><span>        </span><span>hostPath</span>:<span>
</span></span></span><span><span><span>          </span><span>path</span>:<span> </span>/var/run/cdi</span></span></code></pre></div></div></div><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl apply --server-side -f http://k8s.io/examples/dra/driver-install/daemonset.yaml
</span></span></code></pre></div><p>The DaemonSet is configured with
the volume mounts necessary to interact with the underlying Container Device
Interface (CDI) directory, and to expose its socket to <code>kubelet</code> via the
<code>kubelet/plugins</code> directory.</p></li></ol><h3 id="verify-driver-install">Verify the DRA driver installation</h3><ol><li><p>Get a list of the Pods of the DRA driver DaemonSet across all worker nodes:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pod -l app.kubernetes.io/name<span>=</span>dra-example-driver -n dra-tutorial
</span></span></code></pre></div><p>The output is similar to this:</p><pre tabindex="0"><code>NAME                                     READY   STATUS    RESTARTS   AGE
dra-example-driver-kubeletplugin-4sk2x   1/1     Running   0          13s
dra-example-driver-kubeletplugin-cttr2   1/1     Running   0          13s
</code></pre></li><li><p>The initial responsibility of each node's local DRA driver is to update the
cluster with what devices are available to Pods on that node, by publishing its
metadata to the ResourceSlices API. You can check that API to see that each node
with a driver is advertising the device class it represents.</p><p>Check for available ResourceSlices:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get resourceslices
</span></span></code></pre></div><p>The output is similar to this:</p><pre tabindex="0"><code>NAME                                 NODE           DRIVER            POOL           AGE
kind-worker-gpu.example.com-k69gd    kind-worker    gpu.example.com   kind-worker    19s
kind-worker2-gpu.example.com-qdgpn   kind-worker2   gpu.example.com   kind-worker2   19s
</code></pre></li></ol><p>At this point, you have successfully installed the example DRA driver, and
confirmed its initial configuration. You're now ready to use DRA to schedule
Pods.</p><h2 id="claim-resources-pod">Claim resources and deploy a Pod</h2><p>To request resources using DRA, you create ResourceClaims or
ResourceClaimTemplates that define the resources that your Pods need. In the
example driver, a memory capacity attribute is exposed for mock GPU devices.
This section shows you how to use <a class="glossary-tooltip" title="An expression language that's designed to be safe for executing user code." href="https://cel.dev" target="_blank">Common Expression Language</a> to
express your requirements in a ResourceClaim, select that ResourceClaim in a Pod
specification, and observe the resource allocation.</p><p>This tutorial showcases only one basic example of a DRA ResourceClaim. Read
<a href="/docs/concepts/scheduling-eviction/dynamic-resource-allocation/">Dynamic Resource
Allocation</a> to
learn more about ResourceClaims.</p><h3 id="create-the-resourceclaim">Create the ResourceClaim</h3><p>In this section, you create a ResourceClaim and reference it in a Pod. Whatever
the claim, the <code>deviceClassName</code> is a required field, narrowing down the scope
of the request to a specific device class. The request itself can include a <a class="glossary-tooltip" title="An expression language that's designed to be safe for executing user code." href="https://cel.dev" target="_blank">Common Expression Language</a> expression that references attributes that
may be advertised by the driver managing that device class.</p><p>In this example, you will create a request for any GPU advertising over 10Gi
memory capacity. The attribute exposing capacity from the example driver takes
the form <code>device.capacity['gpu.example.com'].memory</code>. Note also that the name of
the claim is set to <code>some-gpu</code>.</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/dra/driver-install/example/resourceclaim.yaml"><code>dra/driver-install/example/resourceclaim.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" title="Copy dra/driver-install/example/resourceclaim.yaml to clipboard"></div><div class="includecode" id="dra-driver-install-example-resourceclaim-yaml"><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span>apiVersion</span>:<span> </span>resource.k8s.io/v1<span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>ResourceClaim<span>
</span></span></span><span><span><span></span><span>metadata</span>:<span>
</span></span></span><span><span><span> </span><span>name</span>:<span> </span>some-gpu<span>
</span></span></span><span><span><span> </span><span>namespace</span>:<span> </span>dra-tutorial<span>
</span></span></span><span><span><span></span><span>spec</span>:<span>
</span></span></span><span><span><span>   </span><span>devices</span>:<span>
</span></span></span><span><span><span>     </span><span>requests</span>:<span>
</span></span></span><span><span><span>     </span>- <span>name</span>:<span> </span>some-gpu<span>
</span></span></span><span><span><span>       </span><span>exactly</span>:<span>
</span></span></span><span><span><span>         </span><span>deviceClassName</span>:<span> </span>gpu.example.com<span>
</span></span></span><span><span><span>         </span><span>selectors</span>:<span>
</span></span></span><span><span><span>         </span>- <span>cel</span>:<span>
</span></span></span><span><span><span>             </span><span>expression</span>:<span> </span><span>"device.capacity['gpu.example.com'].memory.compareTo(quantity('10Gi')) &gt;= 0"</span></span></span></code></pre></div></div></div><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl apply --server-side -f http://k8s.io/examples/dra/driver-install/example/resourceclaim.yaml
</span></span></code></pre></div><h3 id="create-the-pod-that-references-that-resourceclaim">Create the Pod that references that ResourceClaim</h3><p>Below is the Pod manifest referencing the ResourceClaim you just made,
<code>some-gpu</code>, in the <code>spec.resourceClaims.resourceClaimName</code> field. The local name
for that claim, <code>gpu</code>, is then used in the
<code>spec.containers.resources.claims.name</code> field to allocate the claim to the Pod's
underlying container.</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/dra/driver-install/example/pod.yaml"><code>dra/driver-install/example/pod.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" title="Copy dra/driver-install/example/pod.yaml to clipboard"></div><div class="includecode" id="dra-driver-install-example-pod-yaml"><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span>apiVersion</span>:<span> </span>v1<span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>Pod<span>
</span></span></span><span><span><span></span><span>metadata</span>:<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>pod0<span>
</span></span></span><span><span><span>  </span><span>namespace</span>:<span> </span>dra-tutorial<span>
</span></span></span><span><span><span>  </span><span>labels</span>:<span>
</span></span></span><span><span><span>    </span><span>app</span>:<span> </span>pod<span>
</span></span></span><span><span><span></span><span>spec</span>:<span>
</span></span></span><span><span><span>  </span><span>containers</span>:<span>
</span></span></span><span><span><span>  </span>- <span>name</span>:<span> </span>ctr0<span>
</span></span></span><span><span><span>    </span><span>image</span>:<span> </span>ubuntu:24.04<span>
</span></span></span><span><span><span>    </span><span>command</span>:<span> </span>[<span>"bash"</span>,<span> </span><span>"-c"</span>]<span>
</span></span></span><span><span><span>    </span><span>args</span>:<span> </span>[<span>"export; trap 'exit 0' TERM; sleep 9999 &amp; wait"</span>]<span>
</span></span></span><span><span><span>    </span><span>resources</span>:<span>
</span></span></span><span><span><span>      </span><span>claims</span>:<span>
</span></span></span><span><span><span>      </span>- <span>name</span>:<span> </span>gpu<span>
</span></span></span><span><span><span>  </span><span>resourceClaims</span>:<span>
</span></span></span><span><span><span>  </span>- <span>name</span>:<span> </span>gpu<span>
</span></span></span><span><span><span>    </span><span>resourceClaimName</span>:<span> </span>some-gpu</span></span></code></pre></div></div></div><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl apply --server-side -f http://k8s.io/examples/dra/driver-install/example/pod.yaml
</span></span></code></pre></div><ol><li><p>Confirm the pod has deployed:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pod pod0 -n dra-tutorial
</span></span></code></pre></div><p>The output is similar to this:</p><pre tabindex="0"><code>NAME   READY   STATUS    RESTARTS   AGE
pod0   1/1     Running   0          9s
</code></pre></li></ol><h3 id="explore-the-dra-state">Explore the DRA state</h3><p>After you create the Pod, the cluster tries to schedule that Pod to a node where
Kubernetes can satisfy the ResourceClaim. In this tutorial, the DRA driver is
deployed on all nodes, and is advertising mock GPUs on all nodes, all of which
have enough capacity advertised to satisfy the Pod's claim, so Kubernetes can
schedule this Pod on any node and can allocate any of the mock GPUs on that
node.</p><p>When Kubernetes allocates a mock GPU to a Pod, the example driver adds
environment variables in each container it is allocated to in order to indicate
which GPUs <em>would</em> have been injected into them by a real resource driver and
how they would have been configured, so you can check those environment
variables to see how the Pods have been handled by the system.</p><ol><li><p>Check the Pod logs, which report the name of the mock GPU that was allocated:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl logs pod0 -c ctr0 -n dra-tutorial | grep -E <span>"GPU_DEVICE_[0-9]+="</span> | grep -v <span>"RESOURCE_CLAIM"</span>
</span></span></code></pre></div><p>The output is similar to this:</p><pre tabindex="0"><code>declare -x GPU_DEVICE_0="gpu-0"
</code></pre></li><li><p>Check the state of the ResourceClaim object:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get resourceclaims -n dra-tutorial
</span></span></code></pre></div><p>The output is similar to this:</p><pre tabindex="0"><code>NAME       STATE                AGE
some-gpu   allocated,reserved   34s
</code></pre><p>In this output, the <code>STATE</code> column shows that the ResourceClaim is allocated
and reserved.</p></li><li><p>Check the details of the <code>some-gpu</code> ResourceClaim. The <code>status</code> stanza of
the ResourceClaim has information about the allocated device and the Pod it
has been reserved for:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get resourceclaim some-gpu -n dra-tutorial -o yaml
</span></span></code></pre></div><p>The output is similar to this:<div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span> 1</span><span><span>apiVersion</span>:<span> </span>resource.k8s.io/v1<span>
</span></span></span><span><span> 2</span><span><span></span><span>kind</span>:<span> </span>ResourceClaim<span>
</span></span></span><span><span> 3</span><span><span></span><span>metadata</span>:<span>
</span></span></span><span><span> 4</span><span><span>    </span><span>creationTimestamp</span>:<span> </span><span>"2025-08-20T18:17:31Z"</span><span>
</span></span></span><span><span> 5</span><span><span>    </span><span>finalizers</span>:<span>
</span></span></span><span><span> 6</span><span><span>    </span>- resource.kubernetes.io/delete-protection<span>
</span></span></span><span><span> 7</span><span><span>    </span><span>name</span>:<span> </span>some-gpu<span>
</span></span></span><span><span> 8</span><span><span>    </span><span>namespace</span>:<span> </span>dra-tutorial<span>
</span></span></span><span><span> 9</span><span><span>    </span><span>resourceVersion</span>:<span> </span><span>"2326"</span><span>
</span></span></span><span><span>10</span><span><span>    </span><span>uid</span>:<span> </span>d3e48dbf-40da-47c3-a7b9-f7d54d1051c3<span>
</span></span></span><span><span>11</span><span><span></span><span>spec</span>:<span>
</span></span></span><span><span>12</span><span><span>    </span><span>devices</span>:<span>
</span></span></span><span><span>13</span><span><span>        </span><span>requests</span>:<span>
</span></span></span><span><span>14</span><span><span>        </span>- <span>exactly</span>:<span>
</span></span></span><span><span>15</span><span><span>            </span><span>allocationMode</span>:<span> </span>ExactCount<span>
</span></span></span><span><span>16</span><span><span>            </span><span>count</span>:<span> </span><span>1</span><span>
</span></span></span><span><span>17</span><span><span>            </span><span>deviceClassName</span>:<span> </span>gpu.example.com<span>
</span></span></span><span><span>18</span><span><span>            </span><span>selectors</span>:<span>
</span></span></span><span><span>19</span><span><span>            </span>- <span>cel</span>:<span>
</span></span></span><span><span>20</span><span><span>                </span><span>expression</span>:<span> </span>device.capacity['gpu.example.com'].memory.compareTo(quantity('10Gi'))<span>
</span></span></span><span><span>21</span><span><span>                </span>&gt;= 0<span>
</span></span></span><span><span>22</span><span><span>        </span><span>name</span>:<span> </span>some-gpu<span>
</span></span></span><span><span>23</span><span><span></span><span>status</span>:<span>
</span></span></span><span><span>24</span><span><span>    </span><span>allocation</span>:<span>
</span></span></span><span><span>25</span><span><span>        </span><span>devices</span>:<span>
</span></span></span><span><span>26</span><span><span>        </span><span>results</span>:<span>
</span></span></span><span><span>27</span><span><span>        </span>- <span>device</span>:<span> </span>gpu-0<span>
</span></span></span><span><span>28</span><span><span>            </span><span>driver</span>:<span> </span>gpu.example.com<span>
</span></span></span><span><span>29</span><span><span>            </span><span>pool</span>:<span> </span>kind-worker<span>
</span></span></span><span><span>30</span><span><span>            </span><span>request</span>:<span> </span>some-gpu<span>
</span></span></span><span><span>31</span><span><span>        </span><span>nodeSelector</span>:<span>
</span></span></span><span><span>32</span><span><span>        </span><span>nodeSelectorTerms</span>:<span>
</span></span></span><span><span>33</span><span><span>        </span>- <span>matchFields</span>:<span>
</span></span></span><span><span>34</span><span><span>            </span>- <span>key</span>:<span> </span>metadata.name<span>
</span></span></span><span><span>35</span><span><span>            </span><span>operator</span>:<span> </span>In<span>
</span></span></span><span><span>36</span><span><span>            </span><span>values</span>:<span>
</span></span></span><span><span>37</span><span><span>            </span>- kind-worker<span>
</span></span></span><span><span>38</span><span><span>    </span><span>reservedFor</span>:<span>
</span></span></span><span><span>39</span><span><span>    </span>- <span>name</span>:<span> </span>pod0<span>
</span></span></span><span><span>40</span><span><span>        </span><span>resource</span>:<span> </span>pods<span>
</span></span></span><span><span>41</span><span><span>        </span><span>uid</span>:<span> </span>c4dadf20-392a-474d-a47b-ab82080c8bd7</span></span></code></pre></div></p></li><li><p>To check how the driver handled device allocation, get the logs for the
driver DaemonSet Pods:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl logs -l app.kubernetes.io/name<span>=</span>dra-example-driver -n dra-tutorial
</span></span></code></pre></div><p>The output is similar to this:</p><pre tabindex="0"><code>I0820 18:17:44.131324       1 driver.go:106] PrepareResourceClaims is called: number of claims: 1
I0820 18:17:44.135056       1 driver.go:133] Returning newly prepared devices for claim 'd3e48dbf-40da-47c3-a7b9-f7d54d1051c3': [{[some-gpu] kind-worker gpu-0 [k8s.gpu.example.com/gpu=common k8s.gpu.example.com/gpu=d3e48dbf-40da-47c3-a7b9-f7d54d1051c3-gpu-0]}]
</code></pre></li></ol><p>You have now successfully deployed a Pod that claims devices using DRA, verified
that the Pod was scheduled to an appropriate node, and saw that the associated
DRA APIs kinds were updated with the allocation status.</p><h2 id="delete-pod-claim">Delete a Pod that has a claim</h2><p>When a Pod with a claim is deleted, the DRA driver deallocates the resource so
it can be available for future scheduling. To validate this behavior, delete the
Pod that you created in the previous steps and watch the corresponding changes
to the ResourceClaim and driver.</p><ol><li><p>Delete the <code>pod0</code> Pod:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl delete pod pod0 -n dra-tutorial
</span></span></code></pre></div><p>The output is similar to this:</p><pre tabindex="0"><code>pod "pod0" deleted
</code></pre></li></ol><h3 id="observe-the-dra-state">Observe the DRA state</h3><p>When the Pod is deleted, the driver deallocates the device from the
ResourceClaim and updates the ResourceClaim resource in the Kubernetes API. The
ResourceClaim has a <code>pending</code> state until it's referenced in a new Pod.</p><ol><li><p>Check the state of the <code>some-gpu</code> ResourceClaim:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get resourceclaims -n dra-tutorial
</span></span></code></pre></div><p>The output is similar to this:</p><pre tabindex="0"><code>NAME       STATE     AGE
some-gpu   pending   76s
</code></pre></li><li><p>Verify that the driver has processed unpreparing the device for this claim by
checking the driver logs:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl logs -l app.kubernetes.io/name<span>=</span>dra-example-driver -n dra-tutorial
</span></span></code></pre></div><p>The output is similar to this:</p><pre tabindex="0"><code>I0820 18:22:15.629376       1 driver.go:138] UnprepareResourceClaims is called: number of claims: 1
</code></pre></li></ol><p>You have now deleted a Pod that had a claim, and observed that the driver took
action to unprepare the underlying hardware resource and update the DRA APIs to
reflect that the resource is available again for future scheduling.</p><h2 id="cleaning-up">Cleaning up</h2><p>To clean up the resources that you created in this tutorial, follow these steps:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl delete namespace dra-tutorial
</span></span><span><span>kubectl delete deviceclass gpu.example.com
</span></span><span><span>kubectl delete clusterrole dra-example-driver-role
</span></span><span><span>kubectl delete clusterrolebinding dra-example-driver-role-binding
</span></span><span><span>kubectl delete priorityclass dra-driver-high-priority
</span></span></code></pre></div><h2 id="what-s-next">What's next</h2><ul><li><a href="/docs/concepts/scheduling-eviction/dynamic-resource-allocation/">Learn more about DRA</a></li><li><a href="/docs/tasks/configure-pod-container/assign-resources/allocate-devices-dra/">Allocate Devices to Workloads with DRA</a></li></ul></div></div><div><div class="td-content"><h1>Namespaces Walkthrough</h1><p>Kubernetes <a class="glossary-tooltip" title="An abstraction used by Kubernetes to support isolation of groups of resources within a single cluster." href="/docs/concepts/overview/working-with-objects/namespaces" target="_blank">namespaces</a>
help different projects, teams, or customers to share a Kubernetes cluster.</p><p>It does this by providing the following:</p><ol><li>A scope for <a href="/docs/concepts/overview/working-with-objects/names/">Names</a>.</li><li>A mechanism to attach authorization and policy to a subsection of the cluster.</li></ol><p>Use of multiple namespaces is optional.</p><p>This example demonstrates how to use Kubernetes namespaces to subdivide your cluster.</p><h2 id="before-you-begin">Before you begin</h2><p><p>You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. It is recommended to run this tutorial on a cluster with at least two nodes that are not acting as control plane hosts. If you do not already have a
cluster, you can create one by using
<a href="https://minikube.sigs.k8s.io/docs/tutorials/multi_node/">minikube</a>
or you can use one of these Kubernetes playgrounds:</p><ul><li><a href="https://labs.iximiuz.com/playgrounds?category=kubernetes&amp;filter=all">iximiuz Labs</a></li><li><a href="https://killercoda.com/playgrounds/scenario/kubernetes">Killercoda</a></li><li><a href="https://kodekloud.com/public-playgrounds">KodeKloud</a></li><li><a href="https://labs.play-with-k8s.com/">Play with Kubernetes</a></li></ul><p>To check the version, enter <code>kubectl version</code>.</p></p><h2 id="prerequisites">Prerequisites</h2><p>This example assumes the following:</p><ol><li>You have an <a href="/docs/setup/">existing Kubernetes cluster</a>.</li><li>You have a basic understanding of Kubernetes <a class="glossary-tooltip" title="A Pod represents a set of running containers in your cluster." href="/docs/concepts/workloads/pods/" target="_blank">Pods</a>, <a class="glossary-tooltip" title="A way to expose an application running on a set of Pods as a network service." href="/docs/concepts/services-networking/service/" target="_blank">Services</a>, and <a class="glossary-tooltip" title="Manages a replicated application on your cluster." href="/docs/concepts/workloads/controllers/deployment/" target="_blank">Deployments</a>.</li></ol><h2 id="understand-the-default-namespace">Understand the default namespace</h2><p>By default, a Kubernetes cluster will instantiate a default namespace when provisioning the cluster to hold the default set of Pods,
Services, and Deployments used by the cluster.</p><p>Assuming you have a fresh cluster, you can inspect the available namespaces by doing the following:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get namespaces
</span></span></code></pre></div><pre tabindex="0"><code>NAME      STATUS    AGE
default   Active    13m
</code></pre><h2 id="create-new-namespaces">Create new namespaces</h2><p>For this exercise, we will create two additional Kubernetes namespaces to hold our content.</p><p>Let's imagine a scenario where an organization is using a shared Kubernetes cluster for development and production use cases.</p><p>The development team would like to maintain a space in the cluster where they can get a view on the list of Pods, Services, and Deployments
they use to build and run their application. In this space, Kubernetes resources come and go, and the restrictions on who can or cannot modify resources
are relaxed to enable agile development.</p><p>The operations team would like to maintain a space in the cluster where they can enforce strict procedures on who can or cannot manipulate the set of
Pods, Services, and Deployments that run the production site.</p><p>One pattern this organization could follow is to partition the Kubernetes cluster into two namespaces: <code>development</code> and <code>production</code>.</p><p>Let's create two new namespaces to hold our work.</p><p>Use the file <a href="/examples/admin/namespace-dev.yaml"><code>namespace-dev.yaml</code></a> which describes a <code>development</code> namespace:</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/admin/namespace-dev.yaml"><code>admin/namespace-dev.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" title="Copy admin/namespace-dev.yaml to clipboard"></div><div class="includecode" id="admin-namespace-dev-yaml"><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span>apiVersion</span>:<span> </span>v1<span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>Namespace<span>
</span></span></span><span><span><span></span><span>metadata</span>:<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>development<span>
</span></span></span><span><span><span>  </span><span>labels</span>:<span>
</span></span></span><span><span><span>    </span><span>name</span>:<span> </span>development<span>
</span></span></span></code></pre></div></div></div><p>Create the <code>development</code> namespace using kubectl.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl create -f https://k8s.io/examples/admin/namespace-dev.yaml
</span></span></code></pre></div><p>Save the following contents into file <a href="/examples/admin/namespace-prod.yaml"><code>namespace-prod.yaml</code></a> which describes a <code>production</code> namespace:</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/admin/namespace-prod.yaml"><code>admin/namespace-prod.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" title="Copy admin/namespace-prod.yaml to clipboard"></div><div class="includecode" id="admin-namespace-prod-yaml"><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span>apiVersion</span>:<span> </span>v1<span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>Namespace<span>
</span></span></span><span><span><span></span><span>metadata</span>:<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>production<span>
</span></span></span><span><span><span>  </span><span>labels</span>:<span>
</span></span></span><span><span><span>    </span><span>name</span>:<span> </span>production<span>
</span></span></span></code></pre></div></div></div><p>And then let's create the <code>production</code> namespace using kubectl.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl create -f https://k8s.io/examples/admin/namespace-prod.yaml
</span></span></code></pre></div><p>To be sure things are right, let's list all of the namespaces in our cluster.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get namespaces --show-labels
</span></span></code></pre></div><pre tabindex="0"><code>NAME          STATUS    AGE       LABELS
default       Active    32m       &lt;none&gt;
development   Active    29s       name=development
production    Active    23s       name=production
</code></pre><h2 id="create-pods-in-each-namespace">Create pods in each namespace</h2><p>A Kubernetes namespace provides the scope for Pods, Services, and Deployments in the cluster.</p><p>Users interacting with one namespace do not see the content in another namespace.</p><p>To demonstrate this, let's spin up a simple Deployment and Pods in the <code>development</code> namespace.</p><p>We first check what is the current context:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl config view
</span></span></code></pre></div><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span>apiVersion</span>:<span> </span>v1<span>
</span></span></span><span><span><span></span><span>clusters</span>:<span>
</span></span></span><span><span><span></span>- <span>cluster</span>:<span>
</span></span></span><span><span><span>    </span><span>certificate-authority-data</span>:<span> </span>REDACTED<span>
</span></span></span><span><span><span>    </span><span>server</span>:<span> </span>https://130.211.122.180<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>lithe-cocoa-92103_kubernetes<span>
</span></span></span><span><span><span></span><span>contexts</span>:<span>
</span></span></span><span><span><span></span>- <span>context</span>:<span>
</span></span></span><span><span><span>    </span><span>cluster</span>:<span> </span>lithe-cocoa-92103_kubernetes<span>
</span></span></span><span><span><span>    </span><span>user</span>:<span> </span>lithe-cocoa-92103_kubernetes<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>lithe-cocoa-92103_kubernetes<span>
</span></span></span><span><span><span></span><span>current-context</span>:<span> </span>lithe-cocoa-92103_kubernetes<span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>Config<span>
</span></span></span><span><span><span></span><span>preferences</span>:<span> </span>{}<span>
</span></span></span><span><span><span></span><span>users</span>:<span>
</span></span></span><span><span><span></span>- <span>name</span>:<span> </span>lithe-cocoa-92103_kubernetes<span>
</span></span></span><span><span><span>  </span><span>user</span>:<span>
</span></span></span><span><span><span>    </span><span>client-certificate-data</span>:<span> </span>REDACTED<span>
</span></span></span><span><span><span>    </span><span>client-key-data</span>:<span> </span>REDACTED<span>
</span></span></span><span><span><span>    </span><span>token</span>:<span> </span>65rZW78y8HbwXXtSXuUw9DbP4FLjHi4b<span>
</span></span></span><span><span><span></span>- <span>name</span>:<span> </span>lithe-cocoa-92103_kubernetes-basic-auth<span>
</span></span></span><span><span><span>  </span><span>user</span>:<span>
</span></span></span><span><span><span>    </span><span>password</span>:<span> </span>h5M0FtUUIflBSdI7<span>
</span></span></span><span><span><span>    </span><span>username</span>:<span> </span>admin<span>
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl config current-context
</span></span></code></pre></div><pre tabindex="0"><code>lithe-cocoa-92103_kubernetes
</code></pre><p>The next step is to define a context for the kubectl client to work in each namespace. The value of "cluster" and "user" fields are copied from the current context.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl config set-context dev --namespace<span>=</span>development <span>\
</span></span></span><span><span><span></span>  --cluster<span>=</span>lithe-cocoa-92103_kubernetes <span>\
</span></span></span><span><span><span></span>  --user<span>=</span>lithe-cocoa-92103_kubernetes
</span></span><span><span>
</span></span><span><span>kubectl config set-context prod --namespace<span>=</span>production <span>\
</span></span></span><span><span><span></span>  --cluster<span>=</span>lithe-cocoa-92103_kubernetes <span>\
</span></span></span><span><span><span></span>  --user<span>=</span>lithe-cocoa-92103_kubernetes
</span></span></code></pre></div><p>By default, the above commands add two contexts that are saved into file
<code>.kube/config</code>. You can now view the contexts and alternate against the two
new request contexts depending on which namespace you wish to work against.</p><p>To view the new contexts:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl config view
</span></span></code></pre></div><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span>apiVersion</span>:<span> </span>v1<span>
</span></span></span><span><span><span></span><span>clusters</span>:<span>
</span></span></span><span><span><span></span>- <span>cluster</span>:<span>
</span></span></span><span><span><span>    </span><span>certificate-authority-data</span>:<span> </span>REDACTED<span>
</span></span></span><span><span><span>    </span><span>server</span>:<span> </span>https://130.211.122.180<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>lithe-cocoa-92103_kubernetes<span>
</span></span></span><span><span><span></span><span>contexts</span>:<span>
</span></span></span><span><span><span></span>- <span>context</span>:<span>
</span></span></span><span><span><span>    </span><span>cluster</span>:<span> </span>lithe-cocoa-92103_kubernetes<span>
</span></span></span><span><span><span>    </span><span>user</span>:<span> </span>lithe-cocoa-92103_kubernetes<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>lithe-cocoa-92103_kubernetes<span>
</span></span></span><span><span><span></span>- <span>context</span>:<span>
</span></span></span><span><span><span>    </span><span>cluster</span>:<span> </span>lithe-cocoa-92103_kubernetes<span>
</span></span></span><span><span><span>    </span><span>namespace</span>:<span> </span>development<span>
</span></span></span><span><span><span>    </span><span>user</span>:<span> </span>lithe-cocoa-92103_kubernetes<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>dev<span>
</span></span></span><span><span><span></span>- <span>context</span>:<span>
</span></span></span><span><span><span>    </span><span>cluster</span>:<span> </span>lithe-cocoa-92103_kubernetes<span>
</span></span></span><span><span><span>    </span><span>namespace</span>:<span> </span>production<span>
</span></span></span><span><span><span>    </span><span>user</span>:<span> </span>lithe-cocoa-92103_kubernetes<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>prod<span>
</span></span></span><span><span><span></span><span>current-context</span>:<span> </span>lithe-cocoa-92103_kubernetes<span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>Config<span>
</span></span></span><span><span><span></span><span>preferences</span>:<span> </span>{}<span>
</span></span></span><span><span><span></span><span>users</span>:<span>
</span></span></span><span><span><span></span>- <span>name</span>:<span> </span>lithe-cocoa-92103_kubernetes<span>
</span></span></span><span><span><span>  </span><span>user</span>:<span>
</span></span></span><span><span><span>    </span><span>client-certificate-data</span>:<span> </span>REDACTED<span>
</span></span></span><span><span><span>    </span><span>client-key-data</span>:<span> </span>REDACTED<span>
</span></span></span><span><span><span>    </span><span>token</span>:<span> </span>65rZW78y8HbwXXtSXuUw9DbP4FLjHi4b<span>
</span></span></span><span><span><span></span>- <span>name</span>:<span> </span>lithe-cocoa-92103_kubernetes-basic-auth<span>
</span></span></span><span><span><span>  </span><span>user</span>:<span>
</span></span></span><span><span><span>    </span><span>password</span>:<span> </span>h5M0FtUUIflBSdI7<span>
</span></span></span><span><span><span>    </span><span>username</span>:<span> </span>admin<span>
</span></span></span></code></pre></div><p>Let's switch to operate in the <code>development</code> namespace.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl config use-context dev
</span></span></code></pre></div><p>You can verify your current context by doing the following:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl config current-context
</span></span></code></pre></div><pre tabindex="0"><code>dev
</code></pre><p>At this point, all requests we make to the Kubernetes cluster from the command line are scoped to the <code>development</code> namespace.</p><p>Let's create some contents.</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/admin/snowflake-deployment.yaml"><code>admin/snowflake-deployment.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" title="Copy admin/snowflake-deployment.yaml to clipboard"></div><div class="includecode" id="admin-snowflake-deployment-yaml"><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span>apiVersion</span>:<span> </span>apps/v1<span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>Deployment<span>
</span></span></span><span><span><span></span><span>metadata</span>:<span>
</span></span></span><span><span><span>  </span><span>labels</span>:<span>
</span></span></span><span><span><span>    </span><span>app</span>:<span> </span>snowflake<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>snowflake<span>
</span></span></span><span><span><span></span><span>spec</span>:<span>
</span></span></span><span><span><span>  </span><span>replicas</span>:<span> </span><span>2</span><span>
</span></span></span><span><span><span>  </span><span>selector</span>:<span>
</span></span></span><span><span><span>    </span><span>matchLabels</span>:<span>
</span></span></span><span><span><span>      </span><span>app</span>:<span> </span>snowflake<span>
</span></span></span><span><span><span>  </span><span>template</span>:<span>
</span></span></span><span><span><span>    </span><span>metadata</span>:<span>
</span></span></span><span><span><span>      </span><span>labels</span>:<span>
</span></span></span><span><span><span>        </span><span>app</span>:<span> </span>snowflake<span>
</span></span></span><span><span><span>    </span><span>spec</span>:<span>
</span></span></span><span><span><span>      </span><span>containers</span>:<span>
</span></span></span><span><span><span>      </span>- <span>image</span>:<span> </span>registry.k8s.io/serve_hostname<span>
</span></span></span><span><span><span>        </span><span>imagePullPolicy</span>:<span> </span>Always<span>
</span></span></span><span><span><span>        </span><span>name</span>:<span> </span>snowflake<span>
</span></span></span></code></pre></div></div></div><p>Apply the manifest to create a Deployment</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl apply -f https://k8s.io/examples/admin/snowflake-deployment.yaml
</span></span></code></pre></div><p>We have created a deployment whose replica size is 2 that is running the pod called <code>snowflake</code> with a basic container that serves the hostname.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get deployment
</span></span></code></pre></div><pre tabindex="0"><code>NAME         READY   UP-TO-DATE   AVAILABLE   AGE
snowflake    2/2     2            2           2m
</code></pre><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pods -l <span>app</span><span>=</span>snowflake
</span></span></code></pre></div><pre tabindex="0"><code>NAME                         READY     STATUS    RESTARTS   AGE
snowflake-3968820950-9dgr8   1/1       Running   0          2m
snowflake-3968820950-vgc4n   1/1       Running   0          2m
</code></pre><p>And this is great, developers are able to do what they want, and they do not have to worry about affecting content in the <code>production</code> namespace.</p><p>Let's switch to the <code>production</code> namespace and show how resources in one namespace are hidden from the other.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl config use-context prod
</span></span></code></pre></div><p>The <code>production</code> namespace should be empty, and the following commands should return nothing.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get deployment
</span></span><span><span>kubectl get pods
</span></span></code></pre></div><p>Production likes to run cattle, so let's create some cattle pods.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl create deployment cattle --image<span>=</span>registry.k8s.io/serve_hostname --replicas<span>=</span><span>5</span>
</span></span><span><span>
</span></span><span><span>kubectl get deployment
</span></span></code></pre></div><pre tabindex="0"><code>NAME         READY   UP-TO-DATE   AVAILABLE   AGE
cattle       5/5     5            5           10s
</code></pre><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pods -l <span>app</span><span>=</span>cattle
</span></span></code></pre></div><pre tabindex="0"><code>NAME                      READY     STATUS    RESTARTS   AGE
cattle-2263376956-41xy6   1/1       Running   0          34s
cattle-2263376956-kw466   1/1       Running   0          34s
cattle-2263376956-n4v97   1/1       Running   0          34s
cattle-2263376956-p5p3i   1/1       Running   0          34s
cattle-2263376956-sxpth   1/1       Running   0          34s
</code></pre><p>At this point, it should be clear that the resources users create in one namespace are hidden from the other namespace.</p><p>As the policy support in Kubernetes evolves, we will extend this scenario to show how you can provide different
authorization rules for each namespace.</p></div></div><div><div class="td-content"><h1>Services</h1><div class="section-index"><hr class="panel-line"><div class="entry"><h5><a href="/docs/tutorials/services/connect-applications-service/">Connecting Applications with Services</a></h5><p></p></div><div class="entry"><h5><a href="/docs/tutorials/services/source-ip/">Using Source IP</a></h5><p></p></div><div class="entry"><h5><a href="/docs/tutorials/services/pods-and-endpoint-termination-flow/">Explore Termination Behavior for Pods And Their Endpoints</a></h5><p></p></div></div></div></div><div><div class="td-content"><h1>Connecting Applications with Services</h1><h2 id="the-kubernetes-model-for-connecting-containers">The Kubernetes model for connecting containers</h2><p>Now that you have a continuously running, replicated application you can expose it on a network.</p><p>Kubernetes assumes that pods can communicate with other pods, regardless of which host they land on.
Kubernetes gives every pod its own cluster-private IP address, so you do not need to explicitly
create links between pods or map container ports to host ports. This means that containers within
a Pod can all reach each other's ports on localhost, and all pods in a cluster can see each other
without NAT. The rest of this document elaborates on how you can run reliable services on such a
networking model.</p><p>This tutorial uses a simple nginx web server to demonstrate the concept.</p><h2 id="exposing-pods-to-the-cluster">Exposing pods to the cluster</h2><p>We did this in a previous example, but let's do it once again and focus on the networking perspective.
Create an nginx Pod, and note that it has a container port specification:</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/service/networking/run-my-nginx.yaml"><code>service/networking/run-my-nginx.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" title="Copy service/networking/run-my-nginx.yaml to clipboard"></div><div class="includecode" id="service-networking-run-my-nginx-yaml"><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span>apiVersion</span>:<span> </span>apps/v1<span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>Deployment<span>
</span></span></span><span><span><span></span><span>metadata</span>:<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>my-nginx<span>
</span></span></span><span><span><span></span><span>spec</span>:<span>
</span></span></span><span><span><span>  </span><span>selector</span>:<span>
</span></span></span><span><span><span>    </span><span>matchLabels</span>:<span>
</span></span></span><span><span><span>      </span><span>run</span>:<span> </span>my-nginx<span>
</span></span></span><span><span><span>  </span><span>replicas</span>:<span> </span><span>2</span><span>
</span></span></span><span><span><span>  </span><span>template</span>:<span>
</span></span></span><span><span><span>    </span><span>metadata</span>:<span>
</span></span></span><span><span><span>      </span><span>labels</span>:<span>
</span></span></span><span><span><span>        </span><span>run</span>:<span> </span>my-nginx<span>
</span></span></span><span><span><span>    </span><span>spec</span>:<span>
</span></span></span><span><span><span>      </span><span>containers</span>:<span>
</span></span></span><span><span><span>      </span>- <span>name</span>:<span> </span>my-nginx<span>
</span></span></span><span><span><span>        </span><span>image</span>:<span> </span>nginx<span>
</span></span></span><span><span><span>        </span><span>ports</span>:<span>
</span></span></span><span><span><span>        </span>- <span>containerPort</span>:<span> </span><span>80</span><span>
</span></span></span><span><span><span>
</span></span></span></code></pre></div></div></div><p>This makes it accessible from any node in your cluster. Check the nodes the Pod is running on:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl apply -f ./run-my-nginx.yaml
</span></span><span><span>kubectl get pods -l <span>run</span><span>=</span>my-nginx -o wide
</span></span></code></pre></div><pre tabindex="0"><code>NAME                        READY     STATUS    RESTARTS   AGE       IP            NODE
my-nginx-3800858182-jr4a2   1/1       Running   0          13s       10.244.3.4    kubernetes-minion-905m
my-nginx-3800858182-kna2y   1/1       Running   0          13s       10.244.2.5    kubernetes-minion-ljyd
</code></pre><p>Check your pods' IPs:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pods -l <span>run</span><span>=</span>my-nginx -o custom-columns<span>=</span>POD_IP:.status.podIPs
</span></span><span><span>    POD_IP
</span></span><span><span>    <span>[</span>map<span>[</span>ip:10.244.3.4<span>]]</span>
</span></span><span><span>    <span>[</span>map<span>[</span>ip:10.244.2.5<span>]]</span>
</span></span></code></pre></div><p>You should be able to ssh into any node in your cluster and use a tool such as <code>curl</code>
to make queries against both IPs. Note that the containers are <em>not</em> using port 80 on
the node, nor are there any special NAT rules to route traffic to the pod. This means
you can run multiple nginx pods on the same node all using the same <code>containerPort</code>,
and access them from any other pod or node in your cluster using the assigned IP
address for the pod. If you want to arrange for a specific port on the host
Node to be forwarded to backing Pods, you can - but the networking model should
mean that you do not need to do so.</p><p>You can read more about the
<a href="/docs/concepts/cluster-administration/networking/#the-kubernetes-network-model">Kubernetes Networking Model</a>
if you're curious.</p><h2 id="creating-a-service">Creating a Service</h2><p>So we have pods running nginx in a flat, cluster wide, address space. In theory,
you could talk to these pods directly, but what happens when a node dies? The pods
die with it, and the ReplicaSet inside the Deployment will create new ones, with different IPs. This is
the problem a Service solves.</p><p>A Kubernetes Service is an abstraction which defines a logical set of Pods running
somewhere in your cluster, that all provide the same functionality. When created,
each Service is assigned a unique IP address (also called clusterIP). This address
is tied to the lifespan of the Service, and will not change while the Service is alive.
Pods can be configured to talk to the Service, and know that communication to the
Service will be automatically load-balanced out to some pod that is a member of the Service.</p><p>You can create a Service for your 2 nginx replicas with <code>kubectl expose</code>:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl expose deployment/my-nginx
</span></span></code></pre></div><pre tabindex="0"><code>service/my-nginx exposed
</code></pre><p>This is equivalent to <code>kubectl apply -f</code> in the following yaml:</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/service/networking/nginx-svc.yaml"><code>service/networking/nginx-svc.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" title="Copy service/networking/nginx-svc.yaml to clipboard"></div><div class="includecode" id="service-networking-nginx-svc-yaml"><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span>apiVersion</span>:<span> </span>v1<span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>Service<span>
</span></span></span><span><span><span></span><span>metadata</span>:<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>my-nginx<span>
</span></span></span><span><span><span>  </span><span>labels</span>:<span>
</span></span></span><span><span><span>    </span><span>run</span>:<span> </span>my-nginx<span>
</span></span></span><span><span><span></span><span>spec</span>:<span>
</span></span></span><span><span><span>  </span><span>ports</span>:<span>
</span></span></span><span><span><span>  </span>- <span>port</span>:<span> </span><span>80</span><span>
</span></span></span><span><span><span>    </span><span>protocol</span>:<span> </span>TCP<span>
</span></span></span><span><span><span>  </span><span>selector</span>:<span>
</span></span></span><span><span><span>    </span><span>run</span>:<span> </span>my-nginx<span>
</span></span></span></code></pre></div></div></div><p>This specification will create a Service which targets TCP port 80 on any Pod
with the <code>run: my-nginx</code> label, and expose it on an abstracted Service port
(<code>targetPort</code>: is the port the container accepts traffic on, <code>port</code>: is the
abstracted Service port, which can be any port other pods use to access the
Service).
View <a href="/docs/reference/generated/kubernetes-api/v1.34/#service-v1-core">Service</a>
API object to see the list of supported fields in service definition.
Check your Service:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get svc my-nginx
</span></span></code></pre></div><pre tabindex="0"><code>NAME       TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)   AGE
my-nginx   ClusterIP   10.0.162.149   &lt;none&gt;        80/TCP    21s
</code></pre><p>As mentioned previously, a Service is backed by a group of Pods. These Pods are
exposed through
<a class="glossary-tooltip" title="EndpointSlices track the IP addresses of Pods for Services." href="/docs/concepts/services-networking/endpoint-slices/" target="_blank">EndpointSlices</a>.
The Service's selector will be evaluated continuously and the results will be POSTed
to an EndpointSlice that is connected to the Service using
<a class="glossary-tooltip" title="Tags objects with identifying attributes that are meaningful and relevant to users." href="/docs/concepts/overview/working-with-objects/labels" target="_blank">labels</a>.
When a Pod dies, it is automatically removed from the EndpointSlices that contain it
as an endpoint. New Pods that match the Service's selector will automatically get added
to an EndpointSlice for that Service.
Check the endpoints, and note that the IPs are the same as the Pods created in
the first step:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl describe svc my-nginx
</span></span></code></pre></div><pre tabindex="0"><code>Name:                my-nginx
Namespace:           default
Labels:              run=my-nginx
Annotations:         &lt;none&gt;
Selector:            run=my-nginx
Type:                ClusterIP
IP Family Policy:    SingleStack
IP Families:         IPv4
IP:                  10.0.162.149
IPs:                 10.0.162.149
Port:                &lt;unset&gt; 80/TCP
TargetPort:          80/TCP
Endpoints:           10.244.2.5:80,10.244.3.4:80
Session Affinity:    None
Events:              &lt;none&gt;
</code></pre><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get endpointslices -l kubernetes.io/service-name<span>=</span>my-nginx
</span></span></code></pre></div><pre tabindex="0"><code>NAME             ADDRESSTYPE   PORTS   ENDPOINTS               AGE
my-nginx-7vzhx   IPv4          80      10.244.2.5,10.244.3.4   21s
</code></pre><p>You should now be able to curl the nginx Service on <code>&lt;CLUSTER-IP&gt;:&lt;PORT&gt;</code> from
any node in your cluster. Note that the Service IP is completely virtual, it
never hits the wire. If you're curious about how this works you can read more
about the <a href="/docs/reference/networking/virtual-ips/">service proxy</a>.</p><h2 id="accessing-the-service">Accessing the Service</h2><p>Kubernetes supports 2 primary modes of finding a Service - environment variables
and DNS. The former works out of the box while the latter requires the
<a href="https://releases.k8s.io/v1.34.0/cluster/addons/dns/coredns">CoreDNS cluster addon</a>.</p><div class="alert alert-info"><h4 class="alert-heading">Note:</h4>If the service environment variables are not desired (because possible clashing
with expected program ones, too many variables to process, only using DNS, etc)
you can disable this mode by setting the <code>enableServiceLinks</code> flag to <code>false</code> on
the <a href="/docs/reference/generated/kubernetes-api/v1.34/#pod-v1-core">pod spec</a>.</div><h3 id="environment-variables">Environment Variables</h3><p>When a Pod runs on a Node, the kubelet adds a set of environment variables for
each active Service. This introduces an ordering problem. To see why, inspect
the environment of your running nginx Pods (your Pod name will be different):</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl <span>exec</span> my-nginx-3800858182-jr4a2 -- printenv | grep SERVICE
</span></span></code></pre></div><pre tabindex="0"><code>KUBERNETES_SERVICE_HOST=10.0.0.1
KUBERNETES_SERVICE_PORT=443
KUBERNETES_SERVICE_PORT_HTTPS=443
</code></pre><p>Note there's no mention of your Service. This is because you created the replicas
before the Service. Another disadvantage of doing this is that the scheduler might
put both Pods on the same machine, which will take your entire Service down if
it dies. We can do this the right way by killing the 2 Pods and waiting for the
Deployment to recreate them. This time the Service exists <em>before</em> the
replicas. This will give you scheduler-level Service spreading of your Pods
(provided all your nodes have equal capacity), as well as the right environment
variables:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl scale deployment my-nginx --replicas<span>=</span>0; kubectl scale deployment my-nginx --replicas<span>=</span>2;
</span></span><span><span>
</span></span><span><span>kubectl get pods -l <span>run</span><span>=</span>my-nginx -o wide
</span></span></code></pre></div><pre tabindex="0"><code>NAME                        READY     STATUS    RESTARTS   AGE     IP            NODE
my-nginx-3800858182-e9ihh   1/1       Running   0          5s      10.244.2.7    kubernetes-minion-ljyd
my-nginx-3800858182-j4rm4   1/1       Running   0          5s      10.244.3.8    kubernetes-minion-905m
</code></pre><p>You may notice that the pods have different names, since they are killed and recreated.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl <span>exec</span> my-nginx-3800858182-e9ihh -- printenv | grep SERVICE
</span></span></code></pre></div><pre tabindex="0"><code>KUBERNETES_SERVICE_PORT=443
MY_NGINX_SERVICE_HOST=10.0.162.149
KUBERNETES_SERVICE_HOST=10.0.0.1
MY_NGINX_SERVICE_PORT=80
KUBERNETES_SERVICE_PORT_HTTPS=443
</code></pre><h3 id="dns">DNS</h3><p>Kubernetes offers a DNS cluster addon Service that automatically assigns dns names
to other Services. You can check if it's running on your cluster:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get services kube-dns --namespace<span>=</span>kube-system
</span></span></code></pre></div><pre tabindex="0"><code>NAME       TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)         AGE
kube-dns   ClusterIP   10.0.0.10    &lt;none&gt;        53/UDP,53/TCP   8m
</code></pre><p>The rest of this section will assume you have a Service with a long lived IP
(my-nginx), and a DNS server that has assigned a name to that IP. Here we use
the CoreDNS cluster addon (application name <code>kube-dns</code>), so you can talk to the
Service from any pod in your cluster using standard methods (e.g. <code>gethostbyname()</code>).
If CoreDNS isn't running, you can enable it referring to the
<a href="https://github.com/coredns/deployment/tree/master/kubernetes">CoreDNS README</a>
or <a href="/docs/tasks/administer-cluster/coredns/#installing-coredns">Installing CoreDNS</a>.
Let's run another curl application to test this:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl run curl --image<span>=</span>radial/busyboxplus:curl -i --tty --rm
</span></span></code></pre></div><pre tabindex="0"><code>Waiting for pod default/curl-131556218-9fnch to be running, status is Pending, pod ready: false
Hit enter for command prompt
</code></pre><p>Then, hit enter and run <code>nslookup my-nginx</code>:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span>[</span> root@curl-131556218-9fnch:/ <span>]</span>$ nslookup my-nginx
</span></span><span><span>Server:    10.0.0.10
</span></span><span><span>Address 1: 10.0.0.10
</span></span><span><span>
</span></span><span><span>Name:      my-nginx
</span></span><span><span>Address 1: 10.0.162.149
</span></span></code></pre></div><h2 id="securing-the-service">Securing the Service</h2><p>Till now we have only accessed the nginx server from within the cluster. Before
exposing the Service to the internet, you want to make sure the communication
channel is secure. For this, you will need:</p><ul><li>Self signed certificates for https (unless you already have an identity certificate)</li><li>An nginx server configured to use the certificates</li><li>A <a href="/docs/concepts/configuration/secret/">secret</a> that makes the certificates accessible to pods</li></ul><p>You can acquire all these from the
<a href="https://github.com/kubernetes/examples/tree/master/_archived/https-nginx/">nginx https example</a>.
This requires having go and make tools installed. If you don't want to install those,
then follow the manual steps later. In short:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>make keys <span>KEY</span><span>=</span>/tmp/nginx.key <span>CERT</span><span>=</span>/tmp/nginx.crt
</span></span><span><span>kubectl create secret tls nginxsecret --key /tmp/nginx.key --cert /tmp/nginx.crt
</span></span></code></pre></div><pre tabindex="0"><code>secret/nginxsecret created
</code></pre><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get secrets
</span></span></code></pre></div><pre tabindex="0"><code>NAME                  TYPE                                  DATA      AGE
nginxsecret           kubernetes.io/tls                     2         1m
</code></pre><p>And also the configmap:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl create configmap nginxconfigmap --from-file<span>=</span>default.conf
</span></span></code></pre></div><p>You can find an example for <code>default.conf</code> in
<a href="https://github.com/kubernetes/examples/tree/bc9ca4ca32bb28762ef216386934bef20f1f9930/staging/https-nginx/">the Kubernetes examples project repo</a>.</p><pre tabindex="0"><code>configmap/nginxconfigmap created
</code></pre><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get configmaps
</span></span></code></pre></div><pre tabindex="0"><code>NAME             DATA   AGE
nginxconfigmap   1      114s
</code></pre><p>You can view the details of the <code>nginxconfigmap</code> ConfigMap using the following command:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl describe configmap  nginxconfigmap
</span></span></code></pre></div><p>The output is similar to:</p><div class="highlight"><pre tabindex="0"><code class="language-console"><span><span><span>Name:         nginxconfigmap
</span></span></span><span><span><span>Namespace:    default
</span></span></span><span><span><span>Labels:       &lt;none&gt;
</span></span></span><span><span><span>Annotations:  &lt;none&gt;
</span></span></span><span><span><span></span><span>
</span></span></span><span><span><span></span><span>Data
</span></span></span><span><span><span>====
</span></span></span><span><span><span>default.conf:
</span></span></span><span><span><span>----
</span></span></span><span><span><span>server {
</span></span></span><span><span><span>        listen 80 default_server;
</span></span></span><span><span><span>        listen [::]:80 default_server ipv6only=on;
</span></span></span><span><span><span></span><span>
</span></span></span><span><span><span></span><span>        listen 443 ssl;
</span></span></span><span><span><span></span><span>
</span></span></span><span><span><span></span><span>        root /usr/share/nginx/html;
</span></span></span><span><span><span>        index index.html;
</span></span></span><span><span><span></span><span>
</span></span></span><span><span><span></span><span>        server_name localhost;
</span></span></span><span><span><span>        ssl_certificate /etc/nginx/ssl/tls.crt;
</span></span></span><span><span><span>        ssl_certificate_key /etc/nginx/ssl/tls.key;
</span></span></span><span><span><span></span><span>
</span></span></span><span><span><span></span><span>        location / {
</span></span></span><span><span><span>                try_files $uri $uri/ =404;
</span></span></span><span><span><span>        }
</span></span></span><span><span><span>}
</span></span></span><span><span><span></span><span>
</span></span></span><span><span><span></span><span>BinaryData
</span></span></span><span><span><span>====
</span></span></span><span><span><span></span><span>
</span></span></span><span><span><span></span><span>Events:  &lt;none&gt;
</span></span></span></code></pre></div><p>Following are the manual steps to follow in case you run into problems running make (on windows for example):</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span># Create a public private key pair</span>
</span></span><span><span>openssl req -x509 -nodes -days <span>365</span> -newkey rsa:2048 -keyout /d/tmp/nginx.key -out /d/tmp/nginx.crt -subj <span>"/CN=my-nginx/O=my-nginx"</span>
</span></span><span><span><span># Convert the keys to base64 encoding</span>
</span></span><span><span>cat /d/tmp/nginx.crt | base64
</span></span><span><span>cat /d/tmp/nginx.key | base64
</span></span></code></pre></div><p>Use the output from the previous commands to create a yaml file as follows.
The base64 encoded value should all be on a single line.</p><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span>apiVersion</span>:<span> </span><span>"v1"</span><span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span><span>"Secret"</span><span>
</span></span></span><span><span><span></span><span>metadata</span>:<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span><span>"nginxsecret"</span><span>
</span></span></span><span><span><span>  </span><span>namespace</span>:<span> </span><span>"default"</span><span>
</span></span></span><span><span><span></span><span>type</span>:<span> </span>kubernetes.io/tls<span>
</span></span></span><span><span><span></span><span>data</span>:<span>
</span></span></span><span><span><span> </span><span># NOTE: Replace the following values with your own base64-encoded certificate and key.</span><span>
</span></span></span><span><span><span>  </span><span>tls.crt</span>:<span> </span><span>"REPLACE_WITH_BASE64_CERT"</span><span> 
</span></span></span><span><span><span>  </span><span>tls.key</span>:<span> </span><span>"REPLACE_WITH_BASE64_KEY"</span><span>
</span></span></span></code></pre></div><p>Now create the secrets using the file:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl apply -f nginxsecrets.yaml
</span></span><span><span>kubectl get secrets
</span></span></code></pre></div><pre tabindex="0"><code>NAME                  TYPE                                  DATA      AGE
nginxsecret           kubernetes.io/tls                     2         1m
</code></pre><p>Now modify your nginx replicas to start an https server using the certificate
in the secret, and the Service, to expose both ports (80 and 443):</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/service/networking/nginx-secure-app.yaml"><code>service/networking/nginx-secure-app.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" title="Copy service/networking/nginx-secure-app.yaml to clipboard"></div><div class="includecode" id="service-networking-nginx-secure-app-yaml"><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span>apiVersion</span>:<span> </span>v1<span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>Service<span>
</span></span></span><span><span><span></span><span>metadata</span>:<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>my-nginx<span>
</span></span></span><span><span><span>  </span><span>labels</span>:<span>
</span></span></span><span><span><span>    </span><span>run</span>:<span> </span>my-nginx<span>
</span></span></span><span><span><span></span><span>spec</span>:<span>
</span></span></span><span><span><span>  </span><span>type</span>:<span> </span>NodePort<span>
</span></span></span><span><span><span>  </span><span>ports</span>:<span>
</span></span></span><span><span><span>  </span>- <span>port</span>:<span> </span><span>8080</span><span>
</span></span></span><span><span><span>    </span><span>targetPort</span>:<span> </span><span>80</span><span>
</span></span></span><span><span><span>    </span><span>protocol</span>:<span> </span>TCP<span>
</span></span></span><span><span><span>    </span><span>name</span>:<span> </span>http<span>
</span></span></span><span><span><span>  </span>- <span>port</span>:<span> </span><span>443</span><span>
</span></span></span><span><span><span>    </span><span>protocol</span>:<span> </span>TCP<span>
</span></span></span><span><span><span>    </span><span>name</span>:<span> </span>https<span>
</span></span></span><span><span><span>  </span><span>selector</span>:<span>
</span></span></span><span><span><span>    </span><span>run</span>:<span> </span>my-nginx<span>
</span></span></span><span><span><span></span><span>---</span><span>
</span></span></span><span><span><span></span><span>apiVersion</span>:<span> </span>apps/v1<span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>Deployment<span>
</span></span></span><span><span><span></span><span>metadata</span>:<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>my-nginx<span>
</span></span></span><span><span><span></span><span>spec</span>:<span>
</span></span></span><span><span><span>  </span><span>selector</span>:<span>
</span></span></span><span><span><span>    </span><span>matchLabels</span>:<span>
</span></span></span><span><span><span>      </span><span>run</span>:<span> </span>my-nginx<span>
</span></span></span><span><span><span>  </span><span>replicas</span>:<span> </span><span>1</span><span>
</span></span></span><span><span><span>  </span><span>template</span>:<span>
</span></span></span><span><span><span>    </span><span>metadata</span>:<span>
</span></span></span><span><span><span>      </span><span>labels</span>:<span>
</span></span></span><span><span><span>        </span><span>run</span>:<span> </span>my-nginx<span>
</span></span></span><span><span><span>    </span><span>spec</span>:<span>
</span></span></span><span><span><span>      </span><span>volumes</span>:<span>
</span></span></span><span><span><span>      </span>- <span>name</span>:<span> </span>secret-volume<span>
</span></span></span><span><span><span>        </span><span>secret</span>:<span>
</span></span></span><span><span><span>          </span><span>secretName</span>:<span> </span>nginxsecret<span>
</span></span></span><span><span><span>      </span>- <span>name</span>:<span> </span>configmap-volume<span>
</span></span></span><span><span><span>        </span><span>configMap</span>:<span>
</span></span></span><span><span><span>          </span><span>name</span>:<span> </span>nginxconfigmap<span>
</span></span></span><span><span><span>      </span><span>containers</span>:<span>
</span></span></span><span><span><span>      </span>- <span>name</span>:<span> </span>nginxhttps<span>
</span></span></span><span><span><span>        </span><span>image</span>:<span> </span>bprashanth/nginxhttps:1.0<span>
</span></span></span><span><span><span>        </span><span>ports</span>:<span>
</span></span></span><span><span><span>        </span>- <span>containerPort</span>:<span> </span><span>443</span><span>
</span></span></span><span><span><span>        </span>- <span>containerPort</span>:<span> </span><span>80</span><span>
</span></span></span><span><span><span>        </span><span>volumeMounts</span>:<span>
</span></span></span><span><span><span>        </span>- <span>mountPath</span>:<span> </span>/etc/nginx/ssl<span>
</span></span></span><span><span><span>          </span><span>name</span>:<span> </span>secret-volume<span>
</span></span></span><span><span><span>        </span>- <span>mountPath</span>:<span> </span>/etc/nginx/conf.d<span>
</span></span></span><span><span><span>          </span><span>name</span>:<span> </span>configmap-volume<span>
</span></span></span></code></pre></div></div></div><p>Noteworthy points about the nginx-secure-app manifest:</p><ul><li>It contains both Deployment and Service specification in the same file.</li><li>The <a href="https://github.com/kubernetes/examples/blob/master/_archived/https-nginx/default.conf">nginx server</a>
serves HTTP traffic on port 80 and HTTPS traffic on 443, and nginx Service
exposes both ports.</li><li>Each container has access to the keys through a volume mounted at <code>/etc/nginx/ssl</code>.
This is set up <em>before</em> the nginx server is started.</li></ul><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl delete deployments,svc my-nginx; kubectl create -f ./nginx-secure-app.yaml
</span></span></code></pre></div><p>At this point you can reach the nginx server from any node.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pods -l <span>run</span><span>=</span>my-nginx -o custom-columns<span>=</span>POD_IP:.status.podIPs
</span></span><span><span>    POD_IP
</span></span><span><span>    <span>[</span>map<span>[</span>ip:10.244.3.5<span>]]</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>node $ curl -k https://10.244.3.5
</span></span><span><span>...
</span></span><span><span>&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;
</span></span></code></pre></div><p>Note how we supplied the <code>-k</code> parameter to curl in the last step, this is because
we don't know anything about the pods running nginx at certificate generation time,
so we have to tell curl to ignore the CName mismatch. By creating a Service we
linked the CName used in the certificate with the actual DNS name used by pods
during Service lookup. Let's test this from a pod (the same secret is being reused
for simplicity, the pod only needs nginx.crt to access the Service):</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/service/networking/curlpod.yaml"><code>service/networking/curlpod.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" title="Copy service/networking/curlpod.yaml to clipboard"></div><div class="includecode" id="service-networking-curlpod-yaml"><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span>apiVersion</span>:<span> </span>apps/v1<span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>Deployment<span>
</span></span></span><span><span><span></span><span>metadata</span>:<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>curl-deployment<span>
</span></span></span><span><span><span></span><span>spec</span>:<span>
</span></span></span><span><span><span>  </span><span>selector</span>:<span>
</span></span></span><span><span><span>    </span><span>matchLabels</span>:<span>
</span></span></span><span><span><span>      </span><span>app</span>:<span> </span>curlpod<span>
</span></span></span><span><span><span>  </span><span>replicas</span>:<span> </span><span>1</span><span>
</span></span></span><span><span><span>  </span><span>template</span>:<span>
</span></span></span><span><span><span>    </span><span>metadata</span>:<span>
</span></span></span><span><span><span>      </span><span>labels</span>:<span>
</span></span></span><span><span><span>        </span><span>app</span>:<span> </span>curlpod<span>
</span></span></span><span><span><span>    </span><span>spec</span>:<span>
</span></span></span><span><span><span>      </span><span>volumes</span>:<span>
</span></span></span><span><span><span>      </span>- <span>name</span>:<span> </span>secret-volume<span>
</span></span></span><span><span><span>        </span><span>secret</span>:<span>
</span></span></span><span><span><span>          </span><span>secretName</span>:<span> </span>nginxsecret<span>
</span></span></span><span><span><span>      </span><span>containers</span>:<span>
</span></span></span><span><span><span>      </span>- <span>name</span>:<span> </span>curlpod<span>
</span></span></span><span><span><span>        </span><span>command</span>:<span>
</span></span></span><span><span><span>        </span>- sh<span>
</span></span></span><span><span><span>        </span>- -c<span>
</span></span></span><span><span><span>        </span>- while true; do sleep 1; done<span>
</span></span></span><span><span><span>        </span><span>image</span>:<span> </span>radial/busyboxplus:curl<span>
</span></span></span><span><span><span>        </span><span>volumeMounts</span>:<span>
</span></span></span><span><span><span>        </span>- <span>mountPath</span>:<span> </span>/etc/nginx/ssl<span>
</span></span></span><span><span><span>          </span><span>name</span>:<span> </span>secret-volume<span>
</span></span></span></code></pre></div></div></div><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl apply -f ./curlpod.yaml
</span></span><span><span>kubectl get pods -l <span>app</span><span>=</span>curlpod
</span></span></code></pre></div><pre tabindex="0"><code>NAME                               READY     STATUS    RESTARTS   AGE
curl-deployment-1515033274-1410r   1/1       Running   0          1m
</code></pre><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl <span>exec</span> curl-deployment-1515033274-1410r -- curl https://my-nginx --cacert /etc/nginx/ssl/tls.crt
</span></span><span><span>...
</span></span><span><span>&lt;title&gt;Welcome to nginx!&lt;/title&gt;
</span></span><span><span>...
</span></span></code></pre></div><h2 id="exposing-the-service">Exposing the Service</h2><p>For some parts of your applications you may want to expose a Service onto an
external IP address. Kubernetes supports two ways of doing this: NodePorts and
LoadBalancers. The Service created in the last section already used <code>NodePort</code>,
so your nginx HTTPS replica is ready to serve traffic on the internet if your
node has a public IP.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get svc my-nginx -o yaml | grep nodePort -C <span>5</span>
</span></span><span><span>  uid: 07191fb3-f61a-11e5-8ae5-42010af00002
</span></span><span><span>spec:
</span></span><span><span>  clusterIP: 10.0.162.149
</span></span><span><span>  ports:
</span></span><span><span>  - name: http
</span></span><span><span>    nodePort: <span>31704</span>
</span></span><span><span>    port: <span>8080</span>
</span></span><span><span>    protocol: TCP
</span></span><span><span>    targetPort: <span>80</span>
</span></span><span><span>  - name: https
</span></span><span><span>    nodePort: <span>32453</span>
</span></span><span><span>    port: <span>443</span>
</span></span><span><span>    protocol: TCP
</span></span><span><span>    targetPort: <span>443</span>
</span></span><span><span>  selector:
</span></span><span><span>    run: my-nginx
</span></span></code></pre></div><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get nodes -o yaml | grep ExternalIP -C <span>1</span>
</span></span><span><span>    - address: 104.197.41.11
</span></span><span><span>      type: ExternalIP
</span></span><span><span>    allocatable:
</span></span><span><span>--
</span></span><span><span>    - address: 23.251.152.56
</span></span><span><span>      type: ExternalIP
</span></span><span><span>    allocatable:
</span></span><span><span>...
</span></span><span><span>
</span></span><span><span>$ curl https://&lt;EXTERNAL-IP&gt;:&lt;NODE-PORT&gt; -k
</span></span><span><span>...
</span></span><span><span>&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;
</span></span></code></pre></div><p>Let's now recreate the Service to use a cloud load balancer.
Change the <code>Type</code> of <code>my-nginx</code> Service from <code>NodePort</code> to <code>LoadBalancer</code>:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl edit svc my-nginx
</span></span><span><span>kubectl get svc my-nginx
</span></span></code></pre></div><pre tabindex="0"><code>NAME       TYPE           CLUSTER-IP     EXTERNAL-IP        PORT(S)               AGE
my-nginx   LoadBalancer   10.0.162.149     xx.xxx.xxx.xxx     8080:30163/TCP        21s
</code></pre><pre tabindex="0"><code>curl https://&lt;EXTERNAL-IP&gt; -k
...
&lt;title&gt;Welcome to nginx!&lt;/title&gt;
</code></pre><p>The IP address in the <code>EXTERNAL-IP</code> column is the one that is available on the public internet.
The <code>CLUSTER-IP</code> is only available inside your cluster/private cloud network.</p><p>Note that on AWS, type <code>LoadBalancer</code> creates an ELB, which uses a (long)
hostname, not an IP. It's too long to fit in the standard <code>kubectl get svc</code>
output, in fact, so you'll need to do <code>kubectl describe service my-nginx</code> to
see it. You'll see something like this:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl describe service my-nginx
</span></span><span><span>...
</span></span><span><span>LoadBalancer Ingress:   a320587ffd19711e5a37606cf4a74574-1142138393.us-east-1.elb.amazonaws.com
</span></span><span><span>...
</span></span></code></pre></div><h2 id="what-s-next">What's next</h2><ul><li>Learn more about <a href="/docs/tasks/access-application-cluster/service-access-application-cluster/">Using a Service to Access an Application in a Cluster</a></li><li>Learn more about <a href="/docs/tasks/access-application-cluster/connecting-frontend-backend/">Connecting a Front End to a Back End Using a Service</a></li><li>Learn more about <a href="/docs/tasks/access-application-cluster/create-external-load-balancer/">Creating an External Load Balancer</a></li></ul></div></div><div><div class="td-content"><h1>Using Source IP</h1><p>Applications running in a Kubernetes cluster find and communicate with each
other, and the outside world, through the Service abstraction. This document
explains what happens to the source IP of packets sent to different types
of Services, and how you can toggle this behavior according to your needs.</p><h2 id="before-you-begin">Before you begin</h2><h3 id="terminology">Terminology</h3><p>This document makes use of the following terms:</p><dl><dt><a href="https://en.wikipedia.org/wiki/Network_address_translation">NAT</a></dt><dd>Network address translation</dd><dt><a href="https://en.wikipedia.org/wiki/Network_address_translation#SNAT">Source NAT</a></dt><dd>Replacing the source IP on a packet; in this page, that usually means replacing with the IP address of a node.</dd><dt><a href="https://en.wikipedia.org/wiki/Network_address_translation#DNAT">Destination NAT</a></dt><dd>Replacing the destination IP on a packet; in this page, that usually means replacing with the IP address of a <a class="glossary-tooltip" title="A Pod represents a set of running containers in your cluster." href="/docs/concepts/workloads/pods/" target="_blank">Pod</a></dd><dt><a href="/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies">VIP</a></dt><dd>A virtual IP address, such as the one assigned to every <a class="glossary-tooltip" title="A way to expose an application running on a set of Pods as a network service." href="/docs/concepts/services-networking/service/" target="_blank">Service</a> in Kubernetes</dd><dt><a href="/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies">kube-proxy</a></dt><dd>A network daemon that orchestrates Service VIP management on every node</dd></dl><h3 id="prerequisites">Prerequisites</h3><p>You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. It is recommended to run this tutorial on a cluster with at least two nodes that are not acting as control plane hosts. If you do not already have a
cluster, you can create one by using
<a href="https://minikube.sigs.k8s.io/docs/tutorials/multi_node/">minikube</a>
or you can use one of these Kubernetes playgrounds:</p><ul><li><a href="https://labs.iximiuz.com/playgrounds?category=kubernetes&amp;filter=all">iximiuz Labs</a></li><li><a href="https://killercoda.com/playgrounds/scenario/kubernetes">Killercoda</a></li><li><a href="https://kodekloud.com/public-playgrounds">KodeKloud</a></li><li><a href="https://labs.play-with-k8s.com/">Play with Kubernetes</a></li></ul><p>The examples use a small nginx webserver that echoes back the source
IP of requests it receives through an HTTP header. You can create it as follows:</p><div class="alert alert-info"><h4 class="alert-heading">Note:</h4>The image in the following command only runs on AMD64 architectures.</div><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl create deployment source-ip-app --image<span>=</span>registry.k8s.io/echoserver:1.10
</span></span></code></pre></div><p>The output is:</p><pre tabindex="0"><code>deployment.apps/source-ip-app created
</code></pre><h2 id="objectives">Objectives</h2><ul><li>Expose a simple application through various types of Services</li><li>Understand how each Service type handles source IP NAT</li><li>Understand the tradeoffs involved in preserving source IP</li></ul><h2 id="source-ip-for-services-with-type-clusterip">Source IP for Services with <code>Type=ClusterIP</code></h2><p>Packets sent to ClusterIP from within the cluster are never source NAT'd if
you're running kube-proxy in
<a href="/docs/reference/networking/virtual-ips/#proxy-mode-iptables">iptables mode</a>,
(the default). You can query the kube-proxy mode by fetching
<code>http://localhost:10249/proxyMode</code> on the node where kube-proxy is running.</p><div class="highlight"><pre tabindex="0"><code class="language-console"><span><span><span>kubectl get nodes
</span></span></span></code></pre></div><p>The output is similar to this:</p><pre tabindex="0"><code>NAME                           STATUS     ROLES    AGE     VERSION
kubernetes-node-6jst   Ready      &lt;none&gt;   2h      v1.13.0
kubernetes-node-cx31   Ready      &lt;none&gt;   2h      v1.13.0
kubernetes-node-jj1t   Ready      &lt;none&gt;   2h      v1.13.0
</code></pre><p>Get the proxy mode on one of the nodes (kube-proxy listens on port 10249):</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span># Run this in a shell on the node you want to query.</span>
</span></span><span><span>curl http://localhost:10249/proxyMode
</span></span></code></pre></div><p>The output is:</p><pre tabindex="0"><code>iptables
</code></pre><p>You can test source IP preservation by creating a Service over the source IP app:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl expose deployment source-ip-app --name<span>=</span>clusterip --port<span>=</span><span>80</span> --target-port<span>=</span><span>8080</span>
</span></span></code></pre></div><p>The output is:</p><pre tabindex="0"><code>service/clusterip exposed
</code></pre><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get svc clusterip
</span></span></code></pre></div><p>The output is similar to:</p><pre tabindex="0"><code>NAME         TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)   AGE
clusterip    ClusterIP   10.0.170.92   &lt;none&gt;        80/TCP    51s
</code></pre><p>And hitting the <code>ClusterIP</code> from a pod in the same cluster:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl run busybox -it --image<span>=</span>busybox:1.28 --restart<span>=</span>Never --rm
</span></span></code></pre></div><p>The output is similar to this:</p><pre tabindex="0"><code>Waiting for pod default/busybox to be running, status is Pending, pod ready: false
If you don't see a command prompt, try pressing enter.
</code></pre><p>You can then run a command inside that Pod:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span># Run this inside the terminal from "kubectl run"</span>
</span></span><span><span>ip addr
</span></span></code></pre></div><pre tabindex="0"><code>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
3: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1460 qdisc noqueue
    link/ether 0a:58:0a:f4:03:08 brd ff:ff:ff:ff:ff:ff
    inet 10.244.3.8/24 scope global eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::188a:84ff:feb0:26a5/64 scope link
       valid_lft forever preferred_lft forever
</code></pre><p>&#8230;then use <code>wget</code> to query the local webserver</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span># Replace "10.0.170.92" with the IPv4 address of the Service named "clusterip"</span>
</span></span><span><span>wget -qO - 10.0.170.92
</span></span></code></pre></div><pre tabindex="0"><code>CLIENT VALUES:
client_address=10.244.3.8
command=GET
...
</code></pre><p>The <code>client_address</code> is always the client pod's IP address, whether the client pod and server pod are in the same node or in different nodes.</p><h2 id="source-ip-for-services-with-type-nodeport">Source IP for Services with <code>Type=NodePort</code></h2><p>Packets sent to Services with
<a href="/docs/concepts/services-networking/service/#type-nodeport"><code>Type=NodePort</code></a>
are source NAT'd by default. You can test this by creating a <code>NodePort</code> Service:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl expose deployment source-ip-app --name<span>=</span>nodeport --port<span>=</span><span>80</span> --target-port<span>=</span><span>8080</span> --type<span>=</span>NodePort
</span></span></code></pre></div><p>The output is:</p><pre tabindex="0"><code>service/nodeport exposed
</code></pre><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span>NODEPORT</span><span>=</span><span>$(</span>kubectl get -o <span>jsonpath</span><span>=</span><span>"{.spec.ports[0].nodePort}"</span> services nodeport<span>)</span>
</span></span><span><span><span>NODES</span><span>=</span><span>$(</span>kubectl get nodes -o <span>jsonpath</span><span>=</span><span>'{ $.items[*].status.addresses[?(@.type=="InternalIP")].address }'</span><span>)</span>
</span></span></code></pre></div><p>If you're running on a cloud provider, you may need to open up a firewall-rule
for the <code>nodes:nodeport</code> reported above.
Now you can try reaching the Service from outside the cluster through the node
port allocated above.</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span>for</span> node in <span>$NODES</span>; <span>do</span> curl -s <span>$node</span>:<span>$NODEPORT</span> | grep -i client_address; <span>done</span>
</span></span></code></pre></div><p>The output is similar to:</p><pre tabindex="0"><code>client_address=10.180.1.1
client_address=10.240.0.5
client_address=10.240.0.3
</code></pre><p>Note that these are not the correct client IPs, they're cluster internal IPs. This is what happens:</p><ul><li>Client sends packet to <code>node2:nodePort</code></li><li><code>node2</code> replaces the source IP address (SNAT) in the packet with its own IP address</li><li><code>node2</code> replaces the destination IP on the packet with the pod IP</li><li>packet is routed to node 1, and then to the endpoint</li><li>the pod's reply is routed back to node2</li><li>the pod's reply is sent back to the client</li></ul><p>Visually:</p><figure class="diagram-large"><a href="https://mermaid.live/edit#pako:eNqNkV9rwyAUxb-K3LysYEqS_WFYKAzat9GHdW9zDxKvi9RoMIZtlH732ZjSbE970cu5v3s86hFqJxEYfHjRNeT5ZcUtIbXRaMNN2hZ5vrYRqt52cSXV-4iMSuwkZiYtyX739EqWaahMQ-V1qPxDVLNOvkYrO6fj2dupWMR2iiT6foOKdEZoS5Q2hmVSStoH7w7IMqXUVOefWoaG3XVftHbGeZYVRbH6ZXJ47CeL2-qhxvt_ucTe1SUlpuMN6CX12XeGpLdJiaMMFFr0rdAyvvfxjHEIDbbIgcVSohKDCRy4PUV06KQIuJU6OA9MCdMjBTEEt_-2NbDgB7xAGy3i97VJPP0ABRmcqg"><img src="/docs/images/tutor-service-nodePort-fig01.svg" alt="source IP nodeport figure 01"></a><figcaption><p>Figure. Source IP Type=NodePort using SNAT</p></figcaption></figure><p>To avoid this, Kubernetes has a feature to
<a href="/docs/tasks/access-application-cluster/create-external-load-balancer/#preserving-the-client-source-ip">preserve the client source IP</a>.
If you set <code>service.spec.externalTrafficPolicy</code> to the value <code>Local</code>,
kube-proxy only proxies proxy requests to local endpoints, and does not
forward traffic to other nodes. This approach preserves the original
source IP address. If there are no local endpoints, packets sent to the
node are dropped, so you can rely on the correct source-ip in any packet
processing rules you might apply a packet that make it through to the
endpoint.</p><p>Set the <code>service.spec.externalTrafficPolicy</code> field as follows:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl patch svc nodeport -p <span>'{"spec":{"externalTrafficPolicy":"Local"}}'</span>
</span></span></code></pre></div><p>The output is:</p><pre tabindex="0"><code>service/nodeport patched
</code></pre><p>Now, re-run the test:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span>for</span> node in <span>$NODES</span>; <span>do</span> curl --connect-timeout <span>1</span> -s <span>$node</span>:<span>$NODEPORT</span> | grep -i client_address; <span>done</span>
</span></span></code></pre></div><p>The output is similar to:</p><pre tabindex="0"><code>client_address=198.51.100.79
</code></pre><p>Note that you only got one reply, with the <em>right</em> client IP, from the one node on which the endpoint pod
is running.</p><p>This is what happens:</p><ul><li>client sends packet to <code>node2:nodePort</code>, which doesn't have any endpoints</li><li>packet is dropped</li><li>client sends packet to <code>node1:nodePort</code>, which <em>does</em> have endpoints</li><li>node1 routes packet to endpoint with the correct source IP</li></ul><p>Visually:</p><figure class="diagram-large"><img src="/docs/images/tutor-service-nodePort-fig02.svg" alt="source IP nodeport figure 02"><figcaption><p>Figure. Source IP Type=NodePort preserves client source IP address</p></figcaption></figure><h2 id="source-ip-for-services-with-type-loadbalancer">Source IP for Services with <code>Type=LoadBalancer</code></h2><p>Packets sent to Services with
<a href="/docs/concepts/services-networking/service/#loadbalancer"><code>Type=LoadBalancer</code></a>
are source NAT'd by default, because all schedulable Kubernetes nodes in the
<code>Ready</code> state are eligible for load-balanced traffic. So if packets arrive
at a node without an endpoint, the system proxies it to a node <em>with</em> an
endpoint, replacing the source IP on the packet with the IP of the node (as
described in the previous section).</p><p>You can test this by exposing the source-ip-app through a load balancer:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl expose deployment source-ip-app --name<span>=</span>loadbalancer --port<span>=</span><span>80</span> --target-port<span>=</span><span>8080</span> --type<span>=</span>LoadBalancer
</span></span></code></pre></div><p>The output is:</p><pre tabindex="0"><code>service/loadbalancer exposed
</code></pre><p>Print out the IP addresses of the Service:</p><div class="highlight"><pre tabindex="0"><code class="language-console"><span><span><span>kubectl get svc loadbalancer
</span></span></span></code></pre></div><p>The output is similar to this:</p><pre tabindex="0"><code>NAME           TYPE           CLUSTER-IP    EXTERNAL-IP       PORT(S)   AGE
loadbalancer   LoadBalancer   10.0.65.118   203.0.113.140     80/TCP    5m
</code></pre><p>Next, send a request to this Service's external-ip:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>curl 203.0.113.140
</span></span></code></pre></div><p>The output is similar to this:</p><pre tabindex="0"><code>CLIENT VALUES:
client_address=10.240.0.5
...
</code></pre><p>However, if you're running on Google Kubernetes Engine/GCE, setting the same <code>service.spec.externalTrafficPolicy</code>
field to <code>Local</code> forces nodes <em>without</em> Service endpoints to remove
themselves from the list of nodes eligible for loadbalanced traffic by
deliberately failing health checks.</p><p>Visually:</p><p><img alt="Source IP with externalTrafficPolicy" src="/images/docs/sourceip-externaltrafficpolicy.svg"></p><p>You can test this by setting the annotation:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl patch svc loadbalancer -p <span>'{"spec":{"externalTrafficPolicy":"Local"}}'</span>
</span></span></code></pre></div><p>You should immediately see the <code>service.spec.healthCheckNodePort</code> field allocated
by Kubernetes:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get svc loadbalancer -o yaml | grep -i healthCheckNodePort
</span></span></code></pre></div><p>The output is similar to this:</p><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span>  </span><span>healthCheckNodePort</span>:<span> </span><span>32122</span><span>
</span></span></span></code></pre></div><p>The <code>service.spec.healthCheckNodePort</code> field points to a port on every node
serving the health check at <code>/healthz</code>. You can test this:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pod -o wide -l <span>app</span><span>=</span>source-ip-app
</span></span></code></pre></div><p>The output is similar to this:</p><pre tabindex="0"><code>NAME                            READY     STATUS    RESTARTS   AGE       IP             NODE
source-ip-app-826191075-qehz4   1/1       Running   0          20h       10.180.1.136   kubernetes-node-6jst
</code></pre><p>Use <code>curl</code> to fetch the <code>/healthz</code> endpoint on various nodes:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span># Run this locally on a node you choose</span>
</span></span><span><span>curl localhost:32122/healthz
</span></span></code></pre></div><pre tabindex="0"><code>1 Service Endpoints found
</code></pre><p>On a different node you might get a different result:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span><span># Run this locally on a node you choose</span>
</span></span><span><span>curl localhost:32122/healthz
</span></span></code></pre></div><pre tabindex="0"><code>No Service Endpoints Found
</code></pre><p>A controller running on the
<a class="glossary-tooltip" title="The container orchestration layer that exposes the API and interfaces to define, deploy, and manage the lifecycle of containers." href="/docs/reference/glossary/?all=true#term-control-plane" target="_blank">control plane</a> is
responsible for allocating the cloud load balancer. The same controller also
allocates HTTP health checks pointing to this port/path on each node. Wait
about 10 seconds for the 2 nodes without endpoints to fail health checks,
then use <code>curl</code> to query the IPv4 address of the load balancer:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>curl 203.0.113.140
</span></span></code></pre></div><p>The output is similar to this:</p><pre tabindex="0"><code>CLIENT VALUES:
client_address=198.51.100.79
...
</code></pre><h2 id="cross-platform-support">Cross-platform support</h2><p>Only some cloud providers offer support for source IP preservation through
Services with <code>Type=LoadBalancer</code>.
The cloud provider you're running on might fulfill the request for a loadbalancer
in a few different ways:</p><ol><li><p>With a proxy that terminates the client connection and opens a new connection
to your nodes/endpoints. In such cases the source IP will always be that of the
cloud LB, not that of the client.</p></li><li><p>With a packet forwarder, such that requests from the client sent to the
loadbalancer VIP end up at the node with the source IP of the client, not
an intermediate proxy.</p></li></ol><p>Load balancers in the first category must use an agreed upon
protocol between the loadbalancer and backend to communicate the true client IP
such as the HTTP <a href="https://tools.ietf.org/html/rfc7239#section-5.2">Forwarded</a>
or <a href="https://en.wikipedia.org/wiki/X-Forwarded-For">X-FORWARDED-FOR</a>
headers, or the
<a href="https://www.haproxy.org/download/1.8/doc/proxy-protocol.txt">proxy protocol</a>.
Load balancers in the second category can leverage the feature described above
by creating an HTTP health check pointing at the port stored in
the <code>service.spec.healthCheckNodePort</code> field on the Service.</p><h2 id="cleaning-up">Cleaning up</h2><p>Delete the Services:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl delete svc -l <span>app</span><span>=</span>source-ip-app
</span></span></code></pre></div><p>Delete the Deployment, ReplicaSet and Pod:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl delete deployment source-ip-app
</span></span></code></pre></div><h2 id="what-s-next">What's next</h2><ul><li>Learn more about <a href="/docs/tutorials/services/connect-applications-service/">connecting applications via services</a></li><li>Read how to <a href="/docs/tasks/access-application-cluster/create-external-load-balancer/">Create an External Load Balancer</a></li></ul></div></div><div><div class="td-content"><h1>Explore Termination Behavior for Pods And Their Endpoints</h1><p>Once you connected your Application with Service following steps
like those outlined in <a href="/docs/tutorials/services/connect-applications-service/">Connecting Applications with Services</a>,
you have a continuously running, replicated application, that is exposed on a network.
This tutorial helps you look at the termination flow for Pods and to explore ways to implement
graceful connection draining.</p><h2 id="termination-process-for-pods-and-their-endpoints">Termination process for Pods and their endpoints</h2><p>There are often cases when you need to terminate a Pod - be it to upgrade or scale down.
In order to improve application availability, it may be important to implement
a proper active connections draining.</p><p>This tutorial explains the flow of Pod termination in connection with the
corresponding endpoint state and removal by using
a simple nginx web server to demonstrate the concept.</p><h2 id="example-flow-with-endpoint-termination">Example flow with endpoint termination</h2><p>The following is the example flow described in the
<a href="/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination">Termination of Pods</a>
document.</p><p>Let's say you have a Deployment containing a single <code>nginx</code> replica
(say just for the sake of demonstration purposes) and a Service:</p><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/service/pod-with-graceful-termination.yaml"><code>service/pod-with-graceful-termination.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" title="Copy service/pod-with-graceful-termination.yaml to clipboard"></div><div class="includecode" id="service-pod-with-graceful-termination-yaml"><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span>apiVersion</span>:<span> </span>apps/v1<span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>Deployment<span>
</span></span></span><span><span><span></span><span>metadata</span>:<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>nginx-deployment<span>
</span></span></span><span><span><span>  </span><span>labels</span>:<span>
</span></span></span><span><span><span>    </span><span>app</span>:<span> </span>nginx<span>
</span></span></span><span><span><span></span><span>spec</span>:<span>
</span></span></span><span><span><span>  </span><span>replicas</span>:<span> </span><span>1</span><span>
</span></span></span><span><span><span>  </span><span>selector</span>:<span>
</span></span></span><span><span><span>    </span><span>matchLabels</span>:<span>
</span></span></span><span><span><span>      </span><span>app</span>:<span> </span>nginx<span>
</span></span></span><span><span><span>  </span><span>template</span>:<span>
</span></span></span><span><span><span>    </span><span>metadata</span>:<span>
</span></span></span><span><span><span>      </span><span>labels</span>:<span>
</span></span></span><span><span><span>        </span><span>app</span>:<span> </span>nginx<span>
</span></span></span><span><span><span>    </span><span>spec</span>:<span>
</span></span></span><span><span><span>      </span><span>terminationGracePeriodSeconds</span>:<span> </span><span>120</span><span> </span><span># extra long grace period</span><span>
</span></span></span><span><span><span>      </span><span>containers</span>:<span>
</span></span></span><span><span><span>      </span>- <span>name</span>:<span> </span>nginx<span>
</span></span></span><span><span><span>        </span><span>image</span>:<span> </span>nginx:latest<span>
</span></span></span><span><span><span>        </span><span>ports</span>:<span>
</span></span></span><span><span><span>        </span>- <span>containerPort</span>:<span> </span><span>80</span><span>
</span></span></span><span><span><span>        </span><span>lifecycle</span>:<span>
</span></span></span><span><span><span>          </span><span>preStop</span>:<span>
</span></span></span><span><span><span>            </span><span>exec</span>:<span>
</span></span></span><span><span><span>              </span><span># Real life termination may take any time up to terminationGracePeriodSeconds.</span><span>
</span></span></span><span><span><span>              </span><span># In this example - just hang around for at least the duration of terminationGracePeriodSeconds,</span><span>
</span></span></span><span><span><span>              </span><span># at 120 seconds container will be forcibly terminated.</span><span>
</span></span></span><span><span><span>              </span><span># Note, all this time nginx will keep processing requests.</span><span>
</span></span></span><span><span><span>              </span><span>command</span>:<span> </span>[<span>
</span></span></span><span><span><span>                </span><span>"/bin/sh"</span>,<span> </span><span>"-c"</span>,<span> </span><span>"sleep 180"</span><span>
</span></span></span><span><span><span>              </span>]<span>
</span></span></span></code></pre></div></div></div><div class="highlight code-sample"><div class="copy-code-icon"><a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/service/explore-graceful-termination-nginx.yaml"><code>service/explore-graceful-termination-nginx.yaml</code>
</a><img src="/images/copycode.svg" class="icon-copycode" title="Copy service/explore-graceful-termination-nginx.yaml to clipboard"></div><div class="includecode" id="service-explore-graceful-termination-nginx-yaml"><div class="highlight"><pre tabindex="0"><code class="language-yaml"><span><span><span>apiVersion</span>:<span> </span>v1<span>
</span></span></span><span><span><span></span><span>kind</span>:<span> </span>Service<span>
</span></span></span><span><span><span></span><span>metadata</span>:<span>
</span></span></span><span><span><span>  </span><span>name</span>:<span> </span>nginx-service<span>
</span></span></span><span><span><span></span><span>spec</span>:<span>
</span></span></span><span><span><span>  </span><span>selector</span>:<span>
</span></span></span><span><span><span>    </span><span>app</span>:<span> </span>nginx<span>
</span></span></span><span><span><span>  </span><span>ports</span>:<span>
</span></span></span><span><span><span>    </span>- <span>protocol</span>:<span> </span>TCP<span>
</span></span></span><span><span><span>      </span><span>port</span>:<span> </span><span>80</span><span>
</span></span></span><span><span><span>      </span><span>targetPort</span>:<span> </span><span>80</span></span></span></code></pre></div></div></div><p>Now create the Deployment Pod and Service using the above files:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl apply -f pod-with-graceful-termination.yaml
</span></span><span><span>kubectl apply -f explore-graceful-termination-nginx.yaml
</span></span></code></pre></div><p>Once the Pod and Service are running, you can get the name of any associated EndpointSlices:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get endpointslice
</span></span></code></pre></div><p>The output is similar to this:</p><pre tabindex="0"><code class="language-none">NAME                  ADDRESSTYPE   PORTS   ENDPOINTS                 AGE
nginx-service-6tjbr   IPv4          80      10.12.1.199,10.12.1.201   22m
</code></pre><p>You can see its status, and validate that there is one endpoint registered:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get endpointslices -o json -l kubernetes.io/service-name<span>=</span>nginx-service
</span></span></code></pre></div><p>The output is similar to this:</p><pre tabindex="0"><code class="language-none">{
    "addressType": "IPv4",
    "apiVersion": "discovery.k8s.io/v1",
    "endpoints": [
        {
            "addresses": [
                "10.12.1.201"
            ],
            "conditions": {
                "ready": true,
                "serving": true,
                "terminating": false
</code></pre><p>Now let's terminate the Pod and validate that the Pod is being terminated
respecting the graceful termination period configuration:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl delete pod nginx-deployment-7768647bf9-b4b9s
</span></span></code></pre></div><p>All pods:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get pods
</span></span></code></pre></div><p>The output is similar to this:</p><pre tabindex="0"><code class="language-none">NAME                                READY   STATUS        RESTARTS      AGE
nginx-deployment-7768647bf9-b4b9s   1/1     Terminating   0             4m1s
nginx-deployment-7768647bf9-rkxlw   1/1     Running       0             8s
</code></pre><p>You can see that the new pod got scheduled.</p><p>While the new endpoint is being created for the new Pod, the old endpoint is
still around in the terminating state:</p><div class="highlight"><pre tabindex="0"><code class="language-shell"><span><span>kubectl get endpointslice -o json nginx-service-6tjbr
</span></span></code></pre></div><p>The output is similar to this:</p><pre tabindex="0"><code class="language-none">{
    "addressType": "IPv4",
    "apiVersion": "discovery.k8s.io/v1",
    "endpoints": [
        {
            "addresses": [
                "10.12.1.201"
            ],
            "conditions": {
                "ready": false,
                "serving": true,
                "terminating": true
            },
            "nodeName": "gke-main-default-pool-dca1511c-d17b",
            "targetRef": {
                "kind": "Pod",
                "name": "nginx-deployment-7768647bf9-b4b9s",
                "namespace": "default",
                "uid": "66fa831c-7eb2-407f-bd2c-f96dfe841478"
            },
            "zone": "us-central1-c"
        },
        {
            "addresses": [
                "10.12.1.202"
            ],
            "conditions": {
                "ready": true,
                "serving": true,
                "terminating": false
            },
            "nodeName": "gke-main-default-pool-dca1511c-d17b",
            "targetRef": {
                "kind": "Pod",
                "name": "nginx-deployment-7768647bf9-rkxlw",
                "namespace": "default",
                "uid": "722b1cbe-dcd7-4ed4-8928-4a4d0e2bbe35"
            },
            "zone": "us-central1-c"
</code></pre><p>This allows applications to communicate their state during termination
and clients (such as load balancers) to implement connection draining functionality.
These clients may detect terminating endpoints and implement a special logic for them.</p><p>In Kubernetes, endpoints that are terminating always have their <code>ready</code> status set as <code>false</code>.
This needs to happen for backward
compatibility, so existing load balancers will not use it for regular traffic.
If traffic draining on terminating pod is needed, the actual readiness can be
checked as a condition <code>serving</code>.</p><p>When Pod is deleted, the old endpoint will also be deleted.</p><h2 id="what-s-next">What's next</h2><ul><li>Learn how to <a href="/docs/tutorials/services/connect-applications-service/">Connect Applications with Services</a></li><li>Learn more about <a href="/docs/tasks/access-application-cluster/service-access-application-cluster/">Using a Service to Access an Application in a Cluster</a></li><li>Learn more about <a href="/docs/tasks/access-application-cluster/connecting-frontend-backend/">Connecting a Front End to a Back End Using a Service</a></li><li>Learn more about <a href="/docs/tasks/access-application-cluster/create-external-load-balancer/">Creating an External Load Balancer</a></li></ul></div></div>